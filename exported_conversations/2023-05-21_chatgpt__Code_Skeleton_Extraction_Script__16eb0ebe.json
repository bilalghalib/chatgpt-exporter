{
  "id": "16eb0ebe-5760-416b-93a5-a3aed1a4b82e",
  "source": "chatgpt",
  "title": "\"Code Skeleton Extraction Script\"",
  "created_at": "2023-05-21T08:52:27.491481",
  "updated_at": "2023-05-21T09:01:38",
  "summary": null,
  "message_count": 8,
  "messages": [
    {
      "id": "aaa26a59-6841-440a-ac43-828b7206f673",
      "role": "user",
      "content": "can you write me a script that will take all the files in a. folder of javascript react code and python and output a code skeleton text file, just class instances and function definitions so that I can use it to send to an AI so it can draw diagrams of the code? ",
      "created_at": "2023-05-21T08:52:40.638093",
      "sequence_order": 0,
      "parent_id": "db8883e4-a98a-4ece-9c8f-0d14a366d85c",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "e3415591-14df-4d23-b8fe-63b19f76c908",
      "role": "assistant",
      "content": "Sure, I can provide you with a basic script that will do this for you. This script will be written in Python and will use the `os` module to navigate the file system, and the `ast` module to parse the Python and JavaScript files. \n\nPlease note that parsing JavaScript in Python is not straightforward, so for the JavaScript part, we will use a simple approach to extract class and function definitions. For a more accurate parsing, you might want to use a JavaScript-based tool or library.\n\nHere's a basic script:\n\n```python\nimport os\nimport ast\n\ndef parse_python(file_path):\n    with open(file_path, \"r\") as source:\n        tree = ast.parse(source.read())\n        classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n        functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    return classes, functions\n\ndef parse_javascript(file_path):\n    with open(file_path, \"r\") as source:\n        lines = source.readlines()\n        classes = [line for line in lines if line.strip().startswith('class ')]\n        functions = [line for line in lines if 'function' in line]\n    return classes, functions\n\ndef main():\n    skeleton = \"\"\n    for root, dirs, files in os.walk(\"<your_directory>\"):\n        for file in files:\n            if file.endswith(\".py\"):\n                classes, functions = parse_python(os.path.join(root, file))\n                skeleton += f\"Python file: {file}\\nClasses: {classes}\\nFunctions: {functions}\\n\\n\"\n            elif file.endswith(\".js\"):\n                classes, functions = parse_javascript(os.path.join(root, file))\n                skeleton += f\"JavaScript file: {file}\\nClasses: {classes}\\nFunctions: {functions}\\n\\n\"\n\n    with open(\"code_skeleton.txt\", \"w\") as output:\n        output.write(skeleton)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nReplace `<your_directory>` with the path to your directory containing the JavaScript and Python files.\n\nThis script will create a text file named `code_skeleton.txt` in the same directory where the script is run. This file will contain the names of all classes and functions found in the Python and JavaScript files in the specified directory.\n\nPlease note that this script is quite basic and may not handle all edge cases or complex code structures. For a more robust solution, you might want to consider using a dedicated code parsing library or tool.",
      "created_at": "2023-05-21T08:53:27.056019",
      "sequence_order": 1,
      "parent_id": "aaa26a59-6841-440a-ac43-828b7206f673",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa26d81-db76-46b5-b21e-6805a750fd26",
      "role": "user",
      "content": "can you make it run in the command line and use whatever tools you might need, I ran it and the file was empty ",
      "created_at": "2023-05-21T08:56:12.206284",
      "sequence_order": 2,
      "parent_id": "e3415591-14df-4d23-b8fe-63b19f76c908",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "c181bd3a-f349-4335-94fa-bfd5ec1d5a24",
      "role": "assistant",
      "content": "I apologize for the confusion. The script provided is a simple one and might not handle complex code structures or edge cases. It's also possible that there are no class or function definitions in the files you're scanning, or the directory path might be incorrect.\n\nHowever, to improve the script, we can use the `astor` library for Python parsing, and `esprima` for JavaScript parsing. `esprima` is a JavaScript parser, so we'll need to run it using Node.js. We'll create a separate script for it and call it from our Python script.\n\nFirst, install the necessary libraries:\n\nFor Python:\n```\npip install astor\n```\n\nFor JavaScript (Node.js):\n```\nnpm install esprima\n```\n\nHere is the updated Python script:\n\n```python\nimport os\nimport ast\nimport astor\nimport subprocess\n\ndef parse_python(file_path):\n    with open(file_path, \"r\") as source:\n        tree = ast.parse(source.read())\n        classes = [node.name for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n        functions = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]\n    return classes, functions\n\ndef parse_javascript(file_path):\n    result = subprocess.run(['node', 'parse_js.js', file_path], capture_output=True, text=True)\n    return result.stdout\n\ndef main():\n    skeleton = \"\"\n    for root, dirs, files in os.walk(\"<your_directory>\"):\n        for file in files:\n            if file.endswith(\".py\"):\n                classes, functions = parse_python(os.path.join(root, file))\n                skeleton += f\"Python file: {file}\\nClasses: {classes}\\nFunctions: {functions}\\n\\n\"\n            elif file.endswith(\".js\"):\n                classes_functions = parse_javascript(os.path.join(root, file))\n                skeleton += f\"JavaScript file: {file}\\n{classes_functions}\\n\\n\"\n\n    with open(\"code_skeleton.txt\", \"w\") as output:\n        output.write(skeleton)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nAnd here is the Node.js script (`parse_js.js`):\n\n```javascript\nvar esprima = require('esprima');\nvar fs = require('fs');\n\nvar filePath = process.argv[2];\nvar content = fs.readFileSync(filePath, 'utf8');\n\nvar parsedCode = esprima.parseScript(content, { tolerant: true });\n\nvar classes = [];\nvar functions = [];\n\nparsedCode.body.forEach(node => {\n    if (node.type === 'FunctionDeclaration') {\n        functions.push(node.id.name);\n    } else if (node.type === 'ClassDeclaration') {\n        classes.push(node.id.name);\n    }\n});\n\nconsole.log(\"Classes: \", classes);\nconsole.log(\"Functions: \", functions);\n```\n\nRemember to replace `<your_directory>` with the path to your directory containing the JavaScript and Python files.\n\nThis script will create a text file named `code_skeleton.txt` in the same directory where the script is run. This file will contain the names of all classes and functions found in the Python and JavaScript files in the specified directory. \n\nPlease note that this script is still quite basic and may not handle all edge cases or complex code structures. For a more robust solution, you might want to consider using a dedicated code parsing library or tool.",
      "created_at": "2023-05-21T08:57:25.667271",
      "sequence_order": 3,
      "parent_id": "aaa26d81-db76-46b5-b21e-6805a750fd26",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2b548-d75a-4b72-aef9-88469f9cc031",
      "role": "user",
      "content": "ok it's not working. Maybe instead we can just create as ingle text file that contains the code and only keep the lines that are comments and class initialization/function definition lines and delete the \"meat\" \nAnd before you process a file you can put a comment like //fileaddress/filename.py so we know the split between files",
      "created_at": "2023-05-21T09:00:05.658483",
      "sequence_order": 4,
      "parent_id": "c181bd3a-f349-4335-94fa-bfd5ec1d5a24",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "ca909f2f-de8d-40ef-bc0e-b1c68a7134d9",
      "role": "assistant",
      "content": "I apologize for the confusion earlier. Let's try a simpler approach. We'll create a Python script that reads through each Python and JavaScript file in a directory, and writes the comments, class initializations, and function definitions to a new text file.\n\nHere's the updated script:\n\n```python\nimport os\nimport re\n\ndef process_file(file_path):\n    with open(file_path, \"r\") as source:\n        lines = source.readlines()\n\n    processed_lines = []\n    for line in lines:\n        stripped_line = line.strip()\n        if stripped_line.startswith(\"#\") or stripped_line.startswith(\"//\"):  # Comment lines\n            processed_lines.append(line)\n        elif \"class \" in stripped_line or \"def \" in stripped_line or \"function \" in stripped_line:  # Class and function definitions\n            processed_lines.append(line)\n\n    return processed_lines\n\ndef main():\n    skeleton = \"\"\n    for root, dirs, files in os.walk(\"<your_directory>\"):\n        for file in files:\n            if file.endswith(\".py\") or file.endswith(\".js\"):\n                skeleton += f\"// {os.path.join(root, file)}\\n\"\n                processed_lines = process_file(os.path.join(root, file))\n                skeleton += \"\".join(processed_lines) + \"\\n\\n\"\n\n    with open(\"code_skeleton.txt\", \"w\") as output:\n        output.write(skeleton)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nReplace `<your_directory>` with the path to your directory containing the JavaScript and Python files.\n\nThis script will create a text file named `code_skeleton.txt` in the same directory where the script is run. This file will contain the comments, class initializations, and function definitions found in the Python and JavaScript files in the specified directory.\n\nPlease note that this script is quite basic and may not handle all edge cases or complex code structures. For a more robust solution, you might want to consider using a dedicated code parsing library or tool.",
      "created_at": "2023-05-21T09:00:50.773876",
      "sequence_order": 5,
      "parent_id": "aaa2b548-d75a-4b72-aef9-88469f9cc031",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa22cc5-ede9-4271-8f56-091e8c16bba8",
      "role": "user",
      "content": "can we put the the \"your directory\" and output as command line inputs?",
      "created_at": "2023-05-21T09:01:38.609809",
      "sequence_order": 6,
      "parent_id": "ca909f2f-de8d-40ef-bc0e-b1c68a7134d9",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "9eb57344-aba7-402a-99f0-80358bf48a7a",
      "role": "assistant",
      "content": "Absolutely, we can modify the script to accept command line arguments for the directory and output file. We'll use the `argparse` module in Python to handle command line arguments.\n\nHere's the updated script:\n\n```python\nimport os\nimport re\nimport argparse\n\ndef process_file(file_path):\n    with open(file_path, \"r\") as source:\n        lines = source.readlines()\n\n    processed_lines = []\n    for line in lines:\n        stripped_line = line.strip()\n        if stripped_line.startswith(\"#\") or stripped_line.startswith(\"//\"):  # Comment lines\n            processed_lines.append(line)\n        elif \"class \" in stripped_line or \"def \" in stripped_line or \"function \" in stripped_line:  # Class and function definitions\n            processed_lines.append(line)\n\n    return processed_lines\n\ndef main(directory, output_file):\n    skeleton = \"\"\n    for root, dirs, files in os.walk(directory):\n        for file in files:\n            if file.endswith(\".py\") or file.endswith(\".js\"):\n                skeleton += f\"// {os.path.join(root, file)}\\n\"\n                processed_lines = process_file(os.path.join(root, file))\n                skeleton += \"\".join(processed_lines) + \"\\n\\n\"\n\n    with open(output_file, \"w\") as output:\n        output.write(skeleton)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Process some integers.')\n    parser.add_argument('directory', type=str, help='The directory to process')\n    parser.add_argument('output_file', type=str, help='The output file')\n\n    args = parser.parse_args()\n\n    main(args.directory, args.output_file)\n```\n\nNow you can run the script from the command line and provide the directory and output file as arguments. For example:\n\n```bash\npython script.py /path/to/your/directory output.txt\n```\n\nThis will process all Python and JavaScript files in `/path/to/your/directory` and write the output to `output.txt`.",
      "created_at": "2023-05-21T09:02:19.846103",
      "sequence_order": 7,
      "parent_id": "aaa22cc5-ede9-4271-8f56-091e8c16bba8",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    }
  ]
}