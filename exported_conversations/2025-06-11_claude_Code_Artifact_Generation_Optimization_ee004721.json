{
  "id": "ee004721-ce6a-4fd2-a5ea-0866a6c401db",
  "source": "claude",
  "title": "Code Artifact Generation Optimization",
  "created_at": "2025-06-11T14:43:16.039823Z",
  "updated_at": "2025-06-11T14:48:34.272578Z",
  "summary": "",
  "message_count": 2,
  "messages": [
    {
      "id": "08adee1a-653f-428f-83d9-534d48f6e2ee",
      "role": "human",
      "content": "review code and critique and find overlapping functionality and show how we can use the automatic artifact selector to route the selection and generate artifacts. also can you show how to make the artifact generator work ot make slides iwth nested artifacts in it, we need to clena up and streamline the code, give your recommendations by returning suggestions, scripts and files in full:",
      "created_at": "2025-06-11T14:43:19.306490Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-06-11T14:43:19.303170Z",
            "stop_timestamp": "2025-06-11T14:43:19.303170Z",
            "flags": null,
            "type": "text",
            "text": "review code and critique and find overlapping functionality and show how we can use the automatic artifact selector to route the selection and generate artifacts. also can you show how to make the artifact generator work ot make slides iwth nested artifacts in it, we need to clena up and streamline the code, give your recommendations by returning suggestions, scripts and files in full:",
            "citations": []
          }
        ],
        "updated_at": "2025-06-11T14:43:19.306490Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "0275f5eb-2d4d-4035-9b08-67b0822d8834",
      "role": "assistant",
      "content": "Let me analyze this Knowledge Garden codebase to understand the structure and identify overlapping functionality, particularly around artifact generation.\n\n## Key Components I've Identified:\n\n### 1. **Artifact Generation Systems**\nThere are at least 3 different artifact generation approaches:\n\n1. **Legacy artifact_studio** (`apps/artifact_studio/`)\n   - Has `ArtifactStudio` with methods like `generate_framework`, `generate_diagram`\n   - Direct artifact type methods\n\n2. **Unified artifact_generator** (`apps/artifact_generator/`)\n   - More comprehensive with:\n   - `ArtifactGenerator` - main orchestrator\n   - `AutoGenerator` - automatic type selection\n   - Type-specific generators in `generators/` directory\n   - Supports diagrams, summaries, frameworks, reports, presentations, etc.\n\n3. **Living Artifact System** (`core/living_artifact_system.py`)\n   - Another orchestration layer\n   - Seems to manage artifact lifecycle and dependencies\n\n### 2. **Overlapping Functionality**\n\n1. **Artifact Type Selection**:\n   - `AutoGenerator` in artifact_generator already does automatic selection\n   - `Parliament Engine` can also make decisions about artifact types\n   - There's redundancy here\n\n2. **Generator Registration**:\n   - `ArtifactGenerator` has `_register_generators()`\n   - `LivingArtifactSystem` also has `_init_generators()`\n   - Both maintain generator registries\n\n3. **Storage and Paths**:\n   - Multiple places define artifact storage paths\n   - `ArtifactGenerator`, `LivingArtifactSystem`, and individual generators all manage paths\n\n4. **API Endpoints**:\n   - `/api/generate` - direct generation\n   - `/api/auto-generate` - automatic type selection\n   - Similar functionality, could be unified\n\n### 3. **Presentation/Slides Generation**\nLooking at the code, I see:\n\n\nI notice a gap in the presentation generation capabilities. The system lists presentations as an artifact type, but lacks a dedicated implementation. While a PDF generator has a presentation method, it remains unintegrated. This creates a significant limitation in creating comprehensive slide-based artifacts.\n\n### 4. **Nested Artifacts**\nThe current architecture struggles with complex artifact composition. Ideal presentation generation would require sophisticated nested artifact support, enabling dynamic creation of slides with embedded elements like diagrams, charts, and images as sub-artifacts.\n\n## Recommendations:\n\n1. **Consolidate Artifact Generation**\n   - Streamline multiple generation systems\n   - Eliminate redundant approaches\n   - Create a unified, flexible artifact generation framework\n\n2. **Presentation Generator Development**\n   - Design a robust `PresentationGenerator`\n   - Enable dynamic, nested artifact creation\n   - Leverage existing generation mechanisms for sub-components\n\n3. **Intelligent Auto-Selection**\n   - Implement a centralized selection strategy\n   - Utilize specialized engines for complex decision-making\n   - Remove fragmented selection logic\n\n4. **Storage Optimization**\n   - Standardize configuration pathways\n   - Implement consistent naming conventions\n   - Improve overall artifact management infrastructureLooking at the Knowledge Garden codebase, I can see significant overlap and opportunities for streamlining. Here's my analysis and recommendations:\n\n## Key Overlapping Functionality\n\n1. **Multiple Artifact Generation Systems**:\n   - Legacy `artifact_studio` app\n   - Newer `artifact_generator` app  \n   - `LivingArtifactSystem` in core\n   - All doing similar things with different approaches\n\n2. **Redundant Auto-Selection**:\n   - `AutoGenerator` uses LLM for selection\n   - Parliament Engine also makes artifact decisions\n   - API has both `/generate` and `/auto-generate` endpoints\n\n3. **No Presentation Generator** despite it being listed as a type\n\n4. **Nested artifacts not supported** (needed for slides with diagrams/charts)\n\n## Recommendations and Implementation\n\n### 1. **Streamlined Artifact System Architecture**\n\n<artifacts>\n<artifact identifier=\"artifact-system-refactor\" type=\"text/markdown\" title=\"Artifact System Refactoring Plan\">\n# Knowledge Garden Artifact System Refactoring\n\n## Proposed Architecture\n\n```\napps/artifact_generator/\n├── api.py                    # Single API with auto-selection\n├── generator.py              # Main orchestrator\n├── auto_selector.py          # Unified selection logic\n├── generators/\n│   ├── base.py              # Base generator class\n│   ├── diagram.py           \n│   ├── summary.py           \n│   ├── framework.py         \n│   ├── presentation.py      # NEW: With nested artifacts\n│   ├── report.py            \n│   ├── image.py            \n│   └── chart.py            \n└── artifact_manager.py       # Replaces LivingArtifactSystem\n```\n\n## Key Changes\n\n1. **Remove Legacy Code**:\n   - Delete `apps/artifact_studio/` entirely\n   - Move useful parts to `artifact_generator`\n\n2. **Unified Auto-Selection**:\n   - Single `/api/generate` endpoint\n   - Auto-selection by default\n   - Optional `artifact_type` parameter to override\n\n3. **Nested Artifact Support**:\n   - Artifacts can request sub-artifacts\n   - Presentation generator orchestrates slide generation\n   - Each slide can contain diagrams, charts, images\n\n4. **Simplified Storage**:\n   - Single source of truth for paths\n   - Consistent naming conventions\n   - Better organization by type and date\n</artifact>\n</artifacts>\n\n### 2. **Unified API with Auto-Selection**\n\n<artifacts>\n<artifact identifier=\"unified-api\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Unified API for Artifact Generation\">\n\"\"\"Unified API for artifact generation with automatic type selection\"\"\"\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\nfrom typing import Dict, Any, Optional, List\nfrom pathlib import Path\nimport logging\n\nfrom .auto_selector import AutoSelector\nfrom .generator import UnifiedArtifactGenerator\nfrom .artifact_manager import ArtifactManager\n\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(\n    title=\"Knowledge Garden Artifact Generator\",\n    description=\"Unified artifact generation with automatic type selection\",\n    version=\"3.0.0\"\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Static files\nstatic_dir = Path(__file__).parent / \"static\"\nstatic_dir.mkdir(exist_ok=True)\napp.mount(\"/static\", StaticFiles(directory=str(static_dir)), name=\"static\")\n\n# Initialize components\nauto_selector = AutoSelector()\ngenerator = UnifiedArtifactGenerator()\nartifact_manager = ArtifactManager()\n\n\nclass GenerateRequest(BaseModel):\n    \"\"\"Unified generation request\"\"\"\n    content: str\n    artifact_type: Optional[str] = None  # If None, auto-select\n    options: Optional[Dict[str, Any]] = None\n    source_uri: Optional[str] = None\n    nested_artifacts: Optional[List[str]] = None  # For presentations, reports\n\n\nclass GenerateResponse(BaseModel):\n    \"\"\"Generation response\"\"\"\n    success: bool\n    artifact_id: str\n    artifact_type: str\n    title: str\n    format: str\n    file_path: Optional[str] = None\n    uri: Optional[str] = None\n    nested_artifacts: Optional[List[Dict[str, Any]]] = None\n    auto_selected: bool = False\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"API information\"\"\"\n    return {\n        \"name\": \"Knowledge Garden Artifact Generator\",\n        \"version\": \"3.0.0\",\n        \"endpoints\": {\n            \"generate\": \"/api/generate\",\n            \"status\": \"/api/status/{artifact_id}\",\n            \"types\": \"/api/types\",\n            \"health\": \"/health\"\n        },\n        \"features\": [\n            \"Automatic artifact type selection\",\n            \"Nested artifact support\",\n            \"Unified generation pipeline\",\n            \"Real-time status tracking\"\n        ]\n    }\n\n\n@app.post(\"/api/generate\", response_model=GenerateResponse)\nasync def generate_artifact(request: GenerateRequest):\n    \"\"\"Generate an artifact with optional auto-selection\"\"\"\n    try:\n        # Auto-select type if not provided\n        artifact_type = request.artifact_type\n        auto_selected = False\n        \n        if not artifact_type:\n            logger.info(\"Auto-selecting artifact type\")\n            artifact_type = await auto_selector.select_type(\n                content=request.content,\n                options=request.options\n            )\n            auto_selected = True\n            logger.info(f\"Auto-selected type: {artifact_type}\")\n        \n        # Validate artifact type\n        if not generator.is_valid_type(artifact_type):\n            raise HTTPException(400, f\"Invalid artifact type: {artifact_type}\")\n        \n        # Handle nested artifacts for complex types\n        nested_results = None\n        if artifact_type in [\"presentation\", \"report\"] and request.nested_artifacts:\n            logger.info(f\"Generating nested artifacts: {request.nested_artifacts}\")\n            nested_results = await _generate_nested_artifacts(\n                request.content,\n                request.nested_artifacts,\n                request.options\n            )\n        \n        # Generate main artifact\n        result = await generator.generate(\n            artifact_type=artifact_type,\n            content=request.content,\n            options=request.options or {},\n            source_uri=request.source_uri,\n            nested_artifacts=nested_results\n        )\n        \n        # Store in artifact manager\n        await artifact_manager.store(result)\n        \n        return GenerateResponse(\n            success=True,\n            artifact_id=result.artifact_id,\n            artifact_type=result.artifact_type,\n            title=result.title,\n            format=result.format,\n            file_path=str(result.file_path) if result.file_path else None,\n            uri=result.uri,\n            nested_artifacts=nested_results,\n            auto_selected=auto_selected\n        )\n        \n    except Exception as e:\n        logger.error(f\"Generation failed: {e}\")\n        raise HTTPException(500, str(e))\n\n\nasync def _generate_nested_artifacts(\n    content: str,\n    artifact_types: List[str],\n    parent_options: Dict[str, Any]\n) -> List[Dict[str, Any]]:\n    \"\"\"Generate nested artifacts for complex types\"\"\"\n    nested_results = []\n    \n    for artifact_type in artifact_types:\n        try:\n            # Generate nested artifact\n            result = await generator.generate(\n                artifact_type=artifact_type,\n                content=content,\n                options={\n                    **parent_options,\n                    \"is_nested\": True,\n                    \"parent_type\": parent_options.get(\"parent_type\", \"presentation\")\n                }\n            )\n            \n            nested_results.append({\n                \"artifact_id\": result.artifact_id,\n                \"artifact_type\": result.artifact_type,\n                \"title\": result.title,\n                \"uri\": result.uri\n            })\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate nested {artifact_type}: {e}\")\n            \n    return nested_results\n\n\n@app.get(\"/api/status/{artifact_id}\")\nasync def get_artifact_status(artifact_id: str):\n    \"\"\"Get artifact generation status\"\"\"\n    try:\n        status = await artifact_manager.get_status(artifact_id)\n        if not status:\n            raise HTTPException(404, \"Artifact not found\")\n        return status\n    except Exception as e:\n        logger.error(f\"Error getting status: {e}\")\n        raise HTTPException(500, str(e))\n\n\n@app.get(\"/api/types\")\nasync def get_artifact_types():\n    \"\"\"Get available artifact types with descriptions\"\"\"\n    return {\n        \"types\": generator.get_available_types(),\n        \"auto_selection_available\": True,\n        \"nested_support\": [\"presentation\", \"report\"]\n    }\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Check service health\"\"\"\n    health = {\n        \"status\": \"healthy\",\n        \"components\": {\n            \"auto_selector\": await auto_selector.check_health(),\n            \"generator\": await generator.check_health(),\n            \"artifact_manager\": await artifact_manager.check_health()\n        }\n    }\n    \n    # Overall health\n    if all(c.get(\"healthy\", False) for c in health[\"components\"].values()):\n        health[\"status\"] = \"healthy\"\n    else:\n        health[\"status\"] = \"degraded\"\n        \n    return health\n</artifact>\n</artifacts>\n\n### 3. **Improved Auto-Selector**\n\n<artifacts>\n<artifact identifier=\"auto-selector\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Improved Auto-Selector for Artifact Types\">\n\"\"\"Unified auto-selector for artifact types\"\"\"\nimport logging\nfrom typing import Dict, Any, Optional, List\nimport json\n\nlogger = logging.getLogger(__name__)\n\n\nclass AutoSelector:\n    \"\"\"Automatically select the best artifact type based on content analysis\"\"\"\n    \n    def __init__(self, llm_service=None, use_parliament=False):\n        \"\"\"Initialize the auto-selector\n        \n        Args:\n            llm_service: LLM service for content analysis\n            use_parliament: Whether to use Parliament for complex decisions\n        \"\"\"\n        self.llm_service = llm_service\n        self.use_parliament = use_parliament\n        \n        # Define artifact type characteristics\n        self.type_characteristics = {\n            \"diagram\": {\n                \"keywords\": [\"flow\", \"process\", \"sequence\", \"steps\", \"relationship\", \"hierarchy\", \"structure\"],\n                \"patterns\": [r\"(\\w+)\\s*->\\s*(\\w+)\", r\"step \\d+\", r\"first.*then.*finally\"],\n                \"description\": \"Visual representation of processes, flows, or relationships\"\n            },\n            \"summary\": {\n                \"keywords\": [\"summarize\", \"key points\", \"tldr\", \"overview\", \"brief\", \"concise\"],\n                \"patterns\": [r\"in summary\", r\"to summarize\", r\"key takeaways\"],\n                \"description\": \"Concise text summary of content\"\n            },\n            \"framework\": {\n                \"keywords\": [\"framework\", \"model\", \"structure\", \"approach\", \"methodology\", \"system\"],\n                \"patterns\": [r\"\\d+\\s*(steps|phases|stages)\", r\"component\", r\"element\"],\n                \"description\": \"Structured approach or methodology\"\n            },\n            \"practice\": {\n                \"keywords\": [\"practice\", \"exercise\", \"activity\", \"workshop\", \"technique\", \"method\"],\n                \"patterns\": [r\"how to\", r\"instructions\", r\"try this\"],\n                \"description\": \"Actionable practice or exercise\"\n            },\n            \"insight_card\": {\n                \"keywords\": [\"insight\", \"realization\", \"learning\", \"discovery\", \"understanding\"],\n                \"patterns\": [r\"I realized\", r\"key insight\", r\"discovered that\"],\n                \"description\": \"Visual card highlighting key insights\"\n            },\n            \"presentation\": {\n                \"keywords\": [\"presentation\", \"slides\", \"deck\", \"pitch\", \"talk\", \"present\"],\n                \"patterns\": [r\"slide \\d+\", r\"agenda\", r\"objectives\"],\n                \"description\": \"Slide deck for presenting information\"\n            },\n            \"report\": {\n                \"keywords\": [\"report\", \"analysis\", \"findings\", \"research\", \"study\", \"comprehensive\"],\n                \"patterns\": [r\"executive summary\", r\"conclusion\", r\"recommendations\"],\n                \"description\": \"Comprehensive document with analysis\"\n            },\n            \"image\": {\n                \"keywords\": [\"image\", \"picture\", \"photo\", \"visual\", \"illustration\", \"graphic\"],\n                \"patterns\": [r\"show me\", r\"picture of\", r\"image of\"],\n                \"description\": \"Visual image or illustration\"\n            },\n            \"chart\": {\n                \"keywords\": [\"chart\", \"graph\", \"data\", \"statistics\", \"metrics\", \"numbers\", \"percentage\"],\n                \"patterns\": [r\"\\d+%\", r\"data shows\", r\"statistics\"],\n                \"description\": \"Data visualization or chart\"\n            }\n        }\n    \n    async def select_type(\n        self, \n        content: str, \n        options: Optional[Dict[str, Any]] = None,\n        context: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Select the most appropriate artifact type\n        \n        Args:\n            content: Content to analyze\n            options: Additional options\n            context: Additional context\n            \n        Returns:\n            Selected artifact type\n        \"\"\"\n        # Quick pattern-based selection\n        pattern_scores = self._score_by_patterns(content)\n        \n        # If clear winner, return it\n        if pattern_scores:\n            top_type, top_score = max(pattern_scores.items(), key=lambda x: x[1])\n            if top_score > 5:  # High confidence\n                logger.info(f\"Pattern-based selection: {top_type} (score: {top_score})\")\n                return top_type\n        \n        # Use LLM for more nuanced selection\n        if self.llm_service:\n            llm_selection = await self._select_with_llm(content, pattern_scores, options)\n            if llm_selection:\n                return llm_selection\n        \n        # Fallback based on content length and structure\n        return self._fallback_selection(content, pattern_scores)\n    \n    def _score_by_patterns(self, content: str) -> Dict[str, float]:\n        \"\"\"Score artifact types based on keyword and pattern matching\n        \n        Args:\n            content: Content to analyze\n            \n        Returns:\n            Scores for each artifact type\n        \"\"\"\n        import re\n        \n        scores = {}\n        content_lower = content.lower()\n        \n        for artifact_type, characteristics in self.type_characteristics.items():\n            score = 0.0\n            \n            # Check keywords\n            for keyword in characteristics[\"keywords\"]:\n                if keyword in content_lower:\n                    score += 1.0\n            \n            # Check patterns\n            for pattern in characteristics[\"patterns\"]:\n                matches = re.findall(pattern, content, re.IGNORECASE)\n                score += len(matches) * 0.5\n            \n            if score > 0:\n                scores[artifact_type] = score\n        \n        return scores\n    \n    async def _select_with_llm(\n        self, \n        content: str, \n        pattern_scores: Dict[str, float],\n        options: Optional[Dict[str, Any]] = None\n    ) -> Optional[str]:\n        \"\"\"Use LLM to select artifact type\n        \n        Args:\n            content: Content to analyze\n            pattern_scores: Pattern-based scores\n            options: Additional options\n            \n        Returns:\n            Selected artifact type or None\n        \"\"\"\n        # Create prompt\n        type_descriptions = \"\\n\".join([\n            f\"- {t}: {c['description']}\"\n            for t, c in self.type_characteristics.items()\n        ])\n        \n        prompt = f\"\"\"Analyze this content and select the most appropriate artifact type.\n\nContent: \"{content[:500]}...\"\n\nAvailable artifact types:\n{type_descriptions}\n\nPattern analysis suggests: {json.dumps(pattern_scores, indent=2)}\n\nSelect ONE artifact type that best represents how this content should be visualized.\nConsider the user's intent and the nature of the information.\n\nReturn ONLY the artifact type name, nothing else.\"\"\"\n\n        try:\n            response = await self.llm_service.generate(\n                prompt=prompt,\n                temperature=0.3,\n                max_tokens=50\n            )\n            \n            # Clean and validate response\n            selected_type = response.strip().lower().replace(\"_\", \"\")\n            \n            # Map variations to standard names\n            type_mapping = {\n                \"diagram\": [\"diagram\", \"flowchart\", \"flow\"],\n                \"summary\": [\"summary\", \"summarize\", \"brief\"],\n                \"framework\": [\"framework\", \"model\"],\n                \"practice\": [\"practice\", \"exercise\", \"activity\"],\n                \"insight_card\": [\"insight\", \"insightcard\", \"card\"],\n                \"presentation\": [\"presentation\", \"slides\", \"deck\"],\n                \"report\": [\"report\", \"document\"],\n                \"image\": [\"image\", \"picture\", \"photo\"],\n                \"chart\": [\"chart\", \"graph\", \"visualization\"]\n            }\n            \n            for standard_type, variations in type_mapping.items():\n                if any(var in selected_type for var in variations):\n                    logger.info(f\"LLM selected: {standard_type}\")\n                    return standard_type\n                    \n        except Exception as e:\n            logger.error(f\"LLM selection failed: {e}\")\n            \n        return None\n    \n    def _fallback_selection(self, content: str, pattern_scores: Dict[str, float]) -> str:\n        \"\"\"Fallback selection based on content characteristics\n        \n        Args:\n            content: Content to analyze\n            pattern_scores: Pattern-based scores\n            \n        Returns:\n            Selected artifact type\n        \"\"\"\n        # If we have pattern scores, use the top one\n        if pattern_scores:\n            return max(pattern_scores.items(), key=lambda x: x[1])[0]\n        \n        # Otherwise, use content characteristics\n        lines = content.strip().split('\\n')\n        word_count = len(content.split())\n        \n        # Short content -> insight card\n        if word_count < 50:\n            return \"insight_card\"\n        \n        # Multiple lines with arrows -> diagram\n        if any('->' in line for line in lines):\n            return \"diagram\"\n        \n        # Numbered list -> framework or practice\n        if any(line.strip().startswith(('1.', '2.', '3.')) for line in lines):\n            if word_count > 200:\n                return \"framework\"\n            else:\n                return \"practice\"\n        \n        # Long content -> report or summary\n        if word_count > 500:\n            return \"report\"\n        \n        # Default to summary\n        return \"summary\"\n    \n    async def check_health(self) -> Dict[str, Any]:\n        \"\"\"Check health of the auto-selector\"\"\"\n        health = {\n            \"healthy\": True,\n            \"llm_available\": self.llm_service is not None,\n            \"parliament_enabled\": self.use_parliament,\n            \"artifact_types\": len(self.type_characteristics)\n        }\n        \n        if self.llm_service:\n            try:\n                # Test LLM with simple prompt\n                test_response = await self.llm_service.generate(\n                    \"Return 'OK'\",\n                    max_tokens=10\n                )\n                health[\"llm_responsive\"] = \"ok\" in test_response.lower()\n            except:\n                health[\"llm_responsive\"] = False\n                health[\"healthy\"] = False\n                \n        return health\n</artifact>\n</artifacts>\n\n### 4. **Presentation Generator with Nested Artifacts**\n\n<artifacts>\n<artifact identifier=\"presentation-generator\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Presentation Generator with Nested Artifacts\">\n\"\"\"Presentation generator that creates slides with nested artifacts\"\"\"\nimport logging\nimport json\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nimport asyncio\n\nfrom ..models import ArtifactRequest, ArtifactResult, ArtifactType\nfrom .base import BaseGenerator\n\nlogger = logging.getLogger(__name__)\n\n\nclass PresentationGenerator(BaseGenerator):\n    \"\"\"Generate presentations with slides containing nested artifacts\"\"\"\n    \n    def __init__(self, output_dir: Optional[Path] = None, \n                 llm_service=None, generators_registry=None):\n        \"\"\"Initialize the presentation generator\n        \n        Args:\n            output_dir: Output directory for artifacts\n            llm_service: LLM service for content generation\n            generators_registry: Registry of other generators for nested artifacts\n        \"\"\"\n        self._artifact_type = ArtifactType.PRESENTATION\n        super().__init__(output_dir)\n        self.llm = llm_service\n        self.generators = generators_registry or {}\n    \n    @property\n    def artifact_type(self) -> ArtifactType:\n        \"\"\"Get artifact type\"\"\"\n        return self._artifact_type\n    \n    async def generate(self, request: ArtifactRequest, \n                      artifact_id: Optional[str] = None) -> ArtifactResult:\n        \"\"\"Generate a presentation with nested artifacts\n        \n        Args:\n            request: Artifact request\n            artifact_id: Optional artifact ID\n            \n        Returns:\n            Generated presentation artifact\n        \"\"\"\n        # Generate artifact ID\n        artifact_id = self.create_artifact_id(artifact_id)\n        \n        # Extract options\n        options = request.options or {}\n        title = options.get(\"title\", \"Generated Presentation\")\n        slide_count = options.get(\"slide_count\", 5)\n        include_diagrams = options.get(\"include_diagrams\", True)\n        include_charts = options.get(\"include_charts\", False)\n        theme = options.get(\"theme\", \"modern\")\n        \n        # Generate presentation structure\n        presentation_structure = await self._generate_presentation_structure(\n            request.content, title, slide_count, options\n        )\n        \n        # Generate slides with nested artifacts\n        slides = []\n        nested_artifacts = []\n        \n        for slide_spec in presentation_structure[\"slides\"]:\n            slide = await self._generate_slide(\n                slide_spec, request.content, artifact_id\n            )\n            slides.append(slide)\n            \n            # Collect nested artifacts\n            if slide.get(\"nested_artifacts\"):\n                nested_artifacts.extend(slide[\"nested_artifacts\"])\n        \n        # Create presentation data\n        presentation_data = {\n            \"title\": title,\n            \"theme\": theme,\n            \"slides\": slides,\n            \"nested_artifacts\": nested_artifacts,\n            \"metadata\": {\n                \"generated_at\": datetime.now().isoformat(),\n                \"slide_count\": len(slides),\n                \"artifact_count\": len(nested_artifacts)\n            }\n        }\n        \n        # Generate presentation file (Markdown with embedded artifacts)\n        markdown_content = self._generate_markdown_presentation(presentation_data)\n        \n        # Save files\n        markdown_path = self.type_dir / f\"{artifact_id}.md\"\n        json_path = self.type_dir / f\"{artifact_id}.json\"\n        \n        # Save markdown version\n        with open(markdown_path, 'w') as f:\n            f.write(markdown_content)\n            \n        # Save JSON version\n        with open(json_path, 'w') as f:\n            json.dump(presentation_data, f, indent=2)\n        \n        # Generate relative URI\n        rel_path = markdown_path.relative_to(self.output_dir.parent)\n        uri = f\"/static/{rel_path}\"\n        \n        return ArtifactResult(\n            artifact_id=artifact_id,\n            artifact_type=self.artifact_type,\n            title=title,\n            content=presentation_data,\n            format=\"md\",\n            file_path=markdown_path,\n            uri=uri,\n            metadata={\n                \"slide_count\": len(slides),\n                \"nested_artifacts\": nested_artifacts,\n                \"theme\": theme\n            }\n        )\n    \n    async def _generate_presentation_structure(\n        self, content: str, title: str, \n        slide_count: int, options: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"Generate presentation structure using LLM\n        \n        Args:\n            content: Source content\n            title: Presentation title\n            slide_count: Number of slides\n            options: Additional options\n            \n        Returns:\n            Presentation structure\n        \"\"\"\n        if not self.llm:\n            # Fallback structure\n            return self._create_fallback_structure(content, title, slide_count)\n        \n        prompt = f\"\"\"Create a presentation structure for the following content.\n\nTitle: {title}\nTarget slides: {slide_count}\n\nContent:\n{content[:2000]}...\n\nFor each slide, specify:\n1. Slide title\n2. Key points (2-4 bullets)\n3. Suggested artifacts (diagram, chart, image)\n4. Speaker notes\n\nReturn as JSON:\n{{\n  \"slides\": [\n    {{\n      \"title\": \"Slide Title\",\n      \"points\": [\"Point 1\", \"Point 2\"],\n      \"artifacts\": [\"diagram\", \"chart\"],\n      \"notes\": \"Speaker notes...\"\n    }}\n  ]\n}}\"\"\"\n\n        try:\n            response = await self.llm.generate(prompt, temperature=0.7)\n            structure = json.loads(response)\n            return structure\n        except Exception as e:\n            logger.error(f\"Failed to generate structure with LLM: {e}\")\n            return self._create_fallback_structure(content, title, slide_count)\n    \n    def _create_fallback_structure(self, content: str, \n                                  title: str, slide_count: int) -> Dict[str, Any]:\n        \"\"\"Create fallback presentation structure\n        \n        Args:\n            content: Source content\n            title: Presentation title\n            slide_count: Number of slides\n            \n        Returns:\n            Fallback structure\n        \"\"\"\n        # Split content into sections\n        paragraphs = content.split('\\n\\n')\n        content_per_slide = max(1, len(paragraphs) // (slide_count - 2))\n        \n        slides = [\n            {\n                \"title\": title,\n                \"points\": [\n                    \"Introduction\",\n                    \"Overview of key concepts\",\n                    \"What we'll cover\"\n                ],\n                \"artifacts\": [],\n                \"notes\": \"Welcome everyone to this presentation.\"\n            }\n        ]\n        \n        # Content slides\n        for i in range(1, slide_count - 1):\n            slide_content = paragraphs[\n                (i-1)*content_per_slide : i*content_per_slide\n            ]\n            \n            slides.append({\n                \"title\": f\"Key Point {i}\",\n                \"points\": self._extract_points(slide_content),\n                \"artifacts\": [\"diagram\"] if i == 1 else [],\n                \"notes\": \"Elaborate on these points...\"\n            })\n        \n        # Conclusion slide\n        slides.append({\n            \"title\": \"Conclusion\",\n            \"points\": [\n                \"Summary of key points\",\n                \"Next steps\",\n                \"Questions?\"\n            ],\n            \"artifacts\": [],\n            \"notes\": \"Thank you for your attention.\"\n        })\n        \n        return {\"slides\": slides}\n    \n    def _extract_points(self, paragraphs: List[str]) -> List[str]:\n        \"\"\"Extract key points from paragraphs\n        \n        Args:\n            paragraphs: List of paragraph texts\n            \n        Returns:\n            List of bullet points\n        \"\"\"\n        points = []\n        \n        for para in paragraphs[:3]:  # Max 3 points\n            if para.strip():\n                # Take first sentence or first 100 chars\n                sentences = para.split('.')\n                point = sentences[0].strip()\n                if len(point) > 100:\n                    point = point[:97] + \"...\"\n                points.append(point)\n        \n        return points or [\"Key information from this section\"]\n    \n    async def _generate_slide(\n        self, slide_spec: Dict[str, Any], \n        content: str, presentation_id: str\n    ) -> Dict[str, Any]:\n        \"\"\"Generate a single slide with nested artifacts\n        \n        Args:\n            slide_spec: Slide specification\n            content: Source content\n            presentation_id: Parent presentation ID\n            \n        Returns:\n            Generated slide data\n        \"\"\"\n        slide = {\n            \"title\": slide_spec[\"title\"],\n            \"points\": slide_spec[\"points\"],\n            \"notes\": slide_spec.get(\"notes\", \"\"),\n            \"nested_artifacts\": []\n        }\n        \n        # Generate nested artifacts\n        for artifact_type in slide_spec.get(\"artifacts\", []):\n            if artifact_type in self.generators:\n                try:\n                    # Create request for nested artifact\n                    nested_request = ArtifactRequest(\n                        content=f\"{slide['title']}\\n\" + \"\\n\".join(slide['points']),\n                        artifact_type=ArtifactType(artifact_type),\n                        options={\n                            \"parent_id\": presentation_id,\n                            \"parent_type\": \"presentation\",\n                            \"simplified\": True  # Simpler version for slides\n                        }\n                    )\n                    \n                    # Generate nested artifact\n                    generator = self.generators[artifact_type]\n                    nested_result = await generator.generate(nested_request)\n                    \n                    slide[\"nested_artifacts\"].append({\n                        \"type\": artifact_type,\n                        \"artifact_id\": nested_result.artifact_id,\n                        \"uri\": nested_result.uri\n                    })\n                    \n                except Exception as e:\n                    logger.error(f\"Failed to generate nested {artifact_type}: {e}\")\n        \n        return slide\n    \n    def _generate_markdown_presentation(self, presentation_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Markdown representation of presentation\n        \n        Args:\n            presentation_data: Presentation data\n            \n        Returns:\n            Markdown content\n        \"\"\"\n        lines = [\n            f\"# {presentation_data['title']}\",\n            \"\",\n            f\"Generated: {presentation_data['metadata']['generated_at']}\",\n            \"\",\n            \"---\",\n            \"\"\n        ]\n        \n        for i, slide in enumerate(presentation_data['slides']):\n            # Slide header\n            lines.extend([\n                f\"## Slide {i+1}: {slide['title']}\",\n                \"\"\n            ])\n            \n            # Bullet points\n            for point in slide['points']:\n                lines.append(f\"- {point}\")\n            lines.append(\"\")\n            \n            # Nested artifacts\n            if slide.get('nested_artifacts'):\n                lines.append(\"### Artifacts\")\n                for artifact in slide['nested_artifacts']:\n                    lines.append(f\"- [{artifact['type']}]({artifact['uri']})\")\n                lines.append(\"\")\n            \n            # Speaker notes\n            if slide.get('notes'):\n                lines.extend([\n                    \"### Speaker Notes\",\n                    f\"> {slide['notes']}\",\n                    \"\"\n                ])\n            \n            lines.extend([\"---\", \"\"])\n        \n        return \"\\n\".join(lines)\n    \n    async def check_health(self) -> Dict[str, Any]:\n        \"\"\"Check generator health\"\"\"\n        health = await super().check_health()\n        \n        health.update({\n            \"llm_available\": self.llm is not None,\n            \"nested_generators\": len(self.generators),\n            \"max_slides\": 20\n        })\n        \n        return health\n</artifact>\n</artifacts>\n\n### 5. **Unified Artifact Generator**\n\n<artifacts>\n<artifact identifier=\"unified-generator\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Unified Artifact Generator\">\n\"\"\"Unified artifact generator that orchestrates all artifact types\"\"\"\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nimport asyncio\n\nfrom .models import ArtifactRequest, ArtifactResult, ArtifactType\nfrom .generators.base import BaseGenerator\nfrom .generators.diagram import DiagramGenerator\nfrom .generators.image import ImageGenerator\nfrom .generators.summary import SummaryGenerator\nfrom .generators.framework import FrameworkGenerator\nfrom .generators.presentation import PresentationGenerator\nfrom .generators.report import ReportGenerator\nfrom .generators.chart import ChartGenerator\nfrom .generators.practice import PracticeGenerator\nfrom .generators.insight_card import InsightCardGenerator\n\nlogger = logging.getLogger(__name__)\n\n\nclass UnifiedArtifactGenerator:\n    \"\"\"Main generator that orchestrates all artifact generation\"\"\"\n    \n    def __init__(self, output_dir: Optional[Path] = None,\n                 llm_service=None, mermaid_service=None):\n        \"\"\"Initialize the unified generator\n        \n        Args:\n            output_dir: Base output directory\n            llm_service: LLM service for text generation\n            mermaid_service: Service for diagram rendering\n        \"\"\"\n        # Set up output directory\n        self.output_dir = output_dir or Path(__file__).parent / \"static\" / \"artifacts\"\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Services\n        self.llm_service = llm_service\n        self.mermaid_service = mermaid_service\n        \n        # Initialize generators\n        self.generators = self._init_generators()\n        \n        logger.info(f\"Initialized unified generator with {len(self.generators)} generators\")\n    \n    def _init_generators(self) -> Dict[str, BaseGenerator]:\n        \"\"\"Initialize all available generators\"\"\"\n        generators = {}\n        \n        # Diagram generator\n        if self.mermaid_service:\n            generators[\"diagram\"] = DiagramGenerator(\n                output_dir=self.output_dir,\n                mermaid_service=self.mermaid_service,\n                llm_service=self.llm_service\n            )\n        \n        # Image generator\n        generators[\"image\"] = ImageGenerator(\n            output_dir=self.output_dir,\n            llm_service=self.llm_service\n        )\n        \n        # Text-based generators\n        if self.llm_service:\n            generators[\"summary\"] = SummaryGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"framework\"] = FrameworkGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"practice\"] = PracticeGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"insight_card\"] = InsightCardGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"report\"] = ReportGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service,\n                generators=generators  # For nested artifacts\n            )\n        \n        # Chart generator\n        generators[\"chart\"] = ChartGenerator(\n            output_dir=self.output_dir,\n            llm_service=self.llm_service\n        )\n        \n        # Presentation generator (needs access to other generators)\n        if self.llm_service:\n            generators[\"presentation\"] = PresentationGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service,\n                generators_registry=generators\n            )\n        \n        return generators\n    \n    def is_valid_type(self, artifact_type: str) -> bool:\n        \"\"\"Check if artifact type is valid\n        \n        Args:\n            artifact_type: Type to check\n            \n        Returns:\n            True if valid\n        \"\"\"\n        return artifact_type in self.generators\n    \n    def get_available_types(self) -> List[Dict[str, Any]]:\n        \"\"\"Get available artifact types with info\n        \n        Returns:\n            List of type information\n        \"\"\"\n        types = []\n        \n        for type_name, generator in self.generators.items():\n            types.append({\n                \"type\": type_name,\n                \"name\": type_name.replace(\"_\", \" \").title(),\n                \"available\": True,\n                \"supports_nesting\": type_name in [\"presentation\", \"report\"]\n            })\n        \n        # Add unavailable types\n        all_types = set(t.value for t in ArtifactType)\n        available_types = set(self.generators.keys())\n        \n        for missing_type in all_types - available_types:\n            types.append({\n                \"type\": missing_type,\n                \"name\": missing_type.replace(\"_\", \" \").title(),\n                \"available\": False,\n                \"supports_nesting\": False\n            })\n        \n        return sorted(types, key=lambda x: x[\"name\"])\n    \n    async def generate(\n        self,\n        artifact_type: str,\n        content: str,\n        options: Optional[Dict[str, Any]] = None,\n        source_uri: Optional[str] = None,\n        nested_artifacts: Optional[List[Dict[str, Any]]] = None\n    ) -> ArtifactResult:\n        \"\"\"Generate an artifact\n        \n        Args:\n            artifact_type: Type of artifact to generate\n            content: Source content\n            options: Generation options\n            source_uri: Source URI\n            nested_artifacts: Pre-generated nested artifacts\n            \n        Returns:\n            Generated artifact result\n        \"\"\"\n        # Validate type\n        if artifact_type not in self.generators:\n            raise ValueError(f\"No generator available for type: {artifact_type}\")\n        \n        # Get generator\n        generator = self.generators[artifact_type]\n        \n        # Create request\n        try:\n            artifact_type_enum = ArtifactType(artifact_type)\n        except ValueError:\n            raise ValueError(f\"Invalid artifact type: {artifact_type}\")\n        \n        request = ArtifactRequest(\n            content=content,\n            artifact_type=artifact_type_enum,\n            options=options or {},\n            source_uri=source_uri\n        )\n        \n        # Add nested artifacts to options if provided\n        if nested_artifacts:\n            request.options[\"nested_artifacts\"] = nested_artifacts\n        \n        # Generate artifact\n        logger.info(f\"Generating {artifact_type} artifact\")\n        \n        try:\n            result = await generator.generate(request)\n            logger.info(f\"Successfully generated {artifact_type}: {result.artifact_id}\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate {artifact_type}: {e}\")\n            raise\n    \n    async def generate_batch(\n        self,\n        requests: List[Dict[str, Any]]\n    ) -> List[ArtifactResult]:\n        \"\"\"Generate multiple artifacts in parallel\n        \n        Args:\n            requests: List of generation requests\n            \n        Returns:\n            List of results\n        \"\"\"\n        tasks = []\n        \n        for req in requests:\n            task = self.generate(\n                artifact_type=req[\"artifact_type\"],\n                content=req[\"content\"],\n                options=req.get(\"options\"),\n                source_uri=req.get(\"source_uri\")\n            )\n            tasks.append(task)\n        \n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Filter out exceptions\n        successful_results = []\n        for i, result in enumerate(results):\n            if isinstance(result, Exception):\n                logger.error(f\"Batch item {i} failed: {result}\")\n            else:\n                successful_results.append(result)\n        \n        return successful_results\n    \n    async def check_health(self) -> Dict[str, Any]:\n        \"\"\"Check health of all generators\n        \n        Returns:\n            Health status\n        \"\"\"\n        health = {\n            \"healthy\": True,\n            \"generators\": {},\n            \"output_dir_exists\": self.output_dir.exists()\n        }\n        \n        # Check each generator\n        for type_name, generator in self.generators.items():\n            try:\n                generator_health = await generator.check_health()\n                health[\"generators\"][type_name] = generator_health\n                \n                if not generator_health.get(\"healthy\", True):\n                    health[\"healthy\"] = False\n                    \n            except Exception as e:\n                health[\"generators\"][type_name] = {\n                    \"healthy\": False,\n                    \"error\": str(e)\n                }\n                health[\"healthy\"] = False\n        \n        return health\n</artifact>\n</artifacts>\n\n### 6. **Run Script to Clean Up and Migrate**\n\n<artifacts>\n<artifact identifier=\"migration-script\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Migration Script to Clean Up Knowledge Garden\">\n#!/usr/bin/env python3\n\"\"\"Migration script to clean up and streamline Knowledge Garden artifact system\"\"\"\nimport os\nimport shutil\nimport logging\nfrom pathlib import Path\nimport json\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef backup_directory(src: Path, backup_suffix: str = \"_backup\"):\n    \"\"\"Create backup of directory before migration\"\"\"\n    if src.exists():\n        backup = Path(str(src) + backup_suffix)\n        if backup.exists():\n            logger.warning(f\"Backup already exists: {backup}\")\n            return\n        \n        logger.info(f\"Creating backup: {src} -> {backup}\")\n        shutil.copytree(src, backup)\n\n\ndef migrate_artifact_studio():\n    \"\"\"Migrate useful parts from artifact_studio to artifact_generator\"\"\"\n    logger.info(\"=== Migrating artifact_studio ===\")\n    \n    studio_path = Path(\"knowledge_garden/apps/artifact_studio\")\n    generator_path = Path(\"knowledge_garden/apps/artifact_generator\")\n    \n    if not studio_path.exists():\n        logger.warning(\"artifact_studio not found, skipping migration\")\n        return\n    \n    # Backup first\n    backup_directory(studio_path)\n    \n    # Check for any custom generators to migrate\n    custom_generators = []\n    for file in studio_path.glob(\"*.py\"):\n        with open(file) as f:\n            content = f.read()\n            if \"generate_\" in content and file.name not in [\"__init__.py\", \"studio.py\"]:\n                custom_generators.append(file)\n    \n    if custom_generators:\n        logger.info(f\"Found {len(custom_generators)} custom generators to review\")\n        for gen in custom_generators:\n            logger.info(f\"  - Review: {gen}\")\n    \n    # Remove artifact_studio\n    logger.info(\"Removing artifact_studio directory\")\n    shutil.rmtree(studio_path)\n\n\ndef update_living_artifact_system():\n    \"\"\"Update LivingArtifactSystem to use unified generator\"\"\"\n    logger.info(\"=== Updating LivingArtifactSystem ===\")\n    \n    las_path = Path(\"knowledge_garden/core/living_artifact_system.py\")\n    \n    if not las_path.exists():\n        logger.warning(\"LivingArtifactSystem not found\")\n        return\n    \n    # Backup\n    backup_path = las_path.with_suffix(\".py.backup\")\n    shutil.copy(las_path, backup_path)\n    \n    # Read content\n    with open(las_path) as f:\n        content = f.read()\n    \n    # Update imports\n    new_imports = \"\"\"from knowledge_garden.apps.artifact_generator.generator import UnifiedArtifactGenerator\nfrom knowledge_garden.apps.artifact_generator.auto_selector import AutoSelector\nfrom knowledge_garden.apps.artifact_generator.artifact_manager import ArtifactManager\"\"\"\n    \n    # Replace old generator initialization\n    content = content.replace(\n        \"from knowledge_garden.apps.artifact_studio.generator import ArtifactGenerator\",\n        new_imports\n    )\n    \n    # Update initialization\n    content = content.replace(\n        \"self.generators['default'] = ArtifactGenerator()\",\n        \"self.generator = UnifiedArtifactGenerator()\\n        self.auto_selector = AutoSelector()\"\n    )\n    \n    # Write back\n    with open(las_path, 'w') as f:\n        f.write(content)\n    \n    logger.info(\"Updated LivingArtifactSystem\")\n\n\ndef create_missing_generators():\n    \"\"\"Create stub files for missing generators\"\"\"\n    logger.info(\"=== Creating missing generators ===\")\n    \n    generators_dir = Path(\"knowledge_garden/apps/artifact_generator/generators\")\n    generators_dir.mkdir(exist_ok=True, parents=True)\n    \n    # List of generators that need to be created\n    missing_generators = [\n        (\"summary\", \"SummaryGenerator\"),\n        (\"framework\", \"FrameworkGenerator\"),\n        (\"practice\", \"PracticeGenerator\"),\n        (\"insight_card\", \"InsightCardGenerator\"),\n        (\"report\", \"ReportGenerator\"),\n        (\"chart\", \"ChartGenerator\")\n    ]\n    \n    # Base template for generators\n    template = '''\"\"\"[TITLE] generator for Knowledge Garden\"\"\"\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\n\nfrom ..models import ArtifactRequest, ArtifactResult, ArtifactType\nfrom .base import BaseGenerator\n\nlogger = logging.getLogger(__name__)\n\n\nclass [CLASS](BaseGenerator):\n    \"\"\"Generate [TYPE] artifacts\"\"\"\n    \n    def __init__(self, output_dir: Optional[Path] = None, llm_service=None):\n        \"\"\"Initialize the [TYPE] generator\"\"\"\n        self._artifact_type = ArtifactType.[ENUM]\n        super().__init__(output_dir)\n        self.llm = llm_service\n    \n    @property\n    def artifact_type(self) -> ArtifactType:\n        \"\"\"Get artifact type\"\"\"\n        return self._artifact_type\n    \n    async def generate(self, request: ArtifactRequest, \n                      artifact_id: Optional[str] = None) -> ArtifactResult:\n        \"\"\"Generate a [TYPE] artifact\"\"\"\n        # Generate artifact ID\n        artifact_id = self.create_artifact_id(artifact_id)\n        \n        # TODO: Implement [TYPE] generation logic\n        logger.info(f\"Generating [TYPE] artifact: {artifact_id}\")\n        \n        # Extract options\n        options = request.options or {}\n        title = options.get(\"title\", \"Generated [TITLE]\")\n        \n        # For now, return placeholder\n        content = f\"# {title}\\\\n\\\\nPlaceholder [TYPE] content for:\\\\n{request.content[:200]}...\"\n        \n        # Save file\n        file_path = self.type_dir / f\"{artifact_id}.md\"\n        with open(file_path, 'w') as f:\n            f.write(content)\n        \n        # Create result\n        return ArtifactResult(\n            artifact_id=artifact_id,\n            artifact_type=self.artifact_type,\n            title=title,\n            content=content,\n            format=\"md\",\n            file_path=file_path,\n            uri=f\"/static/artifacts/[TYPE]/{artifact_id}.md\"\n        )\n'''\n    \n    for filename, classname in missing_generators:\n        filepath = generators_dir / f\"{filename}.py\"\n        \n        if not filepath.exists():\n            logger.info(f\"Creating {filename}.py\")\n            \n            # Customize template\n            artifact_type = filename.upper()\n            title = filename.replace(\"_\", \" \").title()\n            \n            content = template.replace(\"[CLASS]\", classname)\n            content = content.replace(\"[TYPE]\", filename)\n            content = content.replace(\"[ENUM]\", artifact_type)\n            content = content.replace(\"[TITLE]\", title)\n            \n            with open(filepath, 'w') as f:\n                f.write(content)\n\n\ndef update_api_endpoints():\n    \"\"\"Update API to use unified endpoint\"\"\"\n    logger.info(\"=== Updating API endpoints ===\")\n    \n    # This would be done by replacing the old api.py with the new unified one\n    api_path = Path(\"knowledge_garden/apps/artifact_generator/api.py\")\n    \n    if api_path.exists():\n        backup_directory(api_path.parent, \"_api_backup\")\n        logger.info(\"API backup created\")\n    \n    logger.info(\"Ready to replace with unified API\")\n\n\ndef create_config_file():\n    \"\"\"Create unified configuration file\"\"\"\n    logger.info(\"=== Creating unified config ===\")\n    \n    config_path = Path(\"knowledge_garden/config/artifacts.yaml\")\n    \n    if config_path.exists():\n        logger.info(\"Config already exists, skipping\")\n        return\n    \n    config = {\n        \"artifact_generator\": {\n            \"output_dir\": \"data/artifacts\",\n            \"auto_select\": True,\n            \"default_type\": \"summary\",\n            \"nested_artifacts\": {\n                \"enabled\": True,\n                \"max_depth\": 3\n            },\n            \"generators\": {\n                \"diagram\": {\"enabled\": True},\n                \"summary\": {\"enabled\": True},\n                \"framework\": {\"enabled\": True},\n                \"practice\": {\"enabled\": True},\n                \"insight_card\": {\"enabled\": True},\n                \"presentation\": {\"enabled\": True, \"supports_nesting\": True},\n                \"report\": {\"enabled\": True, \"supports_nesting\": True},\n                \"image\": {\"enabled\": True},\n                \"chart\": {\"enabled\": True}\n            }\n        }\n    }\n    \n    config_path.parent.mkdir(exist_ok=True, parents=True)\n    \n    with open(config_path, 'w') as f:\n        import yaml\n        yaml.dump(config, f, default_flow_style=False)\n    \n    logger.info(\"Created unified config file\")\n\n\ndef main():\n    \"\"\"Run the migration\"\"\"\n    logger.info(\"Starting Knowledge Garden artifact system migration...\")\n    \n    # Check if we're in the right directory\n    if not Path(\"knowledge_garden\").exists():\n        logger.error(\"Please run from the Knowledge Garden root directory\")\n        return\n    \n    # Run migrations\n    try:\n        migrate_artifact_studio()\n        update_living_artifact_system()\n        create_missing_generators()\n        update_api_endpoints()\n        create_config_file()\n        \n        logger.info(\"\\n=== Migration Complete ===\")\n        logger.info(\"Next steps:\")\n        logger.info(\"1. Replace api.py with the unified version\")\n        logger.info(\"2. Update imports in other modules\")\n        logger.info(\"3. Test the unified generator\")\n        logger.info(\"4. Remove backup directories once verified\")\n        \n    except Exception as e:\n        logger.error(f\"Migration failed: {e}\")\n        logger.info(\"Check backups and restore if needed\")\n\n\nif __name__ == \"__main__\":\n    main()\n</artifact>\n</artifacts>\n\n### 7. **Example Usage**\n\n<artifacts>\n<artifact identifier=\"example-usage\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Example Usage of Unified Artifact System\">\n\"\"\"Example usage of the unified artifact generation system\"\"\"\nimport asyncio\nfrom knowledge_garden.apps.artifact_generator.api import app\nfrom knowledge_garden.apps.artifact_generator.generator import UnifiedArtifactGenerator\nfrom knowledge_garden.apps.artifact_generator.auto_selector import AutoSelector\nfrom knowledge_garden.infrastructure.services.llm_service import LLMService\n\n\nasync def example_auto_generation():\n    \"\"\"Example of automatic artifact type selection\"\"\"\n    \n    # Initialize services\n    llm_service = LLMService()\n    auto_selector = AutoSelector(llm_service)\n    generator = UnifiedArtifactGenerator(llm_service=llm_service)\n    \n    # Example content\n    content = \"\"\"\n    The user authentication flow works as follows:\n    1. User enters credentials\n    2. System validates against database\n    3. If valid, generate JWT token\n    4. Return token to user\n    5. User includes token in subsequent requests\n    \n    This ensures secure access to protected resources.\n    \"\"\"\n    \n    # Auto-select artifact type\n    selected_type = await auto_selector.select_type(content)\n    print(f\"Auto-selected type: {selected_type}\")  # Should select \"diagram\"\n    \n    # Generate artifact\n    result = await generator.generate(\n        artifact_type=selected_type,\n        content=content,\n        options={\"title\": \"Authentication Flow\"}\n    )\n    \n    print(f\"Generated: {result.artifact_id}\")\n    print(f\"File: {result.file_path}\")\n\n\nasync def example_presentation_with_nested():\n    \"\"\"Example of presentation with nested artifacts\"\"\"\n    \n    # Initialize services\n    llm_service = LLMService()\n    generator = UnifiedArtifactGenerator(llm_service=llm_service)\n    \n    # Presentation content\n    content = \"\"\"\n    Knowledge Garden Architecture\n    \n    The Knowledge Garden is a system for extracting and organizing knowledge from conversations.\n    \n    Key components:\n    - Extraction pipeline processes conversations\n    - Knowledge graph stores structured data\n    - Artifact generators create visualizations\n    - Parliament engine makes complex decisions\n    \n    The system uses a three-tier knowledge model:\n    - Personal: From user conversations\n    - Digested: Validated external knowledge\n    - Peripheral: References and citations\n    \"\"\"\n    \n    # Generate presentation with nested artifacts\n    result = await generator.generate(\n        artifact_type=\"presentation\",\n        content=content,\n        options={\n            \"title\": \"Knowledge Garden Overview\",\n            \"slide_count\": 5,\n            \"include_diagrams\": True,\n            \"theme\": \"modern\"\n        }\n    )\n    \n    print(f\"Generated presentation: {result.artifact_id}\")\n    print(f\"Slides: {result.metadata['slide_count']}\")\n    print(f\"Nested artifacts: {result.metadata['nested_artifacts']}\")\n\n\nasync def example_api_usage():\n    \"\"\"Example of using the unified API\"\"\"\n    from httpx import AsyncClient\n    \n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Auto-generate (type selection)\n        response = await client.post(\n            \"/api/generate\",\n            json={\n                \"content\": \"I realized that focusing on one task at a time leads to better results than multitasking.\",\n                \"options\": {\"author\": \"Test User\"}\n            }\n        )\n        \n        result = response.json()\n        print(f\"Auto-selected: {result['artifact_type']}\")  # Should be \"insight_card\"\n        print(f\"Artifact ID: {result['artifact_id']}\")\n        \n        # Generate specific type\n        response = await client.post(\n            \"/api/generate\",\n            json={\n                \"content\": \"Productivity increases by 40% when using focused work blocks\",\n                \"artifact_type\": \"chart\",\n                \"options\": {\"chart_type\": \"bar\"}\n            }\n        )\n        \n        result = response.json()\n        print(f\"Generated chart: {result['artifact_id']}\")\n\n\nif __name__ == \"__main__\":\n    # Run examples\n    asyncio.run(example_auto_generation())\n    asyncio.run(example_presentation_with_nested())\n    asyncio.run(example_api_usage())\n</artifact>\n</artifacts>\n\n## Summary\n\nThe refactored system:\n\n1. **Consolidates** all artifact generation into a single, unified system\n2. **Auto-selects** artifact types by default using pattern matching and LLM\n3. **Supports nested artifacts** for presentations and reports\n4. **Simplifies the API** to a single `/api/generate` endpoint\n5. **Removes redundancy** between multiple generator systems\n6. **Provides clear extension points** for new artifact types\n\nThe presentation generator now properly supports slides with nested diagrams, charts, and images, making it a true composite artifact type.",
      "created_at": "2025-06-11T14:48:04.419207Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-06-11T14:43:26.009143Z",
            "stop_timestamp": "2025-06-11T14:43:52.334282Z",
            "flags": null,
            "type": "thinking",
            "thinking": "Let me analyze this Knowledge Garden codebase to understand the structure and identify overlapping functionality, particularly around artifact generation.\n\n## Key Components I've Identified:\n\n### 1. **Artifact Generation Systems**\nThere are at least 3 different artifact generation approaches:\n\n1. **Legacy artifact_studio** (`apps/artifact_studio/`)\n   - Has `ArtifactStudio` with methods like `generate_framework`, `generate_diagram`\n   - Direct artifact type methods\n\n2. **Unified artifact_generator** (`apps/artifact_generator/`)\n   - More comprehensive with:\n   - `ArtifactGenerator` - main orchestrator\n   - `AutoGenerator` - automatic type selection\n   - Type-specific generators in `generators/` directory\n   - Supports diagrams, summaries, frameworks, reports, presentations, etc.\n\n3. **Living Artifact System** (`core/living_artifact_system.py`)\n   - Another orchestration layer\n   - Seems to manage artifact lifecycle and dependencies\n\n### 2. **Overlapping Functionality**\n\n1. **Artifact Type Selection**:\n   - `AutoGenerator` in artifact_generator already does automatic selection\n   - `Parliament Engine` can also make decisions about artifact types\n   - There's redundancy here\n\n2. **Generator Registration**:\n   - `ArtifactGenerator` has `_register_generators()`\n   - `LivingArtifactSystem` also has `_init_generators()`\n   - Both maintain generator registries\n\n3. **Storage and Paths**:\n   - Multiple places define artifact storage paths\n   - `ArtifactGenerator`, `LivingArtifactSystem`, and individual generators all manage paths\n\n4. **API Endpoints**:\n   - `/api/generate` - direct generation\n   - `/api/auto-generate` - automatic type selection\n   - Similar functionality, could be unified\n\n### 3. **Presentation/Slides Generation**\nLooking at the code, I see:\n\n\nI notice a gap in the presentation generation capabilities. The system lists presentations as an artifact type, but lacks a dedicated implementation. While a PDF generator has a presentation method, it remains unintegrated. This creates a significant limitation in creating comprehensive slide-based artifacts.\n\n### 4. **Nested Artifacts**\nThe current architecture struggles with complex artifact composition. Ideal presentation generation would require sophisticated nested artifact support, enabling dynamic creation of slides with embedded elements like diagrams, charts, and images as sub-artifacts.\n\n## Recommendations:\n\n1. **Consolidate Artifact Generation**\n   - Streamline multiple generation systems\n   - Eliminate redundant approaches\n   - Create a unified, flexible artifact generation framework\n\n2. **Presentation Generator Development**\n   - Design a robust `PresentationGenerator`\n   - Enable dynamic, nested artifact creation\n   - Leverage existing generation mechanisms for sub-components\n\n3. **Intelligent Auto-Selection**\n   - Implement a centralized selection strategy\n   - Utilize specialized engines for complex decision-making\n   - Remove fragmented selection logic\n\n4. **Storage Optimization**\n   - Standardize configuration pathways\n   - Implement consistent naming conventions\n   - Improve overall artifact management infrastructure",
            "summaries": [
              {
                "summary": "Thinking about reviewing, optimizing, and streamlining code artifact generation and selection processes"
              },
              {
                "summary": "Analyzing Knowledge Garden codebase for artifact generation systems"
              },
              {
                "summary": "Consolidating artifact generation and recommending system improvements"
              },
              {
                "summary": "Dissected artifact generation, proposed unified streamlined system approach."
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-06-11T14:43:48.366860Z",
            "stop_timestamp": "2025-06-11T14:48:03.695126Z",
            "flags": null,
            "type": "text",
            "text": "Looking at the Knowledge Garden codebase, I can see significant overlap and opportunities for streamlining. Here's my analysis and recommendations:\n\n## Key Overlapping Functionality\n\n1. **Multiple Artifact Generation Systems**:\n   - Legacy `artifact_studio` app\n   - Newer `artifact_generator` app  \n   - `LivingArtifactSystem` in core\n   - All doing similar things with different approaches\n\n2. **Redundant Auto-Selection**:\n   - `AutoGenerator` uses LLM for selection\n   - Parliament Engine also makes artifact decisions\n   - API has both `/generate` and `/auto-generate` endpoints\n\n3. **No Presentation Generator** despite it being listed as a type\n\n4. **Nested artifacts not supported** (needed for slides with diagrams/charts)\n\n## Recommendations and Implementation\n\n### 1. **Streamlined Artifact System Architecture**\n\n<artifacts>\n<artifact identifier=\"artifact-system-refactor\" type=\"text/markdown\" title=\"Artifact System Refactoring Plan\">\n# Knowledge Garden Artifact System Refactoring\n\n## Proposed Architecture\n\n```\napps/artifact_generator/\n├── api.py                    # Single API with auto-selection\n├── generator.py              # Main orchestrator\n├── auto_selector.py          # Unified selection logic\n├── generators/\n│   ├── base.py              # Base generator class\n│   ├── diagram.py           \n│   ├── summary.py           \n│   ├── framework.py         \n│   ├── presentation.py      # NEW: With nested artifacts\n│   ├── report.py            \n│   ├── image.py            \n│   └── chart.py            \n└── artifact_manager.py       # Replaces LivingArtifactSystem\n```\n\n## Key Changes\n\n1. **Remove Legacy Code**:\n   - Delete `apps/artifact_studio/` entirely\n   - Move useful parts to `artifact_generator`\n\n2. **Unified Auto-Selection**:\n   - Single `/api/generate` endpoint\n   - Auto-selection by default\n   - Optional `artifact_type` parameter to override\n\n3. **Nested Artifact Support**:\n   - Artifacts can request sub-artifacts\n   - Presentation generator orchestrates slide generation\n   - Each slide can contain diagrams, charts, images\n\n4. **Simplified Storage**:\n   - Single source of truth for paths\n   - Consistent naming conventions\n   - Better organization by type and date\n</artifact>\n</artifacts>\n\n### 2. **Unified API with Auto-Selection**\n\n<artifacts>\n<artifact identifier=\"unified-api\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Unified API for Artifact Generation\">\n\"\"\"Unified API for artifact generation with automatic type selection\"\"\"\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\nfrom typing import Dict, Any, Optional, List\nfrom pathlib import Path\nimport logging\n\nfrom .auto_selector import AutoSelector\nfrom .generator import UnifiedArtifactGenerator\nfrom .artifact_manager import ArtifactManager\n\nlogger = logging.getLogger(__name__)\n\napp = FastAPI(\n    title=\"Knowledge Garden Artifact Generator\",\n    description=\"Unified artifact generation with automatic type selection\",\n    version=\"3.0.0\"\n)\n\n# CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Static files\nstatic_dir = Path(__file__).parent / \"static\"\nstatic_dir.mkdir(exist_ok=True)\napp.mount(\"/static\", StaticFiles(directory=str(static_dir)), name=\"static\")\n\n# Initialize components\nauto_selector = AutoSelector()\ngenerator = UnifiedArtifactGenerator()\nartifact_manager = ArtifactManager()\n\n\nclass GenerateRequest(BaseModel):\n    \"\"\"Unified generation request\"\"\"\n    content: str\n    artifact_type: Optional[str] = None  # If None, auto-select\n    options: Optional[Dict[str, Any]] = None\n    source_uri: Optional[str] = None\n    nested_artifacts: Optional[List[str]] = None  # For presentations, reports\n\n\nclass GenerateResponse(BaseModel):\n    \"\"\"Generation response\"\"\"\n    success: bool\n    artifact_id: str\n    artifact_type: str\n    title: str\n    format: str\n    file_path: Optional[str] = None\n    uri: Optional[str] = None\n    nested_artifacts: Optional[List[Dict[str, Any]]] = None\n    auto_selected: bool = False\n\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"API information\"\"\"\n    return {\n        \"name\": \"Knowledge Garden Artifact Generator\",\n        \"version\": \"3.0.0\",\n        \"endpoints\": {\n            \"generate\": \"/api/generate\",\n            \"status\": \"/api/status/{artifact_id}\",\n            \"types\": \"/api/types\",\n            \"health\": \"/health\"\n        },\n        \"features\": [\n            \"Automatic artifact type selection\",\n            \"Nested artifact support\",\n            \"Unified generation pipeline\",\n            \"Real-time status tracking\"\n        ]\n    }\n\n\n@app.post(\"/api/generate\", response_model=GenerateResponse)\nasync def generate_artifact(request: GenerateRequest):\n    \"\"\"Generate an artifact with optional auto-selection\"\"\"\n    try:\n        # Auto-select type if not provided\n        artifact_type = request.artifact_type\n        auto_selected = False\n        \n        if not artifact_type:\n            logger.info(\"Auto-selecting artifact type\")\n            artifact_type = await auto_selector.select_type(\n                content=request.content,\n                options=request.options\n            )\n            auto_selected = True\n            logger.info(f\"Auto-selected type: {artifact_type}\")\n        \n        # Validate artifact type\n        if not generator.is_valid_type(artifact_type):\n            raise HTTPException(400, f\"Invalid artifact type: {artifact_type}\")\n        \n        # Handle nested artifacts for complex types\n        nested_results = None\n        if artifact_type in [\"presentation\", \"report\"] and request.nested_artifacts:\n            logger.info(f\"Generating nested artifacts: {request.nested_artifacts}\")\n            nested_results = await _generate_nested_artifacts(\n                request.content,\n                request.nested_artifacts,\n                request.options\n            )\n        \n        # Generate main artifact\n        result = await generator.generate(\n            artifact_type=artifact_type,\n            content=request.content,\n            options=request.options or {},\n            source_uri=request.source_uri,\n            nested_artifacts=nested_results\n        )\n        \n        # Store in artifact manager\n        await artifact_manager.store(result)\n        \n        return GenerateResponse(\n            success=True,\n            artifact_id=result.artifact_id,\n            artifact_type=result.artifact_type,\n            title=result.title,\n            format=result.format,\n            file_path=str(result.file_path) if result.file_path else None,\n            uri=result.uri,\n            nested_artifacts=nested_results,\n            auto_selected=auto_selected\n        )\n        \n    except Exception as e:\n        logger.error(f\"Generation failed: {e}\")\n        raise HTTPException(500, str(e))\n\n\nasync def _generate_nested_artifacts(\n    content: str,\n    artifact_types: List[str],\n    parent_options: Dict[str, Any]\n) -> List[Dict[str, Any]]:\n    \"\"\"Generate nested artifacts for complex types\"\"\"\n    nested_results = []\n    \n    for artifact_type in artifact_types:\n        try:\n            # Generate nested artifact\n            result = await generator.generate(\n                artifact_type=artifact_type,\n                content=content,\n                options={\n                    **parent_options,\n                    \"is_nested\": True,\n                    \"parent_type\": parent_options.get(\"parent_type\", \"presentation\")\n                }\n            )\n            \n            nested_results.append({\n                \"artifact_id\": result.artifact_id,\n                \"artifact_type\": result.artifact_type,\n                \"title\": result.title,\n                \"uri\": result.uri\n            })\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate nested {artifact_type}: {e}\")\n            \n    return nested_results\n\n\n@app.get(\"/api/status/{artifact_id}\")\nasync def get_artifact_status(artifact_id: str):\n    \"\"\"Get artifact generation status\"\"\"\n    try:\n        status = await artifact_manager.get_status(artifact_id)\n        if not status:\n            raise HTTPException(404, \"Artifact not found\")\n        return status\n    except Exception as e:\n        logger.error(f\"Error getting status: {e}\")\n        raise HTTPException(500, str(e))\n\n\n@app.get(\"/api/types\")\nasync def get_artifact_types():\n    \"\"\"Get available artifact types with descriptions\"\"\"\n    return {\n        \"types\": generator.get_available_types(),\n        \"auto_selection_available\": True,\n        \"nested_support\": [\"presentation\", \"report\"]\n    }\n\n\n@app.get(\"/health\")\nasync def health_check():\n    \"\"\"Check service health\"\"\"\n    health = {\n        \"status\": \"healthy\",\n        \"components\": {\n            \"auto_selector\": await auto_selector.check_health(),\n            \"generator\": await generator.check_health(),\n            \"artifact_manager\": await artifact_manager.check_health()\n        }\n    }\n    \n    # Overall health\n    if all(c.get(\"healthy\", False) for c in health[\"components\"].values()):\n        health[\"status\"] = \"healthy\"\n    else:\n        health[\"status\"] = \"degraded\"\n        \n    return health\n</artifact>\n</artifacts>\n\n### 3. **Improved Auto-Selector**\n\n<artifacts>\n<artifact identifier=\"auto-selector\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Improved Auto-Selector for Artifact Types\">\n\"\"\"Unified auto-selector for artifact types\"\"\"\nimport logging\nfrom typing import Dict, Any, Optional, List\nimport json\n\nlogger = logging.getLogger(__name__)\n\n\nclass AutoSelector:\n    \"\"\"Automatically select the best artifact type based on content analysis\"\"\"\n    \n    def __init__(self, llm_service=None, use_parliament=False):\n        \"\"\"Initialize the auto-selector\n        \n        Args:\n            llm_service: LLM service for content analysis\n            use_parliament: Whether to use Parliament for complex decisions\n        \"\"\"\n        self.llm_service = llm_service\n        self.use_parliament = use_parliament\n        \n        # Define artifact type characteristics\n        self.type_characteristics = {\n            \"diagram\": {\n                \"keywords\": [\"flow\", \"process\", \"sequence\", \"steps\", \"relationship\", \"hierarchy\", \"structure\"],\n                \"patterns\": [r\"(\\w+)\\s*->\\s*(\\w+)\", r\"step \\d+\", r\"first.*then.*finally\"],\n                \"description\": \"Visual representation of processes, flows, or relationships\"\n            },\n            \"summary\": {\n                \"keywords\": [\"summarize\", \"key points\", \"tldr\", \"overview\", \"brief\", \"concise\"],\n                \"patterns\": [r\"in summary\", r\"to summarize\", r\"key takeaways\"],\n                \"description\": \"Concise text summary of content\"\n            },\n            \"framework\": {\n                \"keywords\": [\"framework\", \"model\", \"structure\", \"approach\", \"methodology\", \"system\"],\n                \"patterns\": [r\"\\d+\\s*(steps|phases|stages)\", r\"component\", r\"element\"],\n                \"description\": \"Structured approach or methodology\"\n            },\n            \"practice\": {\n                \"keywords\": [\"practice\", \"exercise\", \"activity\", \"workshop\", \"technique\", \"method\"],\n                \"patterns\": [r\"how to\", r\"instructions\", r\"try this\"],\n                \"description\": \"Actionable practice or exercise\"\n            },\n            \"insight_card\": {\n                \"keywords\": [\"insight\", \"realization\", \"learning\", \"discovery\", \"understanding\"],\n                \"patterns\": [r\"I realized\", r\"key insight\", r\"discovered that\"],\n                \"description\": \"Visual card highlighting key insights\"\n            },\n            \"presentation\": {\n                \"keywords\": [\"presentation\", \"slides\", \"deck\", \"pitch\", \"talk\", \"present\"],\n                \"patterns\": [r\"slide \\d+\", r\"agenda\", r\"objectives\"],\n                \"description\": \"Slide deck for presenting information\"\n            },\n            \"report\": {\n                \"keywords\": [\"report\", \"analysis\", \"findings\", \"research\", \"study\", \"comprehensive\"],\n                \"patterns\": [r\"executive summary\", r\"conclusion\", r\"recommendations\"],\n                \"description\": \"Comprehensive document with analysis\"\n            },\n            \"image\": {\n                \"keywords\": [\"image\", \"picture\", \"photo\", \"visual\", \"illustration\", \"graphic\"],\n                \"patterns\": [r\"show me\", r\"picture of\", r\"image of\"],\n                \"description\": \"Visual image or illustration\"\n            },\n            \"chart\": {\n                \"keywords\": [\"chart\", \"graph\", \"data\", \"statistics\", \"metrics\", \"numbers\", \"percentage\"],\n                \"patterns\": [r\"\\d+%\", r\"data shows\", r\"statistics\"],\n                \"description\": \"Data visualization or chart\"\n            }\n        }\n    \n    async def select_type(\n        self, \n        content: str, \n        options: Optional[Dict[str, Any]] = None,\n        context: Optional[Dict[str, Any]] = None\n    ) -> str:\n        \"\"\"Select the most appropriate artifact type\n        \n        Args:\n            content: Content to analyze\n            options: Additional options\n            context: Additional context\n            \n        Returns:\n            Selected artifact type\n        \"\"\"\n        # Quick pattern-based selection\n        pattern_scores = self._score_by_patterns(content)\n        \n        # If clear winner, return it\n        if pattern_scores:\n            top_type, top_score = max(pattern_scores.items(), key=lambda x: x[1])\n            if top_score > 5:  # High confidence\n                logger.info(f\"Pattern-based selection: {top_type} (score: {top_score})\")\n                return top_type\n        \n        # Use LLM for more nuanced selection\n        if self.llm_service:\n            llm_selection = await self._select_with_llm(content, pattern_scores, options)\n            if llm_selection:\n                return llm_selection\n        \n        # Fallback based on content length and structure\n        return self._fallback_selection(content, pattern_scores)\n    \n    def _score_by_patterns(self, content: str) -> Dict[str, float]:\n        \"\"\"Score artifact types based on keyword and pattern matching\n        \n        Args:\n            content: Content to analyze\n            \n        Returns:\n            Scores for each artifact type\n        \"\"\"\n        import re\n        \n        scores = {}\n        content_lower = content.lower()\n        \n        for artifact_type, characteristics in self.type_characteristics.items():\n            score = 0.0\n            \n            # Check keywords\n            for keyword in characteristics[\"keywords\"]:\n                if keyword in content_lower:\n                    score += 1.0\n            \n            # Check patterns\n            for pattern in characteristics[\"patterns\"]:\n                matches = re.findall(pattern, content, re.IGNORECASE)\n                score += len(matches) * 0.5\n            \n            if score > 0:\n                scores[artifact_type] = score\n        \n        return scores\n    \n    async def _select_with_llm(\n        self, \n        content: str, \n        pattern_scores: Dict[str, float],\n        options: Optional[Dict[str, Any]] = None\n    ) -> Optional[str]:\n        \"\"\"Use LLM to select artifact type\n        \n        Args:\n            content: Content to analyze\n            pattern_scores: Pattern-based scores\n            options: Additional options\n            \n        Returns:\n            Selected artifact type or None\n        \"\"\"\n        # Create prompt\n        type_descriptions = \"\\n\".join([\n            f\"- {t}: {c['description']}\"\n            for t, c in self.type_characteristics.items()\n        ])\n        \n        prompt = f\"\"\"Analyze this content and select the most appropriate artifact type.\n\nContent: \"{content[:500]}...\"\n\nAvailable artifact types:\n{type_descriptions}\n\nPattern analysis suggests: {json.dumps(pattern_scores, indent=2)}\n\nSelect ONE artifact type that best represents how this content should be visualized.\nConsider the user's intent and the nature of the information.\n\nReturn ONLY the artifact type name, nothing else.\"\"\"\n\n        try:\n            response = await self.llm_service.generate(\n                prompt=prompt,\n                temperature=0.3,\n                max_tokens=50\n            )\n            \n            # Clean and validate response\n            selected_type = response.strip().lower().replace(\"_\", \"\")\n            \n            # Map variations to standard names\n            type_mapping = {\n                \"diagram\": [\"diagram\", \"flowchart\", \"flow\"],\n                \"summary\": [\"summary\", \"summarize\", \"brief\"],\n                \"framework\": [\"framework\", \"model\"],\n                \"practice\": [\"practice\", \"exercise\", \"activity\"],\n                \"insight_card\": [\"insight\", \"insightcard\", \"card\"],\n                \"presentation\": [\"presentation\", \"slides\", \"deck\"],\n                \"report\": [\"report\", \"document\"],\n                \"image\": [\"image\", \"picture\", \"photo\"],\n                \"chart\": [\"chart\", \"graph\", \"visualization\"]\n            }\n            \n            for standard_type, variations in type_mapping.items():\n                if any(var in selected_type for var in variations):\n                    logger.info(f\"LLM selected: {standard_type}\")\n                    return standard_type\n                    \n        except Exception as e:\n            logger.error(f\"LLM selection failed: {e}\")\n            \n        return None\n    \n    def _fallback_selection(self, content: str, pattern_scores: Dict[str, float]) -> str:\n        \"\"\"Fallback selection based on content characteristics\n        \n        Args:\n            content: Content to analyze\n            pattern_scores: Pattern-based scores\n            \n        Returns:\n            Selected artifact type\n        \"\"\"\n        # If we have pattern scores, use the top one\n        if pattern_scores:\n            return max(pattern_scores.items(), key=lambda x: x[1])[0]\n        \n        # Otherwise, use content characteristics\n        lines = content.strip().split('\\n')\n        word_count = len(content.split())\n        \n        # Short content -> insight card\n        if word_count < 50:\n            return \"insight_card\"\n        \n        # Multiple lines with arrows -> diagram\n        if any('->' in line for line in lines):\n            return \"diagram\"\n        \n        # Numbered list -> framework or practice\n        if any(line.strip().startswith(('1.', '2.', '3.')) for line in lines):\n            if word_count > 200:\n                return \"framework\"\n            else:\n                return \"practice\"\n        \n        # Long content -> report or summary\n        if word_count > 500:\n            return \"report\"\n        \n        # Default to summary\n        return \"summary\"\n    \n    async def check_health(self) -> Dict[str, Any]:\n        \"\"\"Check health of the auto-selector\"\"\"\n        health = {\n            \"healthy\": True,\n            \"llm_available\": self.llm_service is not None,\n            \"parliament_enabled\": self.use_parliament,\n            \"artifact_types\": len(self.type_characteristics)\n        }\n        \n        if self.llm_service:\n            try:\n                # Test LLM with simple prompt\n                test_response = await self.llm_service.generate(\n                    \"Return 'OK'\",\n                    max_tokens=10\n                )\n                health[\"llm_responsive\"] = \"ok\" in test_response.lower()\n            except:\n                health[\"llm_responsive\"] = False\n                health[\"healthy\"] = False\n                \n        return health\n</artifact>\n</artifacts>\n\n### 4. **Presentation Generator with Nested Artifacts**\n\n<artifacts>\n<artifact identifier=\"presentation-generator\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Presentation Generator with Nested Artifacts\">\n\"\"\"Presentation generator that creates slides with nested artifacts\"\"\"\nimport logging\nimport json\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom datetime import datetime\nimport asyncio\n\nfrom ..models import ArtifactRequest, ArtifactResult, ArtifactType\nfrom .base import BaseGenerator\n\nlogger = logging.getLogger(__name__)\n\n\nclass PresentationGenerator(BaseGenerator):\n    \"\"\"Generate presentations with slides containing nested artifacts\"\"\"\n    \n    def __init__(self, output_dir: Optional[Path] = None, \n                 llm_service=None, generators_registry=None):\n        \"\"\"Initialize the presentation generator\n        \n        Args:\n            output_dir: Output directory for artifacts\n            llm_service: LLM service for content generation\n            generators_registry: Registry of other generators for nested artifacts\n        \"\"\"\n        self._artifact_type = ArtifactType.PRESENTATION\n        super().__init__(output_dir)\n        self.llm = llm_service\n        self.generators = generators_registry or {}\n    \n    @property\n    def artifact_type(self) -> ArtifactType:\n        \"\"\"Get artifact type\"\"\"\n        return self._artifact_type\n    \n    async def generate(self, request: ArtifactRequest, \n                      artifact_id: Optional[str] = None) -> ArtifactResult:\n        \"\"\"Generate a presentation with nested artifacts\n        \n        Args:\n            request: Artifact request\n            artifact_id: Optional artifact ID\n            \n        Returns:\n            Generated presentation artifact\n        \"\"\"\n        # Generate artifact ID\n        artifact_id = self.create_artifact_id(artifact_id)\n        \n        # Extract options\n        options = request.options or {}\n        title = options.get(\"title\", \"Generated Presentation\")\n        slide_count = options.get(\"slide_count\", 5)\n        include_diagrams = options.get(\"include_diagrams\", True)\n        include_charts = options.get(\"include_charts\", False)\n        theme = options.get(\"theme\", \"modern\")\n        \n        # Generate presentation structure\n        presentation_structure = await self._generate_presentation_structure(\n            request.content, title, slide_count, options\n        )\n        \n        # Generate slides with nested artifacts\n        slides = []\n        nested_artifacts = []\n        \n        for slide_spec in presentation_structure[\"slides\"]:\n            slide = await self._generate_slide(\n                slide_spec, request.content, artifact_id\n            )\n            slides.append(slide)\n            \n            # Collect nested artifacts\n            if slide.get(\"nested_artifacts\"):\n                nested_artifacts.extend(slide[\"nested_artifacts\"])\n        \n        # Create presentation data\n        presentation_data = {\n            \"title\": title,\n            \"theme\": theme,\n            \"slides\": slides,\n            \"nested_artifacts\": nested_artifacts,\n            \"metadata\": {\n                \"generated_at\": datetime.now().isoformat(),\n                \"slide_count\": len(slides),\n                \"artifact_count\": len(nested_artifacts)\n            }\n        }\n        \n        # Generate presentation file (Markdown with embedded artifacts)\n        markdown_content = self._generate_markdown_presentation(presentation_data)\n        \n        # Save files\n        markdown_path = self.type_dir / f\"{artifact_id}.md\"\n        json_path = self.type_dir / f\"{artifact_id}.json\"\n        \n        # Save markdown version\n        with open(markdown_path, 'w') as f:\n            f.write(markdown_content)\n            \n        # Save JSON version\n        with open(json_path, 'w') as f:\n            json.dump(presentation_data, f, indent=2)\n        \n        # Generate relative URI\n        rel_path = markdown_path.relative_to(self.output_dir.parent)\n        uri = f\"/static/{rel_path}\"\n        \n        return ArtifactResult(\n            artifact_id=artifact_id,\n            artifact_type=self.artifact_type,\n            title=title,\n            content=presentation_data,\n            format=\"md\",\n            file_path=markdown_path,\n            uri=uri,\n            metadata={\n                \"slide_count\": len(slides),\n                \"nested_artifacts\": nested_artifacts,\n                \"theme\": theme\n            }\n        )\n    \n    async def _generate_presentation_structure(\n        self, content: str, title: str, \n        slide_count: int, options: Dict[str, Any]\n    ) -> Dict[str, Any]:\n        \"\"\"Generate presentation structure using LLM\n        \n        Args:\n            content: Source content\n            title: Presentation title\n            slide_count: Number of slides\n            options: Additional options\n            \n        Returns:\n            Presentation structure\n        \"\"\"\n        if not self.llm:\n            # Fallback structure\n            return self._create_fallback_structure(content, title, slide_count)\n        \n        prompt = f\"\"\"Create a presentation structure for the following content.\n\nTitle: {title}\nTarget slides: {slide_count}\n\nContent:\n{content[:2000]}...\n\nFor each slide, specify:\n1. Slide title\n2. Key points (2-4 bullets)\n3. Suggested artifacts (diagram, chart, image)\n4. Speaker notes\n\nReturn as JSON:\n{{\n  \"slides\": [\n    {{\n      \"title\": \"Slide Title\",\n      \"points\": [\"Point 1\", \"Point 2\"],\n      \"artifacts\": [\"diagram\", \"chart\"],\n      \"notes\": \"Speaker notes...\"\n    }}\n  ]\n}}\"\"\"\n\n        try:\n            response = await self.llm.generate(prompt, temperature=0.7)\n            structure = json.loads(response)\n            return structure\n        except Exception as e:\n            logger.error(f\"Failed to generate structure with LLM: {e}\")\n            return self._create_fallback_structure(content, title, slide_count)\n    \n    def _create_fallback_structure(self, content: str, \n                                  title: str, slide_count: int) -> Dict[str, Any]:\n        \"\"\"Create fallback presentation structure\n        \n        Args:\n            content: Source content\n            title: Presentation title\n            slide_count: Number of slides\n            \n        Returns:\n            Fallback structure\n        \"\"\"\n        # Split content into sections\n        paragraphs = content.split('\\n\\n')\n        content_per_slide = max(1, len(paragraphs) // (slide_count - 2))\n        \n        slides = [\n            {\n                \"title\": title,\n                \"points\": [\n                    \"Introduction\",\n                    \"Overview of key concepts\",\n                    \"What we'll cover\"\n                ],\n                \"artifacts\": [],\n                \"notes\": \"Welcome everyone to this presentation.\"\n            }\n        ]\n        \n        # Content slides\n        for i in range(1, slide_count - 1):\n            slide_content = paragraphs[\n                (i-1)*content_per_slide : i*content_per_slide\n            ]\n            \n            slides.append({\n                \"title\": f\"Key Point {i}\",\n                \"points\": self._extract_points(slide_content),\n                \"artifacts\": [\"diagram\"] if i == 1 else [],\n                \"notes\": \"Elaborate on these points...\"\n            })\n        \n        # Conclusion slide\n        slides.append({\n            \"title\": \"Conclusion\",\n            \"points\": [\n                \"Summary of key points\",\n                \"Next steps\",\n                \"Questions?\"\n            ],\n            \"artifacts\": [],\n            \"notes\": \"Thank you for your attention.\"\n        })\n        \n        return {\"slides\": slides}\n    \n    def _extract_points(self, paragraphs: List[str]) -> List[str]:\n        \"\"\"Extract key points from paragraphs\n        \n        Args:\n            paragraphs: List of paragraph texts\n            \n        Returns:\n            List of bullet points\n        \"\"\"\n        points = []\n        \n        for para in paragraphs[:3]:  # Max 3 points\n            if para.strip():\n                # Take first sentence or first 100 chars\n                sentences = para.split('.')\n                point = sentences[0].strip()\n                if len(point) > 100:\n                    point = point[:97] + \"...\"\n                points.append(point)\n        \n        return points or [\"Key information from this section\"]\n    \n    async def _generate_slide(\n        self, slide_spec: Dict[str, Any], \n        content: str, presentation_id: str\n    ) -> Dict[str, Any]:\n        \"\"\"Generate a single slide with nested artifacts\n        \n        Args:\n            slide_spec: Slide specification\n            content: Source content\n            presentation_id: Parent presentation ID\n            \n        Returns:\n            Generated slide data\n        \"\"\"\n        slide = {\n            \"title\": slide_spec[\"title\"],\n            \"points\": slide_spec[\"points\"],\n            \"notes\": slide_spec.get(\"notes\", \"\"),\n            \"nested_artifacts\": []\n        }\n        \n        # Generate nested artifacts\n        for artifact_type in slide_spec.get(\"artifacts\", []):\n            if artifact_type in self.generators:\n                try:\n                    # Create request for nested artifact\n                    nested_request = ArtifactRequest(\n                        content=f\"{slide['title']}\\n\" + \"\\n\".join(slide['points']),\n                        artifact_type=ArtifactType(artifact_type),\n                        options={\n                            \"parent_id\": presentation_id,\n                            \"parent_type\": \"presentation\",\n                            \"simplified\": True  # Simpler version for slides\n                        }\n                    )\n                    \n                    # Generate nested artifact\n                    generator = self.generators[artifact_type]\n                    nested_result = await generator.generate(nested_request)\n                    \n                    slide[\"nested_artifacts\"].append({\n                        \"type\": artifact_type,\n                        \"artifact_id\": nested_result.artifact_id,\n                        \"uri\": nested_result.uri\n                    })\n                    \n                except Exception as e:\n                    logger.error(f\"Failed to generate nested {artifact_type}: {e}\")\n        \n        return slide\n    \n    def _generate_markdown_presentation(self, presentation_data: Dict[str, Any]) -> str:\n        \"\"\"Generate Markdown representation of presentation\n        \n        Args:\n            presentation_data: Presentation data\n            \n        Returns:\n            Markdown content\n        \"\"\"\n        lines = [\n            f\"# {presentation_data['title']}\",\n            \"\",\n            f\"Generated: {presentation_data['metadata']['generated_at']}\",\n            \"\",\n            \"---\",\n            \"\"\n        ]\n        \n        for i, slide in enumerate(presentation_data['slides']):\n            # Slide header\n            lines.extend([\n                f\"## Slide {i+1}: {slide['title']}\",\n                \"\"\n            ])\n            \n            # Bullet points\n            for point in slide['points']:\n                lines.append(f\"- {point}\")\n            lines.append(\"\")\n            \n            # Nested artifacts\n            if slide.get('nested_artifacts'):\n                lines.append(\"### Artifacts\")\n                for artifact in slide['nested_artifacts']:\n                    lines.append(f\"- [{artifact['type']}]({artifact['uri']})\")\n                lines.append(\"\")\n            \n            # Speaker notes\n            if slide.get('notes'):\n                lines.extend([\n                    \"### Speaker Notes\",\n                    f\"> {slide['notes']}\",\n                    \"\"\n                ])\n            \n            lines.extend([\"---\", \"\"])\n        \n        return \"\\n\".join(lines)\n    \n    async def check_health(self) -> Dict[str, Any]:\n        \"\"\"Check generator health\"\"\"\n        health = await super().check_health()\n        \n        health.update({\n            \"llm_available\": self.llm is not None,\n            \"nested_generators\": len(self.generators),\n            \"max_slides\": 20\n        })\n        \n        return health\n</artifact>\n</artifacts>\n\n### 5. **Unified Artifact Generator**\n\n<artifacts>\n<artifact identifier=\"unified-generator\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Unified Artifact Generator\">\n\"\"\"Unified artifact generator that orchestrates all artifact types\"\"\"\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any\nimport asyncio\n\nfrom .models import ArtifactRequest, ArtifactResult, ArtifactType\nfrom .generators.base import BaseGenerator\nfrom .generators.diagram import DiagramGenerator\nfrom .generators.image import ImageGenerator\nfrom .generators.summary import SummaryGenerator\nfrom .generators.framework import FrameworkGenerator\nfrom .generators.presentation import PresentationGenerator\nfrom .generators.report import ReportGenerator\nfrom .generators.chart import ChartGenerator\nfrom .generators.practice import PracticeGenerator\nfrom .generators.insight_card import InsightCardGenerator\n\nlogger = logging.getLogger(__name__)\n\n\nclass UnifiedArtifactGenerator:\n    \"\"\"Main generator that orchestrates all artifact generation\"\"\"\n    \n    def __init__(self, output_dir: Optional[Path] = None,\n                 llm_service=None, mermaid_service=None):\n        \"\"\"Initialize the unified generator\n        \n        Args:\n            output_dir: Base output directory\n            llm_service: LLM service for text generation\n            mermaid_service: Service for diagram rendering\n        \"\"\"\n        # Set up output directory\n        self.output_dir = output_dir or Path(__file__).parent / \"static\" / \"artifacts\"\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Services\n        self.llm_service = llm_service\n        self.mermaid_service = mermaid_service\n        \n        # Initialize generators\n        self.generators = self._init_generators()\n        \n        logger.info(f\"Initialized unified generator with {len(self.generators)} generators\")\n    \n    def _init_generators(self) -> Dict[str, BaseGenerator]:\n        \"\"\"Initialize all available generators\"\"\"\n        generators = {}\n        \n        # Diagram generator\n        if self.mermaid_service:\n            generators[\"diagram\"] = DiagramGenerator(\n                output_dir=self.output_dir,\n                mermaid_service=self.mermaid_service,\n                llm_service=self.llm_service\n            )\n        \n        # Image generator\n        generators[\"image\"] = ImageGenerator(\n            output_dir=self.output_dir,\n            llm_service=self.llm_service\n        )\n        \n        # Text-based generators\n        if self.llm_service:\n            generators[\"summary\"] = SummaryGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"framework\"] = FrameworkGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"practice\"] = PracticeGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"insight_card\"] = InsightCardGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service\n            )\n            \n            generators[\"report\"] = ReportGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service,\n                generators=generators  # For nested artifacts\n            )\n        \n        # Chart generator\n        generators[\"chart\"] = ChartGenerator(\n            output_dir=self.output_dir,\n            llm_service=self.llm_service\n        )\n        \n        # Presentation generator (needs access to other generators)\n        if self.llm_service:\n            generators[\"presentation\"] = PresentationGenerator(\n                output_dir=self.output_dir,\n                llm_service=self.llm_service,\n                generators_registry=generators\n            )\n        \n        return generators\n    \n    def is_valid_type(self, artifact_type: str) -> bool:\n        \"\"\"Check if artifact type is valid\n        \n        Args:\n            artifact_type: Type to check\n            \n        Returns:\n            True if valid\n        \"\"\"\n        return artifact_type in self.generators\n    \n    def get_available_types(self) -> List[Dict[str, Any]]:\n        \"\"\"Get available artifact types with info\n        \n        Returns:\n            List of type information\n        \"\"\"\n        types = []\n        \n        for type_name, generator in self.generators.items():\n            types.append({\n                \"type\": type_name,\n                \"name\": type_name.replace(\"_\", \" \").title(),\n                \"available\": True,\n                \"supports_nesting\": type_name in [\"presentation\", \"report\"]\n            })\n        \n        # Add unavailable types\n        all_types = set(t.value for t in ArtifactType)\n        available_types = set(self.generators.keys())\n        \n        for missing_type in all_types - available_types:\n            types.append({\n                \"type\": missing_type,\n                \"name\": missing_type.replace(\"_\", \" \").title(),\n                \"available\": False,\n                \"supports_nesting\": False\n            })\n        \n        return sorted(types, key=lambda x: x[\"name\"])\n    \n    async def generate(\n        self,\n        artifact_type: str,\n        content: str,\n        options: Optional[Dict[str, Any]] = None,\n        source_uri: Optional[str] = None,\n        nested_artifacts: Optional[List[Dict[str, Any]]] = None\n    ) -> ArtifactResult:\n        \"\"\"Generate an artifact\n        \n        Args:\n            artifact_type: Type of artifact to generate\n            content: Source content\n            options: Generation options\n            source_uri: Source URI\n            nested_artifacts: Pre-generated nested artifacts\n            \n        Returns:\n            Generated artifact result\n        \"\"\"\n        # Validate type\n        if artifact_type not in self.generators:\n            raise ValueError(f\"No generator available for type: {artifact_type}\")\n        \n        # Get generator\n        generator = self.generators[artifact_type]\n        \n        # Create request\n        try:\n            artifact_type_enum = ArtifactType(artifact_type)\n        except ValueError:\n            raise ValueError(f\"Invalid artifact type: {artifact_type}\")\n        \n        request = ArtifactRequest(\n            content=content,\n            artifact_type=artifact_type_enum,\n            options=options or {},\n            source_uri=source_uri\n        )\n        \n        # Add nested artifacts to options if provided\n        if nested_artifacts:\n            request.options[\"nested_artifacts\"] = nested_artifacts\n        \n        # Generate artifact\n        logger.info(f\"Generating {artifact_type} artifact\")\n        \n        try:\n            result = await generator.generate(request)\n            logger.info(f\"Successfully generated {artifact_type}: {result.artifact_id}\")\n            return result\n            \n        except Exception as e:\n            logger.error(f\"Failed to generate {artifact_type}: {e}\")\n            raise\n    \n    async def generate_batch(\n        self,\n        requests: List[Dict[str, Any]]\n    ) -> List[ArtifactResult]:\n        \"\"\"Generate multiple artifacts in parallel\n        \n        Args:\n            requests: List of generation requests\n            \n        Returns:\n            List of results\n        \"\"\"\n        tasks = []\n        \n        for req in requests:\n            task = self.generate(\n                artifact_type=req[\"artifact_type\"],\n                content=req[\"content\"],\n                options=req.get(\"options\"),\n                source_uri=req.get(\"source_uri\")\n            )\n            tasks.append(task)\n        \n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Filter out exceptions\n        successful_results = []\n        for i, result in enumerate(results):\n            if isinstance(result, Exception):\n                logger.error(f\"Batch item {i} failed: {result}\")\n            else:\n                successful_results.append(result)\n        \n        return successful_results\n    \n    async def check_health(self) -> Dict[str, Any]:\n        \"\"\"Check health of all generators\n        \n        Returns:\n            Health status\n        \"\"\"\n        health = {\n            \"healthy\": True,\n            \"generators\": {},\n            \"output_dir_exists\": self.output_dir.exists()\n        }\n        \n        # Check each generator\n        for type_name, generator in self.generators.items():\n            try:\n                generator_health = await generator.check_health()\n                health[\"generators\"][type_name] = generator_health\n                \n                if not generator_health.get(\"healthy\", True):\n                    health[\"healthy\"] = False\n                    \n            except Exception as e:\n                health[\"generators\"][type_name] = {\n                    \"healthy\": False,\n                    \"error\": str(e)\n                }\n                health[\"healthy\"] = False\n        \n        return health\n</artifact>\n</artifacts>\n\n### 6. **Run Script to Clean Up and Migrate**\n\n<artifacts>\n<artifact identifier=\"migration-script\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Migration Script to Clean Up Knowledge Garden\">\n#!/usr/bin/env python3\n\"\"\"Migration script to clean up and streamline Knowledge Garden artifact system\"\"\"\nimport os\nimport shutil\nimport logging\nfrom pathlib import Path\nimport json\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\ndef backup_directory(src: Path, backup_suffix: str = \"_backup\"):\n    \"\"\"Create backup of directory before migration\"\"\"\n    if src.exists():\n        backup = Path(str(src) + backup_suffix)\n        if backup.exists():\n            logger.warning(f\"Backup already exists: {backup}\")\n            return\n        \n        logger.info(f\"Creating backup: {src} -> {backup}\")\n        shutil.copytree(src, backup)\n\n\ndef migrate_artifact_studio():\n    \"\"\"Migrate useful parts from artifact_studio to artifact_generator\"\"\"\n    logger.info(\"=== Migrating artifact_studio ===\")\n    \n    studio_path = Path(\"knowledge_garden/apps/artifact_studio\")\n    generator_path = Path(\"knowledge_garden/apps/artifact_generator\")\n    \n    if not studio_path.exists():\n        logger.warning(\"artifact_studio not found, skipping migration\")\n        return\n    \n    # Backup first\n    backup_directory(studio_path)\n    \n    # Check for any custom generators to migrate\n    custom_generators = []\n    for file in studio_path.glob(\"*.py\"):\n        with open(file) as f:\n            content = f.read()\n            if \"generate_\" in content and file.name not in [\"__init__.py\", \"studio.py\"]:\n                custom_generators.append(file)\n    \n    if custom_generators:\n        logger.info(f\"Found {len(custom_generators)} custom generators to review\")\n        for gen in custom_generators:\n            logger.info(f\"  - Review: {gen}\")\n    \n    # Remove artifact_studio\n    logger.info(\"Removing artifact_studio directory\")\n    shutil.rmtree(studio_path)\n\n\ndef update_living_artifact_system():\n    \"\"\"Update LivingArtifactSystem to use unified generator\"\"\"\n    logger.info(\"=== Updating LivingArtifactSystem ===\")\n    \n    las_path = Path(\"knowledge_garden/core/living_artifact_system.py\")\n    \n    if not las_path.exists():\n        logger.warning(\"LivingArtifactSystem not found\")\n        return\n    \n    # Backup\n    backup_path = las_path.with_suffix(\".py.backup\")\n    shutil.copy(las_path, backup_path)\n    \n    # Read content\n    with open(las_path) as f:\n        content = f.read()\n    \n    # Update imports\n    new_imports = \"\"\"from knowledge_garden.apps.artifact_generator.generator import UnifiedArtifactGenerator\nfrom knowledge_garden.apps.artifact_generator.auto_selector import AutoSelector\nfrom knowledge_garden.apps.artifact_generator.artifact_manager import ArtifactManager\"\"\"\n    \n    # Replace old generator initialization\n    content = content.replace(\n        \"from knowledge_garden.apps.artifact_studio.generator import ArtifactGenerator\",\n        new_imports\n    )\n    \n    # Update initialization\n    content = content.replace(\n        \"self.generators['default'] = ArtifactGenerator()\",\n        \"self.generator = UnifiedArtifactGenerator()\\n        self.auto_selector = AutoSelector()\"\n    )\n    \n    # Write back\n    with open(las_path, 'w') as f:\n        f.write(content)\n    \n    logger.info(\"Updated LivingArtifactSystem\")\n\n\ndef create_missing_generators():\n    \"\"\"Create stub files for missing generators\"\"\"\n    logger.info(\"=== Creating missing generators ===\")\n    \n    generators_dir = Path(\"knowledge_garden/apps/artifact_generator/generators\")\n    generators_dir.mkdir(exist_ok=True, parents=True)\n    \n    # List of generators that need to be created\n    missing_generators = [\n        (\"summary\", \"SummaryGenerator\"),\n        (\"framework\", \"FrameworkGenerator\"),\n        (\"practice\", \"PracticeGenerator\"),\n        (\"insight_card\", \"InsightCardGenerator\"),\n        (\"report\", \"ReportGenerator\"),\n        (\"chart\", \"ChartGenerator\")\n    ]\n    \n    # Base template for generators\n    template = '''\"\"\"[TITLE] generator for Knowledge Garden\"\"\"\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\n\nfrom ..models import ArtifactRequest, ArtifactResult, ArtifactType\nfrom .base import BaseGenerator\n\nlogger = logging.getLogger(__name__)\n\n\nclass [CLASS](BaseGenerator):\n    \"\"\"Generate [TYPE] artifacts\"\"\"\n    \n    def __init__(self, output_dir: Optional[Path] = None, llm_service=None):\n        \"\"\"Initialize the [TYPE] generator\"\"\"\n        self._artifact_type = ArtifactType.[ENUM]\n        super().__init__(output_dir)\n        self.llm = llm_service\n    \n    @property\n    def artifact_type(self) -> ArtifactType:\n        \"\"\"Get artifact type\"\"\"\n        return self._artifact_type\n    \n    async def generate(self, request: ArtifactRequest, \n                      artifact_id: Optional[str] = None) -> ArtifactResult:\n        \"\"\"Generate a [TYPE] artifact\"\"\"\n        # Generate artifact ID\n        artifact_id = self.create_artifact_id(artifact_id)\n        \n        # TODO: Implement [TYPE] generation logic\n        logger.info(f\"Generating [TYPE] artifact: {artifact_id}\")\n        \n        # Extract options\n        options = request.options or {}\n        title = options.get(\"title\", \"Generated [TITLE]\")\n        \n        # For now, return placeholder\n        content = f\"# {title}\\\\n\\\\nPlaceholder [TYPE] content for:\\\\n{request.content[:200]}...\"\n        \n        # Save file\n        file_path = self.type_dir / f\"{artifact_id}.md\"\n        with open(file_path, 'w') as f:\n            f.write(content)\n        \n        # Create result\n        return ArtifactResult(\n            artifact_id=artifact_id,\n            artifact_type=self.artifact_type,\n            title=title,\n            content=content,\n            format=\"md\",\n            file_path=file_path,\n            uri=f\"/static/artifacts/[TYPE]/{artifact_id}.md\"\n        )\n'''\n    \n    for filename, classname in missing_generators:\n        filepath = generators_dir / f\"{filename}.py\"\n        \n        if not filepath.exists():\n            logger.info(f\"Creating {filename}.py\")\n            \n            # Customize template\n            artifact_type = filename.upper()\n            title = filename.replace(\"_\", \" \").title()\n            \n            content = template.replace(\"[CLASS]\", classname)\n            content = content.replace(\"[TYPE]\", filename)\n            content = content.replace(\"[ENUM]\", artifact_type)\n            content = content.replace(\"[TITLE]\", title)\n            \n            with open(filepath, 'w') as f:\n                f.write(content)\n\n\ndef update_api_endpoints():\n    \"\"\"Update API to use unified endpoint\"\"\"\n    logger.info(\"=== Updating API endpoints ===\")\n    \n    # This would be done by replacing the old api.py with the new unified one\n    api_path = Path(\"knowledge_garden/apps/artifact_generator/api.py\")\n    \n    if api_path.exists():\n        backup_directory(api_path.parent, \"_api_backup\")\n        logger.info(\"API backup created\")\n    \n    logger.info(\"Ready to replace with unified API\")\n\n\ndef create_config_file():\n    \"\"\"Create unified configuration file\"\"\"\n    logger.info(\"=== Creating unified config ===\")\n    \n    config_path = Path(\"knowledge_garden/config/artifacts.yaml\")\n    \n    if config_path.exists():\n        logger.info(\"Config already exists, skipping\")\n        return\n    \n    config = {\n        \"artifact_generator\": {\n            \"output_dir\": \"data/artifacts\",\n            \"auto_select\": True,\n            \"default_type\": \"summary\",\n            \"nested_artifacts\": {\n                \"enabled\": True,\n                \"max_depth\": 3\n            },\n            \"generators\": {\n                \"diagram\": {\"enabled\": True},\n                \"summary\": {\"enabled\": True},\n                \"framework\": {\"enabled\": True},\n                \"practice\": {\"enabled\": True},\n                \"insight_card\": {\"enabled\": True},\n                \"presentation\": {\"enabled\": True, \"supports_nesting\": True},\n                \"report\": {\"enabled\": True, \"supports_nesting\": True},\n                \"image\": {\"enabled\": True},\n                \"chart\": {\"enabled\": True}\n            }\n        }\n    }\n    \n    config_path.parent.mkdir(exist_ok=True, parents=True)\n    \n    with open(config_path, 'w') as f:\n        import yaml\n        yaml.dump(config, f, default_flow_style=False)\n    \n    logger.info(\"Created unified config file\")\n\n\ndef main():\n    \"\"\"Run the migration\"\"\"\n    logger.info(\"Starting Knowledge Garden artifact system migration...\")\n    \n    # Check if we're in the right directory\n    if not Path(\"knowledge_garden\").exists():\n        logger.error(\"Please run from the Knowledge Garden root directory\")\n        return\n    \n    # Run migrations\n    try:\n        migrate_artifact_studio()\n        update_living_artifact_system()\n        create_missing_generators()\n        update_api_endpoints()\n        create_config_file()\n        \n        logger.info(\"\\n=== Migration Complete ===\")\n        logger.info(\"Next steps:\")\n        logger.info(\"1. Replace api.py with the unified version\")\n        logger.info(\"2. Update imports in other modules\")\n        logger.info(\"3. Test the unified generator\")\n        logger.info(\"4. Remove backup directories once verified\")\n        \n    except Exception as e:\n        logger.error(f\"Migration failed: {e}\")\n        logger.info(\"Check backups and restore if needed\")\n\n\nif __name__ == \"__main__\":\n    main()\n</artifact>\n</artifacts>\n\n### 7. **Example Usage**\n\n<artifacts>\n<artifact identifier=\"example-usage\" type=\"application/vnd.ant.code\" language=\"python\" title=\"Example Usage of Unified Artifact System\">\n\"\"\"Example usage of the unified artifact generation system\"\"\"\nimport asyncio\nfrom knowledge_garden.apps.artifact_generator.api import app\nfrom knowledge_garden.apps.artifact_generator.generator import UnifiedArtifactGenerator\nfrom knowledge_garden.apps.artifact_generator.auto_selector import AutoSelector\nfrom knowledge_garden.infrastructure.services.llm_service import LLMService\n\n\nasync def example_auto_generation():\n    \"\"\"Example of automatic artifact type selection\"\"\"\n    \n    # Initialize services\n    llm_service = LLMService()\n    auto_selector = AutoSelector(llm_service)\n    generator = UnifiedArtifactGenerator(llm_service=llm_service)\n    \n    # Example content\n    content = \"\"\"\n    The user authentication flow works as follows:\n    1. User enters credentials\n    2. System validates against database\n    3. If valid, generate JWT token\n    4. Return token to user\n    5. User includes token in subsequent requests\n    \n    This ensures secure access to protected resources.\n    \"\"\"\n    \n    # Auto-select artifact type\n    selected_type = await auto_selector.select_type(content)\n    print(f\"Auto-selected type: {selected_type}\")  # Should select \"diagram\"\n    \n    # Generate artifact\n    result = await generator.generate(\n        artifact_type=selected_type,\n        content=content,\n        options={\"title\": \"Authentication Flow\"}\n    )\n    \n    print(f\"Generated: {result.artifact_id}\")\n    print(f\"File: {result.file_path}\")\n\n\nasync def example_presentation_with_nested():\n    \"\"\"Example of presentation with nested artifacts\"\"\"\n    \n    # Initialize services\n    llm_service = LLMService()\n    generator = UnifiedArtifactGenerator(llm_service=llm_service)\n    \n    # Presentation content\n    content = \"\"\"\n    Knowledge Garden Architecture\n    \n    The Knowledge Garden is a system for extracting and organizing knowledge from conversations.\n    \n    Key components:\n    - Extraction pipeline processes conversations\n    - Knowledge graph stores structured data\n    - Artifact generators create visualizations\n    - Parliament engine makes complex decisions\n    \n    The system uses a three-tier knowledge model:\n    - Personal: From user conversations\n    - Digested: Validated external knowledge\n    - Peripheral: References and citations\n    \"\"\"\n    \n    # Generate presentation with nested artifacts\n    result = await generator.generate(\n        artifact_type=\"presentation\",\n        content=content,\n        options={\n            \"title\": \"Knowledge Garden Overview\",\n            \"slide_count\": 5,\n            \"include_diagrams\": True,\n            \"theme\": \"modern\"\n        }\n    )\n    \n    print(f\"Generated presentation: {result.artifact_id}\")\n    print(f\"Slides: {result.metadata['slide_count']}\")\n    print(f\"Nested artifacts: {result.metadata['nested_artifacts']}\")\n\n\nasync def example_api_usage():\n    \"\"\"Example of using the unified API\"\"\"\n    from httpx import AsyncClient\n    \n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\n        # Auto-generate (type selection)\n        response = await client.post(\n            \"/api/generate\",\n            json={\n                \"content\": \"I realized that focusing on one task at a time leads to better results than multitasking.\",\n                \"options\": {\"author\": \"Test User\"}\n            }\n        )\n        \n        result = response.json()\n        print(f\"Auto-selected: {result['artifact_type']}\")  # Should be \"insight_card\"\n        print(f\"Artifact ID: {result['artifact_id']}\")\n        \n        # Generate specific type\n        response = await client.post(\n            \"/api/generate\",\n            json={\n                \"content\": \"Productivity increases by 40% when using focused work blocks\",\n                \"artifact_type\": \"chart\",\n                \"options\": {\"chart_type\": \"bar\"}\n            }\n        )\n        \n        result = response.json()\n        print(f\"Generated chart: {result['artifact_id']}\")\n\n\nif __name__ == \"__main__\":\n    # Run examples\n    asyncio.run(example_auto_generation())\n    asyncio.run(example_presentation_with_nested())\n    asyncio.run(example_api_usage())\n</artifact>\n</artifacts>\n\n## Summary\n\nThe refactored system:\n\n1. **Consolidates** all artifact generation into a single, unified system\n2. **Auto-selects** artifact types by default using pattern matching and LLM\n3. **Supports nested artifacts** for presentations and reports\n4. **Simplifies the API** to a single `/api/generate` endpoint\n5. **Removes redundancy** between multiple generator systems\n6. **Provides clear extension points** for new artifact types\n\nThe presentation generator now properly supports slides with nested diagrams, charts, and images, making it a true composite artifact type.",
            "citations": []
          }
        ],
        "updated_at": "2025-06-11T14:48:04.419207Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}