{
  "id": "ea373a42-94a8-45b1-b082-b8d6cebb1fa7",
  "source": "claude",
  "title": "Troubleshooting Chat Functionality and Node Issues",
  "created_at": "2025-05-14T08:42:09.479198Z",
  "updated_at": "2025-05-14T08:43:30.953608Z",
  "summary": "",
  "message_count": 2,
  "messages": [
    {
      "id": "3d92f9e1-6099-4318-9733-60d01fb81ef1",
      "role": "human",
      "content": "my chat isn't working in my project, for some reason the nodes are not being added when i chat can you review and fix any files in full  i think there might be a lack of clarity and some errors, the main node of the room should be the first question posed to a \n  system prompt that's defined earlier and is the first start of the room - that's something we should be able to talk to i made a \n  new question and talked to it and it didn't update the list iwth my question, nor did it add the response of the LLM, the main \n  node should also be the first chat in the list when i go to the chat view, the node is the chat, we respond to the room and can \n  talk with it, and or we can in the chat view make a new node by saying \"new - agent, artifact, idea, question as a drop down\" or \n  something like that so it'll make a tier two class node inside the main question node,you can talk to them individually in a \n  nested thread, or you can talk to the main question card chat. where should we put the chat box for the main question card tier 1\n   - chats are on tier 3 review, be sure you understand and then analyze our code for how we're doing this and fix it if we're not.\n   and then be sure to actually append the persons message to the list when they chat. Make a plan and make a scrip that exports \n  all the files related to the chat and the view for the chat in one text file so i can edit it",
      "created_at": "2025-05-14T08:42:11.927454Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-14T08:42:11.921586Z",
            "stop_timestamp": "2025-05-14T08:42:11.921586Z",
            "flags": null,
            "type": "text",
            "text": "my chat isn't working in my project, for some reason the nodes are not being added when i chat can you review and fix any files in full  i think there might be a lack of clarity and some errors, the main node of the room should be the first question posed to a \n  system prompt that's defined earlier and is the first start of the room - that's something we should be able to talk to i made a \n  new question and talked to it and it didn't update the list iwth my question, nor did it add the response of the LLM, the main \n  node should also be the first chat in the list when i go to the chat view, the node is the chat, we respond to the room and can \n  talk with it, and or we can in the chat view make a new node by saying \"new - agent, artifact, idea, question as a drop down\" or \n  something like that so it'll make a tier two class node inside the main question node,you can talk to them individually in a \n  nested thread, or you can talk to the main question card chat. where should we put the chat box for the main question card tier 1\n   - chats are on tier 3 review, be sure you understand and then analyze our code for how we're doing this and fix it if we're not.\n   and then be sure to actually append the persons message to the list when they chat. Make a plan and make a scrip that exports \n  all the files related to the chat and the view for the chat in one text file so i can edit it",
            "citations": []
          }
        ],
        "updated_at": "2025-05-14T08:42:11.927454Z",
        "attachments": [
          {
            "file_name": "paste.txt",
            "file_size": 473424,
            "file_type": "txt",
            "extracted_content": "\n\n================================================================================\nFILE: src/adapters/threadAdapter.ts\n================================================================================\n\n/**\n * Thread Adapter\n * \n * Provides conversion functions between the legacy Thread model and the new unified Conversation model.\n * This adapter helps with the transition to the new data model while maintaining compatibility with\n * existing code and data.\n */\n\nimport { Thread, Message as ThreadMessage } from '@/types/thread';\nimport { Conversation, Message, CardType } from '@/types/conversation';\n\n/**\n * Converts a Thread message to a unified Message\n */\nexport function threadMessageToMessage(message: ThreadMessage): Message {\n  return {\n    id: message.id,\n    role: message.role,\n    content: message.content,\n    createdAt: message.createdAt,\n  };\n}\n\n/**\n * Converts a unified Message to a Thread message\n */\nexport function messageToThreadMessage(message: Message): ThreadMessage {\n  return {\n    id: message.id,\n    threadId: '', // Will be set by the caller\n    role: message.role,\n    content: message.content,\n    createdAt: message.createdAt,\n  };\n}\n\n/**\n * Maps a thread cardType to the unified model's CardType\n */\nfunction mapCardType(cardType?: string): CardType | undefined {\n  if (!cardType) return undefined;\n  \n  // Handle common cardType mappings\n  switch (cardType) {\n    case 'chat':\n    case 'question':\n    case 'response':\n    case 'note':\n    case 'image':\n    case 'file':\n      return cardType as CardType;\n    default:\n      return 'chat';\n  }\n}\n\n/**\n * Converts a Thread to a unified Conversation\n */\nexport function threadToConversation(thread: Thread): Conversation {\n  return {\n    id: thread.id,\n    notebookId: thread.notebookId,\n    title: thread.title,\n    userId: '', // This needs to be populated separately\n    createdAt: thread.createdAt,\n    updatedAt: thread.updatedAt,\n    messages: thread.messages.map(threadMessageToMessage),\n    position: thread.position,\n    size: thread.size,\n    parentId: thread.parentId,\n    references: thread.referencedThreads,\n    cardType: mapCardType(thread.cardType),\n    handwritingStyle: thread.handwritingStyle as Conversation['handwritingStyle'],\n    isMinimized: thread.isMinimized,\n    zIndex: thread.zIndex,\n  };\n}\n\n/**\n * Converts a unified Conversation to a Thread\n */\nexport function conversationToThread(conversation: Conversation): Thread {\n  return {\n    id: conversation.id,\n    notebookId: conversation.notebookId,\n    title: conversation.title || '',\n    position: conversation.position || { x: 0, y: 0 },\n    size: conversation.size,\n    messages: conversation.messages.map(msg => ({\n      ...messageToThreadMessage(msg),\n      threadId: conversation.id,\n    })),\n    parentId: conversation.parentId || null,\n    referencedThreads: conversation.references || [],\n    createdAt: conversation.createdAt,\n    updatedAt: conversation.updatedAt,\n    cardType: conversation.cardType,\n    handwritingStyle: conversation.handwritingStyle || 'neat',\n    isMinimized: conversation.isMinimized || false,\n    zIndex: conversation.zIndex || 0,\n  };\n}\n\n/**\n * Converts a collection of Threads to Conversations\n */\nexport function threadsToConversations(threads: Thread[]): Conversation[] {\n  return threads.map(threadToConversation);\n}\n\n/**\n * Converts a collection of Conversations to Threads\n */\nexport function conversationsToThreads(conversations: Conversation[]): Thread[] {\n  return conversations.map(conversationToThread);\n}\n\n================================================================================\nFILE: src/components/canvas/IntegratedChatCard.tsx\n================================================================================\n\n// src/components/canvas/IntegratedChatCard.tsx\nimport React, { useState, useRef, useEffect, useCallback } from 'react';\nimport { useChat } from 'ai/react'; // From Vercel AI SDK\nimport { Group, Rect } from 'react-konva';\nimport { Html } from 'react-konva-utils';\nimport { Conversation } from '@/types/supabase';\nimport { KonvaEventObject } from 'konva/lib/Node';\nimport { cn } from '@/lib/utils'; // ShadCN utility\nimport { v4 as uuidv4 } from 'uuid';\n\n// Card type definition with states for animation\ninterface CardState {\n  isExpanded: boolean;\n  isTyping: boolean;\n  isHighlighted: boolean;\n  isFocused: boolean;\n}\n\ninterface IntegratedChatCardProps {\n  conversation: Conversation;\n  position: {\n    x: number;\n    y: number;\n    isCollapsed: boolean;\n    isDragging: boolean;\n  };\n  isActive: boolean;\n  systemPrompt?: string;\n  notebookId: string;\n  onDragStart: () => void;\n  onDragMove: (x: number, y: number) => void;\n  onDragEnd: () => void;\n  onToggleCollapse: () => void;\n  onSaveContent: (id: string, content: string, isUserMessage: boolean) => Promise<void>;\n}\n\n/**\n * An integrated chat card component that combines thread card UI with \n * streaming AI chat capabilities using Vercel's AI SDK\n */\nconst IntegratedChatCard: React.FC<IntegratedChatCardProps> = ({\n  conversation,\n  position,\n  isActive,\n  systemPrompt = \"You are a helpful AI assistant in a digital canvas environment.\",\n  notebookId,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  onToggleCollapse,\n  onSaveContent\n}) => {\n  // Card dimensions\n  const WIDTH = 320;\n  const COLLAPSED_HEIGHT = 40;\n  const MIN_HEIGHT = 180;\n  \n  // References\n  const contentRef = useRef<HTMLDivElement>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Card state\n  const [cardState, setCardState] = useState<CardState>({\n    isExpanded: false,\n    isTyping: false,\n    isHighlighted: false,\n    isFocused: false\n  });\n  const [cardHeight, setCardHeight] = useState(MIN_HEIGHT);\n  const [isDragging, setIsDragging] = useState(false);\n  \n  // Initialize chat using Vercel AI SDK\n  const {\n    messages,\n    input,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    setMessages\n  } = useChat({\n    api: '/api/claude/chat',\n    id: conversation.id,\n    // Skip initialMessages for now - we'll load them in useEffect\n    initialMessages: [],\n    body: {\n      notebookId,\n      systemPrompt\n    },\n    onFinish: async (message) => {\n      // Save the AI response to the database when streaming finishes\n      await onSaveContent(conversation.id, message.content, false);\n      setCardState(prev => ({ ...prev, isTyping: false }));\n    }\n  });\n  \n  // Scroll to bottom of messages on new content\n  useEffect(() => {\n    if (messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });\n    }\n  }, [messages]);\n  \n  // Update card height based on content\n  useEffect(() => {\n    if (position.isCollapsed) {\n      setCardHeight(COLLAPSED_HEIGHT);\n      return;\n    }\n    \n    if (contentRef.current) {\n      const newHeight = Math.max(\n        contentRef.current.scrollHeight + 60, // Add padding\n        MIN_HEIGHT\n      );\n      setCardHeight(newHeight);\n    }\n  }, [position.isCollapsed, messages, cardState.isExpanded]);\n  \n  // Load initial content\n  useEffect(() => {\n    // Only load if no messages exist yet\n    if (messages.length === 0) {\n      // First check for message history\n      if (conversation.message_history?.length) {\n        // Convert messages from our format to the format expected by useChat\n        const historyMessages = conversation.message_history.map(msg => ({\n          id: uuidv4(),\n          role: msg.role as 'user' | 'assistant' | 'system',\n          content: msg.content\n        }));\n\n        setMessages(historyMessages);\n        return;\n      }\n\n      // Fall back to user_content and ai_response\n      if (conversation.user_content || conversation.ai_response) {\n        const initialMessages = [];\n\n        if (conversation.user_content) {\n          initialMessages.push({\n            id: `user-${conversation.id}`,\n            role: 'user' as const,\n            content: conversation.user_content\n          });\n        }\n\n        if (conversation.ai_response) {\n          initialMessages.push({\n            id: `assistant-${conversation.id}`,\n            role: 'assistant' as const,\n            content: conversation.ai_response\n          });\n        }\n\n        if (initialMessages.length > 0) {\n          setMessages(initialMessages);\n        }\n      }\n    }\n  }, [conversation.id, conversation.user_content, conversation.ai_response, conversation.message_history, setMessages, messages.length]);\n  \n  // Handle drag start with header-only dragging\n  const handleDragStart = useCallback((e: KonvaEventObject<DragEvent>) => {\n    e.cancelBubble = true;\n    \n    // Calculate if clicking in header area (first 30px)\n    const relativeY = e.evt.offsetY;\n    if (relativeY <= 30) {\n      setIsDragging(true);\n      onDragStart();\n    } else {\n      // Cancel drag if not in header\n      e.target.stopDrag();\n    }\n  }, [onDragStart]);\n  \n  const handleDragMove = useCallback((e: KonvaEventObject<DragEvent>) => {\n    if (!isDragging) return;\n    e.cancelBubble = true;\n    onDragMove(e.target.x(), e.target.y());\n  }, [isDragging, onDragMove]);\n  \n  const handleDragEnd = useCallback(() => {\n    setIsDragging(false);\n    onDragEnd();\n  }, [onDragEnd]);\n  \n  // Handle form submission with custom save\n  const handleChatSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (!input.trim()) return;\n    \n    // Show typing indicator\n    setCardState(prev => ({ ...prev, isTyping: true }));\n    \n    // Save user message to database\n    await onSaveContent(conversation.id, input, true);\n    \n    // Process the chat with Vercel AI SDK\n    handleSubmit(e);\n  };\n  \n  // Get background color based on card type\n  const getBackgroundColor = () => {\n    if (cardState.isHighlighted) return '#E3F2FD'; // Highlight color\n    \n    switch (conversation.card_type) {\n      case 'question':\n        return '#EDF2F7'; // Light blue\n      case 'response':\n        return '#F0FFF4'; // Light green\n      case 'follow_up':\n        return '#FFFAF0'; // Light yellow\n      case 'note':\n        return '#F7FAFC'; // Light gray\n      default:\n        return 'white';\n    }\n  };\n  \n  return (\n    <Group\n      x={position.x}\n      y={position.y}\n      draggable\n      onDragStart={handleDragStart}\n      onDragMove={handleDragMove}\n      onDragEnd={handleDragEnd}\n    >\n      {/* Card background with shadow */}\n      <Rect\n        width={WIDTH}\n        height={cardHeight}\n        fill={getBackgroundColor()}\n        stroke={isActive ? '#3182CE' : '#E2E8F0'}\n        strokeWidth={isActive ? 2 : 1}\n        cornerRadius={8}\n        shadowColor=\"rgba(0,0,0,0.1)\"\n        shadowBlur={8}\n        shadowOffset={{ x: 0, y: 4 }}\n        shadowOpacity={0.3}\n        perfectDrawEnabled={false}\n      />\n      \n      {/* Card header */}\n      <Rect\n        width={WIDTH}\n        height={30}\n        fill={isActive ? '#3182CE' : '#F7FAFC'}\n        stroke={isActive ? '#2C5282' : '#E2E8F0'}\n        strokeWidth={1}\n        cornerRadius={[8, 8, 0, 0]}\n      />\n      \n      {/* HTML Content - Using react-konva-utils */}\n      <Html divProps={{\n        style: {\n          width: `${WIDTH}px`,\n          height: `${cardHeight}px`,\n          padding: 0,\n          overflow: 'hidden',\n        }\n      }}>\n        <div className=\"relative w-full h-full flex flex-col\">\n          {/* Header with controls */}\n          <div \n            className={cn(\n              \"flex items-center justify-between px-3 h-8 cursor-move\",\n              isActive ? \"bg-blue-600 text-white\" : \"bg-gray-50 text-gray-700\"\n            )}\n          >\n            <div className=\"text-sm font-medium truncate\">\n              {conversation.card_type === 'question' ? 'Question' : \n               conversation.card_type === 'response' ? 'Response' :\n               conversation.card_type === 'follow_up' ? 'Follow-up' : 'Note'}\n            </div>\n            <div className=\"flex items-center space-x-1\">\n              <button\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onToggleCollapse();\n                }}\n                className={cn(\n                  \"w-5 h-5 rounded flex items-center justify-center\",\n                  isActive ? \"hover:bg-blue-500 text-white\" : \"hover:bg-gray-200 text-gray-600\"\n                )}\n                aria-label={position.isCollapsed ? \"Expand\" : \"Collapse\"}\n              >\n                {position.isCollapsed ? '+' : '-'}\n              </button>\n            </div>\n          </div>\n          \n          {/* Card content */}\n          {!position.isCollapsed && (\n            <div \n              ref={contentRef}\n              className=\"flex-1 overflow-y-auto p-3 bg-white\"\n            >\n              {/* Message thread */}\n              <div className=\"space-y-3\">\n                {messages.map((message) => (\n                  <div \n                    key={message.id} \n                    className={cn(\n                      \"p-2 rounded-lg max-w-[95%]\",\n                      message.role === 'user' \n                        ? \"bg-blue-50 ml-auto\" \n                        : \"bg-gray-50\"\n                    )}\n                  >\n                    <div className=\"text-sm whitespace-pre-wrap\">\n                      {message.content}\n                    </div>\n                  </div>\n                ))}\n                {cardState.isTyping && (\n                  <div className=\"bg-gray-50 p-2 rounded-lg animate-pulse\">\n                    <div className=\"flex space-x-1\">\n                      <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"></div>\n                      <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-75\"></div>\n                      <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce delay-150\"></div>\n                    </div>\n                  </div>\n                )}\n                <div ref={messagesEndRef} />\n              </div>\n              \n              {/* Chat input */}\n              <form onSubmit={handleChatSubmit} className=\"mt-3\">\n                <div className=\"relative\">\n                  <input\n                    type=\"text\"\n                    value={input}\n                    onChange={handleInputChange}\n                    placeholder=\"Type a message...\"\n                    className=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n                    disabled={isLoading || cardState.isTyping}\n                  />\n                  <button\n                    type=\"submit\"\n                    disabled={isLoading || cardState.isTyping || !input.trim()}\n                    className={cn(\n                      \"absolute right-2 top-2 p-1 rounded-md\",\n                      isLoading || cardState.isTyping || !input.trim()\n                        ? \"text-gray-400 cursor-not-allowed\" \n                        : \"text-blue-500 hover:text-blue-600\"\n                    )}\n                  >\n                    <svg \n                      xmlns=\"http://www.w3.org/2000/svg\" \n                      width=\"16\" \n                      height=\"16\" \n                      viewBox=\"0 0 24 24\" \n                      fill=\"none\" \n                      stroke=\"currentColor\" \n                      strokeWidth=\"2\" \n                      strokeLinecap=\"round\" \n                      strokeLinejoin=\"round\"\n                    >\n                      <line x1=\"22\" y1=\"2\" x2=\"11\" y2=\"13\"></line>\n                      <polygon points=\"22 2 15 22 11 13 2 9 22 2\"></polygon>\n                    </svg>\n                  </button>\n                </div>\n              </form>\n            </div>\n          )}\n        </div>\n      </Html>\n    </Group>\n  );\n};\n\nexport default React.memo(IntegratedChatCard);\n\n================================================================================\nFILE: src/components/canvas/ThreadActions.tsx\n================================================================================\n\nimport React from 'react';\nimport { Group, Rect, Text } from 'react-konva';\nimport { Thread, ThreadState } from '@/types/thread';\n\ninterface ThreadActionsProps {\n  thread: Thread;\n  threadState: ThreadState;\n  cardWidth: number;\n  cardHeight: number;\n}\n\n/**\n * Renders action buttons for thread cards when expanded\n */\nconst ThreadActions: React.FC<ThreadActionsProps> = ({\n  thread: _thread,\n  threadState: _threadState,\n  cardWidth,\n  cardHeight\n}) => {\n  // This is a simplified version for rendering\n  const buttonWidth = 80;\n  const buttonHeight = 30;\n  const buttonSpacing = 10;\n  const yPosition = cardHeight - buttonHeight - 10; // 10px from bottom\n  \n  return (\n    <Group>\n      {/* Continue Button */}\n      <Group x={10} y={yPosition}>\n        <Rect\n          width={buttonWidth}\n          height={buttonHeight}\n          fill=\"#3b82f6\"\n          cornerRadius={4}\n        />\n        <Text\n          x={0}\n          y={7}\n          text=\"Continue\"\n          fontSize={12}\n          fontFamily=\"Inter, sans-serif\"\n          fill=\"#ffffff\"\n          align=\"center\"\n          width={buttonWidth}\n        />\n      </Group>\n      \n      {/* Follow-up Button */}\n      <Group x={10 + buttonWidth + buttonSpacing} y={yPosition}>\n        <Rect\n          width={buttonWidth}\n          height={buttonHeight}\n          fill=\"#f3f4f6\"\n          stroke=\"#d1d5db\"\n          strokeWidth={1}\n          cornerRadius={4}\n        />\n        <Text\n          x={0}\n          y={7}\n          text=\"Follow-up\"\n          fontSize={12}\n          fontFamily=\"Inter, sans-serif\"\n          fill=\"#374151\"\n          align=\"center\"\n          width={buttonWidth}\n        />\n      </Group>\n      \n      {/* Edit Button */}\n      <Group x={cardWidth - buttonWidth - 10} y={yPosition}>\n        <Rect\n          width={buttonWidth}\n          height={buttonHeight}\n          fill=\"#f3f4f6\"\n          stroke=\"#d1d5db\"\n          strokeWidth={1}\n          cornerRadius={4}\n        />\n        <Text\n          x={0}\n          y={7}\n          text=\"Edit\"\n          fontSize={12}\n          fontFamily=\"Inter, sans-serif\"\n          fill=\"#374151\"\n          align=\"center\"\n          width={buttonWidth}\n        />\n      </Group>\n    </Group>\n  );\n};\n\nexport default React.memo(ThreadActions);\n\n================================================================================\nFILE: src/components/canvas/ThreadCard.tsx\n================================================================================\n\n// src/components/canvas/ThreadCard.tsx\nimport React, { useCallback, useState, useRef, useEffect } from 'react';\nimport { Group, Rect, Text } from 'react-konva';\nimport { Html } from './konva-extensions';\nimport { Conversation, ThreadConnection } from '@/types/supabase';\nimport Konva from 'konva';\n\ninterface ThreadCardProps {\n  conversationId: string;\n  notebookId: string;\n  position: {\n    x: number;\n    y: number;\n    isCollapsed: boolean;\n    isDragging: boolean;\n  };\n  isActive: boolean;\n  isCollapsed: boolean;\n  isDragging: boolean;\n  conversation: Conversation;\n  connections: ThreadConnection[];\n  onDragStart: () => void;\n  onDragMove: (x: number, y: number) => void;\n  onDragEnd: () => void;\n  onToggleCollapse: () => void;\n  onToggleInfo: () => void;\n  onEditContent?: (text: string) => Promise<void>;\n  onContinueThread?: () => void;\n  onCreateFollowUp?: () => void;\n  onCreateReference?: (targetId?: string) => void;\n  setIsModalOpen?: (isOpen: boolean) => void;\n  enableTextSelection?: boolean;\n  scale?: number;\n  setSelectionMode?: (isSelecting: boolean) => void;\n}\n\nconst ThreadCard: React.FC<ThreadCardProps> = ({\n  conversationId,\n  notebookId,\n  position,\n  isActive,\n  isCollapsed,\n  isDragging,\n  conversation,\n  connections,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  onToggleCollapse,\n  onToggleInfo,\n  onEditContent,\n  onContinueThread,\n  onCreateFollowUp,\n  onCreateReference,\n  setIsModalOpen,\n  enableTextSelection = false,\n  scale = 1,\n  setSelectionMode\n}) => {\n  const cardWidth = 280; // Fixed width for cards\n  const [cardHeight, setCardHeight] = useState(isCollapsed ? 40 : 200);\n  const groupRef = useRef<Konva.Group>(null);\n  const [selectedText, setSelectedText] = useState<string>('');\n  const [isSelecting, setIsSelecting] = useState(false);\n\n  // Adjust card height based on content and collapsed state\n  useEffect(() => {\n    const contentHeight = isCollapsed ? 40 : (conversation.user_content?.length || 0) * 0.5 + 120;\n    setCardHeight(Math.max(120, Math.min(400, contentHeight)));\n  }, [isCollapsed, conversation.user_content]);\n\n  // Enhanced drag event handlers with better event management\n  const handleDragStart = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {\n    // Always cancel bubble to prevent propagation issues\n    e.cancelBubble = true;\n\n    // Ensure browser doesn't also handle this as a native drag operation\n    if (e.evt.preventDefault) {\n      e.evt.preventDefault();\n    }\n\n    // Only allow dragging if not in text selection mode\n    if (enableTextSelection || isSelecting) {\n      console.log(`ThreadCard ${conversationId}: Drag prevented due to text selection mode`);\n      return false; // Return false to cancel drag operation\n    }\n\n    console.log(`ThreadCard ${conversationId}: Starting drag`);\n    onDragStart();\n    return true; // Allow drag to continue\n  }, [onDragStart, enableTextSelection, isSelecting, conversationId]);\n\n  const handleDragMove = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {\n    // Always cancel bubble\n    e.cancelBubble = true;\n\n    // Only process if not in text selection mode\n    if (enableTextSelection || isSelecting) {\n      return;\n    }\n\n    // Get position with safety checks\n    try {\n      const x = e.target.x();\n      const y = e.target.y();\n      onDragMove(x, y);\n    } catch (error) {\n      console.error(`ThreadCard ${conversationId}: Error during drag move:`, error);\n    }\n  }, [onDragMove, enableTextSelection, isSelecting, conversationId]);\n\n  const handleDragEnd = useCallback((e: Konva.KonvaEventObject<DragEvent>) => {\n    // Always cancel bubble\n    e.cancelBubble = true;\n\n    // Only process if not in text selection mode\n    if (enableTextSelection || isSelecting) {\n      if (e.evt.preventDefault) {\n        e.evt.preventDefault();\n      }\n      return;\n    }\n\n    console.log(`ThreadCard ${conversationId}: Ending drag`);\n    onDragEnd();\n  }, [onDragEnd, enableTextSelection, isSelecting, conversationId]);\n\n  // Click handler with improved event management\n  const handleClick = useCallback((e: Konva.KonvaEventObject<MouseEvent>) => {\n    // Always stop event propagation first\n    e.cancelBubble = true;\n\n    // Make sure mouse events don't also trigger in parent components\n    if (e.evt.stopPropagation) {\n      e.evt.stopPropagation();\n    }\n\n    // If we're in text selection mode, don't toggle the card\n    if (enableTextSelection || isSelecting) {\n      console.log('ThreadCard: Click ignored due to text selection mode');\n      return;\n    }\n\n    // Prevent handling if clicking on a button\n    if (e.evt && '_handledByButton' in e.evt && e.evt._handledByButton) {\n      console.log('ThreadCard: Click handled by button');\n      return;\n    }\n\n    // Log the action\n    console.log(`ThreadCard ${conversationId}: Click handled - ${e.evt.shiftKey ? 'info' : 'collapse'} action`);\n\n    // Handle card click logic\n    if (e.evt.shiftKey) {\n      onToggleInfo();\n    } else {\n      onToggleCollapse();\n    }\n  }, [onToggleInfo, onToggleCollapse, enableTextSelection, isSelecting, conversationId]);\n\n  // Reference to track previous tool state\n  const prevToolStateRef = useRef({ enableTextSelection });\n\n  // Monitor tool transitions and clean up\n  useEffect(() => {\n    const prevState = prevToolStateRef.current;\n\n    // Check if we're transitioning between text selection states\n    if (prevState.enableTextSelection !== enableTextSelection) {\n      console.log(`ThreadCard ${conversationId} - Text selection changing: ${prevState.enableTextSelection} -> ${enableTextSelection}`);\n\n      // If we're turning off text selection, clear any selections\n      if (!enableTextSelection && prevState.enableTextSelection) {\n        if (window.getSelection) {\n          window.getSelection()?.removeAllRanges();\n        }\n        setSelectedText('');\n        setIsSelecting(false);\n      }\n    }\n\n    // Update previous state reference\n    prevToolStateRef.current = { enableTextSelection };\n  }, [enableTextSelection, conversationId]);\n\n  // Enhanced text selection handler\n  const handleTextSelect = useCallback((e: React.SyntheticEvent<HTMLDivElement>) => {\n    // Stop event propagation first to prevent issues with canvas events\n    e.stopPropagation();\n\n    // Only process if text selection is enabled\n    if (!enableTextSelection) {\n      console.log(`ThreadCard ${conversationId}: Text selection ignored - not in selection mode`);\n      return;\n    }\n\n    try {\n      // Get the current selection\n      const selection = window.getSelection();\n\n      if (selection && selection.toString().trim()) {\n        const selectedText = selection.toString().trim();\n        console.log(`ThreadCard ${conversationId}: Text selected: \"${selectedText.substring(0, 20)}${selectedText.length > 20 ? '...' : ''}\"`);\n\n        // Set the selection state\n        setSelectedText(selectedText);\n        setIsSelecting(true);\n\n        // Notify parent components about selection mode\n        if (setSelectionMode) {\n          setSelectionMode(true);\n        }\n\n        // Prevent default browser text selection behavior if needed\n        // e.preventDefault(); // Commented out to allow native selection to work\n      } else {\n        // No selection - might be a click\n        if (isSelecting) {\n          console.log(`ThreadCard ${conversationId}: Selection cleared`);\n          setIsSelecting(false);\n          if (setSelectionMode) {\n            setSelectionMode(false);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`ThreadCard ${conversationId}: Error in text selection handler:`, error);\n    }\n  }, [enableTextSelection, setSelectionMode, isSelecting, conversationId]);\n\n  // Handle text transcription - send selected text to AI\n  const handleTranscribe = useCallback(() => {\n    if (selectedText && onEditContent) {\n      onEditContent(selectedText)\n        .then(() => {\n          // Clear selection after successful transcription\n          setSelectedText('');\n          setIsSelecting(false);\n          if (setSelectionMode) {\n            setSelectionMode(false);\n          }\n\n          // Optional: Show confirmation message\n          if (setIsModalOpen) {\n            setIsModalOpen(false);\n          }\n        })\n        .catch(error => {\n          console.error('Error transcribing text:', error);\n        });\n    }\n  }, [selectedText, onEditContent, setSelectionMode, setIsModalOpen]);\n\n  // Clean up selection when component unmounts\n  useEffect(() => {\n    return () => {\n      setSelectedText('');\n      setIsSelecting(false);\n      if (setSelectionMode) {\n        setSelectionMode(false);\n      }\n    };\n  }, [setSelectionMode]);\n\n  return (\n    <Group\n      ref={groupRef}\n      x={position.x}\n      y={position.y}\n      draggable={!enableTextSelection && !isSelecting}\n      onDragStart={handleDragStart}\n      onDragMove={handleDragMove}\n      onDragEnd={handleDragEnd}\n      onClick={handleClick}\n      onTap={handleClick}\n      shadowColor=\"rgba(0,0,0,0.2)\"\n      shadowBlur={isDragging ? 10 : isActive ? 5 : 0}\n      shadowOffset={{ x: 3, y: 3 }}\n      shadowOpacity={0.5}\n      opacity={1}\n    >\n      {/* Background */}\n      <Rect\n        width={cardWidth}\n        height={cardHeight}\n        fill={isActive ? \"#f0f9ff\" : \"#ffffff\"}\n        stroke={isActive ? \"#3b82f6\" : \"#e5e7eb\"}\n        strokeWidth={1.5}\n        cornerRadius={8}\n      />\n\n      {/* Header Bar */}\n      <Rect\n        y={0}\n        width={cardWidth}\n        height={32}\n        fill={isActive ? \"#e0f2fe\" : \"#f9fafb\"}\n        cornerRadius={[8, 8, 0, 0]}\n      />\n\n      {/* Card Type Indicator */}\n      <Rect\n        x={8}\n        y={8}\n        width={16}\n        height={16}\n        fill={conversation.card_type === 'question' ? '#8b5cf6' :\n              conversation.card_type === 'response' ? '#10b981' :\n              conversation.card_type === 'follow_up' ? '#f59e0b' : '#6b7280'}\n        cornerRadius={4}\n      />\n\n      {/* Title Text - limited for simplicity */}\n      <Text\n        x={32}\n        y={8}\n        text={conversation.user_content?.substring(0, 30) || \"Untitled\"}\n        fontSize={14}\n        fontFamily=\"sans-serif\"\n        fill=\"#1f2937\"\n        width={cardWidth - 70}\n        ellipsis={true}\n      />\n\n      {/* Content - either regular text or selectable HTML */}\n      {!isCollapsed && (\n        <>\n          {/* Regular Konva text when text selection is not enabled */}\n          {!enableTextSelection && (\n            <Text\n              x={12}\n              y={40}\n              text={conversation.user_content || \"No content\"}\n              fontSize={13}\n              fontFamily=\"sans-serif\"\n              fill=\"#4b5563\"\n              width={cardWidth - 24}\n              height={cardHeight - 60}\n              ellipsis={true}\n            />\n          )}\n\n          {/* HTML for text selection, only rendered when needed */}\n          {enableTextSelection && (\n            <Html\n              divProps={{\n                style: {\n                  position: 'absolute',\n                  top: `${40}px`,\n                  left: `${12}px`,\n                  width: `${cardWidth - 24}px`,\n                  height: `${cardHeight - 60}px`,\n                  overflow: 'auto',\n                  fontSize: '13px',\n                  fontFamily: 'sans-serif',\n                  color: '#4b5563',\n                  pointerEvents: 'auto',\n                  userSelect: 'text'\n                }\n              }}\n            >\n              <div\n                onMouseUp={handleTextSelect}\n                onTouchEnd={handleTextSelect}\n                style={{ padding: '0', margin: '0', whiteSpace: 'pre-wrap', overflowWrap: 'break-word' }}\n              >\n                {conversation.user_content || \"No content\"}\n              </div>\n\n              {/* Transcribe option that appears when text is selected */}\n              {selectedText && (\n                <div\n                  style={{\n                    position: 'absolute',\n                    top: '0',\n                    right: '0',\n                    background: '#3b82f6',\n                    color: 'white',\n                    padding: '4px 8px',\n                    borderRadius: '4px',\n                    fontSize: '12px',\n                    cursor: 'pointer',\n                    zIndex: 10\n                  }}\n                  onClick={handleTranscribe}\n                  onTouchEnd={handleTranscribe}\n                >\n                  Transcribe Selection\n                </div>\n              )}\n            </Html>\n          )}\n        </>\n      )}\n    </Group>\n  );\n};\n\nexport default React.memo(ThreadCard);\n\n================================================================================\nFILE: src/components/canvas/ThreadContent.tsx\n================================================================================\n\nimport React from 'react';\nimport { Group, Text } from 'react-konva';\nimport { Thread, ThreadState } from '@/types/thread';\n\ninterface ThreadContentProps {\n  thread: Thread;\n  threadState: ThreadState;\n  cardWidth: number;\n}\n\n/**\n * Renders the content of a thread card\n */\nconst ThreadContent: React.FC<ThreadContentProps> = ({\n  thread,\n  threadState,\n  cardWidth\n}) => {\n  // Get the most recent message to show\n  const mostRecentMessage = thread.messages?.length > 0 \n    ? thread.messages[thread.messages.length - 1] \n    : null;\n  \n  // Truncate content if collapsed\n  const displayContent = mostRecentMessage?.content || 'Empty thread';\n  const truncatedContent = threadState.isExpanded \n    ? displayContent \n    : displayContent.length > 100 \n      ? `${displayContent.substring(0, 100)}...` \n      : displayContent;\n  \n  return (\n    <Group>\n      {/* Card title */}\n      <Text\n        x={10}\n        y={8}\n        text={thread.title || 'Thread'}\n        fontSize={14}\n        fontFamily=\"Inter, sans-serif\"\n        fill={threadState.isActive ? \"#ffffff\" : \"#111827\"}\n        fontStyle=\"bold\"\n        width={cardWidth - 60}\n        ellipsis\n      />\n      \n      {/* Card content */}\n      <Text\n        x={10}\n        y={40}\n        text={truncatedContent}\n        fontSize={13}\n        fontFamily=\"Inter, sans-serif\"\n        fill=\"#374151\"\n        width={cardWidth - 20}\n        height={threadState.isExpanded ? undefined : 50}\n        lineHeight={1.4}\n        ellipsis={!threadState.isExpanded}\n      />\n    </Group>\n  );\n};\n\nexport default React.memo(ThreadContent);\n\n================================================================================\nFILE: src/components/canvas/ThreadedCardChat.tsx\n================================================================================\n\n// src/components/canvas/ThreadedCardChat.tsx\nimport React, { useState, useRef, useCallback, useEffect } from 'react';\nimport { Card, CardHeader, CardContent, CardFooter } from '../shadcn/card';\nimport { Button } from '../shadcn/button';\nimport { Textarea } from '../shadcn/textarea';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { Node, Relationship } from '@/types/thread';\nimport { useChat } from 'ai/react';\nimport { useOutsideClick } from '@/hooks/useOutsideClick';\n\n// Custom file upload button component\nconst FileUploadButton = () => {\n  return (\n    <div className=\"flex items-center\">\n      <button\n        type=\"button\"\n        className=\"inline-flex items-center p-1 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100\"\n        title=\"Attach file\"\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-4 w-4\"\n          viewBox=\"0 0 20 20\"\n          fill=\"currentColor\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      </button>\n    </div>\n  );\n};\n\n// Model selector component\nconst ModelSelector = ({ selectedModel, onChangeModel }: { \n  selectedModel: string; \n  onChangeModel: (model: string) => void;\n}) => {\n  return (\n    <select\n      className=\"w-full text-sm bg-white border border-gray-300 py-1.5 px-2 rounded text-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500\"\n      value={selectedModel}\n      onChange={(e) => onChangeModel(e.target.value)}\n      title=\"Select AI model\"\n    >\n      <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n      <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n      <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n      <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n    </select>\n  );\n};\n\n// Chat message component for individual messages\nconst ChatMessage = ({ message, isSelected, onSelect }: {\n  message: { role: string; content: any; id: string; parts?: any[] };\n  isSelected: boolean;\n  onSelect: () => void;\n}) => {\n  const isUser = message.role === 'user';\n  \n  // Format content based on type\n  const getFormattedContent = () => {\n    // Handle message with parts array (new format)\n    if (message.parts && Array.isArray(message.parts) && message.parts.length > 0) {\n      return message.parts.map(part => {\n        if (typeof part === 'object' && part && 'text' in part) {\n          return part.text;\n        }\n        return String(part);\n      }).join('\\n');\n    }\n    \n    // Handle string content\n    if (typeof message.content === 'string') {\n      // Don't show placeholder text\n      if (message.content === \"New response\") {\n        return \"...\";\n      }\n      return message.content;\n    }\n    \n    // Handle array format from Claude API\n    if (Array.isArray(message.content)) {\n      return message.content.map(block => \n        typeof block === 'object' && block && 'text' in block ? block.text : String(block)\n      ).join('\\n');\n    }\n    \n    // Handle object format\n    if (typeof message.content === 'object' && message.content !== null) {\n      // Try to extract text content if it exists\n      if ('text' in message.content) {\n        return message.content.text;\n      }\n      \n      // Fallback to JSON string\n      return JSON.stringify(message.content, null, 2);\n    }\n    \n    // Final fallback\n    return String(message.content || \"\");\n  };\n\n  // Get the appropriate content\n  const formattedContent = getFormattedContent();\n  \n  // Don't display empty or placeholder messages\n  if (formattedContent === \"New response\" || formattedContent === \"\") {\n    return null;\n  }\n  \n  return (\n    <div \n      className={`p-2 rounded-lg mb-2 max-w-[85%] ${\n        isUser \n          ? 'bg-blue-100 ml-auto' \n          : 'bg-gray-100 mr-auto'\n      } ${isSelected ? 'ring-2 ring-blue-400' : ''}`}\n      onClick={onSelect}\n    >\n      <div className=\"text-xs text-gray-500 mb-1\">\n        {isUser ? 'You' : 'AI'}\n      </div>\n      <div className=\"whitespace-pre-wrap text-sm\">\n        {formattedContent}\n      </div>\n    </div>\n  );\n};\n\n// Interface for thread component props\ninterface ThreadedCardChatProps {\n  node: Node;\n  responses: Node[];\n  relationships: Relationship[];\n  position: { x: number; y: number; isCollapsed: boolean; isDragging: boolean };\n  isSelected: boolean;\n  notebookId: string;\n  systemPrompt?: string;\n  onSelect: (id: string) => void;\n  onAddResponse: (parentId: string, content: string, position: { x: number, y: number }) => Promise<Node | null>;\n  onAddMessageToNode?: (nodeId: string, message: Omit<Message, 'id' | 'created_at'>) => Promise<Message | null>;\n  onDragStart: (id: string) => void;\n  onDragMove: (id: string, x: number, y: number) => void;\n  onDragEnd: (id: string) => void;\n  onToggleCollapse: (id: string) => void;\n  scale?: number;\n  useNestedMessages?: boolean; // Flag to determine if we should use the new nested message model\n}\n\nconst ThreadedCardChat: React.FC<ThreadedCardChatProps> = ({\n  node,\n  responses,\n  relationships,\n  position,\n  isSelected,\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant.\",\n  onSelect,\n  onAddResponse,\n  onAddMessageToNode,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  onToggleCollapse,\n  scale = 1,\n  useNestedMessages = false\n}) => {\n  // State\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n  const [isHovered, setIsHovered] = useState(false);\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [showSettings, setShowSettings] = useState(false);\n  \n  // Refs\n  const cardRef = useRef<HTMLDivElement>(null);\n  const contentRef = useRef<HTMLDivElement>(null);\n  const settingsRef = useRef<HTMLDivElement>(null);\n  \n  // Close settings when clicking outside\n  useOutsideClick(settingsRef, () => {\n    if (showSettings) setShowSettings(false);\n  });\n  \n  // Convert thread responses to chat messages\n  const buildChatHistory = useCallback(() => {\n    const history = [\n      { \n        id: 'system-1', \n        role: 'system', \n        content: systemPrompt \n      },\n      {\n        id: node.id,\n        role: node.type === 'question' ? 'user' : 'assistant',\n        content: node.content\n      }\n    ];\n    \n    // Sort responses by creation time\n    const sortedResponses = [...responses].sort((a, b) => \n      new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n    );\n    \n    // Add responses to history\n    sortedResponses.forEach(response => {\n      history.push({\n        id: response.id,\n        role: response.type === 'question' ? 'user' : 'assistant',\n        content: response.content\n      });\n    });\n    \n    return history;\n  }, [node, responses, systemPrompt]);\n  \n  // Initialize chat handler with our simplified, more reliable API endpoint\n  const chatHandler = useChat({\n    api: '/api/claude/chat-simple', // Simplified API that avoids complex streaming issues\n    initialMessages: buildChatHistory(),\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: false // Disable streaming to avoid placeholder issues\n    },\n    onFinish: async (message) => {\n      // Create a new node for the response\n      console.log('AI response finished:', message);\n      \n      // Extract content based on format\n      let responseContent = '';\n      \n      // Handle message with parts array (new format)\n      if (message.parts && Array.isArray(message.parts) && message.parts.length > 0) {\n        responseContent = message.parts\n          .map(part => typeof part === 'object' && part && 'text' in part ? part.text : String(part))\n          .join('\\n');\n      } else if (typeof message.content === 'string') {\n        responseContent = message.content;\n        // Don't use placeholder text\n        if (responseContent === \"New response\") {\n          responseContent = \"The AI didn't provide a response. Please try again.\";\n        }\n      } else if (Array.isArray(message.content)) {\n        // Handle array format from Claude API\n        responseContent = message.content\n          .map(block => typeof block === 'object' && block && 'text' in block ? block.text : String(block))\n          .join('\\n');\n      } else if (typeof message.content === 'object' && message.content !== null) {\n        // Try to extract text content if it exists\n        if ('text' in message.content) {\n          responseContent = message.content.text;\n        } else {\n          // Fallback to JSON string\n          responseContent = JSON.stringify(message.content, null, 2);\n        }\n      } else {\n        // Final fallback\n        responseContent = String(message.content || \"\");\n      }\n      \n      console.log('Extracted response content:', responseContent);\n      \n      // If we still have empty or placeholder content, use fallback text\n      if (!responseContent || responseContent === \"New response\" || responseContent === \"\") {\n        console.error(\"Received placeholder or empty content from AI. Original response:\", message);\n        responseContent = \"The AI didn't provide a response. Please try again.\";\n      }\n      \n      // Log the actual content we'll be using\n      console.log(\"Using response content:\", responseContent);\n      \n      // Calculate position for the new node\n      const responsePosition = {\n        x: position.x,\n        y: position.y + 30\n      };\n      \n      // Add the response to the canvas\n      if (useNestedMessages && onAddMessageToNode) {\n        // Add as a message to the current node\n        await onAddMessageToNode(node.id, {\n          role: 'assistant',\n          content: responseContent\n        });\n      } else {\n        // Add as a new node (legacy approach)\n        await onAddResponse(node.id, responseContent, responsePosition);\n      }\n    }\n  });\n  \n  // Filter out system messages for display and ensure content is a string\n  const visibleMessages = chatHandler.messages\n    .filter(msg => {\n      // Filter out system messages\n      if (msg.role === 'system') return false;\n      \n      // Skip messages with placeholder content\n      if (msg.content === \"New response\") return false;\n      \n      // If using parts array, check if it's just a placeholder\n      if (msg.parts && msg.parts.length === 1 && \n          msg.parts[0].type === 'text' && \n          msg.parts[0].text === \"New response\") {\n        return false;\n      }\n      \n      return true;\n    })\n    .map(msg => {\n      // Process message content\n      let processedContent;\n      \n      // Handle string content\n      if (typeof msg.content === 'string') {\n        processedContent = msg.content;\n      } \n      // Handle parts array (new format)\n      else if (msg.parts && Array.isArray(msg.parts)) {\n        processedContent = msg.parts\n          .map(part => {\n            if (typeof part === 'object' && part && 'text' in part) {\n              return part.text;\n            }\n            return String(part);\n          })\n          .join('\\n');\n      }\n      // Handle array of content blocks (Claude API format)\n      else if (Array.isArray(msg.content)) {\n        processedContent = msg.content\n          .map(block => typeof block === 'object' && block?.text ? block.text : String(block))\n          .join('\\n');\n      }\n      // Fallback for any other format\n      else {\n        processedContent = JSON.stringify(msg.content);\n      }\n      \n      // Return processed message\n      return {\n        ...msg,\n        content: processedContent\n      };\n    });\n  \n  // Debug message display\n  console.log('Visible messages:', visibleMessages);\n\n  // Update chat history when responses change\n  useEffect(() => {\n    chatHandler.setMessages(buildChatHistory());\n  }, [responses, buildChatHistory, chatHandler]);\n  \n  // Auto-scroll to the bottom when messages change\n  useEffect(() => {\n    if (contentRef.current && !position.isCollapsed) {\n      // Scroll to bottom of content\n      contentRef.current.scrollTop = contentRef.current.scrollHeight;\n    }\n  }, [visibleMessages, position.isCollapsed, chatHandler.isLoading]);\n  \n  // Auto-scroll on input submit\n  const handleSubmitMessage = useCallback((e: React.FormEvent) => {\n    e.preventDefault();\n    chatHandler.handleSubmit(e);\n    \n    // Scroll to bottom after a short delay to ensure UI has updated\n    setTimeout(() => {\n      if (contentRef.current) {\n        contentRef.current.scrollTop = contentRef.current.scrollHeight;\n      }\n    }, 100);\n  }, [chatHandler]);\n  \n  // Handle model change\n  const handleModelChange = useCallback((model: string) => {\n    setModelId(model);\n  }, []);\n  \n  // Mouse event handlers for dragging\n  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    // Don't start drag from settings panel or chat input\n    if (settingsRef.current?.contains(e.target as Node)) return;\n    if ((e.target as HTMLElement).closest('.llama-chat-input, button, textarea')) return;\n    \n    if (cardRef.current) {\n      // Only start drag from card header or background\n      const targetElement = e.target as HTMLElement;\n      const isHeader = targetElement.closest('[data-card-header=\"true\"]') !== null;\n      const isBackground = targetElement === cardRef.current || targetElement.classList.contains('card-background');\n      \n      if (isHeader || isBackground) {\n        e.preventDefault();\n        setIsDragging(true);\n        onDragStart(node.id);\n        \n        // Get the card's bounding rectangle in screen coordinates\n        const rect = cardRef.current.getBoundingClientRect();\n        \n        // Calculate the offset within the card where the mouse was clicked\n        const offsetX = e.clientX - rect.left;\n        const offsetY = e.clientY - rect.top;\n        \n        // Set the drag offset\n        setDragOffset({\n          x: offsetX,\n          y: offsetY\n        });\n        \n        // Prevent text selection while dragging\n        document.body.style.userSelect = 'none';\n        \n        // Capture the element so we get all mouse events\n        (e.target as HTMLElement).setPointerCapture(e.pointerId);\n      }\n    }\n  }, [node.id, onDragStart]);\n  \n  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    if (isDragging) {\n      e.preventDefault();\n      \n      // Get container element (usually the parent of the stage)\n      const containerElement = document.querySelector('.absolute.top-0.left-0.w-full.h-full.overflow-hidden');\n      if (!containerElement) return;\n      \n      // Get the container's transformation matrix\n      const containerTransform = window.getComputedStyle(containerElement).transform;\n      const matrix = new DOMMatrix(containerTransform);\n      \n      // Calculate new screen position\n      const newX = e.clientX - dragOffset.x;\n      const newY = e.clientY - dragOffset.y;\n      \n      // Invert the transformation to get canvas coordinates\n      const canvasX = (newX - matrix.e) / matrix.a;\n      const canvasY = (newY - matrix.f) / matrix.d;\n      \n      onDragMove(node.id, canvasX, canvasY);\n    }\n  }, [isDragging, dragOffset, node.id, onDragMove]);\n  \n  const handleMouseUp = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    if (isDragging) {\n      e.preventDefault();\n      setIsDragging(false);\n      onDragEnd(node.id);\n      document.body.style.userSelect = '';\n      \n      // Release the pointer capture\n      (e.target as HTMLElement).releasePointerCapture(e.pointerId);\n    }\n  }, [isDragging, node.id, onDragEnd]);\n  \n  // Card styles\n  const getCardStyle = () => {\n    let baseStyle = \"\";\n    \n    if (position.isDragging) {\n      baseStyle += \" opacity-80\";\n    }\n    \n    if (isSelected) {\n      baseStyle += \" ring-2 ring-offset-2\";\n    }\n    \n    // Card color based on type\n    switch (node.type) {\n      case 'question':\n        return `${baseStyle} bg-white ${isSelected ? 'ring-blue-500' : ''}`;\n      case 'response':\n        return `${baseStyle} bg-white ${isSelected ? 'ring-teal-500' : ''}`;\n      case 'note':\n        return `${baseStyle} bg-white ${isSelected ? 'ring-yellow-500' : ''}`;\n      case 'drawing':\n        return `${baseStyle} bg-white ${isSelected ? 'ring-green-500' : ''}`;\n      default:\n        return `${baseStyle} bg-white ${isSelected ? 'ring-gray-500' : ''}`;\n    }\n  };\n  \n  // Fixed card dimensions to prevent UI shifting during interactions\n  const getCardDimensions = () => {\n    // Standard card width for desktop view\n    const baseWidth = 380;\n    // Use fixed height for consistency\n    return {\n      width: `${baseWidth}px`,\n      height: '450px', // Fixed height for consistency\n    };\n  };\n  \n  // Header style based on node type\n  const getHeaderStyle = () => {\n    if (isSelected) {\n      return 'bg-gray-700 text-white';\n    }\n    \n    switch (node.type) {\n      case 'question':\n        return 'bg-blue-600 text-white';\n      case 'response':\n        return 'bg-teal-600 text-white';\n      case 'note':\n        return 'bg-yellow-600 text-white';\n      case 'drawing':\n        return 'bg-green-600 text-white';\n      default:\n        return 'bg-gray-600 text-white';\n    }\n  };\n  \n  // Card position style\n  const getPositionStyle = () => {\n    return {\n      position: 'absolute' as const,\n      left: `${position.x}px`,\n      top: `${position.y}px`,\n      transform: isDragging ? 'translate3d(0,0,0)' : undefined,\n      zIndex: isSelected || isHovered || isDragging ? 10 : 1,\n      transition: isDragging ? 'none' : 'box-shadow 0.2s ease',\n    };\n  };\n  \n  // Card title based on type\n  const getCardTitle = () => {\n    // Truncate if too long\n    const content = node.content || '';\n    const truncated = content.length > 30 ? content.substring(0, 30) + '...' : content;\n    \n    return truncated || `${node.type.charAt(0).toUpperCase() + node.type.slice(1)} Card`;\n  };\n  \n  // Get fixed dimensions for consistency\n  const cardDimensions = getCardDimensions();\n\n  return (\n    <div \n      className={`${getCardStyle()} cursor-grab ${isDragging ? 'cursor-grabbing' : ''}`}\n      style={{\n        ...getPositionStyle(),\n        width: cardDimensions.width,\n        minHeight: cardDimensions.minHeight,\n        maxHeight: cardDimensions.maxHeight,\n      }}\n      ref={cardRef}\n      onClick={() => onSelect(node.id)}\n      onPointerDown={handleMouseDown}\n      onPointerMove={handleMouseMove}\n      onPointerUp={handleMouseUp}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n    >\n      <Card className={`h-full overflow-hidden border shadow-lg flex flex-col ${position.isCollapsed ? 'max-h-[40px]' : ''}`}>\n        {/* Card Header */}\n        <CardHeader className={`${getHeaderStyle()} py-2 px-3 flex justify-between items-center shrink-0`} data-card-header=\"true\">\n          <div className=\"text-sm font-medium truncate\">{getCardTitle()}</div>\n          <div className=\"flex space-x-1 items-center\">\n            {/* Settings button (three-dot menu) */}\n            <button\n              className=\"inline-flex items-center justify-center w-5 h-5 bg-gray-700 text-white rounded-full hover:bg-gray-600\"\n              onClick={(e) => {\n                e.stopPropagation();\n                setShowSettings(!showSettings);\n              }}\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\" className=\"w-3 h-3\">\n                <path d=\"M6 10a2 2 0 11-4 0 2 2 0 014 0zM12 10a2 2 0 11-4 0 2 2 0 014 0zM16 12a2 2 0 100-4 2 2 0 000 4z\" />\n              </svg>\n            </button>\n            \n            {/* Collapse/Expand button */}\n            <button\n              className=\"inline-flex items-center justify-center w-5 h-5 bg-gray-700 text-white rounded-full hover:bg-gray-600\"\n              onClick={(e) => {\n                e.stopPropagation();\n                onToggleCollapse(node.id);\n              }}\n            >\n              {position.isCollapsed ? '+' : '-'}\n            </button>\n          </div>\n        </CardHeader>\n        \n        {!position.isCollapsed && (\n          <>\n            {/* Main content - scrollable area */}\n            <CardContent className=\"p-3 overflow-y-auto bg-gray-50 grow\" ref={contentRef}>\n              {/* Original thumbnail if available */}\n              {node.metadata?.thumbnail && (\n                <div className=\"mb-2 border border-gray-200 rounded overflow-hidden bg-white\">\n                  <img \n                    src={node.metadata.thumbnail} \n                    alt=\"Transcribed selection\" \n                    className=\"w-full object-contain max-h-[120px]\"\n                  />\n                  <div className=\"bg-gray-100 text-xs text-gray-500 p-1 text-center\">\n                    Transcribed selection\n                  </div>\n                </div>\n              )}\n              \n              {/* Chat Messages */}\n              <div className=\"space-y-2 mb-4\">\n                {visibleMessages.map(message => (\n                  <ChatMessage \n                    key={message.id}\n                    message={message}\n                    isSelected={message.id === node.id}\n                    onSelect={() => onSelect(message.id === node.id ? node.id : message.id)}\n                  />\n                ))}\n                \n                {chatHandler.isLoading && (\n                  <div className=\"flex items-center space-x-2 p-2 bg-gray-100 rounded-lg max-w-[80%]\">\n                    <div className=\"flex space-x-1\">\n                      <div className=\"h-2 w-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0ms' }}></div>\n                      <div className=\"h-2 w-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '150ms' }}></div>\n                      <div className=\"h-2 w-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '300ms' }}></div>\n                    </div>\n                    <div className=\"text-xs text-gray-500\">AI is writing...</div>\n                  </div>\n                )}\n              </div>\n            </CardContent>\n            \n            {/* Chat input - fixed at bottom */}\n            <CardFooter className=\"p-0 border-t shrink-0 bg-white\">\n              <div className=\"w-full px-3 py-2 flex items-center space-x-2\">\n                <Textarea\n                  placeholder=\"Type your message...\"\n                  className=\"flex-1 resize-none min-h-[40px] max-h-[100px] py-2 px-3 text-sm rounded-md border-gray-300 focus:ring-blue-500 focus:border-blue-500\"\n                  value={chatHandler.input}\n                  onChange={(e) => chatHandler.setInput(e.target.value)}\n                  onKeyDown={(e) => {\n                    if (e.key === 'Enter' && !e.shiftKey) {\n                      e.preventDefault();\n                      handleSubmitMessage(e as any);\n                    }\n                  }}\n                  disabled={chatHandler.isLoading}\n                />\n                <div className=\"flex items-center space-x-1\">\n                  <FileUploadButton />\n                  <button\n                    className=\"p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white disabled:bg-blue-400\"\n                    onClick={(e) => {\n                      e.preventDefault();\n                      handleSubmitMessage(e as any);\n                    }}\n                    disabled={chatHandler.isLoading || !chatHandler.input.trim()}\n                  >\n                    {chatHandler.isLoading ? (\n                      <div className=\"h-4 w-4 border-2 border-white border-t-transparent rounded-full animate-spin\"></div>\n                    ) : (\n                      <svg className=\"h-4 w-4\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                      </svg>\n                    )}\n                  </button>\n                </div>\n              </div>\n            </CardFooter>\n          </>\n        )}\n      </Card>\n      \n      {/* Settings panel */}\n      {showSettings && !position.isCollapsed && (\n        <div \n          className=\"absolute z-20 right-0 top-0 -mt-2 -mr-2 w-64 bg-white rounded-lg shadow-xl border border-gray-200\"\n          ref={settingsRef}\n          onClick={(e) => e.stopPropagation()}\n        >\n          <div className=\"p-3\">\n            <div className=\"flex justify-between items-center mb-2\">\n              <h3 className=\"text-sm font-medium\">Card Settings</h3>\n              <button\n                className=\"text-gray-400 hover:text-gray-500\"\n                onClick={() => setShowSettings(false)}\n              >\n                ×\n              </button>\n            </div>\n            \n            <div className=\"mb-3\">\n              <div className=\"text-xs text-gray-500 mb-1\">\n                AI Model\n              </div>\n              <ModelSelector\n                selectedModel={modelId}\n                onChangeModel={handleModelChange}\n              />\n            </div>\n            \n            <div className=\"text-xs text-gray-500 mb-2\">\n              System Prompt\n            </div>\n            \n            <Textarea\n              className=\"w-full text-xs resize-none h-20 mb-3\"\n              value={systemPrompt}\n              readOnly\n            />\n            \n            <div className=\"text-xs text-gray-500 mb-2\">\n              Node Type: {node.type}\n            </div>\n            \n            <div className=\"text-xs text-gray-500\">\n              ID: {node.id.substring(0, 8)}...\n            </div>\n            \n            {node.metadata?.selectionInfo && (\n              <div className=\"mt-2 text-xs text-gray-500\">\n                <div>Position: ({node.metadata.selectionInfo.x.toFixed(0)}, {node.metadata.selectionInfo.y.toFixed(0)})</div>\n                <div>Size: {node.metadata.selectionInfo.width.toFixed(0)} × {node.metadata.selectionInfo.height.toFixed(0)}</div>\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(ThreadedCardChat);\n\n================================================================================\nFILE: src/components/canvas/ThreadHistory.tsx\n================================================================================\n\n// src/components/canvas/ThreadHistory.tsx\nimport React, { useState, useEffect } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Conversation } from '@/types/supabase';\nimport { Card, CardContent, CardHeader, CardTitle, CardFooter } from '@/components/shadcn/card';\nimport { Button } from '@/components/shadcn/button';\nimport { ScrollArea } from '@/components/shadcn/scroll-area';\nimport { formatDistanceToNow } from 'date-fns';\nimport { Skeleton } from '@/components/shadcn/skeleton';\n\ninterface ThreadHistoryProps {\n  notebookId: string;\n  onSelectThread: (threadId: string) => void;\n  activeThreadId: string | null;\n}\n\n/**\n * ThreadHistory displays a list of all thread cards with filtering options\n */\nconst ThreadHistory: React.FC<ThreadHistoryProps> = ({\n  notebookId,\n  onSelectThread,\n  activeThreadId\n}) => {\n  // State\n  const [conversations, setConversations] = useState<Conversation[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [filter, setFilter] = useState<'all' | 'questions' | 'notes'>('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  \n  // Fetch conversations from database\n  useEffect(() => {\n    const fetchConversations = async () => {\n      if (!notebookId) return;\n      \n      try {\n        setIsLoading(true);\n        \n        const { data, error } = await supabase\n          .from('conversations')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: false });\n          \n        if (error) {\n          console.error('Error fetching conversations:', error);\n          return;\n        }\n        \n        setConversations(data || []);\n      } catch (err) {\n        console.error('Error fetching conversations:', err);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n    \n    fetchConversations();\n    \n    // Set up realtime subscription\n    const conversationsSubscription = supabase\n      .channel(`notebook-conversations:${notebookId}`)\n      .on('postgres_changes', {\n        event: '*',\n        schema: 'public',\n        table: 'conversations',\n        filter: `notebook_id=eq.${notebookId}`,\n      }, (payload) => {\n        if (payload.eventType === 'INSERT') {\n          // Add new conversation\n          setConversations(prev => [payload.new as Conversation, ...prev]);\n        } else if (payload.eventType === 'UPDATE') {\n          // Update existing conversation\n          setConversations(prev => \n            prev.map(conv => \n              conv.id === payload.new.id ? (payload.new as Conversation) : conv\n            )\n          );\n        } else if (payload.eventType === 'DELETE') {\n          // Remove deleted conversation\n          setConversations(prev => \n            prev.filter(conv => conv.id !== payload.old.id)\n          );\n        }\n      })\n      .subscribe();\n      \n    return () => {\n      supabase.removeChannel(conversationsSubscription);\n    };\n  }, [notebookId]);\n  \n  // Filter conversations based on search and filter\n  const filteredConversations = conversations.filter(conv => {\n    // Text search\n    const matchesSearch = !searchQuery || \n      (conv.user_content && conv.user_content.toLowerCase().includes(searchQuery.toLowerCase())) ||\n      (conv.ai_response && conv.ai_response.toLowerCase().includes(searchQuery.toLowerCase()));\n    \n    // Filter by type\n    let matchesFilter = filter === 'all';\n    \n    if (filter === 'questions' && conv.card_type === 'question') {\n      matchesFilter = true;\n    } else if (filter === 'notes' && (conv.card_type === 'note' || !conv.card_type)) {\n      matchesFilter = true;\n    }\n    \n    return matchesSearch && matchesFilter;\n  });\n  \n  // Group conversations by date (today, yesterday, earlier this week, last week, earlier)\n  const groupedConversations = filteredConversations.reduce<Record<string, Conversation[]>>((acc, conv) => {\n    const date = new Date(conv.created_at);\n    const now = new Date();\n    const dayDiff = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));\n    \n    let group = 'Earlier';\n    \n    if (dayDiff === 0) {\n      group = 'Today';\n    } else if (dayDiff === 1) {\n      group = 'Yesterday';\n    } else if (dayDiff < 7) {\n      group = 'This Week';\n    } else if (dayDiff < 14) {\n      group = 'Last Week';\n    }\n    \n    if (!acc[group]) {\n      acc[group] = [];\n    }\n    \n    acc[group].push(conv);\n    return acc;\n  }, {});\n  \n  // Render thread card preview\n  const renderThreadCard = (conv: Conversation) => {\n    const cardType = conv.card_type || 'note';\n    const isActive = activeThreadId === conv.id;\n    \n    // Get card accent color based on type\n    const getAccentColor = () => {\n      switch (cardType) {\n        case 'question':\n          return 'bg-green-100 border-l-green-500';\n        case 'response':\n          return 'bg-slate-100 border-l-slate-500';\n        case 'follow_up':\n          return 'bg-orange-100 border-l-orange-500';\n        default:\n          return 'bg-white border-l-slate-300';\n      }\n    };\n    \n    // Format time ago\n    const timeAgo = formatDistanceToNow(new Date(conv.created_at), { addSuffix: true });\n    \n    return (\n      <Card \n        key={conv.id}\n        className={`mb-2 border-l-4 shadow-sm hover:shadow ${getAccentColor()} ${\n          isActive ? 'ring-2 ring-blue-400' : ''\n        }`}\n        onClick={() => onSelectThread(conv.id)}\n      >\n        <CardHeader className=\"py-2 px-4\">\n          <CardTitle className=\"text-sm flex justify-between items-center\">\n            <span className=\"capitalize\">{cardType}</span>\n            <span className=\"text-xs text-slate-500\">{timeAgo}</span>\n          </CardTitle>\n        </CardHeader>\n        \n        <CardContent className=\"p-4 pt-0\">\n          <p className=\"text-sm line-clamp-2 text-slate-800\">\n            {conv.user_content || 'No content'}\n          </p>\n        </CardContent>\n        \n        {conv.ai_response && (\n          <CardFooter className=\"p-0 px-4 pb-2\">\n            <p className=\"text-xs line-clamp-1 text-slate-500\">\n              <span className=\"text-blue-500\">AI:</span> {conv.ai_response}\n            </p>\n          </CardFooter>\n        )}\n      </Card>\n    );\n  };\n  \n  // Loading skeleton\n  if (isLoading) {\n    return (\n      <div className=\"p-4 space-y-4\">\n        <div className=\"flex justify-between mb-4\">\n          <Skeleton className=\"h-8 w-1/3\" />\n          <Skeleton className=\"h-8 w-1/3\" />\n        </div>\n        \n        {[1, 2, 3, 4, 5].map((i) => (\n          <Skeleton key={i} className=\"h-24 w-full\" />\n        ))}\n      </div>\n    );\n  }\n  \n  // Empty state\n  if (conversations.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-[400px] text-center p-4\">\n        <div className=\"text-4xl mb-2\">📝</div>\n        <h3 className=\"text-lg font-semibold mb-1\">No threads yet</h3>\n        <p className=\"text-sm text-slate-500 mb-4\">\n          Draw something and use the selection tool to start a conversation.\n        </p>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"thread-history\">\n      {/* Search and filter controls */}\n      <div className=\"p-4 border-b sticky top-0 bg-white z-10\">\n        <div className=\"flex mb-3\">\n          <input\n            type=\"text\"\n            placeholder=\"Search threads...\"\n            className=\"flex-1 px-3 py-2 text-sm border rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n          />\n        </div>\n        \n        <div className=\"flex space-x-1\">\n          <Button\n            variant={filter === 'all' ? 'default' : 'outline'}\n            size=\"sm\"\n            onClick={() => setFilter('all')}\n            className=\"flex-1\"\n          >\n            All\n          </Button>\n          <Button\n            variant={filter === 'questions' ? 'default' : 'outline'}\n            size=\"sm\"\n            onClick={() => setFilter('questions')}\n            className=\"flex-1\"\n          >\n            Questions\n          </Button>\n          <Button\n            variant={filter === 'notes' ? 'default' : 'outline'}\n            size=\"sm\"\n            onClick={() => setFilter('notes')}\n            className=\"flex-1\"\n          >\n            Notes\n          </Button>\n        </div>\n      </div>\n      \n      {/* Thread list grouped by date */}\n      <ScrollArea className=\"h-[calc(100vh-180px)]\">\n        <div className=\"p-4\">\n          {Object.entries(groupedConversations).map(([group, convs]) => (\n            <div key={group} className=\"mb-6\">\n              <h3 className=\"text-sm font-semibold text-slate-500 mb-2\">{group}</h3>\n              <div className=\"space-y-2\">\n                {convs.map(renderThreadCard)}\n              </div>\n            </div>\n          ))}\n          \n          {filteredConversations.length === 0 && (\n            <div className=\"flex flex-col items-center justify-center py-10 text-center\">\n              <div className=\"text-3xl mb-2\">🔍</div>\n              <h3 className=\"text-lg font-semibold mb-1\">No matching threads</h3>\n              <p className=\"text-sm text-slate-500\">\n                Try adjusting your search or filters\n              </p>\n            </div>\n          )}\n        </div>\n      </ScrollArea>\n    </div>\n  );\n};\n\nexport default ThreadHistory;\n\n================================================================================\nFILE: src/components/canvas/ThreadResponseContainer.tsx\n================================================================================\n\n// src/components/canvas/ThreadResponseContainer.tsx\nimport React, { useState } from 'react';\nimport { Card, CardHeader, CardContent, CardFooter } from '../shadcn/card';\nimport { Button } from '../shadcn/button';\nimport { Textarea } from '../shadcn/textarea';\nimport { Node, Relationship } from '@/types/thread';\n\ninterface ThreadResponseContainerProps {\n  parentNode: Node;\n  responses: Node[];\n  relationships: Relationship[];\n  nodePositions: Record<string, any>;\n  isExpanded: boolean;\n  selectedNodeId: string | null;\n  onSelect: (id: string) => void;\n  onAddThreadResponse: (parentId: string, content: string) => void;\n  scale?: number;\n}\n\nconst ThreadResponseContainer: React.FC<ThreadResponseContainerProps> = ({\n  parentNode,\n  responses,\n  relationships,\n  nodePositions,\n  isExpanded,\n  selectedNodeId,\n  onSelect,\n  onAddThreadResponse,\n  scale = 1\n}) => {\n  const [isAddingThreadResponse, setIsAddingThreadResponse] = useState(false);\n  const [threadResponseText, setThreadResponseText] = useState('');\n\n  // Handle thread response submission\n  const handleAddThreadResponse = () => {\n    if (threadResponseText.trim()) {\n      onAddThreadResponse(parentNode.id, threadResponseText.trim());\n      setThreadResponseText('');\n      setIsAddingThreadResponse(false);\n    }\n  };\n\n  // Get style for a response card based on its type and selection state\n  const getResponseCardStyle = (node: Node) => {\n    const isSelected = selectedNodeId === node.id;\n    \n    let baseStyle = \"border-l-4 mb-2\";\n    \n    if (isSelected) {\n      baseStyle += \" ring-2 ring-offset-1\";\n    }\n    \n    // Card color based on type\n    switch (node.type) {\n      case 'question':\n        return `${baseStyle} bg-blue-50 border-blue-400 ${isSelected ? 'ring-blue-500' : ''}`;\n      case 'response':\n        return `${baseStyle} bg-teal-50 border-teal-400 ${isSelected ? 'ring-teal-500' : ''}`;\n      case 'note':\n        return `${baseStyle} bg-yellow-50 border-yellow-400 ${isSelected ? 'ring-yellow-500' : ''}`;\n      case 'drawing':\n        return `${baseStyle} bg-green-50 border-green-400 ${isSelected ? 'ring-green-500' : ''}`;\n      default:\n        return `${baseStyle} bg-gray-50 border-gray-400 ${isSelected ? 'ring-gray-500' : ''}`;\n    }\n  };\n\n  if (!isExpanded) {\n    return null;\n  }\n\n  return (\n    <div className=\"mt-2 pl-4 border-l border-gray-200\">\n      {/* Render thread responses */}\n      {responses.map(response => (\n        <div \n          key={response.id}\n          className={getResponseCardStyle(response)}\n          onClick={(e) => {\n            e.stopPropagation();\n            onSelect(response.id);\n          }}\n        >\n          <div className=\"p-2\">\n            <div className=\"text-xs text-gray-500 mb-1\">\n              {response.type.charAt(0).toUpperCase() + response.type.slice(1)} • {new Date(response.created_at).toLocaleString()}\n            </div>\n            \n            <div className=\"text-sm\">\n              {/* Display thumbnail if available */}\n              {response.metadata?.thumbnail && (\n                <div className=\"mb-2 border border-gray-200 rounded overflow-hidden\">\n                  <img \n                    src={response.metadata.thumbnail} \n                    alt=\"Transcribed selection\" \n                    className=\"w-full object-contain max-h-[80px]\"\n                  />\n                </div>\n              )}\n              {response.content}\n            </div>\n          </div>\n        </div>\n      ))}\n      \n      {/* Thread response input form */}\n      {isAddingThreadResponse ? (\n        <div className=\"mt-2 p-2 border border-blue-200 rounded bg-blue-50\">\n          <Textarea\n            value={threadResponseText}\n            onChange={(e) => setThreadResponseText(e.target.value)}\n            placeholder=\"Type your response...\"\n            className=\"w-full mb-2 min-h-[80px]\"\n            autoFocus\n          />\n          <div className=\"flex justify-end gap-2\">\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => {\n                setIsAddingThreadResponse(false);\n                setThreadResponseText('');\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"default\"\n              size=\"sm\"\n              className={threadResponseText.trim() ? 'bg-blue-600' : 'bg-blue-400'}\n              disabled={!threadResponseText.trim()}\n              onClick={handleAddThreadResponse}\n            >\n              Send\n            </Button>\n          </div>\n        </div>\n      ) : (\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          className=\"mt-2 bg-blue-50 text-blue-700 border-blue-200 hover:bg-blue-100 w-full\"\n          onClick={(e) => {\n            e.stopPropagation();\n            setIsAddingThreadResponse(true);\n          }}\n        >\n          + Add reply\n        </Button>\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(ThreadResponseContainer);\n\n================================================================================\nFILE: src/components/canvas/ThreadsLayer.tsx\n================================================================================\n\nimport React, { useCallback, useMemo } from 'react';\nimport { Layer, Group, Rect, Text } from 'react-konva'; // Removed unused Line import\nimport { Conversation } from '@/types/supabase';\n\ninterface ThreadsLayerProps {\n  notebookId: string;\n  conversationState: {\n    items: Conversation[];\n    positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>;\n    activeConversation: string | null;\n    activeInfoDialog: string | null;\n  };\n  onToggleInfoDialog: (id: string) => void;\n  onToggleCollapse: (id: string) => void;\n  onDragStart: (id: string) => void;\n  onDragMove: (id: string, x: number, y: number) => void;\n  onDragEnd: (id: string) => void;\n}\n\nconst ThreadsLayer: React.FC<ThreadsLayerProps> = ({\n  notebookId,\n  conversationState,\n  onToggleInfoDialog,\n  onToggleCollapse,\n  onDragStart,\n  onDragMove,\n  onDragEnd\n}) => {\n  const { items, positions, activeConversation, activeInfoDialog } = conversationState;\n  \n  // Filter conversations for this notebook\n  const conversations = useMemo(() => \n    items.filter(item => item.notebook_id === notebookId),\n  [items, notebookId]);\n  \n  // Render a simple thread card\n  const renderThreadCard = useCallback((conversation: Conversation) => {\n    const id = conversation.id;\n    const position = positions[id] || { x: 100, y: 100, isCollapsed: false, isDragging: false };\n    const isActive = activeConversation === id;\n    const showInfoDialog = activeInfoDialog === id;\n    \n    // Calculate dimensions\n    const width = position.isCollapsed ? 160 : 320;\n    const height = position.isCollapsed ? 40 : 200;\n    \n    return (\n      <Group\n        key={id}\n        x={position.x}\n        y={position.y}\n        draggable\n        name={`thread-${id}`}\n        onDragStart={() => onDragStart(id)}\n        onDragMove={e => {\n          const newPos = e.target.position();\n          onDragMove(id, newPos.x, newPos.y);\n        }}\n        onDragEnd={() => onDragEnd(id)}\n        onClick={() => {\n          if (showInfoDialog) {\n            onToggleInfoDialog(id);\n          }\n        }}\n      >\n        {/* Card background */}\n        <Rect\n          width={width}\n          height={height}\n          fill=\"white\"\n          stroke={isActive ? \"#3B82F6\" : \"#E5E7EB\"}\n          strokeWidth={1.5}\n          cornerRadius={6}\n          shadowColor=\"rgba(0,0,0,0.1)\"\n          shadowBlur={5}\n          shadowOffsetY={1}\n          shadowOpacity={0.5}\n        />\n        \n        {/* Header */}\n        <Rect\n          width={width}\n          height={40}\n          fill=\"#F9FAFB\"\n          stroke=\"#E5E7EB\"\n          strokeWidth={1}\n          cornerRadius={[6, 6, 0, 0]}\n        />\n        \n        {/* Title */}\n        <Text\n          x={10}\n          y={12}\n          text={conversation.ai_response ? \"AI Thread\" : \"Thread\"}\n          fontSize={14}\n          fontFamily=\"Arial\"\n          fill=\"#4B5563\"\n          width={width - 80}\n          ellipsis\n        />\n        \n        {/* Controls */}\n        <Group x={width - 35} y={8}>\n          <Rect\n            width={24}\n            height={24}\n            cornerRadius={4}\n            fill=\"#F3F4F6\"\n            onClick={() => onToggleCollapse(id)}\n          />\n          <Text\n            x={6}\n            y={4}\n            text={position.isCollapsed ? \"+\" : \"-\"}\n            fontSize={16}\n            fontFamily=\"Arial\"\n            fill=\"#6B7280\"\n          />\n        </Group>\n        \n        {/* Content (if expanded) */}\n        {!position.isCollapsed && (\n          <Group y={40}>\n            <Rect\n              width={width}\n              height={height - 40}\n              fill=\"white\"\n            />\n            <Text\n              x={10}\n              y={10}\n              text={conversation.user_content || \"Empty thread\"}\n              fontSize={12}\n              fontFamily=\"Arial\"\n              fill=\"#6B7280\"\n              width={width - 20}\n              height={height - 60}\n              wrap=\"word\"\n            />\n          </Group>\n        )}\n      </Group>\n    );\n  }, [positions, activeConversation, activeInfoDialog, onToggleInfoDialog, onToggleCollapse, onDragStart, onDragMove, onDragEnd]);\n  \n  return (\n    <Layer name=\"threads-layer\">\n      <Group>\n        {conversations.map(renderThreadCard)}\n      </Group>\n    </Layer>\n  );\n};\n\nexport default React.memo(ThreadsLayer);\n\n================================================================================\nFILE: src/components/canvas/UnifiedCanvasContainer.tsx\n================================================================================\n\n// src/components/canvas/UnifiedCanvasContainer.hybrid.tsx\nimport React, { useEffect, useState, useRef, useCallback } from 'react';\nimport { exportCanvas } from '@/utils/exportUtils';\nimport { Stage, Layer, Group, Rect, Line } from 'react-konva';\nimport UnifiedCardThreadDOM from './UnifiedCardThreadDOM';\nimport ThreadedCardChat from './ThreadedCardChat';\nimport DrawingLayer from './DrawingLayer'; \nimport ConnectionLayer from './ConnectionLayer';\nimport ResponsiveToolbar from './ResponsiveToolbar';\nimport LlamaChat from '../ui/LlamaChat';\nimport SystemPromptModal from '../modals/SystemPromptModal';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport { createNode, createRelationship } from '@/services/nodeService';\n// Import from stores/index.ts instead of stores/nodeStore directly\nimport { useNodeStore, useNodeActions, useNodeLoader, useNodes, useRelationships, useNodePositions } from '@/stores';\n\ninterface UnifiedCanvasContainerProps {\n  notebookId: string;\n}\n\n// Helper type for Konva events\ntype KonvaEvent = {\n  target: {\n    getStage: () => any;\n  };\n  evt: {\n    preventDefault: () => void;\n    stopPropagation: () => void;\n    cancelBubble?: boolean;\n  };\n  cancelBubble?: boolean;\n};\n\nconst UnifiedCanvasContainer: React.FC<UnifiedCanvasContainerProps> = ({\n  notebookId\n}) => {\n  // Refs\n  const stageRef = useRef<any>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // State for canvas tools and settings\n  const [tool, setTool] = useState<'pen' | 'eraser' | 'select' | 'text' | 'pan'>('pen');  // Set default to 'pen'\n  const [debugMode, setDebugMode] = useState(true);  // Enable debug mode by default\n  const [directDrawingEnabled, setDirectDrawingEnabled] = useState(true); // Enable direct drawing by default\n  const [eventLog, setEventLog] = useState<{type: string, message: string, timestamp: number}[]>([]);\n  const [toolHistory, setToolHistory] = useState<{tool: string, timestamp: number}[]>([]);\n  \n  // Add event to debug log with timestamps\n  const logEvent = useCallback((type: string, message: string) => {\n    if (!debugMode) return;\n    \n    setEventLog(prev => {\n      const newLog = [...prev, {type, message, timestamp: Date.now()}];\n      // Keep only the last 20 events\n      return newLog.slice(-20);\n    });\n  }, [debugMode]);\n  \n  // Log tool changes and apply appropriate cursor styles\n  useEffect(() => {\n    console.log(`Tool changed in UnifiedCanvasContainer: ${tool}`);\n    \n    // Track tool history for debugging\n    setToolHistory(prev => [...prev, {tool, timestamp: Date.now()}].slice(-5));\n    logEvent('tool', `Changed to ${tool}`);\n    \n    // Add global tool tracking for debugging (helps detect when tool state gets out of sync)\n    // @ts-ignore - add debugging helpers to window\n    window.__activeTool = tool;\n    // @ts-ignore\n    window.__toolChangeTimestamp = Date.now();\n    // @ts-ignore\n    window.__debugDrawingState = () => {\n      return {\n        tool,\n        isDrawing,\n        currentLine: currentLine ? { pointCount: currentLine.points.length / 2 } : null,\n        lines: lines.length,\n        directDrawingEnabled\n      };\n    };\n    console.log(\"Global tool tracking updated. Check window.__activeTool and window.__debugDrawingState() in console\");\n    \n    \n    // Apply appropriate cursor styles to the canvas container based on the active tool\n    if (containerRef.current) {\n      const container = containerRef.current;\n      \n      // Reset all cursors\n      container.style.cursor = 'default';\n      \n      // Set specific cursor based on tool\n      switch (tool) {\n        case 'pen':\n          container.style.cursor = 'crosshair';\n          break;\n        case 'eraser':\n          container.style.cursor = 'url(\"data:image/svg+xml,%3Csvg xmlns=\\'http://www.w3.org/2000/svg\\' width=\\'24\\' height=\\'24\\' viewBox=\\'0 0 24 24\\' fill=\\'none\\' stroke=\\'currentColor\\' stroke-width=\\'2\\' stroke-linecap=\\'round\\' stroke-linejoin=\\'round\\'%3E%3Cpath d=\\'M20 20H7L3 16C2.5 15.5 2.5 14.5 3 14L14 3C14.5 2.5 15.5 2.5 16 3L21 8C21.5 8.5 21.5 9.5 21 10L11 20\\'/%3E%3C/svg%3E\") 0 24, default';\n          break;\n        case 'select':\n          container.style.cursor = 'crosshair';\n          break;\n        case 'text':\n          container.style.cursor = 'text';\n          break;\n        case 'pan':\n          container.style.cursor = 'grab';\n          break;\n        default:\n          container.style.cursor = 'default';\n          break;\n      }\n    }\n    \n    // Document-level event listener to detect keyboard shortcuts\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === ' ' && tool !== 'pan') {\n        console.log('Space key pressed - temporarily switching to pan tool');\n        setTool('pan');\n      }\n    };\n    \n    const handleKeyUp = (e: KeyboardEvent) => {\n      if (e.key === ' ') {\n        console.log('Space key released - returning to previous tool');\n      }\n    };\n    \n    document.addEventListener('keydown', handleKeyDown);\n    document.addEventListener('keyup', handleKeyUp);\n    \n    // Add keyboard shortcut to toggle debug mode\n    const handleDebugToggle = (e: KeyboardEvent) => {\n      if (e.key === 'D' && e.shiftKey && e.ctrlKey) {\n        setDebugMode(prev => !prev);\n        console.log(`Debug mode ${!debugMode ? 'enabled' : 'disabled'}`);\n      }\n    };\n    \n    document.addEventListener('keydown', handleDebugToggle);\n    \n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('keydown', handleDebugToggle);\n    };\n  }, [tool, debugMode, logEvent]);\n  const [scale, setScale] = useState(1);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [penSize, setPenSize] = useState(2);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [penColor, setPenColor] = useState('#000000');\n  const [isPenMode, setIsPenMode] = useState(true);\n  // Chat panel state\n  const [isChatPanelOpen, setIsChatPanelOpen] = useState(true); // Set to true by default for better visibility\n  const [isSystemPromptModalOpen, setIsSystemPromptModalOpen] = useState(false);\n  const [isExporting, setIsExporting] = useState(false);\n  const [undoStack, setUndoStack] = useState<any[]>([]);\n  const [redoStack, setRedoStack] = useState<any[]>([]);\n  const [stageSize, setStageSize] = useState({ width: window.innerWidth, height: window.innerHeight - 100 });\n  const [selectionRect, setSelectionRect] = useState<any>(null);\n  const [isTranscribing, setIsTranscribing] = useState(false);\n  \n  // Thread state\n  const [expandedThreads, setExpandedThreads] = useState<Record<string, boolean>>({});\n  \n  // Get notebook data\n  const { notebook, loading: notebookLoading, updateNotebook } = useNotebook(notebookId);\n  \n  // Get node store state and actions using the selector hooks\n  const nodes = useNodes();\n  const relationships = useRelationships();\n  const nodePositions = useNodePositions();\n  const { isLoading: nodesLoading, fetchNodesByNotebook, error: nodeError } = useNodeLoader();\n  const { \n    addNode, \n    addRelationship, \n    setSelectedNode, \n    setActiveNode, \n    updateNodePosition, \n    toggleNodeCollapse, \n    setNodeDragging \n  } = useNodeActions();\n  \n  // Get selected and active node IDs from the store\n  const selectedNodeId = useNodeStore(state => state.selectedNodeId);\n  const activeNodeId = useNodeStore(state => state.activeNodeId);\n  \n  // NOTE: Data loading happens at the UnifiedView level, not here\n  // This component should only render what's already in the store\n  \n  // Handle window resize\n  useEffect(() => {\n    const handleResize = () => {\n      setStageSize({\n        width: window.innerWidth,\n        height: window.innerHeight - 100 // Adjust for toolbar height\n      });\n    };\n    \n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // Simple drawing state\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [currentLine, setCurrentLine] = useState<{points: number[]}>(null);\n  const [lines, setLines] = useState<{points: number[], color: string, width: number}[]>([]);\n  \n  // State for visual event indicator\n  const [lastEventTime, setLastEventTime] = useState(0);\n  const [lastEventType, setLastEventType] = useState('');\n  const [lastEventCoords, setLastEventCoords] = useState({ x: 0, y: 0 });\n\n  // Handle direct drawing on the stage\n  const handleStageMouseDown = (e: any) => {\n    // Update visual event indicator\n    setLastEventTime(Date.now());\n    setLastEventType('mousedown');\n    const stage = e.target.getStage();\n    if (stage) {\n      const pos = stage.getPointerPosition();\n      if (pos) setLastEventCoords(pos);\n    }\n    \n    logEvent('stage', 'Mouse down on stage');\n    console.log('MOUSE DOWN EVENT RECEIVED ON STAGE ✓ Success!');\n    \n    // If using a drawing tool, handle drawing\n    if (tool === 'pen' || tool === 'eraser') {\n      // Prevent default behavior and stop event propagation\n      e.evt.preventDefault();\n      if (e.evt.stopPropagation) e.evt.stopPropagation();\n      e.cancelBubble = true;\n      \n      const stage = e.target.getStage();\n      if (!stage) {\n        console.error(\"No stage found in event\");\n        return;\n      }\n      \n      const point = stage.getPointerPosition();\n      if (!point) {\n        console.error(\"Could not get pointer position\");\n        return;\n      }\n      \n      console.log(`Starting to draw at position: ${point.x}, ${point.y} with tool: ${tool}`);\n      \n      setIsDrawing(true);\n      setCurrentLine({\n        points: [point.x, point.y]\n      });\n      logEvent('draw', `Started drawing at ${point.x}, ${point.y}`);\n    }\n  };\n  \n  const handleStageMouseMove = (e: any) => {\n    // Update visual event indicator (throttled)\n    if (Math.random() < 0.2) { // Only update ~20% of the time to reduce state changes\n      setLastEventTime(Date.now());\n      setLastEventType('mousemove');\n      const stage = e.target.getStage();\n      if (stage) {\n        const pos = stage.getPointerPosition();\n        if (pos) setLastEventCoords(pos);\n      }\n    }\n    \n    // No drawing - nothing to do\n    if (!isDrawing || !currentLine) return;\n    \n    // Prevent default behavior and stop event propagation\n    e.evt.preventDefault();\n    if (e.evt.stopPropagation) e.evt.stopPropagation();\n    e.cancelBubble = true;\n    \n    const stage = e.target.getStage();\n    if (!stage) {\n      console.error(\"No stage found in event\");\n      return;\n    }\n    \n    const point = stage.getPointerPosition();\n    if (!point) {\n      console.error(\"Could not get pointer position\");\n      return;\n    }\n    \n    // Log drawing for debugging (throttled to avoid console spam)\n    if (Math.random() < 0.05) { // ~5% of move events\n      console.log(`Drawing at ${point.x}, ${point.y}`);\n    }\n    \n    // Add point\n    const newPoints = [...currentLine.points, point.x, point.y];\n    \n    // Update current line\n    setCurrentLine({\n      points: newPoints\n    });\n  };\n  \n  const handleStageMouseUp = (e: any) => {\n    // Update visual event indicator\n    setLastEventTime(Date.now());\n    setLastEventType('mouseup');\n    const stage = e?.target?.getStage();\n    if (stage) {\n      const pos = stage.getPointerPosition();\n      if (pos) setLastEventCoords(pos);\n    }\n    console.log('MOUSE UP EVENT RECEIVED ON STAGE ✓');\n    \n    if (!isDrawing || !currentLine) return;\n    \n    // Prevent default behavior\n    if (e && e.evt) {\n      e.evt.preventDefault();\n      if (e.evt.stopPropagation) e.evt.stopPropagation();\n      e.cancelBubble = true;\n    }\n    \n    // Stop drawing\n    setIsDrawing(false);\n    \n    // Ensure we have enough points to consider this a valid line\n    if (currentLine.points.length >= 4) { // At least 2 points (x,y pairs)\n      console.log(`Completed drawing stroke with ${currentLine.points.length/2} points`);\n      \n      // Add current line to the array of lines\n      setLines([\n        ...lines,\n        {\n          points: currentLine.points,\n          color: tool === 'eraser' ? '#ffffff' : penColor,\n          width: tool === 'eraser' ? eraserSize : penSize\n        }\n      ]);\n      \n      logEvent('draw', `Finished drawing stroke with ${currentLine.points.length/2} points`);\n    } else {\n      console.log('Discarded short drawing stroke');\n      logEvent('draw', 'Discarded short drawing stroke');\n    }\n    \n    // Clear current line\n    setCurrentLine(null);\n  };\n  \n  // Handle tool keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Don't handle shortcuts if modifiers are pressed\n      if (e.ctrlKey || e.metaKey || e.altKey) return;\n      \n      // Don't handle shortcuts if focused on input or textarea\n      if (\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement\n      ) {\n        return;\n      }\n      \n      switch (e.key.toLowerCase()) {\n        case 'p':\n          setTool('pen');\n          logEvent('keyboard', 'Pen tool activated (P key)');\n          break;\n        case 'e':\n          setTool('eraser');\n          logEvent('keyboard', 'Eraser tool activated (E key)');\n          break;\n        case 's':\n          setTool('select');\n          logEvent('keyboard', 'Select tool activated (S key)');\n          break;\n        case 't':\n          setTool('text');\n          logEvent('keyboard', 'Text tool activated (T key)');\n          break;\n        case ' ': // Spacebar for pan\n          setTool('pan');\n          logEvent('keyboard', 'Pan tool activated (Space key)');\n          break;\n        default:\n          break;\n      }\n    };\n    \n    const handleKeyUp = (e: KeyboardEvent) => {\n      // Return to previous tool when spacebar is released\n      if (e.key === ' ' && tool === 'pan') {\n        setTool('pen'); // or whatever the previous tool was\n        logEvent('keyboard', 'Returned to pen tool (Space released)');\n      }\n    };\n    \n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    \n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [tool]);\n  \n  // Handle canvas click for text tool\n  const handleCanvasClick = useCallback((e: KonvaEvent) => {\n    if (tool !== 'text') return;\n    \n    const stage = e.target.getStage();\n    if (!stage) return;\n    \n    const pointerPos = stage.getPointerPosition();\n    if (!pointerPos) return;\n    \n    // Convert to canvas coordinates\n    const x = (pointerPos.x - position.x) / scale;\n    const y = (pointerPos.y - position.y) / scale;\n    \n    // Create a new text node\n    createNode(\n      notebookId,\n      'New text note',\n      'note',\n      { x, y }\n    ).then(newNode => {\n      if (newNode) {\n        console.log('Created new text node:', newNode);\n        addNode(newNode);\n        setSelectedNode(newNode.id);\n        setActiveNode(newNode.id);\n      }\n    }).catch(err => {\n      console.error('Error creating text node:', err);\n    });\n  }, [tool, position, scale, notebookId, addNode, setSelectedNode, setActiveNode]);\n  \n  // Handle selection start\n  const handleSelectionStart = useCallback((e: KonvaEvent) => {\n    if (tool !== 'select') return;\n    \n    const stage = e.target.getStage();\n    if (!stage) return;\n    \n    e.evt.preventDefault();\n    \n    const pointerPos = stage.getPointerPosition();\n    if (!pointerPos) return;\n    \n    // Convert screen position to canvas coordinates\n    // We need to account for the current position and scale of the stage\n    // This ensures selections work correctly after panning/zooming\n    const canvasX = (pointerPos.x - position.x) / scale;\n    const canvasY = (pointerPos.y - position.y) / scale;\n    \n    console.log('Selection start at canvas coordinates:', { canvasX, canvasY });\n    \n    setSelectionRect({\n      startX: canvasX,\n      startY: canvasY,\n      endX: canvasX,\n      endY: canvasY,\n    });\n    \n    // Set selected node to null during selection\n    setSelectedNode(null);\n  }, [tool, position, scale, setSelectedNode]);\n  \n  // Handle selection move\n  const handleSelectionMove = useCallback((e: KonvaEvent) => {\n    if (tool !== 'select' || !selectionRect) return;\n    \n    const stage = e.target.getStage();\n    if (!stage) return;\n    \n    e.evt.preventDefault();\n    \n    const pointerPos = stage.getPointerPosition();\n    if (!pointerPos) return;\n    \n    // Convert screen position to canvas coordinates\n    // Ensure we maintain the same coordinate transformation as in handleSelectionStart\n    const canvasX = (pointerPos.x - position.x) / scale;\n    const canvasY = (pointerPos.y - position.y) / scale;\n    \n    setSelectionRect({\n      ...selectionRect,\n      endX: canvasX,\n      endY: canvasY,\n    });\n  }, [tool, selectionRect, position, scale]);\n  \n  // Handle selection end\n  const handleSelectionEnd = useCallback(async (e: KonvaEvent) => {\n    if (tool !== 'select' || !selectionRect) return;\n    \n    e.evt.preventDefault();\n    \n    // Calculate the selection rectangle\n    const x = Math.min(selectionRect.startX, selectionRect.endX);\n    const y = Math.min(selectionRect.startY, selectionRect.endY);\n    const width = Math.abs(selectionRect.startX - selectionRect.endX);\n    const height = Math.abs(selectionRect.startY - selectionRect.endY);\n    \n    // Check if selection is too small - use a very small threshold\n    // to allow capture of even tiny drawings\n    if (width < 5 || height < 5) {\n      console.log('Selection too small, must be at least 5x5 pixels');\n      setSelectionRect(null);\n      return;\n    }\n    \n    // Log selection size for debugging\n    console.log(`Selection dimensions: ${width}x${height} at (${x},${y})`);\n    \n    // Add a visual feedback message about the selection\n    const feedbackDiv = document.createElement('div');\n    feedbackDiv.innerText = `Selection: ${Math.round(width)}x${Math.round(height)} pixels`;\n    feedbackDiv.style.position = 'fixed';\n    feedbackDiv.style.bottom = '20px';\n    feedbackDiv.style.right = '20px';\n    feedbackDiv.style.padding = '10px';\n    feedbackDiv.style.background = 'rgba(0,0,0,0.7)';\n    feedbackDiv.style.color = '#fff';\n    feedbackDiv.style.fontWeight = 'bold';\n    feedbackDiv.style.zIndex = '9999';\n    feedbackDiv.style.borderRadius = '5px';\n    document.body.appendChild(feedbackDiv);\n    \n    // Remove feedback after a few seconds\n    setTimeout(() => {\n      if (feedbackDiv.parentNode) feedbackDiv.parentNode.removeChild(feedbackDiv);\n    }, 3000);\n    \n    try {\n      // Set flag to indicate transcription in progress\n      setIsTranscribing(true);\n      \n      // Get the stage\n      const stage = stageRef.current;\n      if (!stage) {\n        setSelectionRect(null);\n        setIsTranscribing(false);\n        return;\n      }\n      \n      // Create a data URL of the selection by capturing the actual drawing\n      // First create a temporary canvas of the selection area\n      const tempCanvas = document.createElement('canvas');\n      tempCanvas.width = width * scale;\n      tempCanvas.height = height * scale;\n      const tempContext = tempCanvas.getContext('2d');\n      \n      if (!tempContext) {\n        console.error('Failed to create canvas context');\n        throw new Error('Could not create canvas context');\n      }\n      \n      // Set white background - IMPORTANT: This ensures drawings are visible to the LLM\n      tempContext.fillStyle = 'white';\n      tempContext.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n      \n      // Draw from the stage - we need to adjust for position and scaling\n      // Get the visible canvas element from the Konva stage\n      if (!stage.content) {\n        console.error('Stage content is not available');\n        throw new Error('Stage content is not available');\n      }\n      \n      // Find the canvas element in the stage\n      const mainCanvas = stage.content.querySelector('canvas');\n      if (!mainCanvas) {\n        console.error('Could not find main canvas element in the stage');\n        throw new Error('Could not find main canvas element');\n      }\n      \n      // Selection coordinates (for saving with the node)\n      const selectionInfo = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        scale: scale,\n        canvasX: x * scale + position.x,\n        canvasY: y * scale + position.y,\n        canvasWidth: width * scale,\n        canvasHeight: height * scale\n      };\n      \n      // Try to capture the selection area\n      console.log('Capturing selection area:', selectionInfo);\n      \n      // Draw from ALL canvas elements to ensure we capture everything\n      // We need to account for position and scale\n      console.log('Attempting to capture from ALL canvas elements in stage');\n      \n      // Find ALL canvas elements in the stage\n      const allCanvases = stage.content.querySelectorAll('canvas');\n      console.log(`Found ${allCanvases.length} canvas elements in stage`);\n      \n      // Fill with white background first\n      tempContext.fillStyle = 'white';\n      tempContext.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n      \n      // Try to draw from each canvas\n      allCanvases.forEach((canvas, index) => {\n        try {\n          console.log(`Drawing from canvas ${index}`);\n          tempContext.drawImage(\n            canvas,\n            selectionInfo.canvasX, // Source x\n            selectionInfo.canvasY, // Source y\n            selectionInfo.canvasWidth, // Source width\n            selectionInfo.canvasHeight, // Source height\n            0, 0, // Destination x, y\n            selectionInfo.canvasWidth, // Destination width\n            selectionInfo.canvasHeight // Destination height\n          );\n        } catch (err) {\n          console.error(`Error drawing from canvas ${index}:`, err);\n        }\n      });\n      \n      // Draw our direct drawing lines on top\n      try {\n        // Create a temporary canvas just for our lines\n        const linesCanvas = document.createElement('canvas');\n        linesCanvas.width = selectionInfo.canvasWidth;\n        linesCanvas.height = selectionInfo.canvasHeight;\n        const linesContext = linesCanvas.getContext('2d');\n        \n        if (linesContext) {\n          // Draw all our lines with correct offsetting\n          // Apply scale and position to the context\n          linesContext.translate(-selectionInfo.canvasX, -selectionInfo.canvasY);\n          linesContext.scale(scale, scale);\n          \n          // Set proper drawing styles\n          linesContext.lineCap = 'round';\n          linesContext.lineJoin = 'round';\n          \n          // Draw all completed lines\n          lines.forEach(line => {\n            const points = line.points;\n            if (points.length < 4) return; // Need at least 2 points (4 values)\n            \n            linesContext.beginPath();\n            linesContext.moveTo(points[0], points[1]);\n            \n            for (let i = 2; i < points.length; i += 2) {\n              linesContext.lineTo(points[i], points[i + 1]);\n            }\n            \n            linesContext.strokeStyle = line.color;\n            linesContext.lineWidth = line.width;\n            linesContext.stroke();\n          });\n          \n          // Draw current line if any\n          if (currentLine && currentLine.points && currentLine.points.length >= 4) {\n            const points = currentLine.points;\n            \n            linesContext.beginPath();\n            linesContext.moveTo(points[0], points[1]);\n            \n            for (let i = 2; i < points.length; i += 2) {\n              linesContext.lineTo(points[i], points[i + 1]);\n            }\n            \n            linesContext.strokeStyle = tool === 'eraser' ? '#ffffff' : penColor;\n            linesContext.lineWidth = tool === 'eraser' ? eraserSize : penSize;\n            linesContext.stroke();\n          }\n          \n          // Overlay the lines on our temp canvas\n          tempContext.drawImage(linesCanvas, 0, 0);\n        }\n      } catch (err) {\n        console.error('Error drawing lines to selection:', err);\n      }\n      \n      // Don't draw red border or selection text on the image that gets sent to the LLM\n      // The visual feedback is already provided by the selection rectangle in the UI\n      \n      // Convert to data URL (the thumbnail image)\n      const dataURL = tempCanvas.toDataURL('image/png');\n      console.log('Successfully captured selection image, sending for transcription...');\n      \n      // For debugging, let's add the image to the document temporarily\n      if (process.env.NODE_ENV === 'development') {\n        const img = document.createElement('img');\n        img.src = dataURL;\n        img.style.position = 'fixed';\n        img.style.top = '10px';\n        img.style.right = '10px';\n        img.style.width = '200px';\n        img.style.zIndex = '9999';\n        img.style.border = '2px solid red';\n        document.body.appendChild(img);\n        setTimeout(() => document.body.removeChild(img), 5000); // Remove after 5 seconds\n      }\n      \n      // Call the API to transcribe the selection\n      console.log('Sending request to /api/claude/transcribe');\n      \n      // The API expects the base64 data without the prefix\n      // Extract the base64 data after the prefix \"data:image/png;base64,\"\n      const base64Data = dataURL.split(',')[1];\n      if (!base64Data) {\n        throw new Error('Failed to extract base64 data from image');\n      }\n      \n      // Create a clone of the image data to show a preview with a border\n      const displayCanvas = document.createElement('canvas');\n      displayCanvas.width = tempCanvas.width;\n      displayCanvas.height = tempCanvas.height;\n      const displayContext = displayCanvas.getContext('2d');\n      \n      if (displayContext) {\n        // Copy the clean image\n        displayContext.drawImage(tempCanvas, 0, 0);\n        \n        // Add border and label just for the UI preview\n        displayContext.strokeStyle = '#ff0000';\n        displayContext.lineWidth = 8;\n        displayContext.strokeRect(0, 0, displayCanvas.width, displayCanvas.height);\n        \n        // Add a label on the UI preview\n        displayContext.fillStyle = '#ff0000';\n        displayContext.font = 'bold 24px Arial';\n        displayContext.fillText('Preview Only', 10, 30);\n        \n        // Create two images: one for display with border, one for the actual data being sent\n        const displayURL = displayCanvas.toDataURL('image/png');\n        \n        // Display the preview image\n        const img = document.createElement('img');\n        img.src = displayURL;\n        img.style.position = 'fixed';\n        img.style.top = '60px';\n        img.style.right = '10px';\n        img.style.width = '300px';\n        img.style.height = 'auto';\n        img.style.zIndex = '9999';\n        img.style.border = '4px solid red';\n        img.style.padding = '5px';\n        img.style.background = '#fff';\n        document.body.appendChild(img);\n        \n        // Add a label for the debug image\n        const label = document.createElement('div');\n        label.innerText = 'UI PREVIEW (not sent to LLM)';\n        label.style.position = 'fixed';\n        label.style.top = '30px';\n        label.style.right = '10px';\n        label.style.padding = '5px 10px';\n        label.style.background = '#ff0000';\n        label.style.color = '#ffffff';\n        label.style.fontWeight = 'bold';\n        label.style.zIndex = '9999';\n        document.body.appendChild(label);\n        \n        // Also show what's actually being sent to the LLM\n        const actualImg = document.createElement('img');\n        actualImg.src = dataURL;\n        actualImg.style.position = 'fixed';\n        actualImg.style.top = '60px';\n        actualImg.style.left = '10px';\n        actualImg.style.width = '300px';\n        actualImg.style.height = 'auto';\n        actualImg.style.zIndex = '9999';\n        actualImg.style.border = '4px solid green';\n        actualImg.style.padding = '5px';\n        actualImg.style.background = '#fff';\n        document.body.appendChild(actualImg);\n        \n        // Add a label for the actual image\n        const actualLabel = document.createElement('div');\n        actualLabel.innerText = 'SENT TO LLM';\n        actualLabel.style.position = 'fixed';\n        actualLabel.style.top = '30px';\n        actualLabel.style.left = '10px';\n        actualLabel.style.padding = '5px 10px';\n        actualLabel.style.background = '#00aa00';\n        actualLabel.style.color = '#ffffff';\n        actualLabel.style.fontWeight = 'bold';\n        actualLabel.style.zIndex = '9999';\n        document.body.appendChild(actualLabel);\n        \n        // Update the cleanup timeout to remove both images\n        setTimeout(() => {\n          try {\n            if (img && img.parentNode) img.parentNode.removeChild(img);\n            if (label && label.parentNode) label.parentNode.removeChild(label);\n            if (actualImg && actualImg.parentNode) actualImg.parentNode.removeChild(actualImg);\n            if (actualLabel && actualLabel.parentNode) actualLabel.parentNode.removeChild(actualLabel);\n          } catch (err) { /* ignore */ }\n        }, 20000);\n      }\n      \n      const response = await fetch('/api/claude/transcribe', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ \n          image: base64Data, \n          notebookId,\n          selectionInfo,\n          thumbnail: dataURL, // Send the thumbnail image URL to save with the node\n          debug: true // Enable debugging mode\n        })\n      });\n      \n      // We'll leave the debug image visible for 20 seconds\n      setTimeout(() => {\n        try {\n          if (img && img.parentNode) img.parentNode.removeChild(img);\n          if (label && label.parentNode) label.parentNode.removeChild(label);\n        } catch (err) { /* ignore */ }\n      }, 20000);\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('API response not OK:', {\n          status: response.status,\n          statusText: response.statusText,\n          body: errorText\n        });\n        throw new Error(`Failed to transcribe selection: ${response.status} ${response.statusText}`);\n      }\n      \n      // Parse the response\n      const responseData = await response.json();\n      console.log('Transcription API response:', responseData);\n      \n      // The API returns 'transcription' field, not 'text'\n      const text = responseData.transcription || '';\n      \n      // If transcription successful, create a new note node\n      if (text) {\n        console.log('Transcription successful, creating note node with text:', text);\n        \n        // Create node to the right of the selection\n        const nodePosition = {\n          x: x + width + 20,\n          y: y\n        };\n        \n        // Prepare metadata with selection info and thumbnail\n        const metadata = {\n          selectionInfo,\n          thumbnail: dataURL,\n          transcriptionTags: responseData.tags || [],\n          transcribedAt: new Date().toISOString()\n        };\n        \n        const newNode = await createNode(\n          notebookId,\n          text,\n          'note',\n          nodePosition,\n          metadata\n        );\n        \n        if (newNode) {\n          console.log('Successfully created node:', newNode);\n          addNode(newNode);\n          setSelectedNode(newNode.id);\n        } else {\n          console.error('Failed to create node - createNode returned null or undefined');\n        }\n      } else {\n        console.warn('Transcription returned empty text');\n      }\n    } catch (error) {\n      console.error('Error transcribing selection:', error);\n      \n      // Show error to user\n      window.alert(`Failed to transcribe selection: ${error.message}`);\n    } finally {\n      // Clear selection and transcribing flag\n      setSelectionRect(null);\n      setIsTranscribing(false);\n    }\n  }, [tool, selectionRect, notebookId, addNode, setSelectedNode, scale, position]);\n  \n  // Handle node drag\n  const handleNodeDragStart = useCallback((id: string) => {\n    setNodeDragging(id, true);\n    setSelectedNode(id);\n  }, [setNodeDragging, setSelectedNode]);\n  \n  const handleNodeDragMove = useCallback((id: string, x: number, y: number) => {\n    updateNodePosition(id, x, y);\n  }, [updateNodePosition]);\n  \n  const handleNodeDragEnd = useCallback(async (id: string) => {\n    setNodeDragging(id, false);\n    \n    // Update node position in database\n    const node = nodes[id];\n    const position = nodePositions[id];\n    \n    if (node && position) {\n      // Save position to database\n      await updateNodePosition(id, position.x, position.y, true);\n    }\n  }, [nodes, nodePositions, updateNodePosition, setNodeDragging]);\n  \n  // Handle add regular response (not thread)\n  const handleAddResponse = useCallback(async (parentId: string, position: { x: number, y: number }) => {\n    try {\n      // Create a new response node\n      const newNode = await createNode(\n        notebookId,\n        'New response',\n        'response',\n        position\n      );\n      \n      if (newNode) {\n        // Add to store\n        addNode(newNode);\n        \n        // Create the relationship\n        const relationship = await createRelationship(\n          parentId,\n          newNode.id,\n          'extends',\n          notebookId\n        );\n        \n        if (relationship) {\n          addRelationship(relationship);\n        }\n        \n        // Select the new node\n        setSelectedNode(newNode.id);\n        setActiveNode(newNode.id);\n      }\n    } catch (error) {\n      console.error('Error adding response:', error);\n    }\n  }, [notebookId, addNode, addRelationship, setSelectedNode, setActiveNode]);\n  \n  // Handle add thread response (compact thread UI)\n  const handleAddThreadResponse = useCallback(async (parentId: string, content: string) => {\n    try {\n      // Get the parent node\n      const parentNode = nodes[parentId];\n      if (!parentNode) {\n        throw new Error('Parent node not found');\n      }\n      \n      // Get position for thread response (slightly offset from parent)\n      const parentPosition = nodePositions[parentId] || { x: 100, y: 100 };\n      const position = {\n        x: parentPosition.x + 20,\n        y: parentPosition.y + 40\n      };\n      \n      // Create a new response node\n      const newNode = await createNode(\n        notebookId,\n        content,\n        'response',\n        position\n      );\n      \n      if (newNode) {\n        // Add to store\n        addNode(newNode);\n        \n        // Create the relationship with type 'extends' to show it's a thread response\n        const relationship = await createRelationship(\n          parentId,\n          newNode.id,\n          'extends', // Using 'extends' for thread responses\n          notebookId\n        );\n        \n        if (relationship) {\n          addRelationship(relationship);\n          \n          // Make sure the thread is expanded\n          setExpandedThreads(prev => ({\n            ...prev,\n            [parentId]: true\n          }));\n        }\n        \n        // Select the new node\n        setSelectedNode(newNode.id);\n      }\n    } catch (error) {\n      console.error('Error adding thread response:', error);\n    }\n  }, [notebookId, nodes, nodePositions, addNode, addRelationship, setSelectedNode]);\n  \n  // Handle thread expand/collapse\n  const handleThreadExpand = useCallback((nodeId: string) => {\n    setExpandedThreads(prev => ({\n      ...prev,\n      [nodeId]: !prev[nodeId]\n    }));\n  }, []);\n  \n  // Handle system prompt save\n  const handleSystemPromptSave = useCallback(async (prompt: string) => {\n    if (!notebook) return;\n    \n    try {\n      await updateNotebook({\n        system_prompt: prompt\n      });\n      \n      setIsSystemPromptModalOpen(false);\n    } catch (error) {\n      console.error('Error updating system prompt:', error);\n    }\n  }, [notebook, updateNotebook]);\n\n  // Handle canvas export\n  const handleExport = useCallback(async () => {\n    if (!containerRef.current || !stageRef.current) {\n      console.error('Container or stage reference is not available');\n      return;\n    }\n    \n    try {\n      setIsExporting(true);\n      \n      // Use the exportCanvas utility function\n      await exportCanvas(containerRef, stageRef, {\n        filename: `${notebook?.title || 'notebook'}-export`,\n        format: 'png',\n        quality: 2, // Higher quality for export\n        backgroundColor: '#FFFFFF'\n      });\n      \n      console.log('Canvas exported successfully');\n    } catch (error) {\n      console.error('Error exporting canvas:', error);\n    } finally {\n      setIsExporting(false);\n    }\n  }, [containerRef, stageRef, notebook]);\n  \n  // Calculate position for the selection rectangle with enhanced visibility\n  const selectionRectProps = selectionRect ? {\n    x: Math.min(selectionRect.startX, selectionRect.endX),\n    y: Math.min(selectionRect.startY, selectionRect.endY),\n    width: Math.abs(selectionRect.startX - selectionRect.endX),\n    height: Math.abs(selectionRect.startY - selectionRect.endY),\n    stroke: 'rgba(255, 0, 0, 0.9)',  // Bright red for better visibility\n    strokeWidth: 3 / scale,          // Thicker stroke\n    dash: [8 / scale, 4 / scale],    // More prominent dash pattern\n    fill: 'rgba(255, 0, 0, 0.15)',   // Light red fill\n    cornerRadius: 5 / scale          // Rounded corners\n  } : null;\n  \n  // Debug overlay to show current tool state and events\n  const renderDebugOverlay = () => {\n    if (!debugMode) return null;\n    \n    return (\n      <div className=\"absolute top-20 right-4 z-50 bg-white bg-opacity-90 p-3 rounded-lg border border-gray-300 shadow-lg text-xs w-96\">\n        <div className=\"font-bold border-b pb-1 mb-2 flex justify-between\">\n          <span>Debug Mode</span>\n          <button \n            className=\"text-red-500 hover:text-red-700\" \n            onClick={() => setDebugMode(false)}\n          >\n            ×\n          </button>\n        </div>\n        \n        {/* Drawing State Summary */}\n        <div className=\"mb-2 p-2 bg-blue-50 rounded-md border border-blue-100\">\n          <div className=\"font-medium text-blue-800 mb-1 border-b border-blue-200 pb-1\">\n            Drawing State Summary\n          </div>\n          <div className=\"grid grid-cols-2 gap-1\">\n            <div><strong>Active Tool:</strong></div>\n            <div className=\"text-blue-600 font-medium\">{tool}</div>\n            \n            <div><strong>Drawing Mode:</strong></div>\n            <div className={`font-medium ${directDrawingEnabled ? 'text-green-600' : 'text-blue-600'}`}>\n              {directDrawingEnabled ? 'Direct' : 'Legacy'}\n            </div>\n            \n            <div><strong>Currently Drawing:</strong></div>\n            <div className={`font-medium ${isDrawing ? 'text-green-600' : 'text-red-600'}`}>\n              {isDrawing ? 'Yes' : 'No'}\n            </div>\n            \n            <div><strong>Selection Active:</strong></div>\n            <div className={`font-medium ${selectionRect ? 'text-green-600' : 'text-red-600'}`}>\n              {selectionRect ? 'Yes' : 'No'}\n            </div>\n            \n            <div><strong>Current Line Points:</strong></div>\n            <div className=\"text-gray-600\">\n              {currentLine ? (currentLine.points.length / 2) : 0} points\n            </div>\n            \n            <div><strong>Saved Lines:</strong></div>\n            <div className=\"text-gray-600\">{lines.length}</div>\n            \n            <div><strong>Pen Color:</strong></div>\n            <div className=\"flex items-center\">\n              <div \n                className=\"w-3 h-3 rounded-full mr-1\"\n                style={{ backgroundColor: penColor }}\n              />\n              {penColor}\n            </div>\n            \n            <div><strong>Pen Size:</strong></div>\n            <div className=\"text-gray-600\">{penSize}px</div>\n            \n            <div><strong>Eraser Size:</strong></div>\n            <div className=\"text-gray-600\">{eraserSize}px</div>\n          </div>\n        </div>\n        \n        <div className=\"mb-2\">\n          <strong>Tool History:</strong>\n          <div className=\"ml-2 mt-1\">\n            {toolHistory.map((entry, i) => (\n              <div key={i} className=\"text-gray-600\">\n                {entry.tool} \n                <span className=\"ml-2 text-gray-400\">\n                  ({new Date(entry.timestamp).toLocaleTimeString()})\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n        \n        <div className=\"mb-2\">\n          <strong>Position:</strong> \n          <span className=\"text-green-600 ml-2\">\n            x: {Math.round(position.x)}, y: {Math.round(position.y)}\n          </span>\n        </div>\n        \n        <div className=\"mb-2\">\n          <strong>Scale:</strong> <span className=\"text-purple-600\">{Math.round(scale * 100)}%</span>\n        </div>\n        \n        <div>\n          <strong>Event Log:</strong>\n          <div className=\"ml-2 mt-1 max-h-40 overflow-y-auto\">\n            {eventLog.map((entry, i) => (\n              <div key={i} className={`${entry.type === 'error' ? 'text-red-600' : entry.type === 'draw' ? 'text-green-600' : 'text-gray-600'}`}>\n                <span className=\"font-bold\">[{entry.type}]</span> {entry.message}\n              </div>\n            ))}\n          </div>\n        </div>\n        \n        {/* Debugging Actions */}\n        <div className=\"mt-3 pt-2 border-t border-gray-200\">\n          <div className=\"font-medium mb-1\">Debug Actions:</div>\n          <div className=\"flex space-x-2\">\n            <button \n              className=\"bg-blue-100 text-blue-700 px-2 py-1 rounded text-xs\"\n              onClick={() => {\n                setTool('pen');\n                logEvent('debug', 'Force set tool to pen');\n              }}\n            >\n              Force Pen\n            </button>\n            <button \n              className=\"bg-red-100 text-red-700 px-2 py-1 rounded text-xs\"\n              onClick={() => {\n                // Clear current drawing state\n                setIsDrawing(false);\n                setCurrentLine(null);\n                logEvent('debug', 'Reset drawing state');\n              }}\n            >\n              Reset Draw State\n            </button>\n            <button \n              className=\"bg-green-100 text-green-700 px-2 py-1 rounded text-xs\"\n              onClick={() => {\n                // Toggle drawing mode\n                setDirectDrawingEnabled(!directDrawingEnabled);\n                logEvent('debug', `Switched to ${!directDrawingEnabled ? 'direct' : 'legacy'} drawing`);\n              }}\n            >\n              Toggle Mode\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  };\n  \n  return (\n    <div className=\"flex flex-col h-screen\">\n      <ResponsiveToolbar\n        tool={tool}\n        setTool={setTool}\n        scale={scale}\n        setScale={setScale}\n        setPosition={setPosition}\n        notebookId={notebookId}\n        notebookTitle={notebook?.title || 'Untitled Notebook'}\n        isCollaborative={notebook?.is_collaborative || false}\n        isPenMode={isPenMode}\n        setIsPenMode={setIsPenMode}\n        penSize={penSize}\n        setPenSize={setPenSize}\n        eraserSize={eraserSize}\n        setEraserSize={setEraserSize}\n        undoAvailable={undoStack.length > 0}\n        redoAvailable={redoStack.length > 0}\n        onUndo={() => {/* Implement undo */}}\n        onRedo={() => {/* Implement redo */}}\n        penColor={penColor}\n        setPenColor={setPenColor}\n        isSidePanelOpen={isChatPanelOpen}\n        toggleSidePanel={() => setIsChatPanelOpen(!isChatPanelOpen)}\n        onOpenSystemPromptModal={() => setIsSystemPromptModalOpen(true)}\n        onExport={() => handleExport()}\n      />\n      \n      {/* Debug Button - Always visible */}\n      <div className=\"absolute top-20 right-4 z-50 flex flex-col space-y-2\">\n        {/* Debug toggle */}\n        <button \n          className=\"bg-blue-500 text-white px-3 py-1.5 rounded-md shadow-md hover:bg-blue-600\"\n          onClick={() => setDebugMode(prev => !prev)}\n        >\n          {debugMode ? 'Hide Debug' : 'Show Debug'}\n        </button>\n        \n        {/* Status indicator */}\n        <div className=\"bg-white px-3 py-2 rounded-md shadow-md text-sm\">\n          <div className=\"flex items-center mb-1\">\n            <span className=\"font-bold mr-2\">Tool:</span> \n            <span className=\"px-2 py-0.5 bg-blue-100 text-blue-800 rounded-full\">{tool}</span>\n          </div>\n          <div className=\"flex items-center mb-1\">\n            <span className=\"font-bold mr-2\">Drawing:</span> \n            <span className={`px-2 py-0.5 rounded-full ${isDrawing ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`}>\n              {isDrawing ? 'Active' : 'Inactive'}\n            </span>\n          </div>\n          <div className=\"flex items-center mb-1\">\n            <span className=\"font-bold mr-2\">Mode:</span> \n            <span className={`px-2 py-0.5 rounded-full ${directDrawingEnabled ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}`}>\n              {directDrawingEnabled ? 'Direct' : 'Legacy'}\n            </span>\n          </div>\n          {/* Last event indicator - animates when events are received */}\n          <div className=\"flex items-center\">\n            <span className=\"font-bold mr-2\">Events:</span> \n            <span \n              className={`px-2 py-0.5 rounded-full ${Date.now() - lastEventTime < 1000 ? 'bg-green-100 text-green-800 animate-pulse' : 'bg-yellow-100 text-yellow-800'}`}\n            >\n              {lastEventType || 'None'} \n              {lastEventCoords && Date.now() - lastEventTime < 2000 ? \n                `(${Math.round(lastEventCoords.x)},${Math.round(lastEventCoords.y)})` : ''}\n            </span>\n          </div>\n        </div>\n      </div>\n      \n      {/* Debug Overlay */}\n      {renderDebugOverlay()}\n      \n      {/* Drawing Mode Toggle */}\n      <div className=\"absolute bottom-4 right-4 z-40 bg-white p-2 rounded-md shadow-md border border-gray-200\">\n        <button\n          className={`px-3 py-1.5 rounded-md text-sm font-medium flex items-center ${directDrawingEnabled ? 'bg-green-100 text-green-800' : 'bg-blue-100 text-blue-800'}`}\n          onClick={() => setDirectDrawingEnabled(!directDrawingEnabled)}\n        >\n          <span className=\"mr-1\">\n            {directDrawingEnabled ? '✓' : '○'}\n          </span>\n          {directDrawingEnabled ? 'Direct Drawing' : 'Legacy Drawing'}\n        </button>\n      </div>\n      \n      <div className=\"flex flex-1 overflow-hidden\">\n        <div className=\"flex-1 relative\" ref={containerRef}>\n          {/* Loading overlay */}\n          {(notebookLoading || nodesLoading || isTranscribing) && (\n            <div className=\"absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10\">\n              <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500\"></div>\n            </div>\n          )}\n          \n          {/* Canvas Stage */}\n          <Stage\n            ref={stageRef}\n            width={stageSize.width}\n            height={stageSize.height}\n            scaleX={scale}\n            scaleY={scale}\n            x={position.x}\n            y={position.y}\n            draggable={tool === 'pan'}\n            onDragStart={(e) => {\n              console.log('Stage drag start event, current tool:', tool);\n              logEvent('stage', `Drag start attempt with tool: ${tool}`);\n              \n              // Only handle drag if tool is pan, otherwise prevent it for drawing\n              if (tool !== 'pan') {\n                console.log('Preventing drag because tool is not pan');\n                logEvent('error', `Drag prevented - wrong tool active: ${tool}`);\n                e.evt.preventDefault();\n                return false;\n              }\n              \n              // Set a flag to indicate panning is in progress\n              console.log('Stage drag started - panning canvas');\n              logEvent('pan', 'Started panning canvas');\n              \n              // Change cursor style when panning\n              if (containerRef.current) {\n                containerRef.current.style.cursor = 'grabbing';\n              }\n            }}\n            onDragMove={(e) => {\n              // Update position to match stage's position\n              if (tool === 'pan') {\n                const stagePos = e.target.position();\n                if (stagePos) {\n                  setPosition({\n                    x: stagePos.x,\n                    y: stagePos.y\n                  });\n                }\n              }\n            }}\n            onDragEnd={(e) => {\n              // Finish panning - update final position\n              if (tool === 'pan') {\n                const stagePos = stageRef.current?.position();\n                if (stagePos) {\n                  setPosition({\n                    x: stagePos.x,\n                    y: stagePos.y\n                  });\n                  \n                  // Log the new position for debugging\n                  logEvent('pan', `Ended at x:${Math.round(stagePos.x)}, y:${Math.round(stagePos.y)}`);\n                }\n                console.log('Stage drag ended - panning finished');\n                \n                // Restore cursor style after panning\n                if (containerRef.current) {\n                  containerRef.current.style.cursor = 'grab';\n                }\n              }\n            }}\n            // Direct handlers for drawing and selection\n            onMouseDown={(e) => {\n              if (tool === 'select') {\n                handleSelectionStart(e);\n                logEvent('selection', 'Selection started');\n              } else {\n                handleStageMouseDown(e);\n              }\n            }}\n            onMouseMove={(e) => {\n              if (tool === 'select' && selectionRect) {\n                handleSelectionMove(e);\n                logEvent('selection', 'Selection moved');\n              } else {\n                handleStageMouseMove(e);\n              }\n            }}\n            onMouseUp={(e) => {\n              if (tool === 'select' && selectionRect) {\n                handleSelectionEnd(e);\n                logEvent('selection', 'Selection ended');\n              } else {\n                handleStageMouseUp(e);\n              }\n            }}\n            onMouseLeave={(e) => {\n              if (tool === 'select' && selectionRect) {\n                handleSelectionEnd(e);\n              } else {\n                handleStageMouseUp(e);\n              }\n            }}\n            onTouchStart={(e) => {\n              if (tool === 'select') {\n                handleSelectionStart(e);\n              } else {\n                handleStageMouseDown(e);\n              }\n            }}\n            onTouchMove={(e) => {\n              if (tool === 'select' && selectionRect) {\n                handleSelectionMove(e);\n              } else {\n                handleStageMouseMove(e);\n              }\n            }}\n            onTouchEnd={(e) => {\n              if (tool === 'select' && selectionRect) {\n                handleSelectionEnd(e);\n              } else {\n                handleStageMouseUp(e);\n              }\n            }}\n            onClick={(e) => {\n              if (tool === 'text') {\n                handleCanvasClick(e);\n              }\n            }}\n            onDblClick={(e) => {\n              // Handle double-click to reset view\n              if (tool === 'pan') {\n                setPosition({ x: 0, y: 0 });\n                setScale(1);\n              }\n            }}\n          >\n            {/* Background layer with grid */}\n            <Layer>\n              <Rect\n                width={10000}\n                height={10000}\n                x={-5000}\n                y={-5000}\n                fill=\"#FAFAFA\"\n              />\n              {/* Grid would be implemented here */}\n            </Layer>\n            \n            {/* Direct Drawing Layer - Simple implementation */}\n            <Layer>\n              {directDrawingEnabled && (\n                <>\n                  {/* Static lines - direct drawing implementation */}\n                  {lines.map((line, i) => (\n                    <Line\n                      key={i}\n                      points={line.points}\n                      stroke={line.color}\n                      strokeWidth={line.width}\n                      tension={0.5}\n                      lineCap=\"round\"\n                      lineJoin=\"round\"\n                      globalCompositeOperation={\n                        line.color === '#ffffff' ? 'destination-out' : 'source-over'\n                      }\n                      perfectDrawEnabled={false}\n                      listening={false}\n                    />\n                  ))}\n                  \n                  {/* Current line being drawn */}\n                  {currentLine && (\n                    <Line\n                      points={currentLine.points}\n                      stroke={tool === 'eraser' ? '#ffffff' : penColor}\n                      strokeWidth={tool === 'eraser' ? eraserSize : penSize}\n                      tension={0.5}\n                      lineCap=\"round\"\n                      lineJoin=\"round\"\n                      globalCompositeOperation={\n                        tool === 'eraser' ? 'destination-out' : 'source-over'\n                      }\n                      perfectDrawEnabled={false}\n                      listening={false}\n                    />\n                  )}\n                </>\n              )}\n              \n              {/* Original DrawingLayer from previous implementation */}\n              {!directDrawingEnabled && (\n                <DrawingLayer\n                  notebookId={notebookId}\n                  tool={tool}\n                  penSize={penSize}\n                  eraserSize={eraserSize}\n                  penColor={penColor}\n                  isPenMode={isPenMode}\n                  scale={scale}\n                />\n              )}\n            </Layer>\n            \n            {/* Connections layer */}\n            <Layer>\n              <ConnectionLayer\n                relationships={relationships}\n                nodePositions={nodePositions}\n                nodes={nodes}\n              />\n            </Layer>\n            \n            {/* Selection rectangle with enhanced visibility */}\n            <Layer>\n              {selectionRect && selectionRectProps && (\n                <>\n                  {/* Main selection rectangle */}\n                  <Rect {...selectionRectProps} />\n                  \n                  {/* Label to show selection is active */}\n                  <Rect \n                    x={selectionRectProps.x}\n                    y={selectionRectProps.y - 30 / scale}\n                    width={120 / scale}\n                    height={25 / scale}\n                    fill=\"rgba(255, 0, 0, 0.8)\"\n                    cornerRadius={3 / scale}\n                    listening={false}\n                  />\n                </>\n              )}\n            </Layer>\n          </Stage>\n          \n          {/* DOM Overlay for cards - absolutely positioned div */}\n          <div \n            className=\"absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none\"  \n            style={{ \n              transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,\n              transformOrigin: '0 0', // Ensure scaling happens from top-left corner\n              zIndex: 5 // Make sure it's above the Konva stage but doesn't capture clicks\n            }}\n          >\n            <div className=\"origin-top-left w-full h-full\">\n              {/* Diagnostic area to test pointer events */}\n              <div \n                className=\"absolute top-4 left-4 bg-red-500 text-white p-2 rounded pointer-events-auto\"\n                onClick={() => {\n                  console.log('Test area clicked!');\n                  console.log('Current nodes:', Object.values(nodes).length);\n                  console.log('Sample nodes:', Object.values(nodes).slice(0, 3));\n                  logEvent('test', 'Red test area clicked successfully');\n                  alert(`Click test successful! Found ${Object.values(nodes).length} nodes. DOM elements can receive clicks.`);\n                }}\n              >\n                Click Test ({Object.values(nodes).length} nodes)\n              </div>\n              {/* Debug info - Node count */}\n              <div className=\"absolute top-4 right-4 bg-blue-500 text-white p-2 rounded\">\n                Nodes: {Object.values(nodes).length}\n              </div>\n              {/* Render the DOM cards */}\n              {/* Debug log nodes */}\n              {console.log(\"Rendering nodes:\", Object.values(nodes).map(n => ({id: n.id, type: n.type, content: n.content.substring(0, 30)})))}\n              \n              {Object.values(nodes).map(node => {\n                const nodePosition = nodePositions[node.id] || { \n                  x: 100, \n                  y: 100, \n                  isCollapsed: false, \n                  isDragging: false \n                };\n                \n                const nodeRelationships = relationships.filter(\n                  r => r.from_node_id === node.id || r.to_node_id === node.id\n                );\n                \n                // Check if this is a thread response\n                const incomingRelationships = nodeRelationships.filter(r => r.to_node_id === node.id);\n                const isThreadResponse = incomingRelationships.length > 0;\n                \n                // Get thread parent information if applicable\n                let threadParent;\n                if (isThreadResponse) {\n                  const parentId = incomingRelationships[0].from_node_id;\n                  if (nodePositions[parentId]) {\n                    threadParent = {\n                      id: parentId,\n                      position: {\n                        x: nodePositions[parentId].x,\n                        y: nodePositions[parentId].y\n                      }\n                    };\n                  }\n                }\n                \n                // For thread responses, check if parent thread is expanded\n                const hasParentThread = threadParent?.id ? true : false;\n                const isThreadExpanded = hasParentThread ? \n                  expandedThreads[threadParent.id] !== false : true; // Default to expanded\n                \n                // Skip rendering thread responses if parent thread is collapsed\n                if (isThreadResponse && !isThreadExpanded) {\n                  return null;\n                }\n                \n                // Get all responses if this is a main node (not a thread response)\n                const threadResponses = [];\n                if (!isThreadResponse) {\n                  // Find all nodes that have a relationship where this node is the parent\n                  const childNodeIds = relationships\n                    .filter(r => r.from_node_id === node.id)\n                    .map(r => r.to_node_id);\n                    \n                  // Get the actual node objects for these IDs\n                  childNodeIds.forEach(id => {\n                    if (nodes[id]) {\n                      threadResponses.push(nodes[id]);\n                    }\n                  });\n                }\n                \n                // Use threaded card for main nodes with responses\n                if (!isThreadResponse && (threadResponses.length > 0 || node.type === 'question')) {\n                  return (\n                    <div className=\"pointer-events-auto\">\n                      <ThreadedCardChat\n                        key={node.id}\n                        node={node}\n                        responses={threadResponses}\n                        relationships={nodeRelationships}\n                        position={nodePosition}\n                        isSelected={selectedNodeId === node.id}\n                        notebookId={notebookId}\n                        systemPrompt={notebook?.system_prompt}\n                        onSelect={(id) => {\n                          setSelectedNode(id);\n                          setActiveNode(id);\n                        }}\n                        onDragStart={handleNodeDragStart}\n                        onDragMove={handleNodeDragMove}\n                        onDragEnd={handleNodeDragEnd}\n                        onToggleCollapse={(id) => toggleNodeCollapse(id)}\n                        onAddResponse={handleAddThreadResponse}\n                      />\n                    </div>\n                  );\n                }\n                \n                // Use legacy card for thread responses and nodes without responses\n                return (\n                  <div className=\"pointer-events-auto\">\n                    <UnifiedCardThreadDOM\n                      key={node.id}\n                      node={node}\n                      relationships={nodeRelationships}\n                      position={nodePosition}\n                      isSelected={selectedNodeId === node.id}\n                      onSelect={(id) => {\n                        setSelectedNode(id);\n                        setActiveNode(id);\n                      }}\n                      onDragStart={handleNodeDragStart}\n                      onDragMove={handleNodeDragMove}\n                      onDragEnd={handleNodeDragEnd}\n                      onToggleCollapse={(id) => toggleNodeCollapse(id)}\n                      onAddResponse={handleAddResponse}\n                      enableTextSelection={tool === 'text' || tool === 'select'}\n                      scale={scale}\n                      systemPrompt={notebook?.system_prompt}\n                      threadParent={threadParent}\n                      isThreadExpanded={isThreadExpanded}\n                      onThreadExpand={handleThreadExpand}\n                      onAddThreadResponse={handleAddThreadResponse}\n                    />\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n        \n        {/* Chat panel - Modern LlamaIndex UI */}\n        {isChatPanelOpen && (\n          <div className=\"w-96 border-l border-gray-200 flex flex-col bg-white h-full\">\n            <LlamaChat\n              notebookId={notebookId}\n              systemPrompt={notebook?.system_prompt || undefined}\n              onClose={() => setIsChatPanelOpen(false)}\n              initialQuestion={notebook?.title || 'New Conversation'}\n            />\n          </div>\n        )}\n      </div>\n      \n      {/* System prompt modal */}\n      {isSystemPromptModalOpen && (\n        <SystemPromptModal\n          isOpen={isSystemPromptModalOpen}\n          onClose={() => setIsSystemPromptModalOpen(false)}\n          initialPrompt={notebook?.system_prompt || ''}\n          onSave={handleSystemPromptSave}\n        />\n      )}\n    </div>\n  );\n};\n\n// Export without memo to ensure all updates are propagated properly\nexport default UnifiedCanvasContainer;\n\n================================================================================\nFILE: src/components/canvas/UnifiedCardThread.tsx\n================================================================================\n\n// src/components/canvas/UnifiedCardThread.tsx\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Stage, Layer, Group, Rect, Text, Line, Tag, Label } from 'react-konva';\nimport { Node, Relationship } from '@/types/thread';\nimport { KonvaEventObject } from 'konva/lib/Node';\n\ninterface UnifiedCardThreadProps {\n  node: Node;\n  relationships: Relationship[];\n  position: { x: number; y: number; isCollapsed: boolean; isDragging: boolean };\n  isSelected: boolean;\n  onSelect: (id: string) => void;\n  onDragStart: (id: string) => void;\n  onDragMove: (id: string, x: number, y: number) => void;\n  onDragEnd: (id: string) => void;\n  onToggleCollapse: (id: string) => void;\n  onAddResponse?: (nodeId: string, position: { x: number, y: number }) => void;\n  onCreateRelationship?: (fromId: string, toId: string, type: string) => void;\n  enableTextSelection?: boolean;\n  scale?: number;\n  systemPrompt?: string; // System prompt property\n  threadParent?: {\n    id: string;\n    position: { x: number; y: number };\n  }; // Thread parent information\n  isThreadExpanded?: boolean;\n  onThreadExpand?: (id: string) => void;\n  onAddThreadResponse?: (parentId: string, content: string) => void;\n}\n\nconst UnifiedCardThread: React.FC<UnifiedCardThreadProps> = ({\n  node,\n  relationships,\n  position,\n  isSelected,\n  onSelect,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  onToggleCollapse,\n  onAddResponse,\n  onCreateRelationship,\n  enableTextSelection = false,\n  scale = 1,\n  systemPrompt = \"You are a helpful AI assistant\",  // Default system prompt\n  threadParent = undefined,\n  isThreadExpanded = true,\n  onThreadExpand = () => {},\n  onAddThreadResponse = () => {}\n}) => {\n  const groupRef = useRef<any>(null);\n  const [dimensions, setDimensions] = useState({ width: 300, height: 150 });\n  const [isHovered, setIsHovered] = useState(false);\n  const [showRelationMenu, setShowRelationMenu] = useState(false);\n  const [isEditing, setIsEditing] = useState(false);\n  const [editText, setEditText] = useState(node.content);\n  const [showSettings, setShowSettings] = useState(false);\n  const [isAddingThreadResponse, setIsAddingThreadResponse] = useState(false);\n  const [threadResponseText, setThreadResponseText] = useState('');\n  \n  // Calculate dimensions based on content\n  useEffect(() => {\n    if (!node?.content) return;\n    \n    const lines = node.content.split('\\n');\n    const maxLineLength = Math.max(...lines.map(line => line.length));\n    \n    // Rough calculation based on average character width and font size\n    const charWidth = 7;\n    const lineHeight = 18;\n    const paddingX = 30;\n    const paddingY = 30;\n    const headerHeight = 40;\n    \n    // Calculate width based on content (min 250, max 450)\n    const contentWidth = Math.min(Math.max(maxLineLength * charWidth + paddingX, 250), 450);\n    \n    // Calculate height based on number of lines\n    const contentHeight = Math.max(lines.length * lineHeight + paddingY + headerHeight, 120);\n    \n    setDimensions({ width: contentWidth, height: contentHeight });\n  }, [node?.content]);\n  \n  // Handle drag events\n  const handleDragStart = useCallback((e: KonvaEventObject<DragEvent>) => {\n    onDragStart(node.id);\n    // Prevent event bubbling\n    e.cancelBubble = true;\n  }, [node.id, onDragStart]);\n  \n  const handleDragMove = useCallback((e: KonvaEventObject<DragEvent>) => {\n    const target = e.target;\n    onDragMove(node.id, target.x(), target.y());\n    // Prevent event bubbling\n    e.cancelBubble = true;\n  }, [node.id, onDragMove]);\n  \n  const handleDragEnd = useCallback((e: KonvaEventObject<DragEvent>) => {\n    onDragEnd(node.id);\n    // Prevent event bubbling\n    e.cancelBubble = true;\n  }, [node.id, onDragEnd]);\n  \n  // Determine card appearance based on node type and thread status\n  const getCardStyle = useCallback(() => {\n    const baseStyle = {\n      strokeWidth: isSelected ? 2 : 1,\n      shadowEnabled: true,\n      shadowColor: 'rgba(0,0,0,0.3)',\n      shadowBlur: isSelected || isHovered ? 10 : 5,\n      shadowOffset: { x: 2, y: 2 },\n      shadowOpacity: 0.5,\n    };\n    \n    // For thread responses, we want a more compact look with a different style\n    if (isThreadResponse) {\n      return {\n        fill: '#F7FAFC',\n        stroke: '#CBD5E0',\n        strokeWidth: isSelected ? 2 : 1,\n        shadowEnabled: true,\n        shadowColor: 'rgba(0,0,0,0.2)',\n        shadowBlur: isSelected || isHovered ? 8 : 3,\n        shadowOffset: { x: 1, y: 1 },\n        shadowOpacity: 0.4,\n      };\n    }\n    \n    // For main thread parent, possibly highlight differently\n    if (isMainThreadNode) {\n      // Slightly enhanced base style for thread parents\n      const enhancedStyle = {\n        ...baseStyle,\n        shadowBlur: isSelected || isHovered ? 12 : 7,\n        shadowColor: 'rgba(0,0,0,0.35)',\n      };\n      \n      switch (node.type) {\n        case 'question':\n          return { \n            fill: '#EBF8FF', \n            stroke: isSelected ? '#3182CE' : '#4299E1',\n            ...enhancedStyle\n          };\n        case 'response':\n          return { \n            fill: '#E6FFFA', \n            stroke: isSelected ? '#2C7A7B' : '#38B2AC',\n            ...enhancedStyle\n          };\n        case 'note':\n          return { \n            fill: '#FFFBEB', \n            stroke: isSelected ? '#B7791F' : '#D69E2E',\n            ...enhancedStyle\n          };\n        case 'drawing':\n          return { \n            fill: '#F0FFF4', \n            stroke: isSelected ? '#2F855A' : '#48BB78',\n            ...enhancedStyle\n          };\n        default:\n          return { \n            fill: '#F7FAFC', \n            stroke: isSelected ? '#4A5568' : '#A0AEC0',\n            ...enhancedStyle\n          };\n      }\n    }\n    \n    // Regular card styling (no thread)\n    switch (node.type) {\n      case 'question':\n        return { \n          fill: '#EBF8FF', \n          stroke: isSelected ? '#3182CE' : '#4299E1',\n          ...baseStyle\n        };\n      case 'response':\n        return { \n          fill: '#E6FFFA', \n          stroke: isSelected ? '#2C7A7B' : '#38B2AC',\n          ...baseStyle\n        };\n      case 'note':\n        return { \n          fill: '#FFFBEB', \n          stroke: isSelected ? '#B7791F' : '#D69E2E',\n          ...baseStyle\n        };\n      case 'drawing':\n        return { \n          fill: '#F0FFF4', \n          stroke: isSelected ? '#2F855A' : '#48BB78',\n          ...baseStyle\n        };\n      default:\n        return { \n          fill: '#F7FAFC', \n          stroke: isSelected ? '#4A5568' : '#A0AEC0',\n          ...baseStyle\n        };\n    }\n  }, [node.type, isSelected, isHovered, isMainThreadNode, isThreadResponse]);\n\n  // Calculate badge position\n  const getBadgePosition = (index: number) => {\n    return {\n      x: dimensions.width - 30 - (index * 26),\n      y: 10\n    };\n  };\n  \n  // Handle double-click for editing\n  const handleDoubleClick = useCallback((e: KonvaEventObject<MouseEvent>) => {\n    if (!enableTextSelection) return;\n    \n    e.cancelBubble = true;\n    setIsEditing(true);\n  }, [enableTextSelection]);\n\n  // Handle add response button click\n  const handleAddResponse = useCallback((e: KonvaEventObject<MouseEvent>) => {\n    e.cancelBubble = true;\n    \n    if (onAddResponse) {\n      // Calculate position for new response (to the right of this card)\n      const newPosition = {\n        x: position.x + dimensions.width + 40,\n        y: position.y\n      };\n      \n      onAddResponse(node.id, newPosition);\n    }\n  }, [node.id, position, dimensions, onAddResponse]);\n  \n  // Handle toggle collapse\n  const handleToggleCollapse = useCallback((e: KonvaEventObject<MouseEvent>) => {\n    e.cancelBubble = true;\n    onToggleCollapse(node.id);\n  }, [node.id, onToggleCollapse]);\n  \n  // Handle relationship button click\n  const handleRelationshipButton = useCallback((e: KonvaEventObject<MouseEvent>) => {\n    e.cancelBubble = true;\n    setShowRelationMenu(!showRelationMenu);\n  }, [showRelationMenu]);\n  \n  // Get incoming and outgoing relationships\n  const incomingRelationships = relationships.filter(r => r.to_node_id === node.id);\n  const outgoingRelationships = relationships.filter(r => r.from_node_id === node.id);\n  \n  // Determine if this is a main thread node (has responses) or a response in a thread\n  const isMainThreadNode = outgoingRelationships.length > 0;\n  const isThreadResponse = incomingRelationships.length > 0;\n  const hasThread = isMainThreadNode || isThreadResponse;\n  \n  // If this is a thread response, identify the parent node ID\n  const threadParentId = isThreadResponse ? incomingRelationships[0]?.from_node_id : null;\n  \n  // Handle thread response submission\n  const handleAddThreadResponse = useCallback(() => {\n    if (threadResponseText.trim() && onAddThreadResponse) {\n      onAddThreadResponse(node.id, threadResponseText.trim());\n      setThreadResponseText('');\n      setIsAddingThreadResponse(false);\n    }\n  }, [node.id, threadResponseText, onAddThreadResponse]);\n  \n  // Calculate dimensions for thread responses (more compact)\n  useEffect(() => {\n    if (!node?.content) return;\n    \n    // For thread responses, use a more compact size\n    if (isThreadResponse) {\n      const lines = node.content.split('\\n');\n      const maxLineLength = Math.max(...lines.map(line => line.length));\n      \n      // Smaller sizes for thread responses\n      const charWidth = 6.5;\n      const lineHeight = 16;\n      const paddingX = 20;\n      const paddingY = 20;\n      const headerHeight = 30;\n      \n      // Calculate width based on content (min 220, max 380 for thread responses)\n      const contentWidth = Math.min(Math.max(maxLineLength * charWidth + paddingX, 220), 380);\n      \n      // Calculate height based on number of lines (smaller minimum height)\n      const contentHeight = Math.max(lines.length * lineHeight + paddingY + headerHeight, 100);\n      \n      setDimensions({ width: contentWidth, height: contentHeight });\n      return;\n    }\n    \n    // Standard sizing for normal cards\n    const lines = node.content.split('\\n');\n    const maxLineLength = Math.max(...lines.map(line => line.length));\n    \n    // Rough calculation based on average character width and font size\n    const charWidth = 7;\n    const lineHeight = 18;\n    const paddingX = 30;\n    const paddingY = 30;\n    const headerHeight = 40;\n    \n    // Calculate width based on content (min 250, max 450)\n    const contentWidth = Math.min(Math.max(maxLineLength * charWidth + paddingX, 250), 450);\n    \n    // Calculate height based on number of lines\n    const contentHeight = Math.max(lines.length * lineHeight + paddingY + headerHeight, 120);\n    \n    setDimensions({ width: contentWidth, height: contentHeight });\n  }, [node?.content, isThreadResponse]);\n  \n  // Truncate long content\n  const getTruncatedContent = () => {\n    if (!node.content) return '';\n    if (position.isCollapsed) {\n      return node.content.length > 30 \n        ? node.content.substring(0, 30) + '...' \n        : node.content;\n    }\n    return node.content;\n  };\n\n  // Adjust font size for different scale values\n  const getFontSize = (baseSize: number) => Math.max(baseSize / Math.max(scale, 0.5), baseSize / 2);\n  \n  return (\n    <Group\n      ref={groupRef}\n      x={position.x}\n      y={position.y}\n      draggable\n      onDragStart={handleDragStart}\n      onDragMove={handleDragMove}\n      onDragEnd={handleDragEnd}\n      onClick={(e) => {\n        e.cancelBubble = true;\n        onSelect(node.id);\n      }}\n      onTap={() => onSelect(node.id)}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n      opacity={position.isDragging ? 0.7 : 1}\n      onDblClick={handleDoubleClick}\n    >\n      {/* Thread connector line and background - only for thread responses */}\n      {isThreadResponse && threadParent && isThreadExpanded && (\n        <>\n          {/* Thread connection background */}\n          <Rect\n            x={-30}\n            y={0}\n            width={30}\n            height={position.y - threadParent.position.y}\n            fill=\"#F7FAFC\"\n            opacity={0.5}\n            cornerRadius={4}\n          />\n          \n          {/* Thread connection line */}\n          <Line\n            points={[\n              0, isThreadResponse ? 15 : 20, // Start at the left center of this card\n              -15, isThreadResponse ? 15 : 20, // Horizontal line left\n              -15, threadParent.position.y - position.y + 20, // Vertical line up/down to parent\n              threadParent.position.x - position.x, threadParent.position.y - position.y + 20, // Horizontal line to parent\n            ]}\n            stroke=\"#90CDF4\"  // Light blue color for thread connections\n            strokeWidth={1.5}\n            dash={[3, 3]}\n            opacity={0.8}\n            shadowColor=\"rgba(66, 153, 225, 0.3)\"\n            shadowBlur={3}\n            shadowOffset={{ x: 0, y: 0 }}\n            shadowOpacity={0.5}\n          />\n          \n          {/* Connection dot at parent */}\n          <Rect\n            x={threadParent.position.x - position.x - 3}\n            y={threadParent.position.y - position.y + 20 - 3}\n            width={6}\n            height={6}\n            cornerRadius={3}\n            fill=\"#3182CE\"\n          />\n          \n          {/* Connection dot at this node */}\n          <Rect\n            x={-3}\n            y={isThreadResponse ? 15 - 3 : 20 - 3}\n            width={6}\n            height={6}\n            cornerRadius={3}\n            fill=\"#3182CE\"\n          />\n        </>\n      )}\n      {/* Card background */}\n      <Rect\n        width={dimensions.width}\n        height={position.isCollapsed ? 40 : dimensions.height}\n        cornerRadius={8}\n        {...getCardStyle()}\n      />\n      \n      {/* Card header - compact for thread responses */}\n      <Rect\n        width={dimensions.width}\n        height={isThreadResponse ? 30 : 40}\n        cornerRadius={[8, 8, position.isCollapsed ? 8 : 0, position.isCollapsed ? 8 : 0]}\n        fill={\n          isSelected ? '#4A5568' : \n          isThreadResponse ? '#E2E8F0' : \n          isMainThreadNode ? '#718096' : \n          '#718096'\n        }\n      />\n      \n      {/* Card type label or thread label */}\n      <Text\n        x={10}\n        y={isThreadResponse ? 8 : 12}\n        text={\n          isThreadResponse ? \n            `Thread Reply (${node.type.charAt(0).toUpperCase() + node.type.slice(1)})` : \n            isMainThreadNode ? \n            `${node.type.charAt(0).toUpperCase() + node.type.slice(1)} (Thread)` :\n            node.type.charAt(0).toUpperCase() + node.type.slice(1)\n        }\n        fontSize={getFontSize(isThreadResponse ? 12 : 14)}\n        fontStyle=\"bold\"\n        fill={isThreadResponse ? '#4A5568' : 'white'}\n      />\n      \n      {/* Badges showing how many connected nodes */}\n      {(incomingRelationships.length > 0 || outgoingRelationships.length > 0) && (\n        <>\n          {incomingRelationships.length > 0 && (\n            <Label {...getBadgePosition(1)}>\n              <Tag\n                fill=\"#E2E8F0\"\n                cornerRadius={10}\n                pointerDirection=\"none\"\n              />\n              <Text\n                text={incomingRelationships.length.toString()}\n                fontSize={getFontSize(12)}\n                padding={5}\n                fill=\"#4A5568\"\n              />\n            </Label>\n          )}\n          \n          {outgoingRelationships.length > 0 && (\n            <Label {...getBadgePosition(incomingRelationships.length > 0 ? 2 : 1)}>\n              <Tag\n                fill=\"#E2E8F0\"\n                cornerRadius={10}\n                pointerDirection=\"none\"\n              />\n              <Text\n                text={outgoingRelationships.length.toString()}\n                fontSize={getFontSize(12)}\n                padding={5}\n                fill=\"#4A5568\"\n              />\n            </Label>\n          )}\n        </>\n      )}\n      \n      {/* Collapse/Expand button */}\n      <Group\n        x={dimensions.width - 30}\n        y={10}\n        width={20}\n        height={20}\n        onClick={handleToggleCollapse}\n      >\n        <Rect\n          width={20}\n          height={20}\n          cornerRadius={3}\n          fill=\"#4A5568\"\n          opacity={0.7}\n        />\n        <Text\n          width={20}\n          height={20}\n          text={position.isCollapsed ? '+' : '-'}\n          fontSize={getFontSize(16)}\n          fill=\"white\"\n          align=\"center\"\n          verticalAlign=\"middle\"\n        />\n      </Group>\n      \n      {/* Card content - adjusted for thread responses */}\n      <Text\n        x={10}\n        y={position.isCollapsed ? 12 : (isThreadResponse ? 35 : 50)}\n        width={dimensions.width - 20}\n        text={getTruncatedContent()}\n        fontSize={getFontSize(isThreadResponse ? 13 : 14)}\n        fill=\"#2D3748\"\n        wrap={position.isCollapsed ? 'none' : 'word'}\n        ellipsis={position.isCollapsed}\n      />\n      \n      {/* Thread response input (only shown when adding a thread response) - Figma/Miro style */}\n      {isAddingThreadResponse && !position.isCollapsed && (\n        <Group y={dimensions.height + 10}>\n          {/* Connection line from card to thread input */}\n          <Line\n            points={[\n              dimensions.width / 2, 0, // Start at bottom center of the card\n              dimensions.width / 2, 10 // Vertical line down\n            ]}\n            stroke=\"#90CDF4\"\n            strokeWidth={1.5}\n            dash={[3, 3]}\n          />\n          \n          {/* Thread input background */}\n          <Rect\n            width={dimensions.width}\n            height={80}\n            cornerRadius={8}\n            fill=\"white\"\n            stroke=\"#90CDF4\"\n            strokeWidth={1.5}\n            shadowColor=\"rgba(0,0,0,0.15)\"\n            shadowBlur={8}\n            shadowOffset={{ x: 0, y: 2 }}\n            shadowOpacity={0.5}\n          />\n          \n          {/* Thread input header */}\n          <Rect\n            width={dimensions.width}\n            height={25}\n            cornerRadius={[8, 8, 0, 0]}\n            fill=\"#EBF8FF\"\n          />\n          \n          <Text\n            x={10}\n            y={5}\n            text=\"Reply to thread\"\n            fontSize={getFontSize(12)}\n            fontStyle=\"bold\"\n            fill=\"#2B6CB0\"\n          />\n          \n          {/* Text input area */}\n          <Rect\n            y={30}\n            x={10}\n            width={dimensions.width - 20}\n            height={40}\n            cornerRadius={4}\n            fill=\"#F7FAFC\"\n            stroke=\"#E2E8F0\"\n            strokeWidth={1}\n          />\n          \n          <Text\n            x={15}\n            y={37}\n            width={dimensions.width - 30}\n            text={threadResponseText || \"Type your response...\"}\n            fontSize={getFontSize(13)}\n            fill={threadResponseText ? \"#2D3748\" : \"#A0AEC0\"}\n          />\n          \n          {/* Action buttons */}\n          <Group\n            x={dimensions.width - 120}\n            y={75}\n          >\n            <Group\n              x={0}\n              onClick={(e) => {\n                e.cancelBubble = true;\n                setIsAddingThreadResponse(false);\n                setThreadResponseText('');\n              }}\n            >\n              <Rect\n                width={50}\n                height={24}\n                cornerRadius={12}\n                fill=\"#EDF2F7\"\n                stroke=\"#CBD5E0\"\n                strokeWidth={1}\n              />\n              <Text\n                width={50}\n                height={24}\n                text=\"Cancel\"\n                fontSize={getFontSize(11)}\n                fill=\"#4A5568\"\n                align=\"center\"\n                verticalAlign=\"middle\"\n              />\n            </Group>\n            \n            <Group\n              x={60}\n              onClick={(e) => {\n                e.cancelBubble = true;\n                handleAddThreadResponse();\n              }}\n            >\n              <Rect\n                width={50}\n                height={24}\n                cornerRadius={12}\n                fill={threadResponseText.trim() ? \"#4299E1\" : \"#90CDF4\"}\n                opacity={threadResponseText.trim() ? 1 : 0.7}\n              />\n              <Text\n                width={50}\n                height={24}\n                text=\"Send\"\n                fontSize={getFontSize(11)}\n                fill=\"white\"\n                align=\"center\"\n                verticalAlign=\"middle\"\n              />\n            </Group>\n          </Group>\n        </Group>\n      )}\n      \n      {/* Controls at the bottom (only shown when expanded) - different for thread responses */}\n      {!position.isCollapsed && (\n        <Group y={dimensions.height - (isThreadResponse ? 30 : 40)}>\n          {/* Thread response controls */}\n          {isMainThreadNode && (\n            <Group\n              x={10}\n              y={10}\n              onClick={(e) => {\n                e.cancelBubble = true;\n                onThreadExpand(node.id);\n              }}\n            >\n              <Rect\n                width={120}\n                height={24}\n                cornerRadius={12}\n                fill=\"#E2E8F0\"\n                opacity={0.9}\n                stroke=\"#CBD5E0\"\n                strokeWidth={1}\n              />\n              <Text\n                width={120}\n                height={24}\n                text={isThreadExpanded ? \"Collapse Thread\" : \"Expand Thread\"}\n                fontSize={getFontSize(12)}\n                fill=\"#4A5568\"\n                align=\"center\"\n                verticalAlign=\"middle\"\n              />\n            </Group>\n          )}\n          \n          {/* Add thread response button - only on main thread node */}\n          {isMainThreadNode && !isAddingThreadResponse && (\n            <Group\n              x={140}\n              y={10}\n              onClick={(e) => {\n                e.cancelBubble = true;\n                setIsAddingThreadResponse(true);\n              }}\n            >\n              <Rect\n                width={120}\n                height={24}\n                cornerRadius={12}\n                fill=\"#BEE3F8\"\n                opacity={0.9}\n                stroke=\"#90CDF4\"\n                strokeWidth={1}\n              />\n              <Text\n                width={120}\n                height={24}\n                text=\"Reply to Thread\"\n                fontSize={getFontSize(12)}\n                fill=\"#2B6CB0\"\n                align=\"center\"\n                verticalAlign=\"middle\"\n              />\n            </Group>\n          )}\n          \n          {/* Regular controls - don't show on thread responses */}\n          {!isThreadResponse && (\n            <>\n              {/* Add response button */}\n              {onAddResponse && (\n                <Group\n                  x={dimensions.width - 40}\n                  y={10}\n                  width={30}\n                  height={30}\n                  onClick={handleAddResponse}\n                >\n                  <Rect\n                    width={30}\n                    height={30}\n                    cornerRadius={15}\n                    fill=\"#4299E1\"\n                    opacity={0.9}\n                    stroke=\"#2B6CB0\"\n                    strokeWidth={1}\n                  />\n                  <Text\n                    width={30}\n                    height={30}\n                    text=\"+\"\n                    fontSize={getFontSize(20)}\n                    fill=\"white\"\n                    align=\"center\"\n                    verticalAlign=\"middle\"\n                  />\n                </Group>\n              )}\n              \n              {/* Create relationship button */}\n              {onCreateRelationship && (\n                <Group\n                  x={dimensions.width - 80}\n                  y={10}\n                  width={30}\n                  height={30}\n                  onClick={handleRelationshipButton}\n                >\n                  <Rect\n                    width={30}\n                    height={30}\n                    cornerRadius={15}\n                    fill=\"#9F7AEA\"\n                    opacity={0.9}\n                    stroke=\"#6B46C1\"\n                    strokeWidth={1}\n                  />\n                  <Text\n                    width={30}\n                    height={30}\n                    text=\"↔\"\n                    fontSize={getFontSize(16)}\n                    fill=\"white\"\n                    align=\"center\"\n                    verticalAlign=\"middle\"\n                  />\n                </Group>\n              )}\n              \n              {/* Settings button (three dots menu) */}\n              <Group\n                x={dimensions.width - 120}\n                y={10}\n                width={30}\n                height={30}\n                onClick={(e) => {\n                  e.cancelBubble = true;\n                  setShowSettings(!showSettings);\n                }}\n              >\n                <Rect\n                  width={30}\n                  height={30}\n                  cornerRadius={15}\n                  fill=\"#4A5568\"\n                  opacity={0.9}\n                  stroke=\"#2D3748\"\n                  strokeWidth={1}\n                />\n                <Text\n                  width={30}\n                  height={30}\n                  text=\"⋮\"\n                  fontSize={getFontSize(18)}\n                  align=\"center\"\n                  verticalAlign=\"middle\"\n                  fill=\"white\"\n                />\n              </Group>\n            </>\n          )}\n          \n          {/* Relationship menu (only shown when relationship button clicked) */}\n          {showRelationMenu && onCreateRelationship && (\n            <Group\n              x={dimensions.width - 200}\n              y={-100}\n            >\n              <Rect\n                width={180}\n                height={90}\n                fill=\"white\"\n                cornerRadius={8}\n                stroke=\"#A0AEC0\"\n                strokeWidth={1}\n                shadowColor=\"rgba(0,0,0,0.2)\"\n                shadowBlur={10}\n                shadowOffset={{ x: 0, y: 2 }}\n                shadowOpacity={0.5}\n              />\n              <Text\n                x={10}\n                y={10}\n                text=\"Create Relationship:\"\n                fontSize={getFontSize(14)}\n                fontStyle=\"bold\"\n                fill=\"#4A5568\"\n              />\n              \n              {/* Relationship type buttons */}\n              {['extends', 'supports', 'contradicts', 'questions'].map((type, index) => (\n                <Group\n                  key={type}\n                  x={10 + (index % 2) * 90}\n                  y={30 + Math.floor(index / 2) * 30}\n                  onClick={(e) => {\n                    e.cancelBubble = true;\n                    // This would open a modal to select the target node\n                    // For now, we'll just log\n                    console.log(`Create ${type} relationship from ${node.id}`);\n                    setShowRelationMenu(false);\n                  }}\n                >\n                  <Rect\n                    width={80}\n                    height={25}\n                    fill={\n                      type === 'extends' ? '#BEE3F8' : \n                      type === 'supports' ? '#B2F5EA' :\n                      type === 'contradicts' ? '#FED7D7' :\n                      '#E9D8FD'\n                    }\n                    cornerRadius={4}\n                  />\n                  <Text\n                    width={80}\n                    height={25}\n                    text={type.charAt(0).toUpperCase() + type.slice(1)}\n                    fontSize={getFontSize(12)}\n                    fill=\"#2D3748\"\n                    align=\"center\"\n                    verticalAlign=\"middle\"\n                  />\n                </Group>\n              ))}\n            </Group>\n          )}\n          \n          {/* Settings panel with system prompt */}\n          {showSettings && (\n            <Group\n              x={dimensions.width - 350}\n              y={-220}\n            >\n              <Rect\n                width={330}\n                height={200}\n                fill=\"white\"\n                cornerRadius={8}\n                stroke=\"#CBD5E0\"\n                strokeWidth={1.5}\n                shadowColor=\"rgba(0,0,0,0.2)\"\n                shadowBlur={12}\n                shadowOffset={{ x: 0, y: 3 }}\n                shadowOpacity={0.5}\n              />\n              \n              {/* Settings Header */}\n              <Rect\n                width={330}\n                height={40}\n                fill=\"#4A5568\"\n                cornerRadius={[8, 8, 0, 0]}\n              />\n              \n              <Text\n                x={15}\n                y={12}\n                text=\"Card Settings\"\n                fontSize={getFontSize(16)}\n                fontStyle=\"bold\"\n                fill=\"white\"\n              />\n              \n              <Group\n                x={295}\n                y={8}\n                width={24}\n                height={24}\n                onClick={(e) => {\n                  e.cancelBubble = true;\n                  setShowSettings(false);\n                }}\n              >\n                <Rect\n                  width={24}\n                  height={24}\n                  cornerRadius={12}\n                  fill=\"#2D3748\"\n                  opacity={0.6}\n                />\n                <Text\n                  width={24}\n                  height={24}\n                  text=\"×\"\n                  fontSize={getFontSize(18)}\n                  fill=\"white\"\n                  align=\"center\"\n                  verticalAlign=\"middle\"\n                />\n              </Group>\n              \n              {/* Card Info Section */}\n              <Rect\n                x={15}\n                y={50}\n                width={300}\n                height={35}\n                fill=\"#EDF2F7\"\n                cornerRadius={4}\n              />\n              \n              <Text\n                x={25}\n                y={55}\n                text={`Type: ${node.type.charAt(0).toUpperCase() + node.type.slice(1)}`}\n                fontSize={getFontSize(12)}\n                fill=\"#4A5568\"\n              />\n              \n              <Text\n                x={160}\n                y={55}\n                text={`ID: ${node.id.substring(0, 8)}...`}\n                fontSize={getFontSize(12)}\n                fill=\"#718096\"\n              />\n              \n              {/* System Prompt Section */}\n              <Text\n                x={15}\n                y={95}\n                text=\"System Prompt\"\n                fontSize={getFontSize(14)}\n                fontStyle=\"bold\"\n                fill=\"#2D3748\"\n              />\n              \n              <Rect\n                x={15}\n                y={110}\n                width={300}\n                height={80}\n                fill=\"#F7FAFC\"\n                cornerRadius={4}\n                stroke=\"#E2E8F0\"\n                strokeWidth={1}\n              />\n              \n              <Text\n                x={20}\n                y={115}\n                width={290}\n                height={70}\n                text={systemPrompt || \"Default system prompt not set\"}\n                fontSize={getFontSize(12)}\n                fill=\"#4A5568\"\n                wrap=\"word\"\n              />\n            </Group>\n          )}\n        </Group>\n      )}\n    </Group>\n  );\n};\n\nexport default React.memo(UnifiedCardThread);\n\n================================================================================\nFILE: src/components/canvas/UnifiedCardThreadDOM.tsx\n================================================================================\n\n// src/components/canvas/UnifiedCardThreadDOM.tsx\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Card, CardHeader, CardContent, CardFooter } from '../shadcn/card';\nimport { Button } from '../shadcn/button';\nimport { Node, Relationship } from '@/types/thread';\nimport { Textarea } from '../shadcn/textarea';\n\ninterface UnifiedCardThreadDOMProps {\n  node: Node;\n  relationships: Relationship[];\n  position: { x: number; y: number; isCollapsed: boolean; isDragging: boolean };\n  isSelected: boolean;\n  onSelect: (id: string) => void;\n  onDragStart: (id: string) => void;\n  onDragMove: (id: string, x: number, y: number) => void;\n  onDragEnd: (id: string) => void;\n  onToggleCollapse: (id: string) => void;\n  onAddResponse?: (nodeId: string, position: { x: number, y: number }) => void;\n  onCreateRelationship?: (fromId: string, toId: string, type: string) => void;\n  enableTextSelection?: boolean;\n  scale?: number;\n  systemPrompt?: string; // System prompt property\n  threadParent?: {\n    id: string;\n    position: { x: number; y: number };\n  }; // Thread parent information\n  isThreadExpanded?: boolean;\n  onThreadExpand?: (id: string) => void;\n  onAddThreadResponse?: (parentId: string, content: string) => void;\n}\n\nconst UnifiedCardThreadDOM: React.FC<UnifiedCardThreadDOMProps> = ({\n  node,\n  relationships,\n  position,\n  isSelected,\n  onSelect,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  onToggleCollapse,\n  onAddResponse,\n  onCreateRelationship,\n  enableTextSelection = false,\n  scale = 1,\n  systemPrompt = \"You are a helpful AI assistant\",\n  threadParent = undefined,\n  isThreadExpanded = true,\n  onThreadExpand = () => {},\n  onAddThreadResponse = () => {}\n}) => {\n  const cardRef = useRef<HTMLDivElement>(null);\n  const [isHovered, setIsHovered] = useState(false);\n  const [showRelationMenu, setShowRelationMenu] = useState(false);\n  const [isEditing, setIsEditing] = useState(false);\n  const [editText, setEditText] = useState(node.content);\n  const [showSettings, setShowSettings] = useState(false);\n  const [isAddingThreadResponse, setIsAddingThreadResponse] = useState(false);\n  const [threadResponseText, setThreadResponseText] = useState('');\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n  \n  // Get incoming and outgoing relationships\n  const incomingRelationships = relationships.filter(r => r.to_node_id === node.id);\n  const outgoingRelationships = relationships.filter(r => r.from_node_id === node.id);\n  \n  // Determine if this is a main thread node (has responses) or a response in a thread\n  const isMainThreadNode = outgoingRelationships.length > 0;\n  const isThreadResponse = incomingRelationships.length > 0;\n  \n  // Mouse event handlers for dragging\n  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    if (cardRef.current && !isEditing) {\n      // Only start drag from card header or if not clicking on a button/interactive element\n      const targetElement = e.target as HTMLElement;\n      const isHeader = targetElement.closest('[data-card-header=\"true\"]') !== null;\n      const isButton = targetElement.closest('button') !== null;\n      const isTextarea = targetElement.closest('textarea') !== null;\n      \n      if (isHeader || (!isButton && !isTextarea)) {\n        e.preventDefault();\n        setIsDragging(true);\n        onDragStart(node.id);\n        \n        // Get the card's bounding rectangle in screen coordinates\n        const rect = cardRef.current.getBoundingClientRect();\n        \n        // Calculate the offset within the card where the mouse was clicked\n        // This is the difference between the mouse position and the card's top-left corner\n        const offsetX = e.clientX - rect.left;\n        const offsetY = e.clientY - rect.top;\n        \n        // Set the drag offset\n        setDragOffset({\n          x: offsetX,\n          y: offsetY\n        });\n        \n        // Debug log\n        console.log('Drag start:', {\n          mousePosition: { x: e.clientX, y: e.clientY },\n          cardRect: { left: rect.left, top: rect.top, width: rect.width, height: rect.height },\n          offset: { x: offsetX, y: offsetY }\n        });\n        \n        // Prevent text selection while dragging\n        document.body.style.userSelect = 'none';\n        \n        // Capture the element so we get all mouse events\n        (e.target as HTMLElement).setPointerCapture(e.pointerId);\n      }\n    }\n  }, [node.id, onDragStart, isEditing]);\n  \n  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    if (isDragging) {\n      e.preventDefault();\n      \n      // Get container element (usually the parent of the stage)\n      const containerElement = document.querySelector('.absolute.top-0.left-0.w-full.h-full.overflow-hidden');\n      if (!containerElement) return;\n      \n      // Get the container's transformation matrix\n      const containerTransform = window.getComputedStyle(containerElement).transform;\n      const matrix = new DOMMatrix(containerTransform);\n      \n      // Calculate new screen position\n      const newX = e.clientX - dragOffset.x;\n      const newY = e.clientY - dragOffset.y;\n      \n      // Invert the transformation to get canvas coordinates\n      // This accounts for both panning and scaling\n      // We're using the matrix inverse to properly convert from screen to canvas coordinates\n      const canvasX = (newX - matrix.e) / matrix.a;\n      const canvasY = (newY - matrix.f) / matrix.d;\n      \n      // Debug log\n      console.log('Drag move:', {\n        mousePosition: { x: e.clientX, y: e.clientY },\n        offset: dragOffset,\n        newScreenPos: { x: newX, y: newY },\n        containerMatrix: { e: matrix.e, f: matrix.f, a: matrix.a, d: matrix.d },\n        canvasPos: { x: canvasX, y: canvasY }\n      });\n      \n      onDragMove(node.id, canvasX, canvasY);\n    }\n  }, [isDragging, dragOffset, node.id, onDragMove]);\n  \n  const handleMouseUp = useCallback((e: React.MouseEvent<HTMLDivElement>) => {\n    if (isDragging) {\n      e.preventDefault();\n      setIsDragging(false);\n      onDragEnd(node.id);\n      document.body.style.userSelect = '';\n      \n      // Release the pointer capture\n      (e.target as HTMLElement).releasePointerCapture(e.pointerId);\n    }\n  }, [isDragging, node.id, onDragEnd]);\n  \n  // Handle thread response submission\n  const handleAddThreadResponse = useCallback(() => {\n    if (threadResponseText.trim() && onAddThreadResponse) {\n      onAddThreadResponse(node.id, threadResponseText.trim());\n      setThreadResponseText('');\n      setIsAddingThreadResponse(false);\n    }\n  }, [node.id, threadResponseText, onAddThreadResponse]);\n  \n  // Determine the card style based on node type\n  const getCardStyle = () => {\n    // Don't use absolute or transform here since we handle that in getPositionStyle\n    let baseStyle = \"\";\n    \n    if (position.isDragging) {\n      baseStyle += \" opacity-70\";\n    }\n    \n    if (isSelected) {\n      baseStyle += \" ring-2 ring-offset-2\";\n    }\n    \n    // Thread response style is more compact\n    if (isThreadResponse) {\n      baseStyle += \" shadow-md\";\n    } else {\n      baseStyle += \" shadow-lg\";\n    }\n    \n    // Card color based on type\n    switch (node.type) {\n      case 'question':\n        return `${baseStyle} bg-blue-50 ${isSelected ? 'ring-blue-500' : ''}`;\n      case 'response':\n        return `${baseStyle} bg-teal-50 ${isSelected ? 'ring-teal-500' : ''}`;\n      case 'note':\n        return `${baseStyle} bg-yellow-50 ${isSelected ? 'ring-yellow-500' : ''}`;\n      case 'drawing':\n        return `${baseStyle} bg-green-50 ${isSelected ? 'ring-green-500' : ''}`;\n      default:\n        return `${baseStyle} bg-gray-50 ${isSelected ? 'ring-gray-500' : ''}`;\n    }\n  };\n  \n  // Determine width based on card type and content\n  const getCardWidth = () => {\n    const contentLength = node.content?.length || 0;\n    const baseWidth = isThreadResponse ? 300 : 350;\n    \n    if (contentLength > 500) return 'w-[450px]';\n    if (contentLength > 300) return 'w-[400px]';\n    if (contentLength > 100) return `w-[${baseWidth}px]`;\n    return `w-[${baseWidth - 50}px]`;\n  };\n  \n  // Card header background based on type\n  const getHeaderStyle = () => {\n    if (isSelected) {\n      return 'bg-gray-700 text-white';\n    }\n    \n    if (isThreadResponse) {\n      return 'bg-gray-200 text-gray-700';\n    }\n    \n    switch (node.type) {\n      case 'question':\n        return 'bg-blue-600 text-white';\n      case 'response':\n        return 'bg-teal-600 text-white';\n      case 'note':\n        return 'bg-yellow-600 text-white';\n      case 'drawing':\n        return 'bg-green-600 text-white';\n      default:\n        return 'bg-gray-600 text-white';\n    }\n  };\n  \n  // Format card label\n  const getCardLabel = () => {\n    if (isThreadResponse) {\n      return `Thread Reply (${node.type.charAt(0).toUpperCase() + node.type.slice(1)})`;\n    }\n    \n    if (isMainThreadNode) {\n      return `${node.type.charAt(0).toUpperCase() + node.type.slice(1)} (Thread)`;\n    }\n    \n    return node.type.charAt(0).toUpperCase() + node.type.slice(1);\n  };\n  \n  // Get card position style\n  const getPositionStyle = () => {\n    // For DOM positioning, we use absolute positioning with exact coordinates\n    // The parent container already handles the canvas scaling and panning\n    return {\n      position: 'absolute',\n      left: `${position.x}px`,\n      top: `${position.y}px`,\n      transform: isDragging ? 'translate3d(0,0,0)' : undefined, // Force GPU acceleration during drag for smoother performance\n      zIndex: isSelected || isHovered || isDragging ? 10 : 1,\n      transition: isDragging ? 'none' : 'box-shadow 0.2s ease', // Disable transitions during drag for performance\n    };\n  };\n  \n  // Truncate content for collapsed cards\n  const getDisplayContent = () => {\n    if (!node.content) return '';\n    \n    if (position.isCollapsed) {\n      return node.content.length > 30 \n        ? node.content.substring(0, 30) + '...' \n        : node.content;\n    }\n    \n    return node.content;\n  };\n  \n  return (\n    <div \n      className={`${getCardStyle()} ${getCardWidth()} cursor-grab ${isDragging ? 'cursor-grabbing' : ''}`}\n      style={getPositionStyle()}\n      ref={cardRef}\n      onClick={() => onSelect(node.id)}\n      onPointerDown={handleMouseDown}\n      onPointerMove={handleMouseMove}\n      onPointerUp={handleMouseUp}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n      onDoubleClick={() => enableTextSelection && setIsEditing(true)}\n    >\n      {/* Thread connection line (rendered as an SVG element) */}\n      {isThreadResponse && threadParent && isThreadExpanded && (\n        <svg \n          className=\"absolute pointer-events-none\" \n          style={{ \n            left: -15, \n            top: 0, \n            width: 15 + Math.abs(position.x - threadParent.position.x), \n            height: Math.abs(position.y - threadParent.position.y) + 20,\n            zIndex: 0,\n            overflow: 'visible'\n          }}\n        >\n          <path \n            d={`M 0,15 \n                H -15 \n                V ${threadParent.position.y - position.y + 20} \n                H ${threadParent.position.x - position.x}`}\n            stroke=\"#90CDF4\"\n            strokeWidth=\"1.5\"\n            strokeDasharray=\"3,3\"\n            fill=\"none\"\n            opacity=\"0.8\"\n          />\n          {/* Connection dots */}\n          <rect \n            x=\"-3\" \n            y=\"15\" \n            width=\"6\" \n            height=\"6\" \n            rx=\"3\" \n            fill=\"#3182CE\" \n          />\n          <rect \n            x={threadParent.position.x - position.x - 3}\n            y={threadParent.position.y - position.y + 20 - 3}\n            width=\"6\" \n            height=\"6\" \n            rx=\"3\" \n            fill=\"#3182CE\" \n          />\n        </svg>\n      )}\n      \n      <Card className={`h-full overflow-hidden border ${position.isCollapsed ? 'max-h-[40px]' : ''}`}>\n        <CardHeader className={`${getHeaderStyle()} py-2 px-3`} data-card-header=\"true\">\n          <div className=\"flex justify-between items-center\">\n            <span className=\"text-sm font-medium\">{getCardLabel()}</span>\n            <div className=\"flex space-x-1\">\n              {/* Badges showing how many connected nodes */}\n              {incomingRelationships.length > 0 && (\n                <span className=\"inline-flex items-center justify-center w-5 h-5 text-xs bg-gray-200 text-gray-700 rounded-full\">\n                  {incomingRelationships.length}\n                </span>\n              )}\n              \n              {outgoingRelationships.length > 0 && (\n                <span className=\"inline-flex items-center justify-center w-5 h-5 text-xs bg-gray-200 text-gray-700 rounded-full\">\n                  {outgoingRelationships.length}\n                </span>\n              )}\n              \n              {/* Collapse/Expand button */}\n              <button\n                className=\"inline-flex items-center justify-center w-5 h-5 bg-gray-600 text-white rounded\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onToggleCollapse(node.id);\n                }}\n              >\n                {position.isCollapsed ? '+' : '-'}\n              </button>\n            </div>\n          </div>\n        </CardHeader>\n        \n        {!position.isCollapsed && (\n          <>\n            <CardContent className=\"p-3 overflow-y-auto max-h-[300px]\">\n              {isEditing ? (\n                <Textarea\n                  value={editText}\n                  onChange={(e) => setEditText(e.target.value)}\n                  className=\"w-full\"\n                  autoFocus\n                  onClick={(e) => e.stopPropagation()}\n                />\n              ) : (\n                <div className=\"whitespace-pre-wrap text-sm\">\n                  {/* Check for transcription thumbnail and display it */}\n                  {node.metadata?.thumbnail && (\n                    <div className=\"mb-2 border border-gray-200 rounded overflow-hidden\">\n                      <img \n                        src={node.metadata.thumbnail} \n                        alt=\"Transcribed selection\" \n                        className=\"w-full object-contain max-h-[120px]\"\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          // We could later implement a \"zoom to original\" feature using the selectionInfo\n                        }}\n                      />\n                      <div className=\"bg-gray-100 text-xs text-gray-500 p-1 text-center\">\n                        Transcribed selection\n                      </div>\n                    </div>\n                  )}\n                  {getDisplayContent()}\n                </div>\n              )}\n            </CardContent>\n            \n            <CardFooter className=\"p-2 border-t flex justify-between items-center\">\n              {/* Thread controls - different for main thread nodes vs thread responses */}\n              {isMainThreadNode && (\n                <div className=\"flex gap-2\">\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      onThreadExpand(node.id);\n                    }}\n                  >\n                    {isThreadExpanded ? \"Collapse Thread\" : \"Expand Thread\"}\n                  </Button>\n                  \n                  {!isAddingThreadResponse && (\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"bg-blue-50 text-blue-700 border-blue-200 hover:bg-blue-100\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        setIsAddingThreadResponse(true);\n                      }}\n                    >\n                      Reply to Thread\n                    </Button>\n                  )}\n                </div>\n              )}\n              \n              {/* Regular card controls - don't show on thread responses */}\n              {!isThreadResponse && (\n                <div className=\"flex gap-2\">\n                  {/* Settings button with indication for metadata */}\n                  <Button\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className={`p-1 h-7 w-7 ${node.metadata?.thumbnail ? 'bg-blue-50 text-blue-700' : ''}`}\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      setShowSettings(!showSettings);\n                    }}\n                  >\n                    {node.metadata?.thumbnail ? 'ⓘ' : '⋮'}\n                  </Button>\n                  \n                  {/* Create relationship button */}\n                  {onCreateRelationship && (\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"p-1 h-7 w-7 bg-purple-50 text-purple-700 border-purple-200 hover:bg-purple-100\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        setShowRelationMenu(!showRelationMenu);\n                      }}\n                    >\n                      ↔\n                    </Button>\n                  )}\n                  \n                  {/* Add response button */}\n                  {onAddResponse && (\n                    <Button\n                      variant=\"outline\"\n                      size=\"sm\"\n                      className=\"p-1 h-7 w-7 bg-blue-50 text-blue-700 border-blue-200 hover:bg-blue-100\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        // Calculate position for new response (to the right of this card)\n                        const newPosition = {\n                          x: position.x + (isThreadResponse ? 300 : 350) + 40,\n                          y: position.y\n                        };\n                        onAddResponse(node.id, newPosition);\n                      }}\n                    >\n                      +\n                    </Button>\n                  )}\n                </div>\n              )}\n            </CardFooter>\n          </>\n        )}\n      </Card>\n      \n      {/* Thread response input (only shown when adding a thread response) - Figma/Miro style */}\n      {isAddingThreadResponse && !position.isCollapsed && (\n        <div \n          className=\"absolute transform translate-y-full -translate-x-0 top-0 left-0 mt-4 w-full\"\n          onClick={(e) => e.stopPropagation()}\n        >\n          {/* Connection line from card to thread input */}\n          <svg className=\"absolute pointer-events-none\" style={{ top: -10, left: '50%', width: 2, height: 10 }}>\n            <line \n              x1=\"0\" y1=\"0\" \n              x2=\"0\" y2=\"10\" \n              stroke=\"#90CDF4\" \n              strokeWidth=\"1.5\" \n              strokeDasharray=\"3,3\" \n            />\n          </svg>\n          \n          <Card className=\"shadow-lg border border-blue-200\">\n            <CardHeader className=\"bg-blue-50 py-2 px-3\">\n              <span className=\"text-sm font-medium text-blue-700\">Reply to thread</span>\n            </CardHeader>\n            <CardContent className=\"p-3\">\n              <Textarea\n                value={threadResponseText}\n                onChange={(e) => setThreadResponseText(e.target.value)}\n                placeholder=\"Type your response...\"\n                className=\"w-full\"\n                autoFocus\n              />\n            </CardContent>\n            <CardFooter className=\"p-2 flex justify-end gap-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => {\n                  setIsAddingThreadResponse(false);\n                  setThreadResponseText('');\n                }}\n              >\n                Cancel\n              </Button>\n              <Button\n                variant=\"default\"\n                size=\"sm\"\n                className={threadResponseText.trim() ? 'bg-blue-600' : 'bg-blue-400'}\n                disabled={!threadResponseText.trim()}\n                onClick={handleAddThreadResponse}\n              >\n                Send\n              </Button>\n            </CardFooter>\n          </Card>\n        </div>\n      )}\n      \n      {/* Relationship menu (only shown when relationship button clicked) */}\n      {showRelationMenu && onCreateRelationship && (\n        <div \n          className=\"absolute z-20 right-0 top-0 -mt-28 -mr-5 w-[240px]\"\n          onClick={(e) => e.stopPropagation()}\n        >\n          <Card className=\"shadow-xl\">\n            <CardHeader className=\"py-2 px-3\">\n              <span className=\"text-sm font-medium\">Create Relationship:</span>\n            </CardHeader>\n            <CardContent className=\"p-2\">\n              <div className=\"grid grid-cols-2 gap-2\">\n                {['extends', 'supports', 'contradicts', 'questions'].map((type) => (\n                  <Button\n                    key={type}\n                    variant=\"outline\"\n                    size=\"sm\"\n                    className={\n                      type === 'extends' ? 'bg-blue-50 border-blue-200 hover:bg-blue-100' :\n                      type === 'supports' ? 'bg-teal-50 border-teal-200 hover:bg-teal-100' :\n                      type === 'contradicts' ? 'bg-red-50 border-red-200 hover:bg-red-100' :\n                      'bg-purple-50 border-purple-200 hover:bg-purple-100'\n                    }\n                    onClick={() => {\n                      console.log(`Create ${type} relationship from ${node.id}`);\n                      setShowRelationMenu(false);\n                    }}\n                  >\n                    {type.charAt(0).toUpperCase() + type.slice(1)}\n                  </Button>\n                ))}\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      )}\n      \n      {/* Settings panel with system prompt */}\n      {showSettings && (\n        <div \n          className=\"absolute z-20 right-0 top-0 -mt-52 -mr-20 w-[330px]\"\n          onClick={(e) => e.stopPropagation()}\n        >\n          <Card className=\"shadow-xl\">\n            <CardHeader className=\"py-2 px-3 bg-gray-700 text-white\">\n              <div className=\"flex justify-between items-center\">\n                <span className=\"text-sm font-medium\">Card Settings</span>\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  className=\"h-6 w-6 p-0 text-white hover:bg-gray-600\"\n                  onClick={() => setShowSettings(false)}\n                >\n                  ×\n                </Button>\n              </div>\n            </CardHeader>\n            <CardContent className=\"p-3\">\n              <div className=\"bg-gray-100 p-2 rounded mb-3\">\n                <div className=\"flex justify-between text-sm\">\n                  <span>Type: {node.type.charAt(0).toUpperCase() + node.type.slice(1)}</span>\n                  <span className=\"text-gray-500\">ID: {node.id.substring(0, 8)}...</span>\n                </div>\n              </div>\n              \n              {/* Display transcription info if available */}\n              {node.metadata?.thumbnail && (\n                <div className=\"mb-4\">\n                  <div className=\"mb-2\">\n                    <span className=\"text-sm font-medium\">Transcribed Selection</span>\n                  </div>\n                  <div className=\"bg-gray-50 p-2 border border-gray-200 rounded\">\n                    <img \n                      src={node.metadata.thumbnail} \n                      alt=\"Transcribed selection\" \n                      className=\"w-full object-contain max-h-[120px] mb-2\"\n                    />\n                    {node.metadata?.transcriptionTags && node.metadata.transcriptionTags.length > 0 && (\n                      <div className=\"flex flex-wrap gap-1 mt-1\">\n                        {node.metadata.transcriptionTags.map((tag: string, index: number) => (\n                          <span key={index} className=\"inline-block px-2 py-1 bg-blue-100 text-blue-800 text-xs rounded\">\n                            {tag}\n                          </span>\n                        ))}\n                      </div>\n                    )}\n                    {node.metadata?.selectionInfo && (\n                      <div className=\"mt-2 text-xs text-gray-500\">\n                        <div>Position: ({node.metadata.selectionInfo.x.toFixed(0)}, {node.metadata.selectionInfo.y.toFixed(0)})</div>\n                        <div>Size: {node.metadata.selectionInfo.width.toFixed(0)} × {node.metadata.selectionInfo.height.toFixed(0)}</div>\n                      </div>\n                    )}\n                  </div>\n                </div>\n              )}\n              \n              <div className=\"mb-2\">\n                <span className=\"text-sm font-medium\">System Prompt</span>\n              </div>\n              <div className=\"bg-gray-50 p-2 border border-gray-200 rounded text-sm text-gray-700 min-h-[80px]\">\n                {systemPrompt || \"Default system prompt not set\"}\n              </div>\n            </CardContent>\n          </Card>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(UnifiedCardThreadDOM);\n\n================================================================================\nFILE: src/components/canvas/UnifiedView.tsx\n================================================================================\n\n// src/components/canvas/UnifiedView.tsx\nimport React, { useEffect, useState, useCallback, useRef } from 'react';\nimport { useRouter } from 'next/router';\nimport { \n  useNodeLoader, \n  useNodes, \n  useNodePositions, \n  useRelationships,\n  useNodeActions,\n  useNodeStore\n} from '@/stores';\nimport UnifiedCanvasContainer from './UnifiedCanvasContainer';\nimport UnifiedCardThreadDOM from './UnifiedCardThreadDOM';\nimport LlamaChat from '../ui/LlamaChat';\nimport LoadingSpinner from '@/components/ui/LoadingSpinner';\nimport { useNotebook } from '@/hooks/useNotebook';\n\ninterface UnifiedViewProps {\n  notebookId: string;\n}\n\n/**\n * UnifiedView is the main container for the relationship-centric view\n * It manages loading nodes and relationships and renders the canvas\n */\nconst UnifiedView: React.FC<UnifiedViewProps> = ({ notebookId }) => {\n  const router = useRouter();\n  const { notebook, loading: notebookLoading } = useNotebook(notebookId);\n  const { fetchNodesByNotebook, isLoading, error } = useNodeLoader();\n  const nodes = useNodes();\n  const nodePositions = useNodePositions();\n  const relationships = useRelationships();\n  const { setSelectedNode, setActiveNode } = useNodeActions();\n  \n  // State for view options\n  const [activeView, setActiveView] = useState<'canvas' | 'chat' | 'split'>('canvas');\n  const [scale, setScale] = useState(1);\n  const [showRelationships, setShowRelationships] = useState(true);\n  const [filterNodeType, setFilterNodeType] = useState<string | null>(null);\n  \n  // Chat panel size state\n  const [chatPanelWidth, setChatPanelWidth] = useState(350);\n  const [isResizing, setIsResizing] = useState(false);\n  const [startX, setStartX] = useState(0);\n  const [startWidth, setStartWidth] = useState(chatPanelWidth);\n  \n  // Track data loading to prevent duplicate fetches\n  const dataLoadedRef = useRef(false);\n  const isLoadingDataRef = useRef(false);\n  \n  // Load data ONLY ONCE for this view\n  useEffect(() => {\n    // Skip if already loaded or loading in progress or no ID\n    if (!notebookId || dataLoadedRef.current || isLoadingDataRef.current) {\n      return;\n    }\n    \n    // Set loading flag immediately to prevent concurrent fetches\n    isLoadingDataRef.current = true;\n    \n    console.log(\"[UnifiedView] First-time data load for notebook:\", notebookId);\n    \n    // Define the async fetch operation\n    const loadData = async () => {\n      try {\n        await fetchNodesByNotebook(notebookId);\n        dataLoadedRef.current = true; // Mark as loaded only after successful fetch\n      } catch (error) {\n        console.error(\"Error in initial data load:\", error);\n        // Reset loading flag on error to allow retry\n        isLoadingDataRef.current = false;\n      } finally {\n        isLoadingDataRef.current = false;\n      }\n    };\n    \n    // Start the fetch\n    loadData();\n    \n    // Cleanup - no dependencies to worry about\n    return () => {};\n  }, []); // Empty dependency array - run ONCE on mount only\n  \n  // Handle node selection from URL params\n  useEffect(() => {\n    if (!router.isReady) return;\n    \n    const { node } = router.query;\n    if (node && typeof node === 'string' && nodes[node]) {\n      setSelectedNode(node);\n      setActiveNode(node);\n    }\n  }, [router.isReady, router.query, nodes, setSelectedNode, setActiveNode]);\n  \n  // Filter nodes and relationships based on current filter settings\n  const filteredNodes = useCallback(() => {\n    return Object.values(nodes).filter(node => {\n      if (!filterNodeType) return true;\n      return node.type === filterNodeType;\n    });\n  }, [nodes, filterNodeType]);\n  \n  const filteredRelationships = useCallback(() => {\n    if (!showRelationships) return [];\n    \n    const nodeIds = new Set(filteredNodes().map(node => node.id));\n    \n    return relationships.filter(rel => {\n      return nodeIds.has(rel.from_node_id) && nodeIds.has(rel.to_node_id);\n    });\n  }, [relationships, showRelationships, filteredNodes]);\n  \n  // Handle resize logic\n  const handleResizeStart = (e: React.MouseEvent) => {\n    setIsResizing(true);\n    setStartX(e.clientX);\n    setStartWidth(chatPanelWidth);\n  };\n\n  const handleResizeMove = useCallback((e: MouseEvent) => {\n    if (!isResizing) return;\n    const deltaX = e.clientX - startX;\n    const newWidth = Math.max(250, Math.min(800, startWidth - deltaX));\n    setChatPanelWidth(newWidth);\n  }, [isResizing, startX, startWidth]);\n\n  const handleResizeEnd = () => {\n    setIsResizing(false);\n  };\n\n  // Add and remove event listeners for resize\n  useEffect(() => {\n    if (isResizing) {\n      window.addEventListener('mousemove', handleResizeMove);\n      window.addEventListener('mouseup', handleResizeEnd);\n    }\n    \n    return () => {\n      window.removeEventListener('mousemove', handleResizeMove);\n      window.removeEventListener('mouseup', handleResizeEnd);\n    };\n  }, [isResizing, handleResizeMove]);\n  \n  // View mode buttons\n  const ViewToggle = () => (\n    <div className=\"view-toggle absolute top-4 right-4 z-10 bg-white rounded-lg shadow-md p-1 border border-gray-200\">\n      <button\n        className={`p-2 rounded-md text-sm font-medium mr-1 ${activeView === 'canvas' ? 'bg-blue-100 text-blue-800' : 'hover:bg-gray-100'}`}\n        onClick={() => setActiveView('canvas')}\n      >\n        Canvas\n      </button>\n      <button\n        className={`p-2 rounded-md text-sm font-medium mr-1 ${activeView === 'chat' ? 'bg-blue-100 text-blue-800' : 'hover:bg-gray-100'}`}\n        onClick={() => setActiveView('chat')}\n      >\n        Chat\n      </button>\n      <button\n        className={`p-2 rounded-md text-sm font-medium mr-1 ${activeView === 'split' ? 'bg-blue-100 text-blue-800' : 'hover:bg-gray-100'}`}\n        onClick={() => setActiveView('split')}\n      >\n        Split\n      </button>\n      <a\n        href={`/notebooks/${notebookId}/chat`}\n        className=\"p-2 rounded-md text-sm font-medium text-blue-600 hover:bg-blue-50\"\n      >\n        Full Chat\n      </a>\n    </div>\n  );\n  \n  // Loading state\n  if (notebookLoading || isLoading) {\n    return (\n      <div className=\"flex h-screen items-center justify-center\">\n        <LoadingSpinner />\n      </div>\n    );\n  }\n  \n  // Error state\n  if (error) {\n    return (\n      <div className=\"flex h-screen items-center justify-center\">\n        <div className=\"text-center\">\n          <h3 className=\"text-lg font-medium text-red-700\">Error loading notebook</h3>\n          <p className=\"mt-2 text-sm text-gray-600\">{error}</p>\n          <button \n            onClick={() => fetchNodesByNotebook(notebookId)}\n            className=\"mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n          >\n            Try Again\n          </button>\n        </div>\n      </div>\n    );\n  }\n  \n  // Render different layouts based on the active view\n  const renderContent = () => {\n    switch (activeView) {\n      case 'canvas':\n        return (\n          <div className=\"w-full h-full relative\">\n            <UnifiedCanvasContainer \n              notebookId={notebookId} \n              scale={scale}\n              setScale={setScale}\n              showRelationships={showRelationships}\n              filteredNodes={filteredNodes()}\n              filteredRelationships={filteredRelationships()}\n            />\n            <ViewToggle />\n          </div>\n        );\n        \n      case 'chat':\n        return (\n          <div className=\"w-full h-full relative\">\n            <LlamaChat\n              notebookId={notebookId}\n              systemPrompt={notebook?.system_prompt || undefined}\n              fullScreen={true}\n            />\n            <ViewToggle />\n          </div>\n        );\n        \n      case 'split':\n        return (\n          <div className=\"w-full h-full flex relative\">\n            <div className=\"flex-grow relative\" style={{ width: `calc(100% - ${chatPanelWidth}px)` }}>\n              <UnifiedCanvasContainer \n                notebookId={notebookId} \n                scale={scale}\n                setScale={setScale}\n                showRelationships={showRelationships}\n                filteredNodes={filteredNodes()}\n                filteredRelationships={filteredRelationships()}\n              />\n            </div>\n            \n            <div \n              className=\"resize-handle w-1 bg-gray-300 hover:bg-blue-400 cursor-col-resize\" \n              onMouseDown={handleResizeStart}\n            />\n            \n            <div className=\"h-full\" style={{ width: `${chatPanelWidth}px` }}>\n              <LlamaChat \n                notebookId={notebookId}\n                systemPrompt={notebook?.system_prompt || undefined}\n              />\n            </div>\n            \n            <ViewToggle />\n          </div>\n        );\n        \n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"unified-view-container w-full h-full\">\n      {renderContent()}\n    </div>\n  );\n};\n\nexport default React.memo(UnifiedView);\n\n================================================================================\nFILE: src/components/conversation/ChatInput.tsx\n================================================================================\n\n// src/components/conversation/ChatInput.tsx\nimport React, { useState, useRef, useEffect } from 'react';\nimport { useNodeStore } from '@/stores/nodeStore';\nimport { createNode, createRelationship } from '@/services/nodeService';\n\ninterface ChatInputProps {\n  notebookId: string;\n  onSendMessage: (message: string) => Promise<void>;\n  activeNodeId: string | null;\n  placeholder?: string;\n  disabled?: boolean;\n  className?: string;\n}\n\nconst ChatInput: React.FC<ChatInputProps> = ({\n  notebookId,\n  onSendMessage,\n  activeNodeId,\n  placeholder = 'Type a message...',\n  disabled = false,\n  className = ''\n}) => {\n  const [message, setMessage] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  \n  const { \n    addNode, \n    addRelationship, \n    updateNodePosition, \n    nodePositions, \n    nodes \n  } = useNodeStore();\n  \n  // Focus the input when activeNodeId changes\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [activeNodeId]);\n  \n  // Auto-resize the textarea based on content\n  useEffect(() => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto';\n      inputRef.current.style.height = `${Math.min(inputRef.current.scrollHeight, 150)}px`;\n    }\n  }, [message]);\n  \n  const handleSendMessage = async () => {\n    if (!message.trim() || disabled || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      \n      // Send message to chat\n      await onSendMessage(message);\n      \n      // Create a node if appropriate\n      if (!activeNodeId) {\n        // No active node, create a question node\n        const newNode = await createNode(\n          notebookId,\n          message,\n          'question',\n          // Position near the center if possible\n          { x: 100, y: 100 }\n        );\n        \n        if (newNode) {\n          addNode(newNode);\n        }\n      } else {\n        // Create a response node connected to the active node\n        \n        // Calculate position for the new node\n        // Default position is to the right of the active node\n        let newPosition = { x: 400, y: 100 };\n        \n        // Use position of active node if available\n        if (activeNodeId && nodePositions[activeNodeId]) {\n          const activePosition = nodePositions[activeNodeId];\n          const activeNode = nodes[activeNodeId];\n          \n          // Determine type of the active node\n          const isQuestion = activeNode?.type === 'question';\n          \n          // Position the response to the right and slightly below if it's a question\n          if (isQuestion) {\n            newPosition = {\n              x: activePosition.x + 350,\n              y: activePosition.y + 50\n            };\n          } else {\n            // Otherwise, position below another response\n            newPosition = {\n              x: activePosition.x,\n              y: activePosition.y + 200\n            };\n          }\n        }\n        \n        // Create the response node\n        const newNode = await createNode(\n          notebookId,\n          message,\n          'response',\n          newPosition\n        );\n        \n        if (newNode) {\n          addNode(newNode);\n          \n          // Create relationship between active node and new node\n          const relationship = await createRelationship(\n            activeNodeId,\n            newNode.id,\n            'extends', // Default relationship type\n            notebookId\n          );\n          \n          if (relationship) {\n            addRelationship(relationship);\n          }\n        }\n      }\n      \n      // Clear the input\n      setMessage('');\n      \n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n  \n  return (\n    <div className={`flex items-end border-t border-gray-200 p-3 bg-white ${className}`}>\n      <div className=\"relative flex-grow\">\n        <textarea\n          ref={inputRef}\n          className=\"w-full border border-gray-300 rounded-md py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500 min-h-[38px] max-h-[150px] resize-none\"\n          placeholder={activeNodeId \n            ? `Reply to selected ${nodes[activeNodeId]?.type || 'card'}...` \n            : placeholder\n          }\n          value={message}\n          onChange={(e) => setMessage(e.target.value)}\n          onKeyDown={handleKeyDown}\n          disabled={disabled || isLoading}\n          rows={1}\n        />\n        {/* Character counter */}\n        {message.length > 0 && (\n          <div className=\"absolute right-2 bottom-1 text-xs text-gray-400\">\n            {message.length} / 4000\n          </div>\n        )}\n      </div>\n      <button\n        className={`ml-2 px-4 py-2 rounded-md focus:outline-none ${\n          message.trim() && !disabled && !isLoading\n            ? 'bg-blue-500 text-white hover:bg-blue-600'\n            : 'bg-gray-300 text-gray-500 cursor-not-allowed'\n        }`}\n        onClick={handleSendMessage}\n        disabled={!message.trim() || disabled || isLoading}\n      >\n        {isLoading ? (\n          <div className=\"w-5 h-5 border-t-2 border-blue-200 border-solid rounded-full animate-spin\"></div>\n        ) : (\n          <span>Send</span>\n        )}\n      </button>\n    </div>\n  );\n};\n\nexport default ChatInput;\n\n================================================================================\nFILE: src/components/conversation/ChatMessage.tsx\n================================================================================\n\n// src/components/conversation/ChatMessage.tsx\nimport React from 'react';\nimport { formatDistanceToNow } from 'date-fns';\n\ninterface MessageProps {\n  message: {\n    id: string;\n    role: 'user' | 'assistant' | 'system';\n    content: string;\n    nodeId?: string;\n    timestamp: string;\n  };\n  isHighlighted?: boolean;\n}\n\nconst ChatMessage: React.FC<MessageProps> = ({ message, isHighlighted = false }) => {\n  // Format timestamp\n  const formattedTime = formatDistanceToNow(new Date(message.timestamp), { addSuffix: true });\n  \n  // Determine message styles based on role\n  const getMessageStyles = () => {\n    const baseClasses = \"rounded-lg p-3 max-w-md\";\n    \n    // Add role-specific classes\n    if (message.role === 'user') {\n      return `${baseClasses} bg-blue-100 ml-auto text-gray-800`;\n    } else if (message.role === 'assistant') {\n      return `${baseClasses} bg-gray-100 mr-auto text-gray-800`;\n    } else {\n      return `${baseClasses} bg-gray-50 mx-auto text-gray-600 italic`;\n    }\n  };\n  \n  // Add highlight border if message is connected to selected card\n  const containerClasses = isHighlighted \n    ? \"border-2 border-blue-400 rounded-lg\"\n    : \"\";\n  \n  return (\n    <div className={`flex flex-col ${message.role === 'user' ? 'items-end' : 'items-start'}`}>\n      <div className={containerClasses}>\n        <div className={getMessageStyles()}>\n          <p className=\"whitespace-pre-wrap\">{message.content}</p>\n        </div>\n      </div>\n      <div className=\"text-xs text-gray-500 mt-1 px-1\">\n        {message.role === 'user' ? 'You' : 'Claude'} · {formattedTime}\n        {message.nodeId && (\n          <span className=\"ml-1 text-blue-500\">·\n            <span className=\"ml-1 underline cursor-pointer\">\n              View Card\n            </span>\n          </span>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ChatMessage;\n\n================================================================================\nFILE: src/components/conversation/ChatPanel.tsx\n================================================================================\n\n// src/components/conversation/ChatPanel.tsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useNodeStore } from '@/stores/nodeStore';\nimport ChatInput from './ChatInput';\nimport ChatMessage from './ChatMessage';\nimport { Node } from '@/types/thread';\nimport { supabase } from '@/lib/supabaseClient';\n\ninterface ChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string | null;\n  activeNodeId: string | null;\n  onClose: () => void;\n}\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  nodeId?: string;\n  timestamp: string;\n}\n\nconst ChatPanel: React.FC<ChatPanelProps> = ({\n  notebookId,\n  systemPrompt,\n  activeNodeId,\n  onClose\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [contextMode, setContextMode] = useState<'all' | 'thread'>('thread');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  const { nodes, relationships, getNodeRelationships, updateNode } = useNodeStore();\n  \n  // Initialize with system prompt if available\n  useEffect(() => {\n    if (systemPrompt) {\n      setMessages([{\n        id: 'system-prompt',\n        role: 'system',\n        content: systemPrompt,\n        timestamp: new Date().toISOString()\n      }]);\n    } else {\n      setMessages([]);\n    }\n  }, [systemPrompt]);\n  \n  // Update messages when active node changes\n  useEffect(() => {\n    if (activeNodeId) {\n      loadThreadMessages(activeNodeId);\n    } else {\n      // Reset to just system prompt if no active node\n      if (systemPrompt) {\n        setMessages([{\n          id: 'system-prompt',\n          role: 'system',\n          content: systemPrompt,\n          timestamp: new Date().toISOString()\n        }]);\n      } else {\n        setMessages([]);\n      }\n    }\n  }, [activeNodeId, systemPrompt]);\n  \n  // Scroll to bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n  \n  // Load messages for a thread\n  const loadThreadMessages = async (nodeId: string) => {\n    try {\n      // Start with system prompt if available\n      const initialMessages: Message[] = systemPrompt \n        ? [{\n            id: 'system-prompt',\n            role: 'system',\n            content: systemPrompt,\n            timestamp: new Date().toISOString()\n          }] \n        : [];\n      \n      if (contextMode === 'thread') {\n        // Get thread history by traversing relationships\n        const threadMessages = await getThreadMessages(nodeId);\n        setMessages([...initialMessages, ...threadMessages]);\n      } else {\n        // Get all nodes for broader context\n        const allNodeMessages = getAllNodeMessages();\n        setMessages([...initialMessages, ...allNodeMessages]);\n      }\n    } catch (error) {\n      console.error('Error loading thread messages:', error);\n    }\n  };\n  \n  // Get message history for a specific thread\n  const getThreadMessages = async (nodeId: string): Promise<Message[]> => {\n    const result: Message[] = [];\n    const visited = new Set<string>();\n    \n    // Recursive function to traverse thread\n    const traverse = (id: string, depth: number = 0) => {\n      if (visited.has(id)) return;\n      visited.add(id);\n      \n      const node = nodes[id];\n      if (!node) return;\n      \n      // Add this node as a message\n      result.push({\n        id: node.id,\n        role: node.type === 'question' || node.type === 'note' ? 'user' : 'assistant',\n        content: node.content,\n        nodeId: node.id,\n        timestamp: node.created_at\n      });\n      \n      // Get parent relationships (nodes that this node extends from)\n      const parentRels = relationships.filter(r => \n        r.to_node_id === id && r.type === 'extends'\n      );\n      \n      // Traverse parents\n      parentRels.forEach(rel => {\n        traverse(rel.from_node_id, depth + 1);\n      });\n      \n      // Get child relationships (nodes that extend from this node)\n      const childRels = relationships.filter(r => \n        r.from_node_id === id && r.type === 'extends'\n      );\n      \n      // Traverse children\n      childRels.forEach(rel => {\n        traverse(rel.to_node_id, depth + 1);\n      });\n    };\n    \n    // Start traversal from the given node\n    traverse(nodeId);\n    \n    // Sort by timestamp\n    return result.sort((a, b) => \n      new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n    );\n  };\n  \n  // Get all nodes as messages\n  const getAllNodeMessages = (): Message[] => {\n    return Object.values(nodes)\n      .filter(node => node.content.trim() !== '')\n      .map(node => ({\n        id: node.id,\n        role: node.type === 'question' || node.type === 'note' ? 'user' : 'assistant',\n        content: node.content,\n        nodeId: node.id,\n        timestamp: node.created_at\n      }))\n      .sort((a, b) => \n        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n      );\n  };\n  \n  // Handle sending a message\n  const handleSendMessage = async (content: string) => {\n    try {\n      setIsLoading(true);\n      \n      // Add user message to chat\n      const userMessage: Message = {\n        id: `user-${Date.now()}`,\n        role: 'user',\n        content,\n        nodeId: activeNodeId || undefined,\n        timestamp: new Date().toISOString()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare context for AI\n      const contextMessages = messages\n        .filter(msg => msg.role !== 'system') // Filter out system messages\n        .concat(userMessage) // Add the new user message\n        .map(msg => ({\n          role: msg.role,\n          content: msg.content\n        }));\n      \n      // Add system message at the beginning if available\n      if (systemPrompt) {\n        contextMessages.unshift({\n          role: 'system',\n          content: systemPrompt\n        });\n      }\n      \n      // Call API to get AI response\n      const response = await fetch('/api/claude/chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages: contextMessages,\n          notebookId\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to get AI response');\n      }\n      \n      const { answer } = await response.json();\n      \n      // Add AI response to chat\n      const aiMessage: Message = {\n        id: `assistant-${Date.now()}`,\n        role: 'assistant',\n        content: answer,\n        timestamp: new Date().toISOString()\n      };\n      \n      setMessages(prev => [...prev, aiMessage]);\n      \n      // Update the node content if we're editing an existing node\n      if (activeNodeId) {\n        await updateNode(activeNodeId, {\n          content: answer\n        });\n      }\n      \n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-200 px-4 py-3\">\n        <div className=\"flex items-center\">\n          <h3 className=\"font-medium text-gray-800\">\n            {activeNodeId \n              ? `Chat with ${nodes[activeNodeId]?.type || 'Node'}`\n              : 'Notebook Chat'\n            }\n          </h3>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className={`text-xs px-2 py-1 rounded ${\n              contextMode === 'thread'\n                ? 'bg-blue-100 text-blue-800'\n                : 'bg-gray-100 text-gray-600'\n            }`}\n            onClick={() => setContextMode('thread')}\n            title=\"Only include messages in the current thread\"\n          >\n            Thread\n          </button>\n          <button\n            className={`text-xs px-2 py-1 rounded ${\n              contextMode === 'all'\n                ? 'bg-blue-100 text-blue-800'\n                : 'bg-gray-100 text-gray-600'\n            }`}\n            onClick={() => setContextMode('all')}\n            title=\"Include all messages in the notebook\"\n          >\n            All\n          </button>\n          <button\n            className=\"ml-2 text-gray-500 hover:text-gray-700\"\n            onClick={onClose}\n            aria-label=\"Close chat panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {/* System message indicator */}\n        {systemPrompt && (\n          <div className=\"flex justify-center mb-4\">\n            <span className=\"text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full\">\n              Using custom system prompt\n            </span>\n          </div>\n        )}\n        \n        {/* Message list */}\n        {messages\n          .filter(msg => msg.role !== 'system') // Don't show system messages\n          .map((message) => (\n            <ChatMessage\n              key={message.id}\n              message={message}\n              isHighlighted={message.nodeId === activeNodeId}\n            />\n          ))}\n        \n        {/* Loading indicator */}\n        {isLoading && (\n          <div className=\"flex justify-center\">\n            <div className=\"animate-pulse flex space-x-2\">\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n            </div>\n          </div>\n        )}\n        \n        {/* Element to scroll to */}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input */}\n      <ChatInput\n        notebookId={notebookId}\n        onSendMessage={handleSendMessage}\n        activeNodeId={activeNodeId}\n        disabled={isLoading}\n      />\n    </div>\n  );\n};\n\nexport default ChatPanel;\n\n================================================================================\nFILE: src/components/conversation/MessageInput.tsx\n================================================================================\n\n/**\n * MessageInput Component\n * \n * A reusable component for sending messages in a conversation.\n * Supports auto-expanding textarea, keyboard shortcuts, and loading states.\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\n\nexport interface MessageInputProps {\n  onSendMessage: (message: string) => void;\n  isLoading?: boolean;\n  placeholder?: string;\n  initialValue?: string;\n  autoFocus?: boolean;\n  disabled?: boolean;\n  maxRows?: number;\n  sendOnEnter?: boolean;\n  className?: string;\n}\n\nexport const MessageInput: React.FC<MessageInputProps> = ({\n  onSendMessage,\n  isLoading = false,\n  placeholder = 'Type a message...',\n  initialValue = '',\n  autoFocus = false,\n  disabled = false,\n  maxRows = 5,\n  sendOnEnter = true,\n  className = '',\n}) => {\n  const [message, setMessage] = useState(initialValue);\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n  \n  // Auto-focus the textarea when the component mounts\n  useEffect(() => {\n    if (autoFocus && textareaRef.current) {\n      textareaRef.current.focus();\n    }\n  }, [autoFocus]);\n  \n  // Auto-resize the textarea as content grows\n  const resizeTextarea = () => {\n    const textarea = textareaRef.current;\n    if (!textarea) return;\n    \n    // Reset height to get the correct scrollHeight\n    textarea.style.height = 'auto';\n    \n    // Calculate the number of rows\n    const lineHeight = parseInt(getComputedStyle(textarea).lineHeight) || 20;\n    const paddingTop = parseInt(getComputedStyle(textarea).paddingTop) || 0;\n    const paddingBottom = parseInt(getComputedStyle(textarea).paddingBottom) || 0;\n    const rows = Math.min(\n      maxRows,\n      Math.floor((textarea.scrollHeight - paddingTop - paddingBottom) / lineHeight)\n    );\n    \n    // Set the height based on rows\n    textarea.style.height = `${rows * lineHeight + paddingTop + paddingBottom}px`;\n  };\n  \n  // Handle input changes and resize the textarea\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setMessage(e.target.value);\n    resizeTextarea();\n  };\n  \n  // Send the message\n  const sendMessage = () => {\n    const trimmedMessage = message.trim();\n    if (trimmedMessage && !isLoading && !disabled) {\n      onSendMessage(trimmedMessage);\n      setMessage('');\n      \n      // Reset textarea height\n      if (textareaRef.current) {\n        textareaRef.current.style.height = 'auto';\n      }\n    }\n  };\n  \n  // Handle key press events (Enter to send)\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (sendOnEnter && e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      sendMessage();\n    }\n  };\n  \n  return (\n    <div className={`relative ${className}`}>\n      <textarea\n        ref={textareaRef}\n        value={message}\n        onChange={handleChange}\n        onKeyDown={handleKeyDown}\n        placeholder={placeholder}\n        disabled={isLoading || disabled}\n        className={`w-full p-3 pr-12 border rounded-lg shadow-sm resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 \n          ${isLoading || disabled ? 'bg-gray-100 text-gray-500' : 'bg-white text-gray-900'}`}\n        rows={1}\n        aria-label=\"Message input\"\n      />\n      \n      {/* Send button */}\n      <button\n        onClick={sendMessage}\n        disabled={!message.trim() || isLoading || disabled}\n        className={`absolute right-2 bottom-2 p-2 rounded-full\n          ${!message.trim() || isLoading || disabled\n            ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\n            : 'bg-blue-600 text-white hover:bg-blue-700'\n          } transition-colors`}\n        aria-label=\"Send message\"\n      >\n        {isLoading ? (\n          <div className=\"h-5 w-5 animate-spin rounded-full border-b-2 border-white\"></div>\n        ) : (\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n          </svg>\n        )}\n      </button>\n    </div>\n  );\n};\n\n================================================================================\nFILE: src/components/conversation/MessageList.tsx\n================================================================================\n\n/**\n * MessageList Component\n * \n * A reusable component for displaying a list of messages in a conversation.\n * Supports different message types, styling options, and interaction handlers.\n */\n\nimport React, { useRef, useEffect } from 'react';\nimport { Message } from '@/types/conversation';\n\nexport interface MessageListProps {\n  messages: Message[];\n  isLoading?: boolean;\n  error?: Error | null;\n  onEditMessage?: (messageId: string, content: string) => void;\n  onDeleteMessage?: (messageId: string) => void;\n  maxHeight?: string | number;\n  autoScroll?: boolean;\n  highlightedMessageId?: string;\n  className?: string;\n}\n\nexport const MessageList: React.FC<MessageListProps> = ({\n  messages,\n  isLoading = false,\n  error = null,\n  onEditMessage,\n  onDeleteMessage,\n  maxHeight = '600px',\n  autoScroll = true,\n  highlightedMessageId,\n  className = '',\n}) => {\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Auto-scroll to bottom when messages change\n  useEffect(() => {\n    if (autoScroll && messagesEndRef.current) {\n      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });\n    }\n  }, [messages, autoScroll]);\n  \n  // Scroll to highlighted message when it changes\n  useEffect(() => {\n    if (highlightedMessageId) {\n      const highlightedElement = document.getElementById(`message-${highlightedMessageId}`);\n      if (highlightedElement) {\n        highlightedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n        highlightedElement.classList.add('bg-yellow-50');\n        setTimeout(() => {\n          highlightedElement.classList.remove('bg-yellow-50');\n        }, 2000);\n      }\n    }\n  }, [highlightedMessageId]);\n  \n  // Determine if a role change occurred (for grouping)\n  const didRoleChange = (index: number) => {\n    if (index === 0) return true;\n    return messages[index].role !== messages[index - 1].role;\n  };\n  \n  return (\n    <div \n      className={`flex flex-col overflow-y-auto ${className}`}\n      style={{ maxHeight }}\n    >\n      {/* Message bubbles */}\n      <div className=\"flex-1 p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={message.id}\n            id={`message-${message.id}`}\n            className={`transition-all duration-300 ${\n              didRoleChange(index) ? 'mt-6' : 'mt-2'\n            } ${\n              message.role === 'user' ? 'ml-8' : 'mr-8'\n            } ${\n              highlightedMessageId === message.id ? 'bg-yellow-50 rounded-lg p-2 -m-2' : ''\n            }`}\n          >\n            {/* Role label (only shown on role change) */}\n            {didRoleChange(index) && (\n              <div className={`text-xs font-medium mb-1 ${\n                message.role === 'user' ? 'text-gray-600 text-right' : \n                message.role === 'assistant' ? 'text-indigo-600' : 'text-green-600'\n              }`}>\n                {message.role === 'user' ? 'You' : \n                 message.role === 'assistant' ? (message.metadata?.authorName || 'AI Assistant') : \n                 'System'}\n                {message.metadata?.perspective && ` (${message.metadata.perspective})`}\n              </div>\n            )}\n            \n            {/* Message bubble */}\n            <div className={`relative rounded-lg p-3 ${\n              message.role === 'user' ? 'bg-blue-50 ml-auto' : \n              message.role === 'assistant' ? 'bg-white border border-gray-200' : \n              'bg-gray-100 border border-gray-300'\n            }`}>\n              {/* Message content */}\n              <div className=\"whitespace-pre-wrap break-words\">\n                {message.content}\n              </div>\n              \n              {/* Message timestamp - small and subtle */}\n              <div className=\"text-xs text-gray-400 mt-1 text-right\">\n                {new Date(message.createdAt).toLocaleTimeString([], {\n                  hour: '2-digit',\n                  minute: '2-digit'\n                })}\n              </div>\n              \n              {/* Action buttons */}\n              {(onEditMessage || onDeleteMessage) && (\n                <div className=\"absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity\">\n                  {onEditMessage && (\n                    <button\n                      onClick={() => onEditMessage(message.id, message.content)}\n                      className=\"p-1 text-gray-400 hover:text-gray-600 mr-1\"\n                      aria-label=\"Edit message\"\n                    >\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path d=\"M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z\" />\n                      </svg>\n                    </button>\n                  )}\n                  {onDeleteMessage && (\n                    <button\n                      onClick={() => onDeleteMessage(message.id)}\n                      className=\"p-1 text-gray-400 hover:text-red-600\"\n                      aria-label=\"Delete message\"\n                    >\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                        <path fillRule=\"evenodd\" d=\"M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z\" clipRule=\"evenodd\" />\n                      </svg>\n                    </button>\n                  )}\n                </div>\n              )}\n            </div>\n          </div>\n        ))}\n        \n        {/* Loading indicator */}\n        {isLoading && (\n          <div className=\"flex items-center justify-center py-4\">\n            <div className=\"animate-pulse flex space-x-2\">\n              <div className=\"w-2 h-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"w-2 h-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"w-2 h-2 bg-gray-400 rounded-full\"></div>\n            </div>\n          </div>\n        )}\n        \n        {/* Error message */}\n        {error && (\n          <div className=\"bg-red-50 border border-red-200 text-red-600 rounded-lg p-3 my-4\">\n            <p className=\"font-medium\">Error</p>\n            <p className=\"text-sm\">{error.message}</p>\n          </div>\n        )}\n        \n        {/* Auto-scroll marker */}\n        <div ref={messagesEndRef}></div>\n      </div>\n    </div>\n  );\n};\n\n================================================================================\nFILE: src/components/ui/ChatPanel.tsx\n================================================================================\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Thread } from '@/types/thread';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface ChatPanelProps {\n  notebookId: string;\n  activeThreadId: string | null;\n  onClose: () => void;\n  onNewThreadCreated: (thread: Thread) => void;\n}\n\n/**\n * ChatPanel component for notebook side panel\n * Displays conversation threads and allows for new messages\n */\nconst ChatPanel: React.FC<ChatPanelProps> = ({\n  notebookId,\n  activeThreadId,\n  onClose,\n  onNewThreadCreated\n}) => {\n  const { user } = useAuth();\n  const [message, setMessage] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [threads, setThreads] = useState<Thread[]>([]);\n  const messageEndRef = useRef<HTMLDivElement>(null);\n  \n  // Load threads when panel opens\n  useEffect(() => {\n    const loadThreads = async () => {\n      setIsLoading(true);\n      console.log('ChatPanel: Loading threads for notebook:', notebookId);\n\n      try {\n        // This would be replaced with actual thread loading logic\n        // For now, we'll just show a placeholder message\n        setThreads([]);\n\n        // Later you can implement API call to load threads\n        // Example:\n        // const { data, error } = await supabase\n        //   .from('threads')\n        //   .select('*')\n        //   .eq('notebook_id', notebookId)\n        //   .order('created_at', { ascending: false });\n        //\n        // if (error) throw error;\n        // setThreads(data || []);\n\n      } catch (error) {\n        console.error('Error loading threads:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadThreads();\n    console.log('ChatPanel mounted for notebook:', notebookId);\n\n    return () => {\n      console.log('ChatPanel unmounted');\n    };\n  }, [notebookId]);\n  \n  // Scroll to bottom when new messages arrive\n  useEffect(() => {\n    messageEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [threads]);\n  \n  // Create a new thread or add message to existing thread\n  const handleSendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!message.trim() || !user) return;\n    \n    setIsLoading(true);\n    \n    try {\n      // Implement thread creation or message adding logic here\n      console.log('Sending message:', message);\n      \n      // Create a placeholder thread for demo purposes\n      const newThread: Thread = {\n        id: `thread-${Date.now()}`,\n        notebookId,\n        title: 'New Thread',\n        position: { x: 100, y: 100 },\n        messages: [\n          {\n            id: `msg-${Date.now()}`,\n            threadId: `thread-${Date.now()}`,\n            content: message,\n            role: 'user',\n            createdAt: new Date().toISOString()\n          }\n        ],\n        parentId: undefined,\n        referencedThreads: [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        cardType: 'note',\n        handwritingStyle: 'neat',\n        isMinimized: false,\n        zIndex: 1\n      };\n      \n      // Add the new thread to our local state\n      setThreads(prev => [...prev, newThread]);\n      \n      // Notify parent component\n      onNewThreadCreated(newThread);\n      \n      // Clear the input\n      setMessage('');\n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"w-80 h-full bg-white border-l border-gray-200 flex flex-col\">\n      {/* Header */}\n      <div className=\"p-4 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-lg\">Notebook Chat</h2>\n        <button\n          onClick={onClose}\n          className=\"rounded-full p-1 hover:bg-gray-100\"\n          aria-label=\"Close panel\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 text-gray-500\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n          </svg>\n        </button>\n      </div>\n      \n      {/* Chat messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {isLoading && threads.length === 0 ? (\n          <div className=\"flex justify-center py-10\">\n            <Spinner size=\"md\" color=\"primary\" label=\"Loading conversations...\" />\n          </div>\n        ) : threads.length === 0 ? (\n          <div className=\"text-center py-10 text-gray-500\">\n            <p>No conversations yet. Start by sending a message.</p>\n          </div>\n        ) : (\n          threads.map(thread => (\n            <div \n              key={thread.id} \n              className={`p-3 rounded-lg ${thread.id === activeThreadId ? 'bg-blue-50 border border-blue-100' : 'bg-gray-50'}`}\n            >\n              <div className=\"font-medium text-sm text-gray-700 mb-1\">{thread.title}</div>\n              <div className=\"space-y-2\">\n                {thread.messages.map(msg => (\n                  <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>\n                    <div className={`max-w-[80%] px-3 py-2 rounded-lg ${\n                      msg.role === 'user' \n                        ? 'bg-blue-600 text-white' \n                        : 'bg-gray-200 text-gray-800'\n                    }`}>\n                      {msg.content}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          ))\n        )}\n        <div ref={messageEndRef} />\n      </div>\n      \n      {/* Input area */}\n      <div className=\"p-4 border-t border-gray-200\">\n        <form onSubmit={handleSendMessage} className=\"flex\">\n          <input\n            type=\"text\"\n            placeholder=\"Type a message...\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n            disabled={isLoading}\n          />\n          <button\n            type=\"submit\"\n            className=\"px-4 py-2 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50\"\n            disabled={!message.trim() || isLoading}\n          >\n            {isLoading ? (\n              <Spinner size=\"sm\" color=\"white\" />\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            )}\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatPanel;\n\n================================================================================\nFILE: src/components/ui/LlamaChat.tsx\n================================================================================\n\n// src/components/ui/LlamaChat.tsx\n'use client';\n\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\nimport { \n  useNodes, \n  useNodeActions, \n  useSelectedNode, \n  useActiveNode,\n  useUnifiedStore,\n  useUnifiedActions,\n  useChatMessages,\n  useRelationships\n} from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { Node } from '@/types/thread';\n\n// Custom file upload button component\nconst FileUploadButton = () => {\n  return (\n    <div className=\"flex items-center\">\n      <button\n        type=\"button\"\n        className=\"inline-flex items-center p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100\"\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-5 w-5\"\n          viewBox=\"0 0 20 20\"\n          fill=\"currentColor\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      </button>\n    </div>\n  );\n};\n\n// Model selector component\nconst ModelSelector = ({ selectedModel, onChangeModel }: { \n  selectedModel: string; \n  onChangeModel: (model: string) => void;\n}) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\ninterface LlamaChatProps {\n  notebookId: string;\n  systemPrompt?: string;\n  fullScreen?: boolean;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string; // Add initial question parameter\n}\n\nconst LlamaChat: React.FC<LlamaChatProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  // Validate notebookId early\n  if (!notebookId) {\n    console.error('LlamaChat received empty notebookId');\n    return <div className=\"p-4 text-red-500\">Error: Missing notebook ID</div>;\n  }\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionCreatedRef = useRef(false);\n  const syncedNodeRef = useRef(null);\n  const didInitialSyncRef = useRef(false);\n  \n  // Get nodes and actions from the node store\n  const nodes = useNodes();\n  const relationships = useRelationships();\n  const activeNode = useActiveNode();\n  const selectedNode = useSelectedNode();\n  const { \n    addNode, \n    createNodeRelationship, \n    setSelectedNode, \n    setActiveNode \n  } = useNodeActions();\n  \n  // Get unified store actions\n  const unifiedActions = useUnifiedActions();\n  \n  // Implement these ourselves first so they can be referenced\n  const syncChatWithNodes = async (notebookId: string) => {\n    try {\n      // First ensure nodes are loaded\n      if (Object.keys(nodes).length === 0) {\n        // TODO: Load nodes if needed\n      }\n      \n      // Find conversation nodes (prefer questions as root nodes)\n      const conversationNodes = Object.values(nodes)\n        .filter(node => node.isConversationNode || node.messages?.length > 0)\n        .sort((a, b) => {\n          // Sort by type (questions first), then by creation time\n          if (a.type === 'question' && b.type !== 'question') return -1;\n          if (a.type !== 'question' && b.type === 'question') return 1;\n          return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();\n        });\n      \n      if (conversationNodes.length === 0) {\n        console.log('No conversation nodes found to sync');\n        return;\n      }\n      \n      // Extract all messages from conversation nodes\n      let allMessages: any[] = [];\n      \n      for (const node of conversationNodes) {\n        // If node has messages, add them directly\n        if (node.messages && node.messages.length > 0) {\n          allMessages = [\n            ...allMessages,\n            ...node.messages.map((msg: any) => ({\n              ...msg,\n              nodeId: node.id\n            }))\n          ];\n        } else {\n          // Create a synthetic message from the node content\n          allMessages.push({\n            id: `node_${node.id}`,\n            role: node.type === 'question' ? 'user' : 'assistant',\n            content: node.content,\n            created_at: node.created_at,\n            nodeId: node.id\n          });\n        }\n      }\n      \n      // Sort messages by creation time\n      allMessages.sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n      \n      // Update chat messages\n      setChatMessages(allMessages);\n    } catch (error) {\n      console.error('Error syncing chat with nodes:', error);\n    }\n  };\n  \n  const syncNodesToChat = async (threadNodeId: string) => {\n    try {\n      // Get the thread node\n      const threadNode = nodes[threadNodeId];\n      if (!threadNode) {\n        console.error(`Thread node ${threadNodeId} not found`);\n        return;\n      }\n      \n      // Get all related nodes (children)\n      const childNodes = Object.values(nodes).filter(node => {\n        return relationships.some(rel => \n          rel.from_node_id === threadNodeId && rel.to_node_id === node.id\n        );\n      });\n      \n      // Build a thread of messages starting with the thread node\n      let threadMessages: any[] = [];\n      \n      // Add messages from the thread node\n      if (threadNode.messages && threadNode.messages.length > 0) {\n        threadMessages = [\n          ...threadMessages,\n          ...threadNode.messages.map(msg => ({\n            ...msg,\n            nodeId: threadNode.id\n          }))\n        ];\n      } else {\n        // Create a synthetic message from the thread node\n        threadMessages.push({\n          id: `node_${threadNode.id}`,\n          role: threadNode.type === 'question' ? 'user' : 'assistant',\n          content: threadNode.content,\n          created_at: threadNode.created_at,\n          nodeId: threadNode.id\n        });\n      }\n      \n      // Add messages from child nodes (responses)\n      for (const childNode of childNodes) {\n        if (childNode.messages && childNode.messages.length > 0) {\n          threadMessages = [\n            ...threadMessages,\n            ...childNode.messages.map(msg => ({\n              ...msg,\n              nodeId: childNode.id\n            }))\n          ];\n        } else {\n          // Create a synthetic message from the child node\n          threadMessages.push({\n            id: `node_${childNode.id}`,\n            role: childNode.type === 'question' ? 'user' : 'assistant',\n            content: childNode.content,\n            created_at: childNode.created_at,\n            nodeId: childNode.id\n          });\n        }\n      }\n      \n      // Sort messages by creation time\n      threadMessages.sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n      \n      // Add system prompt at the beginning if not present\n      const hasSystemMessage = threadMessages.some(msg => msg.role === 'system');\n      if (!hasSystemMessage) {\n        threadMessages.unshift({\n          id: `system_${Date.now()}`,\n          role: 'system',\n          content: systemPrompt,\n          created_at: new Date().toISOString()\n        });\n      }\n      \n      // Update chat messages\n      setChatMessages(threadMessages);\n    } catch (error) {\n      console.error('Error syncing nodes to chat:', error);\n    }\n  };\n  \n  // Custom implementation of missing functions\n  const createNodeFromMessage = async (message: any, position?: any) => {\n    if (!notebookId) return null;\n    \n    // Determine node type based on message role\n    const nodeType = message.role === 'user' ? 'question' : 'response';\n    \n    // Find a position if not provided\n    if (!position) {\n      // Find open space on the canvas - simple algorithm for now\n      const allNodes = Object.values(nodes);\n      const avgX = allNodes.length > 0 \n        ? allNodes.reduce((sum, node) => sum + (node.position?.x || 0), 0) / allNodes.length \n        : 100;\n      const avgY = allNodes.length > 0 \n        ? allNodes.reduce((sum, node) => sum + (node.position?.y || 0), 0) / allNodes.length \n        : 100;\n      \n      // Position new nodes near the average position with some offset\n      position = {\n        x: avgX + (Math.random() * 200 - 100),\n        y: avgY + (Math.random() * 200 - 100)\n      };\n    }\n    \n    // Create a new node\n    const nodePayload: Partial<Node> = {\n      content: message.content,\n      type: nodeType,\n      notebook_id: notebookId,\n      position,\n      metadata: {\n        source: 'chat',\n        chatMessageId: message.id,\n        timestamp: message.created_at\n      },\n      // Store this as a conversation node with messages\n      messages: [{\n        id: message.id,\n        role: message.role,\n        content: message.content,\n        created_at: message.created_at\n      }],\n      isConversationNode: true\n    };\n    \n    try {\n      // Add node (also persists to database)\n      return await addNode(nodePayload as Node);\n    } catch (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n  };\n  \n  // Get all unified store methods at component level\n  const setNotebookId = useUnifiedStore(state => state.setNotebookId);\n  const setActiveThread = useUnifiedStore(state => state.setActiveThread);\n  const getActiveThreadNodeId = useUnifiedStore(state => state.activeThreadNodeId);\n  const isInitialized = useUnifiedStore(state => state.isInitialized);\n  \n  // Create the sync active thread function using our local methods\n  const syncActiveThreadFn = async () => {\n    const activeThreadId = getActiveThreadNodeId;\n    if (activeThreadId) {\n      try {\n        await syncNodesToChat(activeThreadId);\n      } catch (error) {\n        console.error('Error syncing active thread:', error);\n      }\n    }\n  };\n  \n  // Override unifiedStore's implementation functions with our local implementations\n  const unifiedStoreActions = {\n    ...unifiedActions,\n    createNodeFromMessage,\n    syncChatWithNodes,\n    syncNodesToChat,\n    syncActiveThread: syncActiveThreadFn\n  };\n  \n  // Use the overridden store actions\n  const { \n    addChatMessage = unifiedStoreActions.addChatMessage, \n    setChatMessages = unifiedStoreActions.setChatMessages\n  } = unifiedStoreActions;\n  \n  // Get chat messages and store instance\n  const chatMessages = useChatMessages();\n  \n  // Initialize the unified store with the notebook ID\n  useEffect(() => {\n    if (setNotebookId) {\n      setNotebookId(notebookId);\n    }\n  }, [notebookId, setNotebookId]);\n\n  // Initialize the chat handler with our simplified, more reliable API endpoint\n  const chatHandler = useChat({\n    api: '/api/claude/unified-chat', // Simplified API that avoids complex streaming issues\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt || 'You are a helpful assistant.' }\n    ],\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: true // Enable streaming for better UX\n    },\n    onResponse: (response) => {\n      // Called when a response is received\n      console.log('Chat response started:', response.status);\n    },\n    onFinish: async (message) => {\n      // Called when a message is completed\n      console.log('Message completed:', message);\n      console.log('Message content:', message.content);\n      \n      try {\n        // Create a node for the AI response message\n        if (message && message.content && message.content !== 'New response') {\n          // Ensure content is a valid string\n          const messageContent = typeof message.content === 'string' ? \n            message.content : \n            (message.content ? JSON.stringify(message.content) : 'Empty response');\n\n          // Create message object\n          const messageObj = {\n            id: message.id,\n            role: 'assistant',\n            content: messageContent,\n            created_at: new Date().toISOString()\n          };\n          \n          // Create node from message directly using nodeIntegration\n          const node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId\n          );\n          \n          // Create relationship with previous node if possible\n          if (node) {\n            // Get the last user message to create a relationship\n            const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n            if (userMessages.length > 0) {\n              const lastUserMessage = userMessages[userMessages.length - 1];\n              \n              // Find the node for the last user message\n              const userNodes = Object.values(nodes).filter(n => {\n                return n.messages && n.messages.some(m => m.id === lastUserMessage.id);\n              });\n              \n              if (userNodes.length > 0) {\n                await nodeIntegration.createNodeRelationship(\n                  userNodes[0].id,\n                  node.id,\n                  'extends',\n                  notebookId\n                );\n              }\n            }\n            \n            // Also add to chat messages store for consistency\n            await addChatMessage(messageObj, false); // false = don't create node (already created)\n          }\n          \n          // If we have an active thread, attempt to synchronize\n          if (getActiveThreadNodeId) {\n            try {\n              await syncActiveThreadFn();\n            } catch (syncError) {\n              console.error('Error syncing with active thread:', syncError);\n            }\n          }\n        } else if (message.content === 'New response') {\n          console.log('Skipping placeholder content \"New response\"');\n        } else {\n          console.error('Received empty message from AI', message);\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n  \n  // Sync chat handler messages with unified store (one-way, unified store -> chat handler)\n  useEffect(() => {\n    // When unified store messages change, update chat handler if significantly different\n    const unifiedMessages = chatMessages;\n    const chatHandlerMessages = chatHandler.messages;\n    \n    // Skip if no messages or if processing - prevent loop\n    if (unifiedMessages.length === 0 || isProcessing) return;\n    \n    // Check if significantly different (different number of messages or last message content differs)\n    const isDifferent = \n      unifiedMessages.length !== chatHandlerMessages.length ||\n      (unifiedMessages.length > 0 && chatHandlerMessages.length > 0 &&\n       unifiedMessages[unifiedMessages.length - 1].content !== \n       chatHandlerMessages[chatHandlerMessages.length - 1].content);\n    \n    if (isDifferent) {\n      // Convert from unified store format to chat handler format\n      const newChatMessages = unifiedMessages.map(msg => ({\n        id: msg.id,\n        role: msg.role,\n        content: msg.content\n      }));\n      \n      // Set messages in chat handler\n      chatHandler.setMessages(newChatMessages);\n    }\n  }, [chatMessages, chatHandler, isProcessing]);\n\n  // Handle model change\n  const handleModelChange = useCallback((model: string) => {\n    setModelId(model);\n  }, []);\n\n  // Override the submit handler to create nodes\n  const handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Add user message to unified store and create node\n      const messageContent = content && typeof content === 'string' ? content.trim() : '';\n      if (!messageContent) {\n        console.error('Empty message content, skipping submission');\n        setIsProcessing(false);\n        return;\n      }\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: messageContent,\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node directly using nodeIntegration\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // If we have an active node, create a relationship\n      if (node && activeNode) {\n        await nodeIntegration.createNodeRelationship(\n          activeNode.id,\n          node.id,\n          'extends',\n          notebookId\n        );\n      }\n      \n      // Also add to chat messages store for consistency\n      await addChatMessage(messageObj, false); // false = don't create node (already created)\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Call the chat handler manually to avoid double-submission\n      // This will update messages array and trigger API call\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: messageContent,\n      });\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [addChatMessage, chatHandler, isProcessing, notebookId, activeNode]);\n\n  // Create a new thread or conversation\n  const handleCreateNewThread = useCallback(() => {\n    // Clear active node selection\n    setSelectedNode(null);\n    setActiveNode(null);\n    if (setActiveThread) {\n      setActiveThread(null);\n    }\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n    setChatMessages(systemMessages.map(msg => ({\n      ...msg,\n      created_at: new Date().toISOString()\n    })));\n  }, [setSelectedNode, setActiveNode, chatHandler, setChatMessages, setActiveThread]);\n  \n  // Create initial question node if provided\n  useEffect(() => {\n    const createInitialQuestion = async () => {\n      // Skip if already created, no initial question, or processing\n      if (initialQuestionCreatedRef.current || !initialQuestion || isProcessing) {\n        return;\n      }\n\n      // Skip if any messages already exist\n      if (chatMessages.length > 1) { // More than just system message\n        initialQuestionCreatedRef.current = true;\n        return;\n      }\n\n      // Create the initial question\n      try {\n        setIsProcessing(true);\n        initialQuestionCreatedRef.current = true;\n        \n        // Add initial question to chat\n        await addChatMessage({\n          role: 'user',\n          content: initialQuestion\n        }, true);\n        \n        // Update chat handler\n        chatHandler.setInput('');\n        chatHandler.setMessages([\n          ...chatHandler.messages,\n          {\n            id: `initial-question-${Date.now()}`,\n            role: 'user',\n            content: initialQuestion\n          }\n        ]);\n        \n        // Trigger AI response using the API\n        const response = await fetch('/api/claude/chat', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            messages: [\n              { role: 'system', content: systemPrompt },\n              { role: 'user', content: initialQuestion }\n            ],\n            notebookId,\n            model: modelId,\n            includeUserContext: true\n          })\n        });\n        \n        if (response.ok) {\n          const responseData = await response.json();\n          \n          // Extract text content from response\n          let aiResponseText = '';\n          if (responseData.content && Array.isArray(responseData.content)) {\n            aiResponseText = responseData.content\n              .filter((block: any) => block.type === 'text')\n              .map((block: any) => block.text)\n              .join('\\n');\n          } else if (typeof responseData.content === 'string') {\n            aiResponseText = responseData.content;\n          }\n          \n          // Add AI response to chat\n          if (aiResponseText) {\n            await addChatMessage({\n              role: 'assistant',\n              content: aiResponseText\n            }, true);\n            \n            // Update chat handler messages\n            chatHandler.setMessages([\n              ...chatHandler.messages,\n              {\n                id: `initial-response-${Date.now()}`,\n                role: 'assistant',\n                content: aiResponseText\n              }\n            ]);\n          }\n        }\n      } catch (error) {\n        console.error('Error creating initial question:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    };\n\n    createInitialQuestion();\n  }, [initialQuestion, notebookId, modelId, systemPrompt, chatMessages, addChatMessage, chatHandler, isProcessing]);\n  \n  // REMOVED sync with active thread - this causes infinite loops\n  // Instead, set active thread once when node changes\n  useEffect(() => {\n    if (activeNode && !isProcessing) {\n      const activeNodeId = activeNode.id;\n      if (setActiveThread) {\n        setActiveThread(activeNodeId);\n      }\n    }\n  }, [activeNode, isProcessing, setActiveThread]);\n  \n  // REMOVED automatic sync on mount - caused infinite loops\n  // User can manually sync with the button when needed\n\n  // Debug information for development\n  const nodeCount = Object.keys(nodes).length;\n  const messageCount = chatHandler.messages.length;\n  const visibleMessages = chatHandler.messages.filter(msg => msg.role !== 'system' && msg.content !== 'New response');\n  \n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (activeNode.type === 'question' ? 'Question' : 'Conversation') : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={handleCreateNewThread}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"New conversation\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n          {onClose && (\n            <button \n              onClick={onClose}\n              className=\"text-gray-500 hover:text-gray-700\"\n              aria-label=\"Close panel\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n      \n      {/* Chat UI */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ChatSection handler={chatHandler} className=\"h-full\">\n          <ChatMessages className=\"h-[calc(100%-80px)] overflow-y-auto p-4\" />\n          <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n            <ChatInput.Form className=\"px-3 py-2\">\n              <ChatInput.Field \n                type=\"textarea\" \n                placeholder=\"Type your message...\" \n                className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n                disabled={chatHandler.isLoading || isProcessing}\n              />\n              <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n                <ModelSelector\n                  selectedModel={modelId}\n                  onChangeModel={handleModelChange}\n                />\n                <ChatInput.Upload>\n                  <FileUploadButton />\n                </ChatInput.Upload>\n              </div>\n              <ChatInput.Submit\n                disabled={chatHandler.isLoading || isProcessing}\n                className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n              >\n                {chatHandler.isLoading || isProcessing ? (\n                  <div className=\"h-5 w-5 border-2 border-white border-t-transparent rounded-full animate-spin\"></div>\n                ) : (\n                  <svg className=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                    <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                  </svg>\n                )}\n              </ChatInput.Submit>\n            </ChatInput.Form>\n          </ChatInput>\n        </ChatSection>\n      </div>\n      \n      {/* Information footer */}\n      <div className=\"px-3 py-1 text-xs text-gray-500 bg-gray-50 border-t border-gray-200\">\n        <div className=\"flex justify-between\">\n          <span>All messages appear as cards on the canvas</span>\n          <div className=\"flex space-x-2\">\n            {activeNode && (\n              <span className=\"text-blue-500 cursor-pointer\" onClick={() => {\n                setActiveNode(null);\n                if (setActiveThread) {\n                  setActiveThread(null);\n                }\n                // Don't automatically sync\n              }}>\n                View all threads\n              </span>\n            )}\n            <span className=\"text-blue-500 cursor-pointer\" onClick={() => {\n              try {\n                if (activeNode) {\n                  // Manual sync button to avoid loops\n                  setTimeout(() => {\n                    try {\n                      syncNodesToChat(activeNode.id);\n                    } catch (error) {\n                      console.error('Error in manual sync:', error);\n                    }\n                  }, 100);\n                } else {\n                  setTimeout(() => {\n                    try {\n                      syncChatWithNodes(notebookId);\n                    } catch (error) {\n                      console.error('Error in manual sync:', error);\n                    }\n                  }, 100);\n                }\n              } catch (error) {\n                console.error('Error in sync button:', error);\n              }\n            }}>\n              Sync messages\n            </span>\n          </div>\n        </div>\n        \n        {/* Debug information overlay */}\n        <div className=\"mt-1 p-1 bg-blue-50 rounded text-xs\">\n          <div className=\"flex justify-between\">\n            <span>Nodes: {nodeCount}</span>\n            <span>Message count: {messageCount}</span>\n            <span>Visible messages: {visibleMessages.length}</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default LlamaChat;\n\n================================================================================\nFILE: src/components/ui/LlamaChat.updated.tsx\n================================================================================\n\n/**\n * LlamaChat Component\n * \n * A redesigned chat component using the new chat architecture\n */\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\nimport { \n  useNodes, \n  useNodeActions,\n  useActiveNode,\n} from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { useChatNodeSync } from '@/hooks/useChatNodeSync';\nimport { Spinner } from '../shadcn/spinner';\n\n// Model selector component - extracted for cleaner code\nconst ModelSelector = ({ selectedModel, onChangeModel }: { \n  selectedModel: string; \n  onChangeModel: (model: string) => void;\n}) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\ninterface LlamaChatProps {\n  notebookId: string;\n  systemPrompt?: string;\n  fullScreen?: boolean;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string;\n}\n\nconst LlamaChat: React.FC<LlamaChatProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  // Validate notebookId early\n  if (!notebookId) {\n    console.error('LlamaChat received empty notebookId');\n    return <div className=\"p-4 text-red-500\">Error: Missing notebook ID</div>;\n  }\n\n  // State management\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionCreatedRef = useRef(false);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const activeNode = useActiveNode();\n  const { \n    addNode, \n    createNodeRelationship,\n    setActiveNode \n  } = useNodeActions();\n  \n  // Chat-node synchronization\n  const { \n    syncNodeToChat, \n    findNodeByMessageId,\n    syncChatToNodes\n  } = useChatNodeSync({ notebookId });\n  \n  // Initialize chat with Vercel AI SDK\n  const chatHandler = useChat({\n    api: '/api/claude/unified-chat',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: true\n    },\n    onResponse: (response) => {\n      console.log('Chat response started:', response.status);\n    },\n    onFinish: async (message) => {\n      try {\n        // Create a node for the AI response\n        if (message && message.content) {\n          const messageObj = {\n            id: message.id,\n            role: 'assistant',\n            content: message.content,\n            created_at: new Date().toISOString()\n          };\n          \n          // Create node from message\n          const node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId\n          );\n          \n          // Create relationship with previous node if possible\n          if (node) {\n            // Get the last user message (which should be the question this response answers)\n            const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n            if (userMessages.length > 0) {\n              const lastUserMessage = userMessages[userMessages.length - 1];\n              const userNode = findNodeByMessageId(lastUserMessage.id);\n              \n              if (userNode) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  node.id,\n                  'extends',\n                  notebookId\n                );\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle model change\n  const handleModelChange = useCallback((model: string) => {\n    setModelId(model);\n  }, []);\n\n  // Handle message submission\n  const handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user' as const,\n        content: content.trim(),\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node for user message\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // If we have an active node, create a relationship\n      if (node && activeNode) {\n        await nodeIntegration.createNodeRelationship(\n          activeNode.id,\n          node.id,\n          'extends',\n          notebookId\n        );\n      }\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Send message to AI\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n      });\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [notebookId, isProcessing, chatHandler, activeNode]);\n\n  // Create a new thread\n  const handleCreateNewThread = useCallback(() => {\n    // Reset active node\n    setActiveNode(null);\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n  }, [setActiveNode, chatHandler]);\n  \n  // Send initial question if provided\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionCreatedRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionCreatedRef.current = true;\n          setIsProcessing(true);\n          \n          // Create message ID\n          const messageId = `initial-question-${Date.now()}`;\n          \n          // Create node for the question\n          const questionNode = await nodeIntegration.createNodeFromMessage(\n            {\n              id: messageId,\n              role: 'user',\n              content: initialQuestion,\n              created_at: new Date().toISOString()\n            },\n            notebookId\n          );\n          \n          // Send to chat\n          chatHandler.append({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          });\n        } catch (error) {\n          console.error('Error sending initial question:', error);\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler, notebookId]);\n  \n  // Sync with active node when it changes\n  useEffect(() => {\n    if (activeNode && !isProcessing) {\n      syncNodeToChat(activeNode.id).catch(error => {\n        console.error('Error syncing with active node:', error);\n      });\n    }\n  }, [activeNode, isProcessing, syncNodeToChat]);\n  \n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (activeNode.type === 'question' ? 'Question' : 'Conversation') : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={handleCreateNewThread}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"New conversation\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n          {onClose && (\n            <button \n              onClick={onClose}\n              className=\"text-gray-500 hover:text-gray-700\"\n              aria-label=\"Close panel\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n      \n      {/* Chat UI */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ChatSection handler={chatHandler} className=\"h-full\">\n          <ChatMessages className=\"h-[calc(100%-80px)] overflow-y-auto p-4\" />\n          <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n            <ChatInput.Form className=\"px-3 py-2\">\n              <ChatInput.Field \n                type=\"textarea\" \n                placeholder=\"Type your message...\" \n                className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n                disabled={chatHandler.isLoading || isProcessing}\n              />\n              <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n                <ModelSelector\n                  selectedModel={modelId}\n                  onChangeModel={handleModelChange}\n                />\n              </div>\n              <ChatInput.Submit\n                disabled={chatHandler.isLoading || isProcessing}\n                className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n              >\n                {chatHandler.isLoading || isProcessing ? (\n                  <Spinner className=\"h-5 w-5 border-2 border-white border-t-transparent\" />\n                ) : (\n                  <svg className=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                    <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                  </svg>\n                )}\n              </ChatInput.Submit>\n            </ChatInput.Form>\n          </ChatInput>\n        </ChatSection>\n      </div>\n      \n      {/* Information footer */}\n      <div className=\"px-3 py-1 text-xs text-gray-500 bg-gray-50 border-t border-gray-200\">\n        <div className=\"flex justify-between\">\n          <span>All messages appear as cards on the canvas</span>\n          <div className=\"flex space-x-2\">\n            {activeNode && (\n              <span className=\"text-blue-500 cursor-pointer\" onClick={() => {\n                setActiveNode(null);\n              }}>\n                View all threads\n              </span>\n            )}\n            <span \n              className=\"text-blue-500 cursor-pointer\" \n              onClick={() => syncChatToNodes()}\n            >\n              Sync messages\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default LlamaChat;\n\n================================================================================\nFILE: src/components/ui/SimpleChatPanel.tsx\n================================================================================\n\n/**\n * SimpleChatPanel Component\n * \n * A clean, simple chat interface using Vercel AI SDK\n */\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useChat, type Message } from 'ai/react';\nimport { Button } from '@/components/shadcn/button';\nimport { Textarea } from '@/components/shadcn/textarea';\nimport { Spinner } from '@/components/shadcn/spinner';\nimport { nodeIntegration } from '@/lib/chat';\nimport { supabase } from '@/lib/supabaseClient';\n\ninterface SimpleChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string;\n}\n\nexport const SimpleChatPanel: React.FC<SimpleChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionSentRef = useRef(false);\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  \n  // Initialize chat with Vercel AI SDK\n  const chatHandler = useChat({\n    api: '/api/claude/unified-chat',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: 'claude-3-sonnet-20240229',\n      includeUserContext: true,\n      stream: true\n    },\n    onResponse: (response) => {\n      console.log('Chat response started:', response.status);\n    },\n    onFinish: async (message) => {\n      try {\n        // Create a node for the AI response\n        if (message?.content) {\n          await handleNodeCreation(message, 'assistant');\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle node creation\n  const handleNodeCreation = async (message: Message, role: 'user' | 'assistant') => {\n    try {\n      // Create node from message\n      const node = await nodeIntegration.createNodeFromMessage(\n        message,\n        notebookId\n      );\n      \n      // Create relationship if needed\n      if (node && role === 'assistant') {\n        // Find the last user message node to connect to\n        const userMessageNode = await findUserMessageNode();\n        if (userMessageNode) {\n          await nodeIntegration.createNodeRelationship(\n            userMessageNode.id,\n            node.id,\n            'extends',\n            notebookId\n          );\n        }\n      }\n      \n      return node;\n    } catch (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n  };\n  \n  // Find the most recent user message node\n  const findUserMessageNode = async () => {\n    try {\n      const { data } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .eq('type', 'question')\n        .order('created_at', { ascending: false })\n        .limit(1)\n        .single();\n      \n      return data;\n    } catch (error) {\n      console.error('Error finding user message node:', error);\n      return null;\n    }\n  };\n\n  // Handle message submission\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!inputRef.current?.value.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Get message content\n      const content = inputRef.current.value.trim();\n      \n      // Generate unique ID\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user' as const,\n        content,\n        createdAt: new Date()\n      };\n      \n      // Send message to AI\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content,\n      });\n      \n      // Clear input\n      inputRef.current.value = '';\n      \n      // Create node for user message\n      await handleNodeCreation(messageObj, 'user');\n    } catch (error) {\n      console.error('Error sending message:', error);\n      setIsProcessing(false);\n    }\n  };\n  \n  // Send initial question if provided\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionSentRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionSentRef.current = true;\n          setIsProcessing(true);\n          \n          // Create message ID\n          const messageId = `initial-question-${Date.now()}`;\n          \n          // Send to chat\n          chatHandler.append({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          });\n        } catch (error) {\n          console.error('Error sending initial question:', error);\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler]);\n  \n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow-md ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">Chat</h2>\n        {onClose && (\n          <Button \n            onClick={onClose}\n            size=\"sm\"\n            variant=\"ghost\"\n            aria-label=\"Close panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </Button>\n        )}\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        {chatHandler.messages.filter(msg => msg.role !== 'system').map((message) => (\n          <div \n            key={message.id} \n            className={`mb-4 ${message.role === 'user' ? 'ml-auto max-w-[80%]' : 'mr-auto max-w-[80%]'}`}\n          >\n            <div \n              className={`p-3 rounded-lg ${\n                message.role === 'user' \n                  ? 'bg-blue-500 text-white' \n                  : 'bg-gray-100 text-gray-800'\n              }`}\n            >\n              {message.content}\n            </div>\n          </div>\n        ))}\n        {chatHandler.isLoading && (\n          <div className=\"flex justify-center items-center p-4\">\n            <Spinner className=\"w-6 h-6 text-blue-500\" />\n          </div>\n        )}\n      </div>\n      \n      {/* Input */}\n      <form onSubmit={handleSubmit} className=\"border-t border-gray-200 p-3\">\n        <div className=\"relative\">\n          <Textarea\n            ref={inputRef}\n            placeholder=\"Type your message...\"\n            className=\"resize-none min-h-[80px] pr-16\"\n            disabled={isProcessing || chatHandler.isLoading}\n          />\n          <Button \n            type=\"submit\"\n            className=\"absolute bottom-2 right-2\"\n            disabled={isProcessing || chatHandler.isLoading}\n          >\n            {isProcessing || chatHandler.isLoading ? (\n              <Spinner className=\"w-5 h-5\" />\n            ) : (\n              <svg className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n              </svg>\n            )}\n          </Button>\n        </div>\n        <p className=\"text-xs text-gray-500 mt-1\">\n          All messages appear as cards on the canvas\n        </p>\n      </form>\n    </div>\n  );\n};\n\nexport default SimpleChatPanel;\n\n================================================================================\nFILE: src/components/ui/UnifiedChatPanel.tsx\n================================================================================\n\nimport React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';\nimport { useAIInteraction } from '@/hooks/useAIInteraction';\nimport { \n  useNodes, \n  useNodeActions, \n  useSelectedNode, \n  useActiveNode,\n  useNodeStore\n} from '@/stores';\nimport { Node, CardType, RelationshipType } from '@/types/thread';\n\ninterface UnifiedChatPanelProps {\n  notebookId: string;\n  fullScreen?: boolean;\n  onClose?: () => void;\n  filterNodeType?: string | null;\n}\n\nconst UnifiedChatPanel: React.FC<UnifiedChatPanelProps> = ({ \n  notebookId, \n  fullScreen = false,\n  onClose,\n  filterNodeType\n}) => {\n  const [message, setMessage] = useState('');\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  // Get nodes and actions from the store\n  const nodes = useNodes();\n  const selectedNode = useSelectedNode();\n  const activeNode = useActiveNode();\n  const { \n    addNode, \n    createNodeRelationship, \n    setSelectedNode, \n    setActiveNode \n  } = useNodeActions();\n\n  // Initialize AI interaction hook\n  const { sendToAI, isProcessing, error: aiError } = useAIInteraction({\n    notebookId\n  });\n\n  // Scroll to bottom when messages change\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  };\n\n  useEffect(() => {\n    scrollToBottom();\n  }, [nodes]);\n\n  // Get conversation thread as a flat list sorted by creation time\n  const conversationNodes = useMemo(() => {\n    const nodeArray = Object.values(nodes)\n      .filter(node => {\n        // Apply type filter if specified\n        if (filterNodeType) {\n          return node.type === filterNodeType;\n        }\n        // Only show question and response nodes in chat view\n        return node.type === 'question' || node.type === 'response';\n      })\n      .sort((a, b) => {\n        return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();\n      });\n    \n    // If active node is set, prioritize showing its thread\n    if (activeNode) {\n      const { getConnectedNodes } = useNodeStore.getState();\n      const connectedNodes = getConnectedNodes(activeNode.id);\n      const connectedIds = new Set([activeNode.id, ...connectedNodes.map(node => node.id)]);\n      \n      // If we have a connected thread, filter to show only those nodes\n      if (connectedIds.size > 1) {\n        return nodeArray.filter(node => connectedIds.has(node.id));\n      }\n    }\n    \n    return nodeArray;\n  }, [nodes, filterNodeType, activeNode]);\n\n  // Handle sending a new message\n  const handleSendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    if (!message.trim() || isSubmitting || isProcessing) return;\n\n    setIsSubmitting(true);\n\n    try {\n      // Determine if this is starting a new thread or continuing an existing one\n      const isNewThread = !activeNode;\n      const isQuestion = isNewThread || activeNode?.type === 'response';\n      \n      // Generate a position for the message node\n      let position = { x: 100, y: 100 };\n      \n      if (activeNode) {\n        if (isQuestion) {\n          // Place question nodes below the active node in the thread\n          position = {\n            x: activeNode.position?.x || 100,\n            y: (activeNode.position?.y || 100) + 150 // Below current node\n          };\n        } else {\n          // Place response nodes to the right of the question\n          position = {\n            x: (activeNode.position?.x || 100) + 200, // To the right of the question\n            y: activeNode.position?.y || 100 // Same vertical level\n          };\n        }\n      } else {\n        // For a brand new thread, randomly offset position slightly\n        const randomOffset = Math.floor(Math.random() * 50);\n        position = {\n          x: 100 + randomOffset,\n          y: 100 + randomOffset\n        };\n      }\n      \n      // Create metadata for better searchability\n      const metadata: Record<string, any> = {\n        source: 'chat',\n        timestamp: new Date().toISOString()\n      };\n\n      // Ensure proper UUID \n      const generateValidUUID = () => {\n        if (crypto.randomUUID) {\n          return crypto.randomUUID();\n        } else {\n          // Fallback UUID v4 generator for older browsers\n          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            const r = Math.random() * 16 | 0;\n            const v = c === 'x' ? r : (r & 0x3 | 0x8);\n            return v.toString(16);\n          });\n        }\n      };\n\n      // Create a new node for the user's message\n      const userNode: Partial<Node> = {\n        id: generateValidUUID(), // Explicitly generate a valid UUID\n        content: message,\n        type: isQuestion ? 'question' : 'response',\n        notebook_id: notebookId,\n        position,\n        metadata\n      };\n\n      // Add user message node to the store and database\n      console.log(\"Creating node with data:\", JSON.stringify(userNode));\n      const newUserNode = await addNode(userNode as Node);\n      \n      if (!newUserNode) {\n        console.error(\"Node creation returned null or undefined\");\n        throw new Error('Failed to create user message node');\n      }\n\n      // If there's an active node, create a relationship\n      if (activeNode) {\n        try {\n          await createNodeRelationship(\n            activeNode.id, \n            newUserNode.id, \n            'extends', // Thread relationship\n            notebookId,\n            { // Add vector properties for more meaningful relationships\n              direction: 'outgoing',\n              intention: 'continuation',\n              state: 'active'\n            }\n          );\n        } catch (relError) {\n          console.error(\"Error creating relationship:\", relError);\n          // Continue even if relationship creation fails\n        }\n      }\n\n      // Set as the new active node\n      setSelectedNode(newUserNode.id);\n      setActiveNode(newUserNode.id);\n\n      // Reset input early for better UX\n      const userMessage = message;\n      setMessage('');\n\n      // Build a coherent conversation history for AI context\n      // Get all connected nodes in this thread for better context\n      const { getConnectedNodes } = useNodeStore.getState();\n      let threadNodes = [newUserNode];\n      \n      if (activeNode) {\n        // Get all nodes connected in this thread\n        const connectedNodes = getConnectedNodes(activeNode.id);\n        threadNodes = [...connectedNodes, activeNode, newUserNode]\n          .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n      }\n      \n      // Create message history from thread nodes\n      const previousMessages = threadNodes.map(node => ({\n        role: node.type === 'question' ? 'user' : 'assistant',\n        content: node.content\n      }));\n\n      // Send to AI with thread context\n      const aiResponse = await sendToAI(userMessage, previousMessages);\n\n      if (aiResponse.response) {\n        // Create AI response node\n        const responseNode: Partial<Node> = {\n          content: aiResponse.response,\n          type: 'response',\n          notebook_id: notebookId,\n          position: {\n            x: newUserNode.position?.x as number + 200, // Position to the right\n            y: newUserNode.position?.y as number // Same vertical position as question\n          },\n          metadata: {\n            source: 'ai',\n            timestamp: new Date().toISOString(),\n            model: 'claude' // Track which AI model generated this\n          }\n        };\n\n        // Add response node\n        const newResponseNode = await addNode(responseNode as Node);\n        \n        if (!newResponseNode) {\n          throw new Error('Failed to create AI response node');\n        }\n\n        // Create relationship between user message and AI response\n        await createNodeRelationship(\n          newUserNode.id, \n          newResponseNode.id, \n          'extends', \n          notebookId,\n          { // Add vector properties\n            direction: 'outgoing',\n            intention: 'response',\n            state: 'active'\n          }\n        );\n\n        // Set as the new active node\n        setSelectedNode(newResponseNode.id);\n        setActiveNode(newResponseNode.id);\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsSubmitting(false);\n      // Scroll to bottom after processing\n      setTimeout(scrollToBottom, 100);\n    }\n  };\n\n  // Create a new thread or conversation\n  const handleCreateNewThread = useCallback(() => {\n    // Clear active node selection\n    setSelectedNode(null);\n    setActiveNode(null);\n    \n    // Position for new thread (offset from previous threads)\n    const threadCount = Object.values(nodes).filter(n => n.type === 'question').length;\n    const offset = threadCount * 50;\n    \n    // Create a visual offset for each new thread\n    const startPos = {\n      x: 100 + offset,\n      y: 100 + offset\n    };\n    \n    // Update state to indicate we're starting a new thread\n    // This doesn't create a node yet, but will position the next node at this location\n    setMessage(''); // Clear any existing draft message\n  }, [setSelectedNode, setActiveNode, nodes]);\n\n  return (\n    <div className={`bg-white border-l border-gray-200 h-full flex flex-col ${fullScreen ? 'w-full' : ''}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (activeNode.type === 'question' ? 'Question' : 'Conversation') : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={handleCreateNewThread}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"New conversation\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n          <button\n            onClick={() => scrollToBottom()}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"Scroll to bottom\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z\" clipRule=\"evenodd\" style={{ transform: \"rotate(180deg)\", transformOrigin: \"center\" }} />\n            </svg>\n          </button>\n          {onClose && (\n            <button \n              onClick={onClose}\n              className=\"text-gray-500 hover:text-gray-700\"\n              aria-label=\"Close panel\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n      \n      {/* Messages area */}\n      <div className=\"flex-1 overflow-y-auto p-3\">\n        {conversationNodes.length === 0 ? (\n          <div className=\"text-center text-gray-500 mt-8\">\n            <p>No messages yet</p>\n            <p className=\"text-sm mt-2\">Start by typing a message below</p>\n          </div>\n        ) : (\n          <div className=\"space-y-4\">\n            {conversationNodes.map(node => (\n              <div\n                key={node.id}\n                className={`flex ${node.type === 'question' ? 'justify-end' : 'justify-start'}`}\n                onClick={() => {\n                  setSelectedNode(node.id);\n                  setActiveNode(node.id);\n                }}\n              >\n                <div\n                  className={`max-w-[80%] p-3 rounded-lg ${\n                    node.type === 'question'\n                      ? 'bg-blue-600 text-white'\n                      : 'bg-gray-200 text-gray-800'\n                  } ${selectedNode?.id === node.id ? 'border-2 border-blue-400' : ''}`}\n                >\n                  <div className=\"relative\">\n                    {/* Content */}\n                    <div>{node.content}</div>\n                    \n                    {/* Timestamp */}\n                    {node.metadata?.timestamp && (\n                      <div className=\"text-xs opacity-70 mt-2 text-right\">\n                        {new Date(node.metadata.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}\n                      </div>\n                    )}\n                    \n                    {/* Node ID - helpful for debugging */}\n                    <div className=\"absolute right-0 -bottom-4 text-[8px] text-gray-400\">\n                      {node.id ? node.id.substring(0, 8) : ''}\n                    </div>\n                  </div>\n                </div>\n              </div>\n            ))}\n\n            {/* Show processing indicator */}\n            {isProcessing && (\n              <div className=\"flex justify-start\">\n                <div className=\"max-w-[80%] p-3 rounded-lg bg-gray-200 text-gray-800 flex items-center\">\n                  <div className=\"animate-pulse mr-2\">\n                    <div className=\"h-2 w-2 bg-gray-500 rounded-full mr-1 inline-block\"></div>\n                    <div className=\"h-2 w-2 bg-gray-500 rounded-full mr-1 inline-block animate-pulse delay-100\"></div>\n                    <div className=\"h-2 w-2 bg-gray-500 rounded-full inline-block animate-pulse delay-200\"></div>\n                  </div>\n                  <span className=\"text-sm text-gray-500\">Thinking...</span>\n                </div>\n              </div>\n            )}\n\n            {/* Show error messages if any */}\n            {aiError && (\n              <div className=\"flex justify-center\">\n                <div className=\"max-w-[90%] p-2 rounded-lg bg-red-50 text-red-600 text-sm\">\n                  Error: {aiError}\n                </div>\n              </div>\n            )}\n            \n            {/* Empty div for scrolling to bottom */}\n            <div ref={messagesEndRef} />\n          </div>\n        )}\n      </div>\n      \n      {/* Message input */}\n      <div className=\"p-3 border-t border-gray-200\">\n        <form onSubmit={handleSendMessage} className=\"flex items-center\">\n          <input\n            type=\"text\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n            placeholder=\"Type a question or message...\"\n            className=\"flex-1 p-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-blue-500\"\n            disabled={isSubmitting || isProcessing}\n          />\n          <button\n            type=\"submit\"\n            disabled={!message.trim() || isSubmitting || isProcessing}\n            className=\"bg-blue-600 text-white p-2 rounded-r-md disabled:bg-gray-400\"\n          >\n            {isSubmitting || isProcessing ? (\n              <div className=\"h-5 w-5 border-2 border-white border-t-transparent rounded-full animate-spin\"></div>\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n              </svg>\n            )}\n          </button>\n        </form>\n        <div className=\"mt-1 text-xs text-gray-500 flex justify-between items-center\">\n          <span>All messages appear as cards on the canvas</span>\n          {activeNode && (\n            <span className=\"text-blue-500 cursor-pointer\" onClick={() => setActiveNode(null)}>View all threads</span>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default React.memo(UnifiedChatPanel);\n\n================================================================================\nFILE: src/hooks/useAIChat.ts\n================================================================================\n\n// src/hooks/useAIChat.ts\nimport { useCallback, useState } from 'react';\nimport { useChat } from 'ai/react';\nimport { Message } from 'ai';\n\nexport interface UseAIChatOptions {\n  /**\n   * The ID of the notebook for context\n   */\n  notebookId: string;\n  /**\n   * Optional system prompt to control the AI's behavior\n   */\n  systemPrompt?: string;\n  /**\n   * Whether to include user context processing\n   */\n  includeUserContext?: boolean;\n  /**\n   * The model to use\n   */\n  model?: string;\n  /**\n   * API endpoint to use\n   */\n  api?: string;\n}\n\n/**\n * AI chat hook built on Vercel AI SDK using React hooks\n */\nexport function useAIChat({\n  notebookId,\n  systemPrompt,\n  includeUserContext = true,\n  model = 'claude-3-5-sonnet-20240620',\n  api = '/api/ai/chat'\n}: UseAIChatOptions) {\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Initialize the Vercel AI SDK chat hook\n  const {\n    messages,\n    input,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    setMessages,\n    append,\n    reload,\n    stop,\n    status\n  } = useChat({\n    api,\n    body: {\n      notebookId,\n      model,\n      includeUserContext\n    },\n    // Include system message if provided\n    initialMessages: systemPrompt \n      ? [{ id: 'system-1', role: 'system', content: systemPrompt }] \n      : [],\n    // Handle errors gracefully\n    onError: (err) => {\n      console.error('Chat error:', err);\n      setError(err);\n    }\n  });\n\n  /**\n   * Converts chat messages to the format expected by the API\n   */\n  const getFormattedHistory = useCallback(() => {\n    return messages.map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n  }, [messages]);\n\n  /**\n   * Sends a message directly without using the form handling\n   */\n  const sendMessage = useCallback(async (content: string) => {\n    try {\n      setError(null);\n      \n      // Generate unique ID for the message\n      const id = Math.random().toString(36).substring(2, 10);\n      \n      // Add user message to the chat\n      const userMessage: Message = {\n        id,\n        role: 'user',\n        content\n      };\n      \n      // Append the message and get the assistant's response\n      await append(userMessage);\n      \n      return true;\n    } catch (err) {\n      console.error('Failed to send message:', err);\n      setError(err instanceof Error ? err : new Error('Unknown error sending message'));\n      return false;\n    }\n  }, [append]);\n\n  /**\n   * Resets the conversation while maintaining the system message\n   */\n  const resetConversation = useCallback(() => {\n    const systemMessages = messages.filter(msg => msg.role === 'system');\n    setMessages(systemMessages);\n    setError(null);\n  }, [messages, setMessages]);\n\n  return {\n    // Basic chat functionality\n    messages,\n    input,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    \n    // Additional utilities\n    sendMessage,\n    resetConversation,\n    getFormattedHistory,\n    \n    // Control functions\n    reload,\n    stop,\n    \n    // Status\n    error,\n    status\n  };\n}\n\n================================================================================\nFILE: src/hooks/useChatNodeSync.ts\n================================================================================\n\n/**\n * useChatNodeSync Hook\n * \n * A custom hook to synchronize chat messages with nodes on the canvas\n */\nimport { useCallback, useEffect, useState } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\nimport { useNodes, useNodeActions, useRelationships } from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { Node, Relationship } from '@/types/thread';\n\ninterface UseChatNodeSyncOptions {\n  notebookId: string;\n  autoSync?: boolean;\n}\n\ninterface UseChatNodeSyncResult {\n  syncState: 'idle' | 'syncing' | 'error' | 'success';\n  syncError: string | null;\n  lastSyncTime: Date | null;\n  syncChatToNodes: () => Promise<void>;\n  syncNodeToChat: (nodeId: string) => Promise<void>;\n  findNodeByMessageId: (messageId: string) => Node | null;\n}\n\n/**\n * Custom hook for synchronizing chat and nodes\n */\nexport const useChatNodeSync = (options: UseChatNodeSyncOptions): UseChatNodeSyncResult => {\n  const { notebookId, autoSync = false } = options;\n  \n  const [syncState, setSyncState] = useState<'idle' | 'syncing' | 'error' | 'success'>('idle');\n  const [syncError, setSyncError] = useState<string | null>(null);\n  const [lastSyncTime, setLastSyncTime] = useState<Date | null>(null);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const relationships = useRelationships();\n  const { addNode, updateNode, createNodeRelationship } = useNodeActions();\n  \n  /**\n   * Find a node by its associated message ID\n   */\n  const findNodeByMessageId = useCallback((messageId: string): Node | null => {\n    // Look through all nodes to find one with a matching message ID\n    const matchingNode = Object.values(nodes).find(node => {\n      if (!node.messages) return false;\n      return node.messages.some(msg => msg.id === messageId);\n    });\n    \n    return matchingNode || null;\n  }, [nodes]);\n  \n  /**\n   * Sync all chat messages to nodes\n   */\n  const syncChatToNodes = useCallback(async () => {\n    if (!notebookId) return;\n    \n    try {\n      setSyncState('syncing');\n      setSyncError(null);\n      \n      // First get all chat messages from the database\n      const { data: chatMessages, error } = await supabase\n        .from('chat_messages')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n        \n      if (error) throw error;\n      \n      // Check if we have messages to process\n      if (!chatMessages || chatMessages.length === 0) {\n        setSyncState('success');\n        setLastSyncTime(new Date());\n        return;\n      }\n      \n      // Process each message\n      for (const message of chatMessages) {\n        // Check if a node already exists for this message\n        const existingNode = findNodeByMessageId(message.id);\n        \n        if (!existingNode) {\n          // Create a new node for this message\n          await nodeIntegration.createNodeFromMessage(\n            {\n              id: message.id,\n              role: message.role,\n              content: message.content,\n              created_at: message.created_at\n            },\n            notebookId\n          );\n        }\n      }\n      \n      // Create relationships for message pairs\n      for (let i = 1; i < chatMessages.length; i++) {\n        const prevMessage = chatMessages[i - 1];\n        const currentMessage = chatMessages[i];\n        \n        // Find the corresponding nodes\n        const prevNode = findNodeByMessageId(prevMessage.id);\n        const currentNode = findNodeByMessageId(currentMessage.id);\n        \n        // Create relationship if both nodes exist and they don't already have a relationship\n        if (prevNode && currentNode) {\n          const existingRelationship = relationships.some(rel => \n            (rel.from_node_id === prevNode.id && rel.to_node_id === currentNode.id) ||\n            (rel.from_node_id === currentNode.id && rel.to_node_id === prevNode.id)\n          );\n          \n          if (!existingRelationship) {\n            // Create a relationship - usually from user to assistant or vice versa\n            await nodeIntegration.createNodeRelationship(\n              prevNode.id,\n              currentNode.id,\n              'extends',\n              notebookId\n            );\n          }\n        }\n      }\n      \n      setSyncState('success');\n      setLastSyncTime(new Date());\n    } catch (error) {\n      console.error('Error syncing chat to nodes:', error);\n      setSyncState('error');\n      setSyncError(error.message || 'Unknown error');\n    }\n  }, [notebookId, findNodeByMessageId, relationships]);\n  \n  /**\n   * Sync a specific node to the chat\n   */\n  const syncNodeToChat = useCallback(async (nodeId: string) => {\n    if (!notebookId || !nodeId) return;\n    \n    try {\n      setSyncState('syncing');\n      setSyncError(null);\n      \n      // Get the node\n      const node = nodes[nodeId];\n      if (!node) throw new Error(`Node ${nodeId} not found`);\n      \n      // Get all related nodes\n      const relatedNodeIds = relationships\n        .filter(rel => rel.from_node_id === nodeId || rel.to_node_id === nodeId)\n        .map(rel => rel.from_node_id === nodeId ? rel.to_node_id : rel.from_node_id);\n      \n      const relatedNodes = relatedNodeIds.map(id => nodes[id]).filter(Boolean);\n      \n      // Sort all nodes by creation time\n      const allNodes = [node, ...relatedNodes].sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n      \n      // Extract messages from nodes\n      const messages = allNodes.flatMap(node => {\n        if (node.messages && node.messages.length > 0) {\n          return node.messages.map(msg => ({\n            ...msg,\n            nodeId: node.id\n          }));\n        } else {\n          // Create a synthetic message\n          return [{\n            id: `node_${node.id}`,\n            role: node.type === 'question' ? 'user' : 'assistant',\n            content: node.content,\n            created_at: node.created_at,\n            nodeId: node.id\n          }];\n        }\n      });\n      \n      // Sort messages by time\n      messages.sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n      \n      // Store the thread structure in the node's metadata\n      await updateNode(nodeId, {\n        metadata: {\n          ...node.metadata,\n          threadMessages: messages,\n          lastSyncTime: new Date().toISOString()\n        }\n      });\n      \n      setSyncState('success');\n      setLastSyncTime(new Date());\n    } catch (error) {\n      console.error('Error syncing node to chat:', error);\n      setSyncState('error');\n      setSyncError(error.message || 'Unknown error');\n    }\n  }, [notebookId, nodes, relationships, updateNode]);\n  \n  // Auto-sync if enabled\n  useEffect(() => {\n    if (autoSync && notebookId) {\n      syncChatToNodes().catch(error => {\n        console.error('Auto-sync error:', error);\n      });\n    }\n  }, [autoSync, notebookId, syncChatToNodes]);\n  \n  return {\n    syncState,\n    syncError,\n    lastSyncTime,\n    syncChatToNodes,\n    syncNodeToChat,\n    findNodeByMessageId\n  };\n};\n\nexport default useChatNodeSync;\n\n================================================================================\nFILE: src/hooks/useThreadManagement.ts\n================================================================================\n\n// src/hooks/useThreadManagement.ts\nimport { useCallback, useEffect } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { threadService } from '@/services/threadService';\nimport useThreadStore from '@/stores/threadStore';\nimport { Thread, Message } from '@/types/thread';\nimport { supabase } from '@/lib/supabaseClient';\n\ninterface UseThreadManagementProps {\n  notebookId: string;\n}\n\n/**\n * Hook for managing threads including loading, updating, and realtime sync\n */\nexport function useThreadManagement({ notebookId }: UseThreadManagementProps) {\n  const queryClient = useQueryClient();\n  \n  // Access thread store actions with individual selectors to prevent unnecessary re-renders\n  const setThreads = useThreadStore(state => state.setThreads);\n  const addThread = useThreadStore(state => state.addThread);\n  const updateThread = useThreadStore(state => state.updateThread);\n  const removeThread = useThreadStore(state => state.removeThread);\n  const setConnections = useThreadStore(state => state.setConnections);\n  const setNotebookId = useThreadStore(state => state.setNotebookId);\n  const setLoadingState = useThreadStore(state => state.setLoadingState);\n  \n  // Load threads for notebook\n  const loadThreads = useCallback(async () => {\n    if (!notebookId) return;\n    \n    try {\n      setLoadingState(true);\n      \n      // Fetch threads\n      const threads = await threadService.getThreadsByNotebook(notebookId);\n      setThreads(threads);\n      \n      // Fetch connections\n      const connections = await threadService.getThreadConnections(notebookId);\n      setConnections(connections);\n      \n      // Set notebook ID in store\n      setNotebookId(notebookId);\n      \n      setLoadingState(false);\n    } catch (error) {\n      console.error('Error loading threads:', error);\n      setLoadingState(false, error instanceof Error ? error : new Error('Failed to load threads'));\n    }\n  }, [notebookId, setThreads, setConnections, setNotebookId, setLoadingState]);\n  \n  // Create a new thread\n  const createThread = useCallback(async (\n    threadData: Omit<Thread, 'id' | 'createdAt' | 'updatedAt' | 'messages'> & { initialMessage?: string }\n  ) => {\n    try {\n      const { initialMessage, ...threadProps } = threadData;\n      \n      // Create messages array if initial message exists\n      const messages: Omit<Message, 'id' | 'threadId' | 'createdAt'>[] = [];\n      if (initialMessage) {\n        messages.push({\n          content: initialMessage,\n          role: 'user'\n        });\n      }\n\n      // Create thread via service\n      const newThread = await threadService.createThread({\n        ...threadProps,\n        messages // ThreadService expects a messages field\n      });\n      \n      // Add to store\n      addThread(newThread);\n      \n      return newThread;\n    } catch (error) {\n      console.error('Error creating thread:', error);\n      throw error;\n    }\n  }, [addThread]);\n  \n  // Delete a thread\n  const deleteThread = useCallback(async (threadId: string) => {\n    try {\n      await threadService.deleteThread(threadId);\n      removeThread(threadId);\n    } catch (error) {\n      console.error('Error deleting thread:', error);\n      throw error;\n    }\n  }, [removeThread]);\n  \n  // Send a message in a thread with streaming response\n  const sendMessage = useCallback(async (\n    threadId: string, \n    message: string,\n    systemPrompt?: string\n  ) => {\n    try {\n      // First add user message to the thread\n      await threadService.addMessage(threadId, message, 'user');\n      \n      // Start streaming the AI response\n      return threadService.streamMessage(threadId, message, systemPrompt);\n    } catch (error) {\n      console.error('Error sending message:', error);\n      throw error;\n    }\n  }, []);\n  \n  // Move a thread to a new position\n  const moveThread = useCallback(async (threadId: string, x: number, y: number) => {\n    try {\n      // Update position in store\n      updateThread(threadId, { position: { x, y } });\n      \n      // Save to database (debounced in the service)\n      await threadService.updateThread(threadId, { position: { x, y } });\n    } catch (error) {\n      console.error('Error moving thread:', error);\n      throw error;\n    }\n  }, [updateThread]);\n  \n  // Change thread properties\n  const updateThreadProperties = useCallback(async (\n    threadId: string, \n    properties: Partial<Thread>\n  ) => {\n    try {\n      // Update in store\n      updateThread(threadId, properties);\n      \n      // Save to database\n      await threadService.updateThread(threadId, properties);\n    } catch (error) {\n      console.error('Error updating thread properties:', error);\n      throw error;\n    }\n  }, [updateThread]);\n  \n  // Get thread by ID - memoized selector\n  const getThread = useThreadStore(state => state.getThread);\n\n  // Create a follow-up thread\n  const createFollowUpThread = useCallback(async (\n    parentId: string,\n    initialMessage?: string\n  ) => {\n    try {\n      // Use the store's selector instead of direct state access\n      const parentThread = getThread(parentId);\n      if (!parentThread) throw new Error('Parent thread not found');\n\n      // Create position slightly offset from parent\n      const position = {\n        x: parentThread.position.x + 30,\n        y: parentThread.position.y + 200\n      };\n\n      // Create new thread\n      return createThread({\n        notebookId,\n        parentId,\n        position,\n        cardType: 'follow_up',\n        initialMessage\n      });\n    } catch (error) {\n      console.error('Error creating follow-up:', error);\n      throw error;\n    }\n  }, [notebookId, createThread, getThread]);\n  \n  // Set up realtime subscriptions\n  useEffect(() => {\n    if (!notebookId) return;\n    \n    // Initial load\n    loadThreads();\n    \n    // Set up realtime subscription for threads\n    const threadsSubscription = supabase\n      .channel(`threads:${notebookId}`)\n      .on(\n        // @ts-expect-error: Supabase types are not fully compatible\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'threads',\n          filter: `notebook_id=eq.${notebookId}`\n        },\n        async (payload: {\n          eventType: 'INSERT' | 'UPDATE' | 'DELETE',\n          new: {\n            id: string,\n            position: { x: number; y: number },\n            title?: string,\n            parent_id?: string,\n            referenced_threads?: string[],\n            card_type: string,\n            handwriting_style?: string,\n            is_minimized?: boolean,\n            z_index?: number,\n            updated_at: string\n          },\n          old: { id: string }\n        }) => {\n          // Handle different event types\n          if (payload.eventType === 'INSERT') {\n            // Fetch the complete thread with messages\n            const thread = (await threadService.getThreadsByNotebook(notebookId))\n              .find(t => t.id === payload.new.id);\n              \n            if (thread) {\n              addThread(thread);\n            }\n          } else if (payload.eventType === 'UPDATE') {\n            // Update thread in store\n            const updates: Partial<Thread> = {\n              position: payload.new.position,\n              title: payload.new.title,\n              parentId: payload.new.parent_id,\n              referencedThreads: payload.new.referenced_threads,\n              // Cast to expected enum type since we know it's one of the valid values\n              cardType: payload.new.card_type as 'question' | 'response' | 'note' | 'follow_up',\n              handwritingStyle: payload.new.handwriting_style as Thread['handwritingStyle'],\n              isMinimized: payload.new.is_minimized,\n              zIndex: payload.new.z_index,\n              updatedAt: payload.new.updated_at\n            };\n            \n            updateThread(payload.new.id, updates);\n          } else if (payload.eventType === 'DELETE') {\n            // Remove thread from store\n            removeThread(payload.old.id);\n          }\n          \n          // Invalidate queries - using object syntax for newer React Query versions\n          queryClient.invalidateQueries({ queryKey: ['threads', notebookId] });\n        }\n      )\n      .subscribe();\n      \n    // Set up realtime subscription for messages\n    const messagesSubscription = supabase\n      .channel(`thread_messages:${notebookId}`)\n      .on(\n        // @ts-expect-error: Supabase types are not fully compatible\n        'postgres_changes',\n        {\n          event: '*',\n          schema: 'public',\n          table: 'thread_messages'\n        },\n        async (payload: { new?: { thread_id: string }, old?: { thread_id: string } }) => {\n          // We need to get the thread ID to know which thread to update\n          const threadId = payload.new?.thread_id || payload.old?.thread_id;\n          \n          if (!threadId) return;\n          \n          // Check if this thread belongs to our notebook using the memoized selector\n          const thread = getThread(threadId);\n          if (!thread || thread.notebookId !== notebookId) return;\n          \n          // Refresh the thread to get updated messages\n          const updatedThreads = await threadService.getThreadsByNotebook(notebookId);\n          const updatedThread = updatedThreads.find(t => t.id === threadId);\n          \n          if (updatedThread) {\n            // Update just the messages and updatedAt\n            updateThread(threadId, {\n              messages: updatedThread.messages,\n              updatedAt: updatedThread.updatedAt\n            });\n          }\n          \n          // Invalidate queries - using object syntax for newer React Query versions\n          queryClient.invalidateQueries({ queryKey: ['threads', notebookId] });\n        }\n      )\n      .subscribe();\n      \n    // Cleanup subscriptions\n    return () => {\n      supabase.removeChannel(threadsSubscription);\n      supabase.removeChannel(messagesSubscription);\n    };\n  }, [notebookId, loadThreads, addThread, updateThread, removeThread, queryClient, getThread]);\n  \n  return {\n    loadThreads,\n    createThread,\n    deleteThread,\n    sendMessage,\n    moveThread,\n    updateThreadProperties,\n    createFollowUpThread\n  };\n}\n\n================================================================================\nFILE: src/hooks/useThreadQueries.ts\n================================================================================\n\n// src/hooks/useThreadQueries.ts\nimport React from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { threadService } from '@/services/threadService';\nimport { Thread, Message } from '@/types/thread';\nimport useThreadStore from '@/stores/threadStore';\nimport { migrationUtils } from '@/utils/migrationUtils';\n\n/**\n * Input type for thread creation\n */\ninterface CreateThreadInput {\n  notebookId: string;\n  parentId?: string;\n  position: { x: number; y: number };\n  cardType: 'question' | 'response' | 'note' | 'follow_up';\n  handwritingStyle?: 'neat' | 'cursive' | 'messy' | 'print' | 'architect';\n  isMinimized?: boolean;\n  zIndex?: number;\n  title?: string;\n  referencedThreads?: string[];\n  initialMessage?: string; // Optional initial message\n}\n\n/**\n * React Query hooks for thread operations\n */\nexport function useThreadQueries(notebookId: string) {\n  const queryClient = useQueryClient();\n  \n  // Access thread store actions\n  const { \n    setThreads, \n    addThread, \n    updateThread,\n    removeThread,\n    setConnections\n  } = useThreadStore(state => ({\n    setThreads: state.setThreads,\n    addThread: state.addThread,\n    updateThread: state.updateThread,\n    removeThread: state.removeThread,\n    setConnections: state.setConnections\n  }));\n  \n  // Check if migration is needed\n  const migrationCheckQuery = useQuery({\n    queryKey: ['migration-check', notebookId],\n    queryFn: () => migrationUtils.isMigrationNeeded(notebookId),\n    staleTime: Infinity // Don't need to re-check frequently\n  });\n  \n  // Migrate notebook if needed\n  const migrateMutation = useMutation({\n    mutationFn: () => migrationUtils.migrateNotebookConversations(notebookId),\n    onSuccess: () => {\n      // After migration, refetch threads\n      queryClient.invalidateQueries({ queryKey: ['threads', notebookId] });\n      queryClient.invalidateQueries({ queryKey: ['migration-check', notebookId] });\n    }\n  });\n  \n  // Get all threads for notebook\n  const threadsQuery = useQuery({\n    queryKey: ['threads', notebookId],\n    queryFn: () => threadService.getThreadsByNotebook(notebookId),\n    // Don't fetch threads if migration is needed but not completed\n    enabled: !migrationCheckQuery.data || migrateMutation.isSuccess || !notebookId,\n  });\n\n  // Set threads in store when query succeeds - with a stable reference to threadsQuery.data\n  const threadsData = threadsQuery.data;\n  React.useEffect(() => {\n    if (threadsData) {\n      // Use stableCallback to prevent infinite loops\n      const threadsCopy = [...threadsData]; // Create a copy to prevent mutation issues\n      setThreads(threadsCopy);\n    }\n  }, [threadsData, setThreads]);\n\n  // Get thread connections\n  const connectionsQuery = useQuery({\n    queryKey: ['connections', notebookId],\n    queryFn: () => threadService.getThreadConnections(notebookId),\n    // Only fetch if threads have been fetched\n    enabled: Boolean(threadsData) && !threadsQuery.isError\n  });\n\n  // Set connections in store when query succeeds - with a stable reference to connectionsQuery.data\n  const connectionsData = connectionsQuery.data;\n  React.useEffect(() => {\n    if (connectionsData) {\n      // Use stableCallback to prevent infinite loops\n      const connectionsCopy = [...connectionsData]; // Create a copy to prevent mutation issues\n      setConnections(connectionsCopy);\n    }\n  }, [connectionsData, setConnections]);\n  \n  // Create new thread\n  const createThreadMutation = useMutation({\n    mutationFn: (threadData: CreateThreadInput) => {\n      // Create initial messages array if needed\n      const messages: Omit<Message, 'id' | 'threadId' | 'createdAt'>[] = [];\n      \n      if (threadData.initialMessage) {\n        messages.push({\n          content: threadData.initialMessage,\n          role: 'user'\n        });\n      }\n      \n      // Extract initialMessage from threadData (with correct property name)\n      // Use underscore prefix since we've already used initialMessage above\n      const { initialMessage: _initialMessage, ...threadProps } = threadData;\n      \n      // Call service to create thread\n      return threadService.createThread({\n        ...threadProps,\n        messages\n      });\n    },\n    onSuccess: (newThread) => {\n      // Add thread to store\n      addThread(newThread);\n      \n      // Invalidate queries\n      queryClient.invalidateQueries({ queryKey: ['threads', notebookId] });\n      \n      // If thread has a parent, also invalidate connections\n      if (newThread.parentId) {\n        queryClient.invalidateQueries({ queryKey: ['connections', notebookId] });\n      }\n    }\n  });\n  \n  // Update thread\n  const updateThreadMutation = useMutation({\n    mutationFn: ({ \n      threadId, \n      updates \n    }: { \n      threadId: string; \n      updates: Partial<Thread> \n    }) => threadService.updateThread(threadId, updates),\n    onSuccess: (_, variables) => {\n      // Update thread in store\n      updateThread(variables.threadId, variables.updates);\n      \n      // Invalidate thread query\n      queryClient.invalidateQueries({ \n        queryKey: ['threads', notebookId, variables.threadId] \n      });\n      \n      // If parentId or referencedThreads changed, also invalidate connections\n      if (\n        variables.updates.parentId !== undefined || \n        variables.updates.referencedThreads !== undefined\n      ) {\n        queryClient.invalidateQueries({ \n          queryKey: ['connections', notebookId] \n        });\n      }\n    }\n  });\n  \n  // Delete thread\n  const deleteThreadMutation = useMutation({\n    mutationFn: (threadId: string) => threadService.deleteThread(threadId),\n    onSuccess: (_, threadId) => {\n      // Remove thread from store\n      removeThread(threadId);\n      \n      // Invalidate queries\n      queryClient.invalidateQueries({ queryKey: ['threads', notebookId] });\n      queryClient.invalidateQueries({ queryKey: ['connections', notebookId] });\n    }\n  });\n  \n  // Add message to thread\n  const addMessageMutation = useMutation({\n    mutationFn: ({ \n      threadId, \n      content, \n      role \n    }: { \n      threadId: string; \n      content: string; \n      role: 'user' | 'assistant' | 'system' \n    }) => threadService.addMessage(threadId, content, role),\n    onSuccess: (newMessage, variables) => {\n      // Manually update thread in store to avoid refetching\n      const threads = useThreadStore.getState().threads;\n      const thread = threads[variables.threadId];\n      \n      if (thread) {\n        updateThread(variables.threadId, {\n          messages: [...thread.messages, newMessage],\n          updatedAt: newMessage.createdAt\n        });\n      }\n      \n      // Invalidate specific thread query\n      queryClient.invalidateQueries({ \n        queryKey: ['threads', notebookId, variables.threadId] \n      });\n    }\n  });\n  \n  return {\n    // Queries\n    threadsQuery,\n    connectionsQuery,\n    migrationCheckQuery,\n    \n    // Mutations\n    migrateMutation,\n    createThreadMutation,\n    updateThreadMutation,\n    deleteThreadMutation,\n    addMessageMutation,\n    \n    // Helper derived values\n    isLoading: threadsQuery.isLoading || connectionsQuery.isLoading,\n    isError: threadsQuery.isError || connectionsQuery.isError,\n    error: threadsQuery.error || connectionsQuery.error,\n    needsMigration: migrationCheckQuery.data,\n    allThreads: threadsQuery.data || []\n  };\n}\n\n================================================================================\nFILE: src/lib/chat/chatService.ts\n================================================================================\n\n/**\n * Chat Service Module\n * \n * Provides unified handling of chat functionality with Anthropic Claude API\n */\nimport Anthropic from '@anthropic-ai/sdk';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Initialize Anthropic client\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nlet anthropic: Anthropic | null = null;\n\ntry {\n  anthropic = new Anthropic({ apiKey });\n  console.log('Anthropic client initialized successfully');\n} catch (error) {\n  console.error('Failed to initialize Anthropic client:', error);\n}\n\n/**\n * Determines if the service is in demo mode (no API key)\n */\nexport const isDemoMode = (): boolean => {\n  return !anthropic || !apiKey || apiKey.trim() === '';\n};\n\n/**\n * Transforms messages array for Claude API compatibility\n * Extracts system message and returns cleaned messages\n */\nexport const prepareMessagesForClaude = (messages: any[]) => {\n  if (!messages || !Array.isArray(messages)) {\n    throw new Error('Invalid messages format');\n  }\n\n  // Extract system message if present\n  const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n  \n  // Filter out system messages - they should be passed as a separate parameter\n  const filteredMessages = messages\n    .filter(msg => msg.role !== 'system')\n    .map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n  return { \n    systemMessage, \n    messages: filteredMessages\n  };\n};\n\n/**\n * Processes AI response for user context and memory\n */\nexport const processResponse = async (userId: string | null, response: string, userMessage: string, includeUserContext = true) => {\n  if (!userId || !includeUserContext) return;\n\n  try {\n    // Process for traditional user context\n    await processResponseForUserContext(userId, response);\n\n    // Process user message for memory extraction\n    if (userMessage) {\n      await processMessageForMemories(userId, userMessage);\n    }\n  } catch (error) {\n    console.error('Error processing response for user context:', error);\n  }\n};\n\n/**\n * Gets demo response content for fallback/development use\n */\nexport const getDemoResponse = (): string => {\n  return \"This is a demo response from Claude. In production, this would be an actual response based on your input. The app is currently running in demo mode without a Claude API key.\";\n};\n\n/**\n * Creates a fallback response object for error cases\n */\nexport const createFallbackResponse = (error?: any): any => {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  \n  return {\n    content: [{\n      type: 'text',\n      text: `Sorry, there was an error contacting the AI service: ${errorMessage}. This is a fallback response.`\n    }],\n    model: \"claude-3-fallback\",\n    role: 'assistant'\n  };\n};\n\nexport default {\n  anthropic,\n  isDemoMode,\n  prepareMessagesForClaude,\n  processResponse,\n  getDemoResponse,\n  createFallbackResponse\n};\n\n================================================================================\nFILE: src/lib/chat/index.ts\n================================================================================\n\n/**\n * Chat Module Index\n * \n * Exports all chat-related functionality from a single entry point\n * Conditionally imports server or client version based on environment\n */\nimport nodeIntegration from './nodeIntegration';\n\n// Conditionally import the right chatService implementation\nlet chatService: any;\n\nif (typeof window === 'undefined') {\n  // Server-side\n  // Dynamic import to avoid browser errors with server-only code\n  const serverModule = require('./server/chatService');\n  chatService = serverModule.default || serverModule;\n} else {\n  // Client-side\n  // Dynamic import to ensure client-side code is used in the browser\n  const clientModule = require('./client/chatService');\n  chatService = clientModule.default || clientModule;\n}\n\nexport {\n  chatService,\n  nodeIntegration\n};\n\nexport default {\n  chatService,\n  nodeIntegration\n};\n\n================================================================================\nFILE: src/lib/chat/nodeIntegration.ts\n================================================================================\n\n/**\n * Node Integration Service\n * \n * Handles integration between chat messages and the node-based canvas system\n */\nimport { supabase } from '@/lib/supabaseClient';\nimport { Node, Relationship } from '@/types/thread';\n\n/**\n * Creates a node from a chat message\n */\nexport const createNodeFromMessage = async (\n  message: any, \n  notebookId: string,\n  position?: { x: number, y: number }\n): Promise<Node | null> => {\n  if (!notebookId || !message) return null;\n  \n  try {\n    // Determine node type based on message role\n    const nodeType = message.role === 'user' ? 'question' : 'response';\n    \n    // Use provided position or generate a default one\n    const nodePosition = position || { x: 100 + Math.random() * 200, y: 100 + Math.random() * 200 };\n    \n    // Create the node\n    const { data: node, error } = await supabase\n      .from('nodes')\n      .insert({\n        content: message.content,\n        type: nodeType,\n        notebook_id: notebookId,\n        position: nodePosition,\n        metadata: {\n          source: 'chat',\n          chatMessageId: message.id,\n          timestamp: message.created_at || new Date().toISOString()\n        },\n        messages: [{\n          id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n          role: message.role,\n          content: message.content,\n          created_at: message.created_at || new Date().toISOString()\n        }],\n        isConversationNode: true,\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return node;\n  } catch (error) {\n    console.error('Error creating node from message:', error);\n    return null;\n  }\n};\n\n/**\n * Creates a relationship between two nodes\n */\nexport const createNodeRelationship = async (\n  fromNodeId: string,\n  toNodeId: string,\n  type: 'supports' | 'contradicts' | 'questions' | 'extends' | 'tensions',\n  notebookId: string\n): Promise<Relationship | null> => {\n  if (!fromNodeId || !toNodeId || !notebookId) return null;\n  \n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .insert({\n        from_node_id: fromNodeId,\n        to_node_id: toNodeId,\n        type,\n        notebook_id: notebookId,\n        context: 'Created from chat',\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Error creating relationship between nodes:', error);\n    return null;\n  }\n};\n\n/**\n * Adds a message to an existing node\n */\nexport const addMessageToNode = async (\n  nodeId: string,\n  message: {\n    role: 'user' | 'assistant' | 'system',\n    content: string,\n    id?: string\n  }\n): Promise<boolean> => {\n  if (!nodeId || !message) return false;\n  \n  try {\n    // First, get the current node to access its messages\n    const { data: node, error: fetchError } = await supabase\n      .from('nodes')\n      .select('messages')\n      .eq('id', nodeId)\n      .single();\n    \n    if (fetchError) throw fetchError;\n    \n    // Prepare the new message with ID if not provided\n    const newMessage = {\n      id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n      role: message.role,\n      content: message.content,\n      created_at: new Date().toISOString()\n    };\n    \n    // Add the new message to the existing messages array\n    const updatedMessages = [\n      ...(node.messages || []),\n      newMessage\n    ];\n    \n    // Update the node with the new messages array\n    const { error: updateError } = await supabase\n      .from('nodes')\n      .update({\n        messages: updatedMessages,\n        lastMessageId: newMessage.id,\n        isConversationNode: true\n      })\n      .eq('id', nodeId);\n    \n    if (updateError) throw updateError;\n    return true;\n  } catch (error) {\n    console.error('Error adding message to node:', error);\n    return false;\n  }\n};\n\nexport default {\n  createNodeFromMessage,\n  createNodeRelationship,\n  addMessageToNode\n};\n\n================================================================================\nFILE: src/pages/api/ai/chat.ts\n================================================================================\n\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { StreamingTextResponse } from 'ai';\nimport { anthropic } from '@ai-sdk/anthropic';\nimport { streamText } from 'ai';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Get environment variables\nconst ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY || '';\nconst isValidApiKey = ANTHROPIC_API_KEY && ANTHROPIC_API_KEY.trim() !== '';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  console.log('AI SDK Chat API request received');\n  \n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n\n  // Check if API key is configured\n  const isDemoMode = !isValidApiKey;\n\n  // Get the session if we need it\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Log auth info for debugging\n  console.log('Auth check (chat):', {\n    hasSession: !!session,\n    sessionUser: session?.user?.email || 'none',\n    productionEnv: process.env.NODE_ENV === 'production'\n  });\n\n  // ALWAYS BYPASS AUTH CHECK FOR NOW - can be enabled later\n  const requireAuth = false;\n  if (requireAuth && !session && !isDemoMode) {\n    console.log('Rejecting request: Unauthorized');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { messages: rawMessages, stream = true, model = 'claude-3-5-sonnet-20240620', includeUserContext = true } = req.body;\n    const userId = session?.user?.id || null;\n\n    if (!rawMessages || !Array.isArray(rawMessages)) {\n      return res.status(400).json({ error: 'Invalid or missing messages parameter' });\n    }\n\n    // Clean the messages to have just the expected fields\n    const messages = rawMessages.map(msg => {\n      const { role, content } = msg;\n      return { role, content };\n    });\n\n    // If demo mode or no API key, return a demo response\n    if (isDemoMode) {\n      console.log('Using demo mode for chat');\n      \n      if (stream) {\n        const demoResponse = \"This is a demo response from Claude. In production, this would be an actual response based on your query. The app is currently running in demo mode without a Claude API key.\";\n        \n        const chunks = demoResponse.split('. ');\n        for (const chunk of chunks) {\n          await new Promise(resolve => setTimeout(resolve, 300));\n          res.write(`data: ${JSON.stringify({ \n            type: 'chunk', \n            data: { content: chunk + '. ' } \n          })}\\n\\n`);\n        }\n        \n        res.write(`data: ${JSON.stringify({ type: 'done' })}\\n\\n`);\n        res.end();\n        return;\n      } else {\n        return res.status(200).json({\n          content: \"This is a demo response from Claude. In production, this would be an actual response based on your query.\",\n          model: \"claude-3-demo\"\n        });\n      }\n    }\n\n    // Extract the system message if present\n    let systemMessage = '';\n    const nonSystemMessages = messages.filter(msg => {\n      if (msg.role === 'system') {\n        systemMessage = msg.content;\n        return false;\n      }\n      return true;\n    });\n\n    try {\n      if (stream) {\n        // Using Vercel AI SDK with Anthropic for streaming\n        // Create an in-flight variable to capture the full response for processing\n        let fullResponse = '';\n        \n        // Create stream with anthropic client\n        const anthropicClient = anthropic(model);\n        const stream = await anthropicClient.chat({\n          messages: nonSystemMessages,\n          system: systemMessage || \"You are a helpful AI assistant.\",\n          max_tokens: 1024,\n        });\n        \n        // Create a TransformStream to intercept and collect chunks\n        const transformStream = new TransformStream({\n          transform(chunk, controller) {\n            // Parse the chunk and extract content\n            const decodedChunk = new TextDecoder().decode(chunk);\n            if (decodedChunk.includes('content')) {\n              try {\n                // Extract content from the event data\n                const match = decodedChunk.match(/data: (.*)/);  \n                if (match && match[1]) {\n                  const jsonData = JSON.parse(match[1]);\n                  if (jsonData.delta?.content) {\n                    fullResponse += jsonData.delta.content;\n                  }\n                }\n              } catch (e) {\n                // Silently handle parse errors for non-content chunks\n              }\n            }\n            // Pass through all chunks\n            controller.enqueue(chunk);\n          }\n        });\n        \n        // Create modified stream that processes content when done\n        stream.pipeThrough(transformStream).pipeTo(\n          new WritableStream({\n            close() {\n              // Process the complete response after stream finishes\n              if (userId && includeUserContext && fullResponse) {\n                try {\n                  // Process for traditional user context\n                  processResponseForUserContext(userId, fullResponse);\n                  \n                  // Also process Theory of Mind\n                  const userMessage = messages\n                    .filter(msg => msg.role === 'user')\n                    .pop()?.content || '';\n                    \n                  if (userMessage) {\n                    processMessageForMemories(userId, userMessage);\n                  }\n                } catch (contextError) {\n                  console.error('Error processing for user context:', contextError);\n                }\n              }\n            }\n          })\n        ).catch(e => console.error('Stream processing error:', e));\n        \n        // Return the stream directly\n        return new StreamingTextResponse(stream);\n      } else {\n        // For non-streaming, we need to wait for the full response\n        const anthropicClient = anthropic(model);\n        const response = await anthropicClient.chat({\n          messages: nonSystemMessages,\n          system: systemMessage || \"You are a helpful AI assistant.\",\n          max_tokens: 1024,\n        });\n        \n        const responseText = response.content || '';\n        \n        // Process for user context\n        if (userId && includeUserContext) {\n          try {\n            await processResponseForUserContext(userId, responseText);\n            \n            // Process for Theory of Mind\n            const userMessage = messages\n              .filter(msg => msg.role === 'user')\n              .pop()?.content || '';\n              \n            if (userMessage) {\n              await processMessageForMemories(userId, userMessage);\n            }\n          } catch (contextError) {\n            console.error('Error processing for user context:', contextError);\n          }\n        }\n        \n        return res.status(200).json({\n          content: responseText,\n          model: model\n        });\n      }\n    } catch (apiError) {\n      console.error('API error:', apiError);\n      \n      // Return a fallback response\n      if (stream) {\n        const fallbackResponse = \"Sorry, there was an error contacting the AI service. This is a fallback response.\";\n        \n        res.write(`data: ${JSON.stringify({ \n          type: 'chunk',\n          data: { content: fallbackResponse } \n        })}\\n\\n`);\n        \n        res.write(`data: ${JSON.stringify({ type: 'done' })}\\n\\n`);\n        res.end();\n      } else {\n        return res.status(200).json({\n          content: \"Sorry, there was an error contacting the AI service. This is a fallback response.\",\n          model: model,\n          error: apiError instanceof Error ? apiError.message : 'Unknown API error'\n        });\n      }\n    }\n  } catch (error) {\n    console.error('Unexpected error in handler:', error);\n    \n    // Return fallback response\n    return res.status(200).json({\n      content: \"An unexpected error occurred. This is a fallback response.\",\n      model: \"fallback\",\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}\n\n================================================================================\nFILE: src/pages/api/claude/chat-simple.ts\n================================================================================\n\n// Simplified fallback version of the chat API without the complexity\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport Anthropic from '@anthropic-ai/sdk';\n\n// Initialize Anthropic client directly with the API key\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY || '',\n});\n\n// Basic demo response for demo mode\nconst demoResponse = `This is a simplified fallback API response.\nIn production, this would be an actual response from Claude AI.\nThe main API endpoint might be experiencing issues.`;\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  console.log('Simple fallback API called');\n  \n  // Only handle POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Get request parameters\n    const { messages, stream = false } = req.body;\n    \n    // Validate messages\n    if (!messages || !Array.isArray(messages)) {\n      return res.status(400).json({ error: 'Invalid messages parameter' });\n    }\n\n    // Demo mode response - always return the demo content\n    const isDemoMode = process.env.NODE_ENV === 'development' || !process.env.ANTHROPIC_API_KEY;\n    if (isDemoMode) {\n      return res.status(200).json({\n        content: demoResponse,\n        model: \"claude-3-demo\",\n        role: 'assistant'\n      });\n    }\n\n    // If we have a valid API key, try to use the Anthropic client\n    try {\n      // Extract system message if present\n      const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n      \n      // Filter out system messages - they should be passed as a separate parameter\n      const filteredMessages = messages\n        .filter(msg => msg.role !== 'system')\n        .map(msg => ({\n          role: msg.role,\n          content: msg.content\n        }));\n      \n      console.log(\"Making request to Claude with:\", {\n        model: 'claude-3-haiku-20240307',\n        system: systemMessage,\n        messagesCount: filteredMessages.length\n      });\n      \n      // Make a simple, non-streaming request to Anthropic\n      const response = await anthropic.messages.create({\n        model: 'claude-3-haiku-20240307', // Use Haiku for faster responses\n        max_tokens: 1000,\n        system: systemMessage,\n        messages: filteredMessages,\n        temperature: 0.7 // Add temperature for more natural responses\n      });\n\n      // Extract text from the response\n      const textContent = response.content\n        .filter(block => block.type === 'text')\n        .map(block => 'text' in block ? block.text : '')\n        .join('\\n');\n\n      // Return the simple, processed response\n      return res.status(200).json({\n        content: textContent,\n        model: response.model,\n        role: 'assistant'\n      });\n    } catch (error) {\n      console.error('API error:', error);\n      \n      // Return a fallback even for API errors\n      return res.status(200).json({\n        content: `Sorry, there was an error contacting the AI service: ${error.message || 'Unknown error'}`,\n        model: \"claude-3-fallback\",\n        role: 'assistant'\n      });\n    }\n  } catch (error) {\n    console.error('Unexpected error:', error);\n    \n    // Final fallback response\n    return res.status(200).json({\n      content: \"An unexpected error occurred. The API might be temporarily unavailable.\",\n      model: \"claude-3-fallback\",\n      role: 'assistant'\n    });\n  }\n}\n\n================================================================================\nFILE: src/pages/api/claude/chat.ts\n================================================================================\n\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { AnthropicStream, StreamingTextResponse } from 'ai';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Initialize Anthropic client when we have an API key\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nconst isValidApiKey = apiKey && apiKey.trim() !== '';\nlet anthropic = null;\n\n// Wrap in try-catch to handle initialization errors\ntry {\n  anthropic = isValidApiKey ? new Anthropic({ apiKey }) : null;\n  // Try a simple operation to verify client is working\n  if (anthropic) {\n    console.log('Anthropic client initialized successfully');\n  }\n} catch (error) {\n  console.error('Failed to initialize Anthropic client:', error);\n  anthropic = null;\n}\n\nconsole.log('Chat API initialized:', {\n  hasApiKey: Boolean(apiKey),\n  apiKeyLength: apiKey ? apiKey.length : 0,\n  nodeEnv: process.env.NODE_ENV\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Log headers for debugging\n  console.log('Request headers:', {\n    host: req.headers.host,\n    origin: req.headers.origin,\n    referer: req.headers.referer,\n    'content-type': req.headers['content-type']\n  });\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n\n  // Check if API key is configured\n  const isDemoMode = !anthropic || !isValidApiKey;\n\n  // Get the session if we need it\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Log auth info for debugging\n  console.log('Auth check (chat):', {\n    hasSession: !!session,\n    sessionUser: session?.user?.email || 'none',\n    productionEnv: process.env.NODE_ENV === 'production'\n  });\n\n  // ALWAYS BYPASS AUTH CHECK FOR NOW - can be enabled later\n  const requireAuth = false;\n  if (requireAuth && !session && !isDemoMode) {\n    console.log('Rejecting request: Unauthorized');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { messages: rawMessages, stream = false, model = 'claude-3-5-sonnet-20240620', includeUserContext = true, notebookId } = req.body;\n    const userId = session?.user?.id || null;\n\n    if (!rawMessages || !Array.isArray(rawMessages)) {\n      return res.status(400).json({ error: 'Invalid or missing messages parameter' });\n    }\n\n    // Log the raw messages for debugging\n    console.log('Raw messages received:', JSON.stringify(rawMessages.slice(0, 2), null, 2));\n\n    // IMPORTANT: Deep clean messages to ONLY include fields accepted by Claude API\n    // Claude API strictly rejects any extra fields like 'timestamp'\n    const messages = rawMessages.map(msg => {\n      // Explicitly extract only the fields Claude accepts and nothing else\n      const { role, content } = msg;\n      return { role, content };\n    });\n\n    // Double-check that no timestamps are present\n    const hasInvalidFields = messages.some(msg =>\n      Object.keys(msg).some(key => key !== 'role' && key !== 'content')\n    );\n\n    if (hasInvalidFields) {\n      console.warn('WARNING: Invalid fields detected in messages after cleaning!');\n      console.warn('Forcing strict cleanup...');\n\n      // Force a stringification and re-parsing to eliminate any unexpected fields\n      const strippedMessages = JSON.parse(JSON.stringify(messages))\n        .map(msg => ({ role: msg.role, content: msg.content }));\n\n      console.log('Strictly cleaned messages:', JSON.stringify(strippedMessages.slice(0, 2), null, 2));\n    }\n\n    // Log the cleaned messages\n    console.log('Cleaned messages:', JSON.stringify(messages.slice(0, 2), null, 2));\n\n    // Always provide a response whether in demo mode or not\n    if (isDemoMode || !anthropic) {\n      console.log('Using demo mode for chat');\n\n      if (stream) {\n        // Provide a mock streaming response for demo mode\n        const demoResponse = \"This is a demo response from Claude. In production, this would be an actual response based on your handwritten text. The app is currently running in demo mode without a Claude API key. Your handwriting would be analyzed and I'd provide a thoughtful, detailed response.\";\n\n        // Use the AI SDK's streaming response functionality to simulate streaming\n        const encoder = new TextEncoder();\n        const stream = new ReadableStream({\n          async start(controller) {\n            for (const word of demoResponse.split(' ')) {\n              controller.enqueue(encoder.encode(`data: ${JSON.stringify({\n                id: `chatmsg-${Date.now()}`,\n                object: 'chat.completion.chunk',\n                created: Date.now(),\n                model: \"claude-3-demo\",\n                delta: { content: word + ' ' },\n                role: 'assistant'\n              })}\\n\\n`));\n              await new Promise(resolve => setTimeout(resolve, 50));\n            }\n            controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n            controller.close();\n          }\n        });\n\n        return new Response(stream, {\n          headers: {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            'Connection': 'keep-alive'\n          }\n        });\n      } else {\n        // Non-streaming demo response\n        return res.status(200).json({\n          content: [{\n            type: 'text',\n            text: \"This is a demo response from Claude. In production, this would be an actual response based on your handwritten text.\"\n          }],\n          model: \"claude-3-demo\",\n          role: 'assistant'\n        });\n      }\n    }\n\n    try {\n      if (stream) {\n        // Create a proper stream using the Anthropic client\n        // Add verbose logging to diagnose the 500 error\n        console.log('About to call Anthropic API with:', {\n          modelToUse: model,\n          messageCount: messages.length,\n          firstUserMessage: messages.find(m => m.role === 'user')?.content?.substring(0, 50) + '...',\n        });\n        \n        // Wrap in try-catch for better error logging\n        try {\n          // Extract system message if present\n          const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n          \n          // Filter out system messages - they should be passed as a separate parameter\n          const filteredMessages = messages.filter(msg => msg.role !== 'system');\n          \n          const response = await anthropic.messages.create({\n            model,\n            max_tokens: 4000,\n            system: systemMessage,\n            messages: filteredMessages,\n            stream: true,\n          });\n\n        // Create a variable to track the full response\n        let fullResponse = '';\n        \n        // Create a transform stream to intercept chunks and collect the full response\n        const transformStream = new TransformStream({\n          transform(chunk, controller) {\n            // Pass through all chunks\n            controller.enqueue(chunk);\n            \n            // Try to extract content\n            try {\n              const text = new TextDecoder().decode(chunk);\n              if (text.includes('data:')) {\n                const match = text.match(/data: (.+?)(?=\\n|$)/g);\n                if (match) {\n                  for (const dataLine of match) {\n                    try {\n                      // Skip [DONE] events\n                      if (dataLine === 'data: [DONE]') continue;\n                      \n                      // Parse the JSON data\n                      const data = JSON.parse(dataLine.slice(6));\n                      \n                      // Handle different response formats\n                      if (data.delta?.content) {\n                        // Anthropic format\n                        fullResponse += data.delta.content;\n                      } else if (data.choices?.[0]?.delta?.content) {\n                        // OpenAI-like format\n                        fullResponse += data.choices[0].delta.content;\n                      } else if (typeof data.content === 'string') {\n                        // Direct content format\n                        fullResponse += data.content;\n                      }\n                    } catch (e) {\n                      // Quietly ignore parse errors in non-content chunks\n                      console.debug('Error parsing chunk:', e);\n                    }\n                  }\n                }\n              }\n            } catch (e) {\n              // Ignore any errors in content extraction\n            }\n          }\n        });\n        \n        // Create a copy of the original stream\n        const responseStream = AnthropicStream(response);\n        const readableStream = responseStream.pipeThrough(transformStream);\n        \n        // Process user context in the background\n        const userContextProcessing = async () => {\n          try {\n            // Handle memory extraction first (doesn't need response)\n            if (userId && includeUserContext) {\n              const userMessage = messages\n                .filter(msg => msg.role === 'user')\n                .pop()?.content as string || '';\n\n              if (userMessage) {\n                await processMessageForMemories(userId, userMessage);\n              }\n            }\n          } catch (error) {\n            console.error('Error processing user context:', error);\n          }\n        };\n        \n        // Start memory extraction in the background\n        userContextProcessing();\n        \n        // Also process the full response when the stream ends\n        readableStream.pipeTo(\n          new WritableStream({\n            close() {\n              if (userId && includeUserContext && fullResponse) {\n                processResponseForUserContext(userId, fullResponse)\n                  .catch(error => console.error('Error processing response context:', error));\n              }\n            }\n          })\n        ).catch(e => console.error('Stream processing error:', e));\n\n        // Return the stream as a streaming response\n        return new StreamingTextResponse(readableStream);\n        } catch (streamError) {\n          console.error('Streaming API call failed with error:', streamError);\n          console.error('Error details:', {\n            name: streamError instanceof Error ? streamError.name : 'Unknown',\n            message: streamError instanceof Error ? streamError.message : 'Unknown error',\n            status: streamError.status || 'No status',\n            stack: streamError instanceof Error ? streamError.stack : 'No stack trace',\n          });\n          \n          // Provide a fallback non-streaming response\n          const fallbackResponse = \"Sorry, there was an error with the streaming API. Trying with non-streaming instead.\";\n          \n          // Use non-streaming API as fallback\n          try {\n            console.log('Attempting fallback to non-streaming API');\n            // Extract system message if present\n            const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n            \n            // Filter out system messages - they should be passed as a separate parameter\n            const filteredMessages = messages.filter(msg => msg.role !== 'system');\n            \n            const fallbackApiResponse = await anthropic.messages.create({\n              model,\n              max_tokens: 1000,\n              system: systemMessage,\n              messages: filteredMessages,\n            });\n            \n            const textContent = fallbackApiResponse.content\n              .filter(block => block.type === 'text')\n              .map(block => 'text' in block ? block.text : '')\n              .join('\\n');\n              \n            // Return as streamed response for consistency\n            const encoder = new TextEncoder();\n            const stream = new ReadableStream({\n              start(controller) {\n                controller.enqueue(encoder.encode(`data: ${JSON.stringify({\n                  id: `chatmsg-${Date.now()}`,\n                  object: 'chat.completion.chunk',\n                  created: Date.now(),\n                  model: model,\n                  delta: { content: textContent },\n                  role: 'assistant'\n                })}\\n\\n`));\n                controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n                controller.close();\n              }\n            });\n            \n            return new StreamingTextResponse(stream);\n          } catch (fallbackError) {\n            console.error('Even fallback API call failed:', fallbackError);\n            throw streamError; // Re-throw original error for consistent error handling\n          }\n        }\n      } else {\n        // Handle non-streaming response\n        // Extract system message if present\n        const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n        \n        // Filter out system messages - they should be passed as a separate parameter\n        const filteredMessages = messages.filter(msg => msg.role !== 'system');\n        \n        const response = await anthropic.messages.create({\n          model,\n          max_tokens: 4000,\n          system: systemMessage,\n          messages: filteredMessages,\n        });\n\n        // Process the response for user context (if we have a userId)\n        if (userId && includeUserContext && response.content) {\n          const responseText = response.content\n            .filter(block => block.type === 'text')\n            .map(block => 'text' in block ? block.text : '')\n            .join('\\n');\n\n          try {\n            // Process for traditional user context\n            await processResponseForUserContext(userId, responseText);\n\n            // Also process for Theory of Mind memory extraction - get the user message\n            const userMessage = messages\n              .filter(msg => msg.role === 'user')\n              .pop()?.content as string || '';\n\n            if (userMessage) {\n              // Process the user's message to extract memories\n              await processMessageForMemories(userId, userMessage);\n            }\n          } catch (contextError) {\n            console.error('Error processing response for user context:', contextError);\n          }\n        }\n\n        return res.status(200).json(response);\n      }\n    } catch (apiError) {\n      console.error('Claude API error:', apiError);\n\n      // Log more detailed error info\n      console.error('Detailed API error:', {\n        name: apiError instanceof Error ? apiError.name : 'Unknown',\n        message: apiError instanceof Error ? apiError.message : 'Unknown error',\n        stack: apiError instanceof Error ? apiError.stack : 'No stack trace',\n      });\n\n      // Return a demo response even on API error\n      if (stream) {\n        const encoder = new TextEncoder();\n        const errorStream = new ReadableStream({\n          start(controller) {\n            const errorResponse = \"Sorry, there was an error contacting the AI service. This is a fallback response to prevent the application from breaking.\";\n            controller.enqueue(encoder.encode(`data: ${JSON.stringify({\n              id: `chatmsg-${Date.now()}`,\n              object: 'chat.completion.chunk',\n              created: Date.now(),\n              model: \"claude-3-demo\",\n              delta: { content: errorResponse },\n              role: 'assistant'\n            })}\\n\\n`));\n            controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n            controller.close();\n          }\n        });\n\n        return new Response(errorStream, {\n          headers: {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            'Connection': 'keep-alive'\n          }\n        });\n      } else {\n        return res.status(200).json({\n          content: [{\n            type: 'text',\n            text: \"Sorry, there was an error contacting the AI service. This is a fallback response to prevent the application from breaking.\"\n          }],\n          model: \"claude-3-demo\",\n          role: 'assistant'\n        });\n      }\n    }\n  } catch (error) {\n    console.error('Unexpected error in handler:', error);\n    console.error('Error details:', {\n      type: typeof error,\n      message: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : 'No stack trace'\n    });\n\n    // For unexpected errors, still try to return something useful\n    return res.status(200).json({\n      content: [{\n        type: 'text',\n        text: \"An unexpected error occurred. This is a fallback response.\"\n      }],\n      model: \"claude-3-demo\",\n      role: 'assistant',\n      errorDetails: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}\n\n================================================================================\nFILE: src/pages/api/claude/unified-chat.ts\n================================================================================\n\n/**\n * Unified Chat API handler for Claude\n * Handles both streaming and non-streaming requests\n */\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport chatService from '@/lib/chat/server/chatService';\n\n// Configure longer timeout\nexport const config = {\n  api: {\n    bodyParser: {\n      sizeLimit: '4mb',\n    },\n    responseLimit: '8mb',\n  },\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only accept POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Initialize Supabase client\n    const supabase = createPagesServerClient({ req, res });\n    const { data: { session } } = await supabase.auth.getSession();\n    const userId = session?.user?.id || null;\n\n    // Extract request parameters\n    const { \n      messages, \n      stream = false, \n      model = 'claude-3-sonnet-20240229', \n      includeUserContext = true,\n      notebookId \n    } = req.body;\n\n    // Basic validation\n    if (!messages || !Array.isArray(messages)) {\n      return res.status(400).json({ error: 'Invalid messages parameter' });\n    }\n\n    // Check if we're in demo mode (no API key)\n    if (chatService.isDemoMode()) {\n      // Return a demo response\n      return res.status(200).json({\n        content: chatService.getDemoResponse(),\n        model: \"claude-3-demo\",\n        role: 'assistant'\n      });\n    }\n\n    // Extract system message and prepare messages\n    const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n    const cleanedMessages = messages.filter(msg => msg.role !== 'system').map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n    // Handle non-streaming response (always use this for simplicity)\n    try {\n      // Make the API call using the chatService\n      const response = await chatService.anthropic.messages.create({\n        model,\n        max_tokens: 4000,\n        system: systemMessage,\n        messages: cleanedMessages,\n      });\n\n      // Extract text content\n      const textContent = response.content\n        .filter(block => block.type === 'text')\n        .map(block => block.text)\n        .join('\\n');\n        \n      // Process response for user context if needed (do this async)\n      if (userId && includeUserContext) {\n        const lastUserMessage = messages\n          .filter(msg => msg.role === 'user')\n          .pop()?.content || '';\n          \n        chatService.processResponse(userId, textContent, lastUserMessage, includeUserContext)\n          .catch(err => console.error('Error processing response:', err));\n      }\n\n      // Return response\n      return res.status(200).json({\n        content: textContent,\n        model: response.model,\n        role: 'assistant'\n      });\n    } catch (error) {\n      console.error('Error in chat response:', error);\n      return res.status(500).json({ \n        success: false, \n        error: error.message || 'An unknown error occurred'\n      });\n    }\n  } catch (error) {\n    console.error('Unexpected error in chat handler:', error);\n    return res.status(500).json({ \n      success: false, \n      error: 'An unknown error occurred'\n    });\n  }\n}\n\n================================================================================\nFILE: src/pages/notebooks/[id]/chat.tsx\n================================================================================\n\n// src/pages/notebooks/[id]/chat.tsx\nimport React from 'react';\nimport { useRouter } from 'next/router';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport LlamaChat from '@/components/ui/LlamaChat';\nimport Layout from '@/components/layout/Layout';\nimport LoadingSpinner from '@/components/ui/LoadingSpinner';\n\nconst NotebookChatPage = () => {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Handle the case when router.query isn't loaded yet\n  if (!router.isReady) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n  \n  const notebookId = typeof id === 'string' ? id : '';\n  \n  const { notebook, loading, error } = useNotebook(notebookId);\n\n  // Handle loading state\n  if (loading) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n\n  // Handle error state\n  if (error || !notebook) {\n    return (\n      <Layout>\n        <div className=\"flex flex-col items-center justify-center h-screen\">\n          <h2 className=\"text-xl font-semibold text-red-600 mb-4\">Error Loading Notebook</h2>\n          <p className=\"text-gray-700 mb-6\">{error || 'Notebook not found'}</p>\n          <button\n            onClick={() => router.push('/notebooks')}\n            className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n          >\n            Return to Notebooks\n          </button>\n        </div>\n      </Layout>\n    );\n  }\n\n  return (\n    <Layout>\n      <div className=\"flex flex-col h-screen\">\n        {/* Header */}\n        <div className=\"bg-white border-b border-gray-200 px-4 py-4 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <button\n              onClick={() => router.push(`/notebooks/${notebookId}`)}\n              className=\"mr-4 text-gray-600 hover:text-gray-900\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-5 w-5\"\n                viewBox=\"0 0 20 20\"\n                fill=\"currentColor\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n            </button>\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              {notebook.title || 'Untitled Notebook'} - Chat\n            </h1>\n          </div>\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={() => router.push(`/notebooks/${notebookId}/unified`)}\n              className=\"text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-600 rounded-md hover:bg-blue-50\"\n            >\n              Switch to Canvas\n            </button>\n          </div>\n        </div>\n\n        {/* Main content - Chat UI */}\n        <div className=\"flex-1 overflow-hidden bg-gray-50\">\n          <LlamaChat\n            notebookId={notebookId}\n            systemPrompt={notebook.system_prompt}\n            fullScreen={true}\n            className=\"max-w-4xl mx-auto bg-white shadow-sm h-full\"\n          />\n        </div>\n      </div>\n    </Layout>\n  );\n};\n\nexport default NotebookChatPage;\n\n================================================================================\nFILE: src/pages/notebooks/[id]/unified.tsx\n================================================================================\n\n// src/pages/notebooks/[id]/unified.tsx\n// Redirect to the main notebook page\nimport { useRouter } from 'next/router';\nimport { useEffect } from 'react';\n\nexport default function UnifiedCanvasPage() {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Redirect to the main notebook page when the router is ready\n  useEffect(() => {\n    if (!id || typeof id !== 'string') return;\n    \n    // Redirect to main notebook page since the unified view is now the default\n    router.replace(`/notebooks/${id}`);\n  }, [id, router]);\n  \n  // Show loading state while redirecting\n  return (\n    <div className=\"flex items-center justify-center h-screen\">\n      <div className=\"text-center\">\n        <div className=\"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500 mx-auto mb-4\"></div>\n        <p className=\"text-gray-600\">Redirecting to notebook...</p>\n      </div>\n    </div>\n  );\n}\n\n================================================================================\nFILE: src/services/nodeService.ts\n================================================================================\n\n// Service for working with nodes and relationships\n// src/services/nodeService.ts\n\nimport { supabase } from '@/lib/supabaseClient';\nimport { \n  Node, \n  Relationship, \n  CardType, \n  RelationshipType, \n  Vector,\n  ThreadView \n} from '@/types/thread';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Create a new node\n * @param notebookId The ID of the notebook to create the node in\n * @param content The content of the node\n * @param type The type of node (question, response, note, drawing)\n * @param position The position of the node on the canvas\n * @param metadata Optional metadata for the node (e.g., selection info, thumbnail)\n * @param attention Optional attention markers for the node\n * @returns The created node or null if there was an error\n */\nexport async function createNode(\n  notebookId: string, \n  content: string,\n  type: CardType,\n  position: { x: number, y: number },\n  metadata?: Record<string, any>,\n  attention?: string[]\n): Promise<Node | null> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .insert({\n        id: uuidv4(),\n        content,\n        type,\n        notebook_id: notebookId,\n        position,\n        attention: attention || [],\n        metadata: metadata || {},\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n      \n    if (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n    \n    return data;\n  } catch (err) {\n    console.error('Exception creating node:', err);\n    return null;\n  }\n}\n\n/**\n * Update an existing node\n * @param nodeId The ID of the node to update\n * @param updates The properties to update\n * @returns The updated node or null if there was an error\n */\nexport async function updateNode(\n  nodeId: string,\n  updates: Partial<Omit<Node, 'id' | 'created_at' | 'created_by'>>\n): Promise<Node | null> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .update(updates)\n      .eq('id', nodeId)\n      .select()\n      .single();\n      \n    if (error) {\n      console.error('Error updating node:', error);\n      return null;\n    }\n    \n    return data;\n  } catch (err) {\n    console.error('Exception updating node:', err);\n    return null;\n  }\n}\n\n/**\n * Create a relationship between two nodes\n * @param fromNodeId The ID of the source node\n * @param toNodeId The ID of the target node\n * @param type The type of relationship\n * @param notebookId The ID of the notebook that contains both nodes\n * @param context Optional context explaining the relationship\n * @param vector Optional vector properties for the relationship\n * @returns The created relationship or null if there was an error\n */\nexport async function createRelationship(\n  fromNodeId: string,\n  toNodeId: string,\n  type: RelationshipType,\n  notebookId: string,\n  context?: string,\n  vector?: Vector\n): Promise<Relationship | null> {\n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .insert({\n        id: uuidv4(),\n        from_node_id: fromNodeId,\n        to_node_id: toNodeId,\n        type,\n        notebook_id: notebookId,\n        context,\n        vector,\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n      \n    if (error) {\n      console.error('Error creating relationship:', error);\n      return null;\n    }\n    \n    return data;\n  } catch (err) {\n    console.error('Exception creating relationship:', err);\n    return null;\n  }\n}\n\n/**\n * Get all nodes for a notebook\n * @param notebookId The ID of the notebook to get nodes for\n * @returns Array of nodes or empty array if there was an error\n */\nexport async function getNodesByNotebook(notebookId: string): Promise<Node[]> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting nodes:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting nodes:', err);\n    return [];\n  }\n}\n\n/**\n * Get nodes by type for a notebook\n * @param notebookId The ID of the notebook to get nodes for\n * @param type The type of nodes to get\n * @returns Array of nodes matching the type or empty array if there was an error\n */\nexport async function getNodesByType(notebookId: string, type: CardType): Promise<Node[]> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .eq('type', type)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting nodes by type:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting nodes by type:', err);\n    return [];\n  }\n}\n\n/**\n * Get all relationships for a notebook\n * @param notebookId The ID of the notebook to get relationships for\n * @returns Array of relationships or empty array if there was an error\n */\nexport async function getRelationshipsByNotebook(notebookId: string): Promise<Relationship[]> {\n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting relationships:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting relationships:', err);\n    return [];\n  }\n}\n\n/**\n * Get all relationships of a specific type for a notebook\n * @param notebookId The ID of the notebook to get relationships for\n * @param type The type of relationships to get\n * @returns Array of relationships matching the type or empty array if there was an error\n */\nexport async function getRelationshipsByType(\n  notebookId: string, \n  type: RelationshipType\n): Promise<Relationship[]> {\n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .eq('type', type)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting relationships by type:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting relationships by type:', err);\n    return [];\n  }\n}\n\n/**\n * Get a threaded view of nodes for a notebook\n * Constructs a hierarchical view based on relationships\n * @param notebookId The ID of the notebook to get thread view for\n * @returns Array of ThreadView objects with parent-child relationships\n */\nexport async function getThreadView(notebookId: string): Promise<ThreadView[]> {\n  try {\n    // First get all nodes and relationships\n    const [nodes, relationships] = await Promise.all([\n      getNodesByNotebook(notebookId),\n      getRelationshipsByNotebook(notebookId)\n    ]);\n    \n    // Create a map of nodes by ID for quick lookup\n    const nodeMap = nodes.reduce((acc, node) => {\n      acc[node.id] = node;\n      return acc;\n    }, {} as Record<string, Node>);\n    \n    // Build parent-child relationships (prioritize 'extends' relationship type)\n    const childrenMap: Record<string, string[]> = {};\n    const parentMap: Record<string, string> = {};\n    \n    // First pass: process 'extends' relationships\n    relationships\n      .filter(rel => rel.type === 'extends')\n      .forEach(rel => {\n        if (!childrenMap[rel.from_node_id]) {\n          childrenMap[rel.from_node_id] = [];\n        }\n        childrenMap[rel.from_node_id].push(rel.to_node_id);\n        parentMap[rel.to_node_id] = rel.from_node_id;\n      });\n    \n    // Second pass: process other relationships (if no 'extends' is found)\n    relationships\n      .filter(rel => rel.type !== 'extends')\n      .forEach(rel => {\n        if (!parentMap[rel.to_node_id]) {\n          if (!childrenMap[rel.from_node_id]) {\n            childrenMap[rel.from_node_id] = [];\n          }\n          if (!childrenMap[rel.from_node_id].includes(rel.to_node_id)) {\n            childrenMap[rel.from_node_id].push(rel.to_node_id);\n            parentMap[rel.to_node_id] = rel.from_node_id;\n          }\n        }\n      });\n    \n    // Find root nodes (nodes without parents)\n    const rootNodeIds = nodes\n      .filter(node => !parentMap[node.id])\n      .map(node => node.id);\n    \n    // Build thread view recursively\n    const buildThreadView = (nodeId: string, depth: number = 0): ThreadView | null => {\n      const node = nodeMap[nodeId];\n      if (!node) return null;\n      \n      const childNodes = (childrenMap[nodeId] || [])\n        .map(childId => buildThreadView(childId, depth + 1))\n        .filter(Boolean) as ThreadView[];\n      \n      return {\n        id: node.id,\n        content: node.content,\n        type: node.type,\n        parent_id: parentMap[node.id],\n        depth,\n        position: node.position || { x: 0, y: 0 },\n        created_at: node.created_at,\n        created_by: node.created_by,\n        children: childNodes\n      };\n    };\n    \n    // Build thread views for all root nodes\n    return rootNodeIds\n      .map(nodeId => buildThreadView(nodeId))\n      .filter(Boolean) as ThreadView[];\n  } catch (err) {\n    console.error('Exception getting thread view:', err);\n    return [];\n  }\n}\n\n/**\n * Delete a node (and all its relationships)\n * @param nodeId The ID of the node to delete\n * @returns Boolean indicating success\n */\nexport async function deleteNode(nodeId: string): Promise<boolean> {\n  try {\n    // Deleting the node will cascade to delete its relationships\n    const { error } = await supabase\n      .from('nodes')\n      .delete()\n      .eq('id', nodeId);\n      \n    if (error) {\n      console.error('Error deleting node:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Exception deleting node:', err);\n    return false;\n  }\n}\n\n/**\n * Delete a relationship\n * @param relationshipId The ID of the relationship to delete\n * @returns Boolean indicating success\n */\nexport async function deleteRelationship(relationshipId: string): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('relationships')\n      .delete()\n      .eq('id', relationshipId);\n      \n    if (error) {\n      console.error('Error deleting relationship:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Exception deleting relationship:', err);\n    return false;\n  }\n}\n\n/**\n * Update node position in the database\n * @param nodeId The ID of the node to update\n * @param position The new position\n * @returns Boolean indicating success\n */\nexport async function updateNodePosition(\n  nodeId: string, \n  position: { x: number, y: number }\n): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('nodes')\n      .update({ position })\n      .eq('id', nodeId);\n      \n    if (error) {\n      console.error('Error updating node position:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Exception updating node position:', err);\n    return false;\n  }\n}\n\n/**\n * Get related nodes for a specific node\n * @param nodeId The ID of the node to get related nodes for\n * @returns Array of related nodes\n */\nexport async function getRelatedNodes(nodeId: string): Promise<Node[]> {\n  try {\n    // Get relationships involving this node\n    const { data: relationships, error: relError } = await supabase\n      .from('relationships')\n      .select('*')\n      .or(`from_node_id.eq.${nodeId},to_node_id.eq.${nodeId}`);\n      \n    if (relError) {\n      console.error('Error getting relationships:', relError);\n      return [];\n    }\n    \n    // Extract the related node IDs\n    const relatedNodeIds = new Set<string>();\n    relationships?.forEach(rel => {\n      if (rel.from_node_id === nodeId) {\n        relatedNodeIds.add(rel.to_node_id);\n      } else {\n        relatedNodeIds.add(rel.from_node_id);\n      }\n    });\n    \n    // If no related nodes, return empty array\n    if (relatedNodeIds.size === 0) {\n      return [];\n    }\n    \n    // Get the related nodes\n    const { data: nodes, error: nodeError } = await supabase\n      .from('nodes')\n      .select('*')\n      .in('id', Array.from(relatedNodeIds));\n      \n    if (nodeError) {\n      console.error('Error getting related nodes:', nodeError);\n      return [];\n    }\n    \n    return nodes || [];\n  } catch (err) {\n    console.error('Exception getting related nodes:', err);\n    return [];\n  }\n}\n\n/**\n * Convert legacy conversational data to the relationship-centric model\n * @param notebookId The ID of the notebook to migrate\n * @returns Boolean indicating success\n */\nexport async function migrateConversationsToNodes(notebookId: string): Promise<boolean> {\n  try {\n    // Call the RPC function in the database\n    const { data, error } = await supabase\n      .rpc('migrate_conversations_to_nodes', { p_notebook_id: notebookId });\n      \n    if (error) {\n      console.error('Error migrating conversations to nodes:', error);\n      return false;\n    }\n    \n    return data || false;\n  } catch (err) {\n    console.error('Exception migrating conversations to nodes:', err);\n    return false;\n  }\n}\n\n================================================================================\nFILE: src/services/threadService.ts\n================================================================================\n\n// src/services/threadService.ts\nimport { supabase } from '@/lib/supabaseClient';\nimport { Thread, Message, ThreadConnection, Card, CardConnection } from '@/types/thread';\nimport { nanoid } from 'nanoid';\n\n/**\n * Database update data type for thread\n */\ninterface ThreadUpdateData {\n  position?: { x: number; y: number };\n  title?: string;\n  parent_id?: string | null;\n  referenced_threads?: string[];\n  card_type?: string;\n  handwriting_style?: string;\n  is_minimized?: boolean;\n  z_index?: number;\n}\n\n// Service for thread operations\nexport const threadService = {\n  // Check if migration is needed\n  async isMigrationNeeded(_notebookId: string): Promise<boolean> {\n    try {\n      // This is a simple implementation that always returns false\n      // In a real implementation, you'd check if there are conversations to migrate\n      return false;\n    } catch (error) {\n      console.error('Error checking migration status:', error);\n      return false;\n    }\n  },\n\n  // Migrate conversations to threads\n  async migrateNotebookConversations(_notebookId: string): Promise<void> {\n    // This is a simple implementation that does nothing\n    // In a real implementation, you'd convert old conversation records to new thread format\n    console.log(`Migration would happen for notebook ${_notebookId}`);\n  },\n  // Fetch all threads for a notebook\n  async getThreadsByNotebook(notebookId: string): Promise<Thread[]> {\n    try {\n      const { data: threadsData, error: threadsError } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n        \n      if (threadsError) {\n        throw threadsError;\n      }\n      \n      if (!threadsData?.length) {\n        return [];\n      }\n      \n      // Fetch all messages for these threads in a single query\n      const threadIds = threadsData.map(thread => thread.id);\n      const { data: messagesData, error: messagesError } = await supabase\n        .from('thread_messages')\n        .select('*')\n        .in('thread_id', threadIds)\n        .order('created_at', { ascending: true });\n        \n      if (messagesError) {\n        throw messagesError;\n      }\n      \n      // Group messages by thread ID\n      const messagesByThread: Record<string, Message[]> = {};\n      \n      (messagesData || []).forEach(message => {\n        if (!messagesByThread[message.thread_id]) {\n          messagesByThread[message.thread_id] = [];\n        }\n        \n        messagesByThread[message.thread_id].push({\n          id: message.id,\n          threadId: message.thread_id,\n          content: message.content,\n          role: message.role,\n          createdAt: message.created_at\n        });\n      });\n      \n      // Combine thread data with messages\n      return threadsData.map(thread => ({\n        id: thread.id,\n        notebookId: thread.notebook_id,\n        title: thread.title,\n        position: thread.position,\n        messages: messagesByThread[thread.id] || [],\n        parentId: thread.parent_id,\n        referencedThreads: thread.referenced_threads,\n        createdAt: thread.created_at,\n        updatedAt: thread.updated_at,\n        cardType: thread.card_type,\n        handwritingStyle: thread.handwriting_style,\n        isMinimized: thread.is_minimized,\n        zIndex: thread.z_index\n      }));\n    } catch (error) {\n      console.error('Error fetching threads:', error);\n      throw error;\n    }\n  },\n  \n  // Create a new thread\n  async createThread(thread: Omit<Thread, 'id' | 'createdAt' | 'updatedAt' | 'messages'> & { messages?: Omit<Message, 'id' | 'threadId' | 'createdAt'>[] }): Promise<Thread> {\n    try {\n      // Let the database generate the UUID - don't specify an ID in the insert\n      const newThread = {\n        notebook_id: thread.notebookId,\n        title: thread.title,\n        position: thread.position,\n        parent_id: thread.parentId,\n        referenced_threads: thread.referencedThreads,\n        card_type: thread.cardType,\n        handwriting_style: thread.handwritingStyle,\n        is_minimized: thread.isMinimized || false,\n        z_index: thread.zIndex || 0\n      };\n      \n      // Insert thread into database and get the generated ID\n      const { data, error: threadError } = await supabase\n        .from('threads')\n        .insert(newThread)\n        .select('id')\n        .single();\n\n      if (threadError || !data) {\n        throw threadError || new Error('Failed to create thread - no ID returned');\n      }\n\n      // Get the database-generated UUID\n      const threadId = data.id;\n\n      // Create initial messages if any\n      if (thread.messages && thread.messages.length > 0) {\n        const messagesToInsert = thread.messages.map(message => ({\n          thread_id: threadId,\n          content: message.content,\n          role: message.role\n        }));\n\n        const { error: messagesError } = await supabase\n          .from('thread_messages')\n          .insert(messagesToInsert);\n\n        if (messagesError) {\n          throw messagesError;\n        }\n      }\n\n      // Convert message data to proper Message objects\n      const messageData = thread.messages || [];\n      const messages: Message[] = messageData.map(msg => ({\n        id: nanoid(), // It's ok to use nanoid here as it's just for the client\n        threadId,\n        content: msg.content,\n        role: msg.role,\n        createdAt: new Date().toISOString()\n      }));\n\n      // Return the complete thread\n      return {\n        id: threadId,\n        notebookId: thread.notebookId,\n        title: thread.title,\n        position: thread.position,\n        messages,\n        parentId: thread.parentId,\n        referencedThreads: thread.referencedThreads,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        cardType: thread.cardType,\n        handwritingStyle: thread.handwritingStyle,\n        isMinimized: thread.isMinimized || false,\n        zIndex: thread.zIndex || 0\n      };\n    } catch (error) {\n      console.error('Error creating thread:', error);\n      throw error;\n    }\n  },\n  \n  // Update thread properties (position, zIndex, title, etc.)\n  async updateThread(threadId: string, updates: Partial<Thread>): Promise<void> {\n    try {\n      // Convert to snake_case format for database\n      const updateData: ThreadUpdateData = {};\n      \n      if (updates.position) updateData.position = updates.position;\n      if (updates.title !== undefined) updateData.title = updates.title;\n      if (updates.parentId !== undefined) updateData.parent_id = updates.parentId;\n      if (updates.referencedThreads !== undefined) updateData.referenced_threads = updates.referencedThreads;\n      if (updates.cardType !== undefined) updateData.card_type = updates.cardType;\n      if (updates.handwritingStyle !== undefined) updateData.handwriting_style = updates.handwritingStyle;\n      if (updates.isMinimized !== undefined) updateData.is_minimized = updates.isMinimized;\n      if (updates.zIndex !== undefined) updateData.z_index = updates.zIndex;\n      \n      // Only update if we have changes\n      if (Object.keys(updateData).length === 0) return;\n      \n      const { error } = await supabase\n        .from('threads')\n        .update(updateData)\n        .eq('id', threadId);\n        \n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Delete a thread and all its messages\n  async deleteThread(threadId: string): Promise<void> {\n    try {\n      // Messages will be deleted automatically via ON DELETE CASCADE\n      const { error } = await supabase\n        .from('threads')\n        .delete()\n        .eq('id', threadId);\n        \n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error deleting thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Add a message to a thread\n  async addMessage(threadId: string, content: string, role: 'user' | 'assistant' | 'system'): Promise<Message> {\n    try {\n      const messageId = nanoid();\n      \n      const { error } = await supabase\n        .from('thread_messages')\n        .insert({\n          id: messageId,\n          thread_id: threadId,\n          content,\n          role\n        });\n        \n      if (error) {\n        throw error;\n      }\n      \n      // Return the new message\n      return {\n        id: messageId,\n        threadId,\n        content,\n        role,\n        createdAt: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error(`Error adding message to thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Stream a message from AI while saving it to the database\n  async streamMessage(threadId: string, userMessage: string, systemPrompt?: string): Promise<Response> {\n    try {\n      // First save the user message\n      await this.addMessage(threadId, userMessage, 'user');\n\n      // Call the AI endpoint and return the response\n      const response = await fetch('/api/claude/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          threadId,\n          message: userMessage,\n          systemPrompt\n        })\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`AI streaming error: ${errorText}`);\n      }\n\n      // Return the full response object\n      return response;\n    } catch (error) {\n      console.error(`Error streaming message to thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Update a message's content\n  async updateMessage(messageId: string, content: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('thread_messages')\n        .update({ content })\n        .eq('id', messageId);\n        \n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating message ${messageId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Get thread connections\n  async getThreadConnections(notebookId: string): Promise<ThreadConnection[]> {\n    try {\n      // Fetch all threads for the notebook\n      const { data, error } = await supabase\n        .from('threads')\n        .select('id, parent_id, referenced_threads')\n        .eq('notebook_id', notebookId);\n\n      if (error) {\n        throw error;\n      }\n\n      const connections: ThreadConnection[] = [];\n\n      // Process parent-child relationships\n      data?.forEach(thread => {\n        if (thread.parent_id) {\n          connections.push({\n            fromId: thread.parent_id,\n            toId: thread.id,\n            type: 'parent-child'\n          });\n        }\n\n        // Process referenced threads\n        if (thread.referenced_threads && thread.referenced_threads.length > 0) {\n          thread.referenced_threads.forEach((referencedId: string) => {\n            connections.push({\n              fromId: thread.id,\n              toId: referencedId,\n              type: 'reference'\n            });\n          });\n        }\n      });\n\n      return connections;\n    } catch (error) {\n      console.error('Error fetching thread connections:', error);\n      throw error;\n    }\n  },\n\n  // Create a card linked to a thread\n  async createCard(notebookId: string, threadId: string, card: Omit<Card, 'id' | 'notebookId' | 'threadId' | 'createdAt' | 'updatedAt'>): Promise<Card> {\n    try {\n      const { data, error } = await supabase\n        .from('cards')\n        .insert({\n          notebook_id: notebookId,\n          thread_id: threadId,\n          type: card.type,\n          title: card.title,\n          content: card.content,\n          position: card.position,\n          size: card.size,\n          is_collapsed: card.isCollapsed,\n          z_index: card.zIndex,\n          style: card.style,\n          config: card.config\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      return {\n        id: data.id,\n        notebookId: data.notebook_id,\n        threadId: data.thread_id,\n        type: data.type,\n        title: data.title,\n        content: data.content,\n        position: data.position,\n        size: data.size,\n        isCollapsed: data.is_collapsed,\n        isDragging: false,\n        zIndex: data.z_index,\n        style: data.style,\n        config: data.config,\n        createdAt: data.created_at,\n        updatedAt: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error creating card:', error);\n      throw error;\n    }\n  },\n\n  // Get a card by thread ID\n  async getCardByThreadId(threadId: string): Promise<Card | null> {\n    try {\n      const { data, error } = await supabase\n        .from('cards')\n        .select('*')\n        .eq('thread_id', threadId)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          // No row found\n          return null;\n        }\n        throw error;\n      }\n\n      if (!data) return null;\n\n      return {\n        id: data.id,\n        notebookId: data.notebook_id,\n        threadId: data.thread_id,\n        type: data.type,\n        title: data.title,\n        content: data.content,\n        position: data.position,\n        size: data.size,\n        isCollapsed: data.is_collapsed,\n        isDragging: false,\n        zIndex: data.z_index,\n        style: data.style,\n        config: data.config,\n        createdAt: data.created_at,\n        updatedAt: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error fetching card by thread ID:', error);\n      throw error;\n    }\n  },\n\n  // Get a thread by card ID\n  async getThreadByCardId(cardId: string): Promise<Thread | null> {\n    try {\n      // First get the card to find the thread ID\n      const { data: cardData, error: cardError } = await supabase\n        .from('cards')\n        .select('thread_id')\n        .eq('id', cardId)\n        .single();\n\n      if (cardError) {\n        if (cardError.code === 'PGRST116') {\n          // No row found\n          return null;\n        }\n        throw cardError;\n      }\n\n      if (!cardData || !cardData.thread_id) return null;\n\n      // Get the thread\n      const { data: threadData, error: threadError } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('id', cardData.thread_id)\n        .single();\n\n      if (threadError) {\n        throw threadError;\n      }\n\n      if (!threadData) return null;\n\n      // Get thread messages\n      const { data: messagesData, error: messagesError } = await supabase\n        .from('thread_messages')\n        .select('*')\n        .eq('thread_id', threadData.id)\n        .order('created_at', { ascending: true });\n\n      if (messagesError) {\n        throw messagesError;\n      }\n\n      // Convert messages to the correct format\n      const messages: Message[] = (messagesData || []).map(message => ({\n        id: message.id,\n        threadId: message.thread_id,\n        content: message.content,\n        role: message.role,\n        createdAt: message.created_at\n      }));\n\n      // Return the thread with messages\n      return {\n        id: threadData.id,\n        notebookId: threadData.notebook_id,\n        title: threadData.title,\n        position: threadData.position,\n        messages: messages,\n        parentId: threadData.parent_id,\n        referencedThreads: threadData.referenced_threads,\n        createdAt: threadData.created_at,\n        updatedAt: threadData.updated_at,\n        cardType: threadData.card_type,\n        handwritingStyle: threadData.handwriting_style,\n        isMinimized: threadData.is_minimized,\n        zIndex: threadData.z_index\n      };\n    } catch (error) {\n      console.error('Error fetching thread by card ID:', error);\n      throw error;\n    }\n  },\n\n  // Get all cards in a notebook\n  async getCardsByNotebook(notebookId: string): Promise<Card[]> {\n    try {\n      const { data, error } = await supabase\n        .from('cards')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n\n      if (error) {\n        throw error;\n      }\n\n      return (data || []).map(card => ({\n        id: card.id,\n        notebookId: card.notebook_id,\n        threadId: card.thread_id,\n        type: card.type,\n        title: card.title,\n        content: card.content,\n        position: card.position,\n        size: card.size,\n        isCollapsed: card.is_collapsed,\n        isDragging: false,\n        zIndex: card.z_index,\n        style: card.style,\n        config: card.config,\n        createdAt: card.created_at,\n        updatedAt: card.updated_at\n      }));\n    } catch (error) {\n      console.error('Error fetching cards by notebook:', error);\n      throw error;\n    }\n  },\n\n  // Update a card\n  async updateCard(cardId: string, updates: Partial<Card>): Promise<void> {\n    try {\n      const updateData: Record<string, any> = {};\n\n      if (updates.title !== undefined) updateData.title = updates.title;\n      if (updates.content !== undefined) updateData.content = updates.content;\n      if (updates.position !== undefined) updateData.position = updates.position;\n      if (updates.size !== undefined) updateData.size = updates.size;\n      if (updates.isCollapsed !== undefined) updateData.is_collapsed = updates.isCollapsed;\n      if (updates.zIndex !== undefined) updateData.z_index = updates.zIndex;\n      if (updates.style !== undefined) updateData.style = updates.style;\n      if (updates.config !== undefined) updateData.config = updates.config;\n\n      // Only update if we have changes\n      if (Object.keys(updateData).length === 0) return;\n\n      const { error } = await supabase\n        .from('cards')\n        .update(updateData)\n        .eq('id', cardId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  // Delete a card\n  async deleteCard(cardId: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('cards')\n        .delete()\n        .eq('id', cardId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error deleting card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  // Card connection methods\n\n  // Create a connection between two cards\n  async createCardConnection(connection: Omit<CardConnection, 'id' | 'createdAt' | 'updatedAt'>): Promise<CardConnection> {\n    try {\n      const { data, error } = await supabase\n        .from('card_connections')\n        .insert({\n          notebook_id: connection.notebookId,\n          from_card_id: connection.fromCardId,\n          to_card_id: connection.toCardId,\n          type: connection.type,\n          label: connection.label,\n          style: connection.style\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      return {\n        id: data.id,\n        notebookId: data.notebook_id,\n        fromCardId: data.from_card_id,\n        toCardId: data.to_card_id,\n        type: data.type,\n        label: data.label,\n        style: data.style,\n        createdAt: data.created_at,\n        updatedAt: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error creating card connection:', error);\n      throw error;\n    }\n  },\n\n  // Get all connections for a notebook\n  async getCardConnections(notebookId: string): Promise<CardConnection[]> {\n    try {\n      const { data, error } = await supabase\n        .from('card_connections')\n        .select('*')\n        .eq('notebook_id', notebookId);\n\n      if (error) {\n        throw error;\n      }\n\n      return (data || []).map(conn => ({\n        id: conn.id,\n        notebookId: conn.notebook_id,\n        fromCardId: conn.from_card_id,\n        toCardId: conn.to_card_id,\n        type: conn.type,\n        label: conn.label,\n        style: conn.style,\n        createdAt: conn.created_at,\n        updatedAt: conn.updated_at\n      }));\n    } catch (error) {\n      console.error('Error fetching card connections:', error);\n      throw error;\n    }\n  },\n\n  // Get connections for a specific card\n  async getCardConnectionsForCard(cardId: string): Promise<CardConnection[]> {\n    try {\n      const { data, error } = await supabase\n        .from('card_connections')\n        .select('*')\n        .or(`from_card_id.eq.${cardId},to_card_id.eq.${cardId}`);\n\n      if (error) {\n        throw error;\n      }\n\n      return (data || []).map(conn => ({\n        id: conn.id,\n        notebookId: conn.notebook_id,\n        fromCardId: conn.from_card_id,\n        toCardId: conn.to_card_id,\n        type: conn.type,\n        label: conn.label,\n        style: conn.style,\n        createdAt: conn.created_at,\n        updatedAt: conn.updated_at\n      }));\n    } catch (error) {\n      console.error(`Error fetching connections for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  // Update a card connection\n  async updateCardConnection(connectionId: string, updates: Partial<CardConnection>): Promise<void> {\n    try {\n      const updateData: Record<string, any> = {};\n\n      if (updates.type !== undefined) updateData.type = updates.type;\n      if (updates.label !== undefined) updateData.label = updates.label;\n      if (updates.style !== undefined) updateData.style = updates.style;\n\n      // Only update if we have changes\n      if (Object.keys(updateData).length === 0) return;\n\n      const { error } = await supabase\n        .from('card_connections')\n        .update(updateData)\n        .eq('id', connectionId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating card connection ${connectionId}:`, error);\n      throw error;\n    }\n  },\n\n  // Delete a card connection\n  async deleteCardConnection(connectionId: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('card_connections')\n        .delete()\n        .eq('id', connectionId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error deleting card connection ${connectionId}:`, error);\n      throw error;\n    }\n  },\n\n  // Connect two threads with their cards\n  async connectThreads(fromThreadId: string, toThreadId: string, connectionType: 'parent-child' | 'reference' | 'custom', label?: string): Promise<void> {\n    try {\n      // First get the cards for both threads\n      const fromCard = await this.getCardByThreadId(fromThreadId);\n      const toCard = await this.getCardByThreadId(toThreadId);\n\n      if (!fromCard || !toCard) {\n        throw new Error('One or both threads do not have associated cards');\n      }\n\n      // Create the card connection\n      await this.createCardConnection({\n        notebookId: fromCard.notebookId,\n        fromCardId: fromCard.id,\n        toCardId: toCard.id,\n        type: connectionType,\n        label,\n        style: {}\n      });\n\n      // If this is a parent-child relationship, also update the thread's parent_id\n      if (connectionType === 'parent-child') {\n        await this.updateThread(toThreadId, {\n          parentId: fromThreadId\n        });\n      }\n\n      // If this is a reference, update the thread's referenced_threads array\n      if (connectionType === 'reference') {\n        const { data } = await supabase\n          .from('threads')\n          .select('referenced_threads')\n          .eq('id', fromThreadId)\n          .single();\n\n        const referencedThreads = data?.referenced_threads || [];\n\n        if (!referencedThreads.includes(toThreadId)) {\n          await this.updateThread(fromThreadId, {\n            referencedThreads: [...referencedThreads, toThreadId]\n          });\n        }\n      }\n    } catch (error) {\n      console.error(`Error connecting threads ${fromThreadId} and ${toThreadId}:`, error);\n      throw error;\n    }\n  },\n\n  // Drawing-related methods\n\n  /**\n   * Create a new stroke with support for multi-device inputs and pressure sensitivity\n   * @param notebookId The notebook ID\n   * @param points Array of stroke points with pressure data\n   * @param tool The drawing tool used (pen/eraser)\n   * @param color The stroke color\n   * @param width The stroke width\n   * @param inputType The input type (mouse/touch/pen)\n   */\n  async createStroke(\n    notebookId: string,\n    points: StrokePoint[],\n    tool: string,\n    color: string,\n    width: number,\n    inputType?: 'mouse' | 'touch' | 'pen'\n  ): Promise<Stroke> {\n    try {\n      // Add input type metadata to help with rendering optimization\n      const metadata = {\n        inputType: inputType || 'mouse'\n      };\n\n      // Insert the stroke record\n      const { data, error } = await supabase\n        .from('strokes')\n        .insert({\n          notebook_id: notebookId,\n          points: points,\n          tool: tool,\n          color: color,\n          width: width,\n          metadata: metadata\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      // Convert the database record to our application type\n      return {\n        id: data.id,\n        notebook_id: data.notebook_id,\n        points: data.points as StrokePoint[],\n        tool: data.tool,\n        color: data.color,\n        width: data.width,\n        order_index: data.order_index,\n        created_at: data.created_at,\n        updated_at: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error creating stroke:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get all strokes for a notebook with optimized batch loading\n   * @param notebookId The notebook ID\n   */\n  async getStrokesByNotebook(notebookId: string): Promise<Stroke[]> {\n    try {\n      // Get all strokes in one query\n      const { data, error } = await supabase\n        .from('strokes')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n\n      if (error) {\n        throw error;\n      }\n\n      // Convert the database records to our application type\n      return (data || []).map(stroke => ({\n        id: stroke.id,\n        notebook_id: stroke.notebook_id,\n        points: stroke.points as StrokePoint[],\n        tool: stroke.tool,\n        color: stroke.color,\n        width: stroke.width,\n        order_index: stroke.order_index,\n        created_at: stroke.created_at,\n        updated_at: stroke.updated_at\n      }));\n    } catch (error) {\n      console.error('Error fetching strokes:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Send a stroke update in real-time to other users\n   * @param notebookId The notebook ID\n   * @param strokeId The stroke ID\n   * @param userId The user ID\n   * @param newPoints New stroke points to add\n   * @param inputType The input device type\n   */\n  async broadcastStrokeUpdate(\n    notebookId: string,\n    strokeId: string,\n    userId: string,\n    newPoints: StrokePoint[],\n    inputType?: 'mouse' | 'touch' | 'pen'\n  ): Promise<void> {\n    try {\n      // Generate a unique client ID if needed\n      const clientId = window.clientId || `client-${Math.random().toString(36).substring(2, 9)}`;\n\n      // Send the real-time update\n      await supabase.channel('drawing-updates')\n        .send({\n          type: 'broadcast',\n          event: 'stroke-update',\n          payload: {\n            notebookId,\n            strokeId,\n            userId,\n            clientId,\n            newPoints,\n            timestamp: new Date().toISOString(),\n            inputType: inputType || 'mouse'\n          }\n        });\n    } catch (error) {\n      console.error('Error broadcasting stroke update:', error);\n      // Don't throw the error - this is non-critical\n    }\n  }\n};\n\n================================================================================\nFILE: src/stores/nodeStore.ts\n================================================================================\n\n// src/stores/nodeStore.ts\nimport { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { supabase } from '@/lib/supabaseClient';\nimport { \n  Node, \n  Relationship, \n  CardType, \n  NodePosition as NodePositionType,\n  RelationshipType,\n  Vector\n} from '@/types/thread';\n\n// Re-export NodePosition from thread.ts to avoid duplication\nexport type NodePosition = NodePositionType;\n\n/**\n * NodeState interface defines the state and actions for the node store\n * This store is the central state management for the relationship-centric model\n */\ninterface NodeState {\n  // State\n  nodes: Record<string, Node>;\n  relationships: Relationship[];\n  nodePositions: Record<string, NodePosition>;\n  selectedNodeId: string | null;\n  activeNodeId: string | null;\n  isLoading: boolean;\n  error: string | null;\n  \n  // Actions\n  fetchNodesByNotebook: (notebookId: string) => Promise<void>;\n  addNode: (node: Node) => void;\n  addRelationship: (relationship: Relationship) => void;\n  updateNode: (id: string, updates: Partial<Node>) => Promise<void>;\n  deleteNode: (id: string) => Promise<void>;\n  updateRelationship: (id: string, updates: Partial<Relationship>) => Promise<void>;\n  deleteRelationship: (id: string) => Promise<void>;\n  updateNodePosition: (id: string, x: number, y: number, persistToDatabase?: boolean) => Promise<void>;\n  setNodeDragging: (id: string, isDragging: boolean) => void;\n  toggleNodeCollapse: (id: string) => void;\n  setSelectedNode: (id: string | null) => void;\n  setActiveNode: (id: string | null) => void;\n  \n  // Relationship Operations\n  createNodeRelationship: (\n    fromNodeId: string, \n    toNodeId: string, \n    type: RelationshipType, \n    notebookId: string,\n    vector?: Vector\n  ) => Promise<Relationship | null>;\n  \n  // Message Operations\n  addMessageToNode: (\n    nodeId: string,\n    message: Omit<Message, 'id' | 'created_at'>,\n    persistToDatabase?: boolean\n  ) => Promise<Message | null>;\n  \n  updateNodeMessages: (\n    nodeId: string,\n    messages: Message[],\n    persistToDatabase?: boolean\n  ) => Promise<void>;\n  \n  getNodeMessages: (nodeId: string) => Message[];\n  \n  // Query Helpers\n  getChildNodes: (nodeId: string, relationshipType?: RelationshipType) => Node[];\n  getParentNode: (nodeId: string, relationshipType?: RelationshipType) => Node | null;\n  getConnectedNodes: (nodeId: string, relationshipType?: RelationshipType) => Node[];\n  getRelationshipsBetween: (fromNodeId: string, toNodeId: string) => Relationship[];\n  getNodesByType: (notebookId: string, type: CardType) => Node[];\n}\n\n/**\n * useNodeStore is the primary store for managing the relationship-centric model\n * It handles all node and relationship CRUD operations and provides helper functions\n */\nconst useNodeStore = create<NodeState>()(\n  immer((set, get) => ({\n    // State\n    nodes: {},\n    relationships: [],\n    nodePositions: {},\n    selectedNodeId: null,\n    activeNodeId: null,\n    isLoading: false,\n    error: null,\n    \n    // Message Operations\n    addMessageToNode: async (\n      nodeId: string, \n      message: Omit<Message, 'id' | 'created_at'>, \n      persistToDatabase = true\n    ) => {\n      const node = get().nodes[nodeId];\n      if (!node) {\n        console.error(`Node with ID ${nodeId} not found`);\n        return null;\n      }\n      \n      // Create a new message with ID and timestamp\n      const newMessage: Message = {\n        ...message,\n        id: `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n        created_at: new Date().toISOString()\n      };\n      \n      // Update in-memory state\n      set(state => {\n        // Initialize messages array if it doesn't exist\n        if (!state.nodes[nodeId].messages) {\n          state.nodes[nodeId].messages = [];\n        }\n        \n        // Add the new message\n        state.nodes[nodeId].messages!.push(newMessage);\n        state.nodes[nodeId].lastMessageId = newMessage.id;\n        state.nodes[nodeId].isConversationNode = true;\n      });\n      \n      // Persist to database if requested\n      if (persistToDatabase) {\n        try {\n          const updatedNode = {\n            ...node,\n            messages: [...(node.messages || []), newMessage],\n            lastMessageId: newMessage.id,\n            isConversationNode: true\n          };\n          \n          // Update the node in the database\n          await supabase\n            .from('nodes')\n            .update(updatedNode)\n            .eq('id', nodeId);\n        } catch (error: any) {\n          console.error('Error persisting message to node:', error);\n          set(state => { state.error = error.message; });\n        }\n      }\n      \n      return newMessage;\n    },\n    \n    updateNodeMessages: async (\n      nodeId: string, \n      messages: Message[], \n      persistToDatabase = true\n    ) => {\n      const node = get().nodes[nodeId];\n      if (!node) {\n        console.error(`Node with ID ${nodeId} not found`);\n        return;\n      }\n      \n      // Update in-memory state\n      set(state => {\n        state.nodes[nodeId].messages = messages;\n        state.nodes[nodeId].lastMessageId = messages.length > 0 \n          ? messages[messages.length - 1].id \n          : undefined;\n        state.nodes[nodeId].isConversationNode = messages.length > 0;\n      });\n      \n      // Persist to database if requested\n      if (persistToDatabase) {\n        try {\n          const updatedNode = {\n            ...node,\n            messages,\n            lastMessageId: messages.length > 0 ? messages[messages.length - 1].id : undefined,\n            isConversationNode: messages.length > 0\n          };\n          \n          await supabase\n            .from('nodes')\n            .update(updatedNode)\n            .eq('id', nodeId);\n        } catch (error: any) {\n          console.error('Error updating node messages:', error);\n          set(state => { state.error = error.message; });\n        }\n      }\n    },\n    \n    getNodeMessages: (nodeId: string) => {\n      const node = get().nodes[nodeId];\n      return (node?.messages || []).sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n    },\n    \n    // Actions\n    fetchNodesByNotebook: async (notebookId: string) => {\n      set(state => { state.isLoading = true; state.error = null; });\n      \n      const maxRetries = 3;\n      const retryDelay = 1000; // Start with 1 second\n      \n      const fetchWithRetry = async (apiCall: () => Promise<any>, errorLabel: string, attempt = 0): Promise<any> => {\n        try {\n          if (attempt > 0) {\n            // Exponential backoff\n            const delay = retryDelay * Math.pow(2, attempt - 1);\n            await new Promise(resolve => setTimeout(resolve, delay));\n          }\n          \n          const result = await apiCall();\n          if (result.error) throw result.error;\n          return result.data;\n        } catch (error: any) {\n          console.error(`Error ${errorLabel} (attempt ${attempt + 1}/${maxRetries}):`, error);\n          \n          if (attempt < maxRetries - 1) {\n            console.log(`Retrying ${errorLabel} (${attempt + 1}/${maxRetries})...`);\n            return fetchWithRetry(apiCall, errorLabel, attempt + 1);\n          }\n          \n          throw error;\n        }\n      };\n      \n      try {\n        // Use Promise.all to fetch nodes and relationships in parallel\n        const [nodes, relationships] = await Promise.all([\n          // Fetch nodes with retry (limit to 100 for better performance)\n          fetchWithRetry(\n            () => supabase\n              .from('nodes')\n              .select('*')\n              .eq('notebook_id', notebookId)\n              .limit(100),\n            'fetching nodes'\n          ),\n          \n          // Fetch relationships with retry (limit to 100 for better performance)\n          fetchWithRetry(\n            () => supabase\n              .from('relationships')\n              .select('*')\n              .eq('notebook_id', notebookId)\n              .limit(100),\n            'fetching relationships'\n          )\n        ]);\n        \n        // Update state\n        set(state => {\n          // Index nodes by ID\n          state.nodes = nodes.reduce((acc, node) => {\n            acc[node.id] = node;\n            return acc;\n          }, {} as Record<string, Node>);\n          \n          // Store relationships as array\n          state.relationships = relationships || [];\n          \n          // Initialize positions for nodes that don't have them\n          nodes.forEach(node => {\n            if (!state.nodePositions[node.id]) {\n              const position = node.position || { x: 100, y: 100 };\n              state.nodePositions[node.id] = {\n                x: position.x,\n                y: position.y,\n                isCollapsed: false,\n                isDragging: false\n              };\n            }\n          });\n          \n          state.isLoading = false;\n        });\n        \n        console.log(`Successfully loaded ${nodes.length} nodes and ${relationships ? relationships.length : 0} relationships`);\n      } catch (error: any) {\n        console.error('Error fetching data:', error);\n        set(state => {\n          state.error = error.message || 'Failed to load notebook data';\n          state.isLoading = false;\n          \n          // Initialize with empty data to allow partial functionality\n          state.nodes = {};\n          state.relationships = [];\n        });\n      }\n    },\n    \n    // Add a node to the store (without DB persistence)\n    addNode: (node: Node) => {\n      set(state => {\n        state.nodes[node.id] = node;\n        \n        // Initialize position\n        const position = node.position || { x: 100, y: 100 };\n        state.nodePositions[node.id] = {\n          x: position.x,\n          y: position.y,\n          isCollapsed: false,\n          isDragging: false\n        };\n      });\n    },\n    \n    // Add a relationship to the store (without DB persistence)\n    addRelationship: (relationship: Relationship) => {\n      set(state => {\n        state.relationships.push(relationship);\n      });\n    },\n    \n    updateNode: async (id: string, updates: Partial<Node>) => {\n      try {\n        const { error } = await supabase\n          .from('nodes')\n          .update(updates)\n          .eq('id', id);\n          \n        if (error) throw error;\n        \n        set(state => {\n          if (state.nodes[id]) {\n            state.nodes[id] = { ...state.nodes[id], ...updates };\n          }\n        });\n      } catch (error: any) {\n        console.error('Error updating node:', error);\n        set(state => { state.error = error.message; });\n      }\n    },\n    \n    deleteNode: async (id: string) => {\n      try {\n        const { error } = await supabase\n          .from('nodes')\n          .delete()\n          .eq('id', id);\n          \n        if (error) throw error;\n        \n        set(state => {\n          delete state.nodes[id];\n          delete state.nodePositions[id];\n          \n          // Remove related relationships\n          state.relationships = state.relationships.filter(\n            r => r.from_node_id !== id && r.to_node_id !== id\n          );\n          \n          // If this was the selected or active node, clear those states\n          if (state.selectedNodeId === id) {\n            state.selectedNodeId = null;\n          }\n          \n          if (state.activeNodeId === id) {\n            state.activeNodeId = null;\n          }\n        });\n      } catch (error: any) {\n        console.error('Error deleting node:', error);\n        set(state => { state.error = error.message; });\n      }\n    },\n    \n    updateRelationship: async (id: string, updates: Partial<Relationship>) => {\n      try {\n        const { error } = await supabase\n          .from('relationships')\n          .update(updates)\n          .eq('id', id);\n          \n        if (error) throw error;\n        \n        set(state => {\n          const index = state.relationships.findIndex(r => r.id === id);\n          if (index >= 0) {\n            state.relationships[index] = { \n              ...state.relationships[index], \n              ...updates \n            };\n          }\n        });\n      } catch (error: any) {\n        console.error('Error updating relationship:', error);\n        set(state => { state.error = error.message; });\n      }\n    },\n    \n    deleteRelationship: async (id: string) => {\n      try {\n        const { error } = await supabase\n          .from('relationships')\n          .delete()\n          .eq('id', id);\n          \n        if (error) throw error;\n        \n        set(state => {\n          state.relationships = state.relationships.filter(r => r.id !== id);\n        });\n      } catch (error: any) {\n        console.error('Error deleting relationship:', error);\n        set(state => { state.error = error.message; });\n      }\n    },\n    \n    updateNodePosition: async (id: string, x: number, y: number, persistToDatabase = false) => {\n      set(state => {\n        if (!state.nodePositions[id]) {\n          state.nodePositions[id] = {\n            x,\n            y,\n            isCollapsed: false,\n            isDragging: false\n          };\n        } else {\n          state.nodePositions[id] = {\n            ...state.nodePositions[id],\n            x,\n            y\n          };\n        }\n        \n        // Update position in the node object as well\n        if (state.nodes[id]) {\n          state.nodes[id] = {\n            ...state.nodes[id],\n            position: { x, y }\n          };\n        }\n      });\n      \n      // Optionally persist to database\n      if (persistToDatabase && get().nodes[id]) {\n        try {\n          const node = get().nodes[id];\n          await supabase\n            .from('nodes')\n            .update({\n              position: { x, y }\n            })\n            .eq('id', id);\n        } catch (error: any) {\n          console.error('Error persisting node position:', error);\n          set(state => { state.error = error.message; });\n        }\n      }\n    },\n    \n    setNodeDragging: (id: string, isDragging: boolean) => {\n      set(state => {\n        if (state.nodePositions[id]) {\n          state.nodePositions[id] = {\n            ...state.nodePositions[id],\n            isDragging\n          };\n        }\n      });\n    },\n    \n    toggleNodeCollapse: (id: string) => {\n      set(state => {\n        if (state.nodePositions[id]) {\n          state.nodePositions[id] = {\n            ...state.nodePositions[id],\n            isCollapsed: !state.nodePositions[id].isCollapsed\n          };\n        }\n      });\n    },\n    \n    setSelectedNode: (id: string | null) => {\n      set(state => { state.selectedNodeId = id; });\n    },\n    \n    setActiveNode: (id: string | null) => {\n      set(state => { state.activeNodeId = id; });\n    },\n    \n    // Create a relationship between nodes with DB persistence\n    createNodeRelationship: async (\n      fromNodeId: string, \n      toNodeId: string, \n      type: RelationshipType, \n      notebookId: string,\n      vector?: Vector\n    ) => {\n      try {\n        const relationship: Partial<Relationship> = {\n          from_node_id: fromNodeId,\n          to_node_id: toNodeId,\n          type,\n          notebook_id: notebookId,\n          vector,\n          created_at: new Date().toISOString()\n        };\n        \n        const { data, error } = await supabase\n          .from('relationships')\n          .insert(relationship)\n          .select()\n          .single();\n          \n        if (error) throw error;\n        \n        // Add to state\n        set(state => {\n          state.relationships.push(data);\n        });\n        \n        return data;\n      } catch (error: any) {\n        console.error('Error creating relationship:', error);\n        set(state => { state.error = error.message; });\n        return null;\n      }\n    },\n    \n    // Helper functions\n    getChildNodes: (nodeId: string, relationshipType?: RelationshipType) => {\n      const { nodes, relationships } = get();\n      \n      const childRelationships = relationships.filter(rel => {\n        const isFromNode = rel.from_node_id === nodeId;\n        const matchesType = !relationshipType || rel.type === relationshipType;\n        return isFromNode && matchesType;\n      });\n      \n      return childRelationships\n        .map(rel => nodes[rel.to_node_id])\n        .filter(Boolean);\n    },\n    \n    getParentNode: (nodeId: string, relationshipType?: RelationshipType) => {\n      const { nodes, relationships } = get();\n      \n      const parentRelationship = relationships.find(rel => {\n        const isToNode = rel.to_node_id === nodeId;\n        const matchesType = !relationshipType || rel.type === relationshipType;\n        return isToNode && matchesType;\n      });\n      \n      if (!parentRelationship) return null;\n      return nodes[parentRelationship.from_node_id] || null;\n    },\n    \n    getConnectedNodes: (nodeId: string, relationshipType?: RelationshipType) => {\n      const { nodes, relationships } = get();\n      \n      const connectedRelationships = relationships.filter(rel => {\n        const isConnected = rel.from_node_id === nodeId || rel.to_node_id === nodeId;\n        const matchesType = !relationshipType || rel.type === relationshipType;\n        return isConnected && matchesType;\n      });\n      \n      return connectedRelationships\n        .map(rel => {\n          const connectedId = rel.from_node_id === nodeId \n            ? rel.to_node_id \n            : rel.from_node_id;\n          return nodes[connectedId];\n        })\n        .filter(Boolean);\n    },\n    \n    getRelationshipsBetween: (fromNodeId: string, toNodeId: string) => {\n      const { relationships } = get();\n      \n      return relationships.filter(\n        rel => \n          (rel.from_node_id === fromNodeId && rel.to_node_id === toNodeId) || \n          (rel.from_node_id === toNodeId && rel.to_node_id === fromNodeId)\n      );\n    },\n    \n    getNodesByType: (notebookId: string, type: CardType) => {\n      const { nodes } = get();\n      \n      return Object.values(nodes).filter(\n        node => node.notebook_id === notebookId && node.type === type\n      );\n    }\n  }))\n);\n\nexport default useNodeStore;\n\n================================================================================\nFILE: src/stores/threadStore.ts\n================================================================================\n\n// src/stores/threadStore.ts\nimport { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { Thread, ThreadState, Message, ThreadConnection } from '@/types/thread';\nimport { nanoid } from 'nanoid';\n\ninterface ThreadStore {\n  // Data\n  threads: Record<string, Thread>;\n  threadStates: Record<string, ThreadState>;\n  connections: ThreadConnection[];\n  activeThreadId: string | null;\n  notebookId: string | null;\n  isLoading: boolean;\n  error: Error | null;\n  \n  // Actions - Threads\n  setThreads: (threads: Thread[]) => void;\n  addThread: (thread: Thread) => void;\n  updateThread: (threadId: string, updates: Partial<Thread>) => void;\n  removeThread: (threadId: string) => void;\n  setActiveThread: (threadId: string | null) => void;\n  setNotebookId: (notebookId: string) => void;\n  setLoadingState: (isLoading: boolean, error?: Error | null) => void;\n  \n  // Actions - Thread States\n  updateThreadState: (threadId: string, updates: Partial<ThreadState>) => void;\n  \n  // Actions - Messages\n  addMessage: (threadId: string, message: Omit<Message, 'id' | 'threadId' | 'createdAt'>) => void;\n  updateMessage: (threadId: string, messageId: string, content: string) => void;\n  \n  // Actions - Connections\n  setConnections: (connections: ThreadConnection[]) => void;\n  addConnection: (connection: ThreadConnection) => void;\n  removeConnection: (fromId: string, toId: string) => void;\n  \n  // Computed\n  getThread: (threadId: string) => Thread | undefined;\n  getThreadState: (threadId: string) => ThreadState;\n  getThreadMessages: (threadId: string) => Message[];\n  getThreadConnections: (threadId: string) => ThreadConnection[];\n}\n\n// Default thread state for new threads\nconst DEFAULT_THREAD_STATE: ThreadState = {\n  isExpanded: false,\n  isDragging: false,\n  isActive: false,\n  isFocused: false,\n  isTyping: false,\n  isEditing: false\n};\n\nconst useThreadStore = create<ThreadStore>()(\n  immer((set, get) => ({\n    // State\n    threads: {},\n    threadStates: {},\n    connections: [],\n    activeThreadId: null,\n    notebookId: null,\n    isLoading: false,\n    error: null,\n    \n    // Actions - Threads\n    setThreads: (threads) => set((state) => {\n      // Reset threads object\n      state.threads = {};\n      \n      // Add all threads to the state\n      threads.forEach(thread => {\n        state.threads[thread.id] = thread;\n        \n        // Initialize thread state if doesn't exist\n        if (!state.threadStates[thread.id]) {\n          state.threadStates[thread.id] = {\n            ...DEFAULT_THREAD_STATE\n          };\n        }\n      });\n    }),\n    \n    addThread: (thread) => set((state) => {\n      state.threads[thread.id] = thread;\n      state.threadStates[thread.id] = {\n        ...DEFAULT_THREAD_STATE,\n        isActive: true // Make new thread active\n      };\n      \n      // Set as active thread\n      state.activeThreadId = thread.id;\n      \n      // If thread has a parent, add a connection\n      if (thread.parentId) {\n        state.connections.push({\n          fromId: thread.parentId,\n          toId: thread.id,\n          type: 'parent-child'\n        });\n      }\n      \n      // Add connections for referenced threads\n      if (thread.referencedThreads && thread.referencedThreads.length > 0) {\n        thread.referencedThreads.forEach(referencedId => {\n          state.connections.push({\n            fromId: thread.id,\n            toId: referencedId,\n            type: 'reference'\n          });\n        });\n      }\n    }),\n    \n    updateThread: (threadId, updates) => set((state) => {\n      if (state.threads[threadId]) {\n        // Update thread\n        state.threads[threadId] = {\n          ...state.threads[threadId],\n          ...updates,\n          updatedAt: new Date().toISOString()\n        };\n      }\n    }),\n    \n    removeThread: (threadId) => set((state) => {\n      // Delete thread\n      delete state.threads[threadId];\n      delete state.threadStates[threadId];\n      \n      // Remove related connections\n      state.connections = state.connections.filter(\n        conn => conn.fromId !== threadId && conn.toId !== threadId\n      );\n      \n      // Update active thread if needed\n      if (state.activeThreadId === threadId) {\n        state.activeThreadId = null;\n      }\n    }),\n    \n    setActiveThread: (threadId) => set((state) => {\n      // Clear previous active state\n      if (state.activeThreadId && state.threadStates[state.activeThreadId]) {\n        state.threadStates[state.activeThreadId].isActive = false;\n      }\n      \n      // Set new active thread\n      state.activeThreadId = threadId;\n      \n      // Update thread state\n      if (threadId && state.threadStates[threadId]) {\n        state.threadStates[threadId].isActive = true;\n      }\n    }),\n    \n    setNotebookId: (notebookId) => set((state) => {\n      state.notebookId = notebookId;\n    }),\n    \n    setLoadingState: (isLoading, error = null) => set((state) => {\n      state.isLoading = isLoading;\n      state.error = error;\n    }),\n    \n    // Actions - Thread States\n    updateThreadState: (threadId, updates) => set((state) => {\n      if (state.threadStates[threadId]) {\n        state.threadStates[threadId] = {\n          ...state.threadStates[threadId],\n          ...updates\n        };\n      } else {\n        // Initialize with defaults and apply updates\n        state.threadStates[threadId] = {\n          ...DEFAULT_THREAD_STATE,\n          ...updates\n        };\n      }\n    }),\n    \n    // Actions - Messages\n    addMessage: (threadId, message) => set((state) => {\n      if (state.threads[threadId]) {\n        // Create new message with ID and timestamp\n        const newMessage: Message = {\n          id: nanoid(),\n          threadId,\n          content: message.content,\n          role: message.role,\n          createdAt: new Date().toISOString()\n        };\n        \n        // Add to messages array\n        state.threads[threadId].messages.push(newMessage);\n        \n        // Update thread's updatedAt timestamp\n        state.threads[threadId].updatedAt = newMessage.createdAt;\n      }\n    }),\n    \n    updateMessage: (threadId, messageId, content) => set((state) => {\n      if (state.threads[threadId]) {\n        const messageIndex = state.threads[threadId].messages.findIndex(\n          msg => msg.id === messageId\n        );\n        \n        if (messageIndex !== -1) {\n          state.threads[threadId].messages[messageIndex].content = content;\n          state.threads[threadId].updatedAt = new Date().toISOString();\n        }\n      }\n    }),\n    \n    // Actions - Connections\n    setConnections: (connections) => set((state) => {\n      state.connections = connections;\n    }),\n    \n    addConnection: (connection) => set((state) => {\n      // Check if connection already exists\n      const exists = state.connections.some(\n        conn => conn.fromId === connection.fromId && conn.toId === connection.toId\n      );\n      \n      if (!exists) {\n        state.connections.push(connection);\n      }\n    }),\n    \n    removeConnection: (fromId, toId) => set((state) => {\n      state.connections = state.connections.filter(\n        conn => !(conn.fromId === fromId && conn.toId === toId)\n      );\n    }),\n    \n    // Computed getters with memoization\n    getThread: (threadId) => {\n      // Using a stable reference to avoid unnecessary rerenders\n      const threads = get().threads;\n      return threads[threadId];\n    },\n\n    getThreadState: (threadId) => {\n      // Using a stable reference to avoid unnecessary rerenders\n      const threadStates = get().threadStates;\n      const state = threadStates[threadId];\n      // Return the cached state or a shared default instance\n      return state || DEFAULT_THREAD_STATE;\n    },\n\n    getThreadMessages: (threadId) => {\n      // Using a stable reference to avoid unnecessary rerenders\n      const threads = get().threads;\n      const thread = threads[threadId];\n      return thread ? thread.messages : [];\n    },\n\n    getThreadConnections: (threadId) => {\n      // Using a stable reference to avoid unnecessary rerenders\n      const connections = get().connections;\n      return connections.filter(\n        conn => conn.fromId === threadId || conn.toId === threadId\n      );\n    }\n  }))\n);\n\nexport { useThreadStore };\n\n================================================================================\nFILE: src/stores/unifiedStore.ts\n================================================================================\n\n// src/stores/unifiedStore.ts\nimport { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { Node } from '@/types/thread';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface ChatMessage {\n  id: string;\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n  created_at: string;\n  nodeId?: string; // Reference to associated node if exists\n}\n\ninterface UnifiedState {\n  // Chat state\n  chatMessages: ChatMessage[];\n  activeThreadNodeId: string | null;\n  isInitialized: boolean;\n  notebookId: string | null;\n  \n  // Actions\n  addChatMessage: (message: Omit<ChatMessage, 'id' | 'created_at'>, createNode?: boolean) => Promise<ChatMessage>;\n  setChatMessages: (messages: ChatMessage[]) => void;\n  setActiveThread: (nodeId: string | null) => void;\n  setNotebookId: (notebookId: string) => void;\n  \n  // Synchronization\n  syncChatWithNodes: (notebookId: string) => Promise<void>;\n  createNodeFromMessage: (message: ChatMessage, position?: { x: number, y: number }) => Promise<Node | null>;\n  syncNodesToChat: (threadNodeId: string) => Promise<void>;\n  syncActiveThread: () => Promise<void>;\n}\n\n// Create the unified store\nconst unifiedStore = create<UnifiedState>()(\n  immer((set, get) => ({\n    // State\n    chatMessages: [],\n    activeThreadNodeId: null,\n    isInitialized: false,\n    notebookId: null,\n    \n    // Actions\n    addChatMessage: async (message, createNode = true) => {\n      // Create a new chat message with ID and timestamp\n      const newMessage: ChatMessage = {\n        ...message,\n        id: `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n        created_at: new Date().toISOString()\n      };\n      \n      // Add to chat messages\n      set(state => {\n        state.chatMessages.push(newMessage);\n      });\n      \n      // Optionally create a node for this message\n      if (createNode && get().notebookId) {\n        try {\n          const node = await get().createNodeFromMessage(newMessage);\n          if (node) {\n            // Update message with reference to the created node\n            set(state => {\n              const index = state.chatMessages.findIndex(m => m.id === newMessage.id);\n              if (index >= 0) {\n                state.chatMessages[index].nodeId = node.id;\n              }\n            });\n            \n            // If this is a response and we have an active thread, create a relationship\n            if (message.role === 'assistant' && get().activeThreadNodeId) {\n              // We need to import nodeStore dynamically to avoid circular dependency\n              // This is an alternative approach to avoid the issue\n              // This will be implemented in the component that uses this function\n              \n              // Set this as the new active thread node if it's a question\n              if (message.role === 'user') {\n                set(state => {\n                  state.activeThreadNodeId = node.id;\n                });\n              }\n            }\n          }\n        } catch (error) {\n          console.error('Error creating node from message:', error);\n        }\n      }\n      \n      return newMessage;\n    },\n    \n    setChatMessages: (messages) => {\n      set(state => {\n        state.chatMessages = messages;\n      });\n    },\n    \n    setActiveThread: (nodeId) => {\n      set(state => {\n        state.activeThreadNodeId = nodeId;\n      });\n    },\n    \n    setNotebookId: (notebookId) => {\n      set(state => {\n        state.notebookId = notebookId;\n        if (!state.isInitialized && notebookId) {\n          state.isInitialized = true;\n          // We'll handle sync in the component\n        }\n      });\n    },\n    \n    // Create a node from a chat message - implement in component\n    createNodeFromMessage: async (message, position) => {\n      // This will be implemented in the component that uses this function\n      // to avoid circular dependencies\n      console.log(\"createNodeFromMessage needs to be implemented in the component\");\n      return null;\n    },\n    \n    // Sync chat messages from nodes in a notebook - implement in component\n    syncChatWithNodes: async (notebookId) => {\n      // This will be implemented in the component that uses this function\n      console.log(\"syncChatWithNodes needs to be implemented in the component\");\n    },\n    \n    // Sync nodes to chat messages for a specific thread - implement in component\n    syncNodesToChat: async (threadNodeId) => {\n      // This will be implemented in the component that uses this function\n      console.log(\"syncNodesToChat needs to be implemented in the component\");\n    },\n    \n    // Sync the active thread - implement in component\n    syncActiveThread: async () => {\n      // This will be implemented in the component that uses this function\n      console.log(\"syncActiveThread needs to be implemented in the component\");\n    }\n  }))\n);\n\nexport default unifiedStore;\n\n================================================================================\nFILE: src/stores/unifiedViewStore.ts\n================================================================================\n\nimport { create } from 'zustand';\nimport { immer } from 'zustand/middleware/immer';\nimport { useThreadStore } from './threadStore';\nimport { threadService } from '../services/threadService';\n\ninterface UnifiedViewState {\n  // View state\n  activeView: 'canvas' | 'chat' | 'split';\n  activeThreadId: string | null;\n  activeCardId: string | null;\n  chatPanelWidth: number;\n  isChatPanelCollapsed: boolean;\n  \n  // Actions\n  setActiveView: (view: 'canvas' | 'chat' | 'split') => void;\n  setActiveThread: (threadId: string | null) => void;\n  setActiveCard: (cardId: string | null) => void;\n  toggleChatPanel: () => void;\n  resizeChatPanel: (width: number) => void;\n  \n  // Synchronization\n  syncCardToThread: (cardId: string) => Promise<void>;\n  syncThreadToCard: (threadId: string) => Promise<void>;\n}\n\nexport const useUnifiedViewStore = create<UnifiedViewState>()(\n  immer((set, get) => ({\n    // Initial state\n    activeView: 'canvas',\n    activeThreadId: null,\n    activeCardId: null,\n    chatPanelWidth: 350,\n    isChatPanelCollapsed: false,\n    \n    // View actions\n    setActiveView: (view) => set((state) => {\n      state.activeView = view;\n    }),\n    \n    setActiveThread: (threadId) => set((state) => {\n      state.activeThreadId = threadId;\n      \n      // If we have a thread ID, try to find its associated card\n      if (threadId) {\n        threadService.getCardByThreadId(threadId)\n          .then(card => {\n            if (card) {\n              set(state => { state.activeCardId = card.id; });\n            }\n          })\n          .catch(err => console.error('Error syncing thread to card:', err));\n      }\n    }),\n    \n    setActiveCard: (cardId) => set((state) => {\n      state.activeCardId = cardId;\n\n      // If we have a card ID, try to find its associated thread\n      if (cardId) {\n        threadService.getThreadByCardId(cardId)\n          .then(thread => {\n            if (thread) {\n              set(state => { state.activeThreadId = thread.id; });\n              // Don't reference useThreadStore directly here to avoid circular dependencies\n            }\n          })\n          .catch(err => console.error('Error syncing card to thread:', err));\n      }\n    }),\n    \n    toggleChatPanel: () => set((state) => {\n      state.isChatPanelCollapsed = !state.isChatPanelCollapsed;\n    }),\n    \n    resizeChatPanel: (width) => set((state) => {\n      // Constrain width between reasonable values\n      state.chatPanelWidth = Math.max(250, Math.min(width, 600));\n    }),\n    \n    // Synchronization between cards and threads\n    syncCardToThread: async (cardId) => {\n      try {\n        const thread = await threadService.getThreadByCardId(cardId);\n        if (thread) {\n          set(state => {\n            state.activeThreadId = thread.id;\n            // Thread store is updated separately to avoid circular dependencies\n          });\n          return;\n        }\n      } catch (err) {\n        console.error('Error syncing card to thread:', err);\n      }\n    },\n    \n    syncThreadToCard: async (threadId) => {\n      try {\n        const card = await threadService.getCardByThreadId(threadId);\n        if (card) {\n          set(state => { state.activeCardId = card.id; });\n          return;\n        }\n      } catch (err) {\n        console.error('Error syncing thread to card:', err);\n      }\n    }\n  }))\n);\n\n================================================================================\nFILE: src/types/thread.ts\n================================================================================\n\n// Type definitions for the unified card-chat system\n// src/types/thread.ts\n\n/**\n * CardType represents the different types of nodes in the system\n */\nexport type CardType = 'question' | 'response' | 'note' | 'drawing';\n\n/**\n * RelationshipType defines the semantic meaning of connections between nodes\n */\nexport type RelationshipType = 'supports' | 'contradicts' | 'questions' | 'extends' | 'tensions';\n\n/**\n * VectorDirection indicates the directionality of a relationship\n */\nexport type VectorDirection = 'resolving' | 'exploring' | 'deepening';\n\n/**\n * VectorState indicates the current status of a relationship\n */\nexport type VectorState = 'active' | 'resolved' | 'abandoned';\n\n/**\n * Vector represents the directional properties of a relationship\n * Contains properties that describe the intent and state of the connection\n */\nexport interface Vector {\n  direction: VectorDirection | 'incoming' | 'outgoing';\n  intention: string;\n  state: VectorState;\n  progress?: number; // 0-1 scale, optional\n}\n\n/**\n * Message represents a chat message within a node\n * This is used to store conversation threads inside a node\n */\nexport interface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  created_at: string;\n  parent_message_id?: string; // For threaded replies within a conversation\n}\n\n/**\n * Node represents a basic unit of content in the system\n * Can be a question, response, note, or drawing\n * Nodes are the primary entities that users interact with\n * Nodes can contain a conversation thread of messages\n */\nexport interface Node {\n  id: string;\n  content: string;\n  type: CardType;\n  attention?: string[]; // CAPs - what to focus on\n  metadata?: Record<string, any>;\n  notebook_id: string;\n  position?: { x: number; y: number }; // Canvas position\n  created_at: string;\n  created_by?: string;\n  \n  // Chat/conversation support\n  messages?: Message[]; // Nested chat messages within this node\n  lastMessageId?: string; // Points to the last message for quick access\n  isConversationNode?: boolean; // Indicates if this node contains a conversation\n}\n\n/**\n * Relationship represents a connection between two nodes\n * The relationship itself is a first-class entity with its own properties\n */\nexport interface Relationship {\n  id: string;\n  from_node_id: string;\n  to_node_id: string;\n  type: RelationshipType;\n  context?: string; // Why this connection exists\n  vector?: Vector;\n  notebook_id: string;\n  created_at: string;\n  created_by?: string;\n}\n\n/**\n * NodePosition represents the UI state of a node on the canvas\n */\nexport interface NodePosition {\n  x: number;\n  y: number;\n  isCollapsed: boolean;\n  isDragging: boolean;\n}\n\n/**\n * ThreadView represents a node with additional thread-related properties\n * Used for displaying threaded conversations\n */\nexport interface ThreadView {\n  id: string;\n  content: string;\n  type: CardType;\n  parent_id?: string;\n  depth: number;\n  position: { x: number; y: number };\n  created_at: string;\n  created_by?: string;\n  children?: ThreadView[];\n}\n\n/**\n * ChatMessage represents a message in the chat history\n * Used for providing context to AI\n * @deprecated Use Message interface instead\n */\nexport interface ChatMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n  node_id?: string;\n  created_at: string;\n}\n\n/**\n * ThreadConnection is a simplified representation of a relationship\n * Used for legacy compatibility\n * @deprecated Use Relationship instead\n */\nexport interface ThreadConnection {\n  fromId: string;\n  toId: string;\n  type: 'parent-child' | 'reference';\n}\n\n/**\n * NodeWithRelationships extends Node to include related connections\n * Useful for efficiently displaying a node with its connections\n */\nexport interface NodeWithRelationships extends Node {\n  incomingRelationships?: Relationship[];\n  outgoingRelationships?: Relationship[];\n  connectedNodes?: Node[];\n}\n\n================================================================================\nFILE: src/types/threads.ts\n================================================================================\n\n// src/types/thread.ts\n\n// Message represents a single message within a thread\nexport type Message = {\n  id: string;\n  threadId: string;\n  content: string;\n  role: 'user' | 'assistant' | 'system';\n  createdAt: string;\n};\n\n// Thread model - a container for messages\nexport type Thread = {\n  id: string;\n  notebookId: string;\n  title?: string;\n  position: { x: number; y: number };\n  messages: Message[];\n  parentId?: string;\n  referencedThreads?: string[];\n  createdAt: string;\n  updatedAt: string;\n  cardType: 'question' | 'response' | 'note' | 'follow_up';\n  handwritingStyle?: 'neat' | 'cursive' | 'messy' | 'print' | 'architect';\n  isMinimized?: boolean;\n  zIndex?: number;\n};\n\n// Thread state includes UI state that isn't persisted\nexport type ThreadState = {\n  isExpanded: boolean;\n  isDragging: boolean;\n  isActive: boolean;\n  isFocused: boolean;\n  isTyping: boolean;\n  isEditing: boolean;\n};\n\n// Placeholder types for Supabase tables that aren't yet in the Database type\n// Note: These should be removed once proper database types are generated\n\n// Thread table shape\nexport type CanvasThread = {\n  id: string;\n  notebook_id: string;\n  title?: string;\n  position: { x: number; y: number };\n  parent_id?: string;\n  referenced_threads?: string[];\n  card_type: 'question' | 'response' | 'note' | 'follow_up';\n  handwriting_style?: 'neat' | 'cursive' | 'messy' | 'print' | 'architect';\n  is_minimized?: boolean;\n  z_index?: number;\n  created_at: string;\n  updated_at: string;\n};\n\n// Message table shape\nexport type CanvasMessage = {\n  id: string;\n  thread_id: string;\n  content: string;\n  role: 'user' | 'assistant' | 'system';\n  created_at: string;\n};\n\n// For thread connections (visual lines between threads)\nexport type ThreadConnection = {\n  fromId: string;\n  toId: string;\n  type: 'parent-child' | 'reference';\n};\n\n// Modified migration type to map old conversation to new thread structure\nexport type ConversationToThreadMapping = {\n  oldConversationId: string;\n  newThreadId: string;\n  oldParentId?: string;\n  newParentId?: string;\n};\n\n================================================================================\nFILE: src/lib/chat/client/chatService.ts\n================================================================================\n\n/**\n * Client-side Chat Service Module\n * \n * Provides mock implementations for the chat service functionality\n * This is used in the browser to avoid loading server-only modules\n */\n\n/**\n * Determines if the service is in demo mode (always true for client)\n */\nexport const isDemoMode = (): boolean => {\n  return true; // Client is always in \"demo\" mode\n};\n\n/**\n * Transforms messages array for Claude API compatibility (client version)\n */\nexport const prepareMessagesForClaude = (messages: any[]) => {\n  if (!messages || !Array.isArray(messages)) {\n    throw new Error('Invalid messages format');\n  }\n\n  // Extract system message if present\n  const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n  \n  // Filter out system messages\n  const filteredMessages = messages\n    .filter(msg => msg.role !== 'system')\n    .map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n  return { \n    systemMessage, \n    messages: filteredMessages\n  };\n};\n\n/**\n * Mock processing function for client\n */\nexport const processResponse = async (userId: string | null, response: string, userMessage: string, includeUserContext = true) => {\n  console.log('Client-side mock of processResponse called');\n  return Promise.resolve();\n};\n\n/**\n * Gets demo response content for fallback/development use\n */\nexport const getDemoResponse = (): string => {\n  return \"This is a client-side mock response. API calls will be made from the server.\";\n};\n\n/**\n * Creates a fallback response object for error cases\n */\nexport const createFallbackResponse = (error?: any): any => {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  \n  return {\n    content: [{\n      type: 'text',\n      text: `Client-side mock fallback response: ${errorMessage}`\n    }],\n    model: \"claude-3-client-mock\",\n    role: 'assistant'\n  };\n};\n\n// Client-side mockable object\nconst mockAnthroic = {\n  messages: {\n    create: async () => {\n      return {\n        content: [{ type: 'text', text: 'This is a client-side mock response' }],\n        model: 'claude-3-client-mock',\n        role: 'assistant'\n      };\n    }\n  }\n};\n\nexport default {\n  anthropic: mockAnthroic,\n  isDemoMode,\n  prepareMessagesForClaude,\n  processResponse,\n  getDemoResponse,\n  createFallbackResponse\n};\n\n================================================================================\nFILE: src/lib/chat/server/chatService.ts\n================================================================================\n\n/**\n * Server-side Chat Service Module\n * \n * Provides unified handling of chat functionality with Anthropic Claude API\n * IMPORTANT: This module is server-side only and should not be imported on the client\n */\nimport Anthropic from '@anthropic-ai/sdk';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Initialize Anthropic client (only on server)\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nlet anthropic: Anthropic | null = null;\n\n// Only initialize on server\nif (typeof window === 'undefined') {\n  try {\n    anthropic = new Anthropic({ apiKey });\n    console.log('Anthropic client initialized successfully');\n  } catch (error) {\n    console.error('Failed to initialize Anthropic client:', error);\n  }\n}\n\n/**\n * Determines if the service is in demo mode (no API key)\n */\nexport const isDemoMode = (): boolean => {\n  return !anthropic || !apiKey || apiKey.trim() === '';\n};\n\n/**\n * Transforms messages array for Claude API compatibility\n * Extracts system message and returns cleaned messages\n */\nexport const prepareMessagesForClaude = (messages: any[]) => {\n  if (!messages || !Array.isArray(messages)) {\n    throw new Error('Invalid messages format');\n  }\n\n  // Extract system message if present\n  const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n  \n  // Filter out system messages - they should be passed as a separate parameter\n  const filteredMessages = messages\n    .filter(msg => msg.role !== 'system')\n    .map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n  return { \n    systemMessage, \n    messages: filteredMessages\n  };\n};\n\n/**\n * Processes AI response for user context and memory\n */\nexport const processResponse = async (userId: string | null, response: string, userMessage: string, includeUserContext = true) => {\n  if (!userId || !includeUserContext) return;\n\n  try {\n    // Process for traditional user context\n    await processResponseForUserContext(userId, response);\n\n    // Process user message for memory extraction\n    if (userMessage) {\n      await processMessageForMemories(userId, userMessage);\n    }\n  } catch (error) {\n    console.error('Error processing response for user context:', error);\n  }\n};\n\n/**\n * Gets demo response content for fallback/development use\n */\nexport const getDemoResponse = (): string => {\n  return \"This is a demo response from Claude. In production, this would be an actual response based on your input. The app is currently running in demo mode without a Claude API key.\";\n};\n\n/**\n * Creates a fallback response object for error cases\n */\nexport const createFallbackResponse = (error?: any): any => {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  \n  return {\n    content: [{\n      type: 'text',\n      text: `Sorry, there was an error contacting the AI service: ${errorMessage}. This is a fallback response.`\n    }],\n    model: \"claude-3-fallback\",\n    role: 'assistant'\n  };\n};\n\nexport default {\n  anthropic,\n  isDemoMode,\n  prepareMessagesForClaude,\n  processResponse,\n  getDemoResponse,\n  createFallbackResponse\n};"
          }
        ],
        "files": [
          {
            "file_name": "paste.txt"
          }
        ]
      }
    },
    {
      "id": "4a098752-98d7-40d2-af1c-3314cd30c220",
      "role": "assistant",
      "content": "You're asking me to help identify and fix issues with your chat functionality in your project. Your primary concerns appear to be:\n\n1. Nodes aren't being added when chatting\n2. The main node (first question) isn't correctly set up or displayed\n3. Messages aren't appearing in the chat view\n4. There might be confusion about the hierarchy of nodes/chats\n\nTo help solve these issues, I'll:\n1. Review the core chat-related files in your codebase\n2. Identify where the problems might be\n3. Propose specific fixes\n4. Create a plan for implementation\n5. Generate a script to export all chat-related files\n\nLet's start by understanding the key components and their roles in the chat functionality:\n\n## Key Components Analysis\n\n### Chat Integration\n\nLooking at `LlamaChat.tsx`, this seems to be your main chat component. It uses Vercel's AI SDK via the `useChat` hook. The component handles sending messages to the API, receiving responses, and creating nodes for messages.\n\n### Node Integration\n\nThe `nodeIntegration.ts` file provides functions to create nodes from messages, create relationships between nodes, and add messages to existing nodes.\n\n### Chat to Node Flow\n\nThe flow appears to be:\n1. User sends a message in the chat interface\n2. The message is processed by the AI\n3. Both the user message and AI response should be added as nodes\n4. Relationships should be created between these nodes\n\n### Issues I'm Noticing:\n\n1. There may be issues in how messages are being added to the nodeStore\n2. The synchronization between chat messages and nodes might not be working correctly\n3. The relationship creation between nodes might not be properly implemented\n4. There could be issues with how the active thread/node is being set\n\nLet's look at specific areas that might be problematic:\n\n#### In `LlamaChat.tsx`:\n\nThe `handleSubmit` function is responsible for creating nodes from messages, but there might be issues with how it's persisting data or creating the relationships.\n\n```javascript\n// This function handles submitting a user message and getting AI response\nconst handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Add user message to unified store and create node\n      const messageContent = content && typeof content === 'string' ? content.trim() : '';\n      if (!messageContent) {\n        console.error('Empty message content, skipping submission');\n        setIsProcessing(false);\n        return;\n      }\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: messageContent,\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node directly using nodeIntegration\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // If we have an active node, create a relationship\n      if (node && activeNode) {\n        await nodeIntegration.createNodeRelationship(\n          activeNode.id,\n          node.id,\n          'extends',\n          notebookId\n        );\n      }\n      \n      // Also add to chat messages store for consistency\n      await addChatMessage(messageObj, false); // false = don't create node (already created)\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Call the chat handler manually to avoid double-submission\n      // This will update messages array and trigger API call\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: messageContent,\n      });\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [addChatMessage, chatHandler, isProcessing, notebookId, activeNode]);\n```\n\n#### In `nodeIntegration.ts`:\n\nLooking at the `createNodeFromMessage` function, it creates a node from a message but there might be issues with how it's handling the message format or structuring the node:\n\n```javascript\nexport const createNodeFromMessage = async (\n  message: any, \n  notebookId: string,\n  position?: { x: number, y: number }\n): Promise<Node | null> => {\n  if (!notebookId || !message) return null;\n  \n  try {\n    // Determine node type based on message role\n    const nodeType = message.role === 'user' ? 'question' : 'response';\n    \n    // Use provided position or generate a default one\n    const nodePosition = position || { x: 100 + Math.random() * 200, y: 100 + Math.random() * 200 };\n    \n    // Create the node\n    const { data: node, error } = await supabase\n      .from('nodes')\n      .insert({\n        content: message.content,\n        type: nodeType,\n        notebook_id: notebookId,\n        position: nodePosition,\n        metadata: {\n          source: 'chat',\n          chatMessageId: message.id,\n          timestamp: message.created_at || new Date().toISOString()\n        },\n        messages: [{\n          id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n          role: message.role,\n          content: message.content,\n          created_at: message.created_at || new Date().toISOString()\n        }],\n        isConversationNode: true,\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return node;\n  } catch (error) {\n    console.error('Error creating node from message:', error);\n    return null;\n  }\n};\n```\n\n#### Issues with `onFinish` handler in `LlamaChat.tsx`:\n\nWhen an AI response is received, the `onFinish` handler should create a node for the response and link it to the user's question, but there might be issues:\n\n```javascript\nonFinish: async (message) => {\n  // Called when a message is completed\n  console.log('Message completed:', message);\n  console.log('Message content:', message.content);\n  \n  try {\n    // Create a node for the AI response message\n    if (message && message.content && message.content !== 'New response') {\n      // Ensure content is a valid string\n      const messageContent = typeof message.content === 'string' ? \n        message.content : \n        (message.content ? JSON.stringify(message.content) : 'Empty response');\n\n      // Create message object\n      const messageObj = {\n        id: message.id,\n        role: 'assistant',\n        content: messageContent,\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node from message directly using nodeIntegration\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // Create relationship with previous node if possible\n      if (node) {\n        // Get the last user message to create a relationship\n        const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n        if (userMessages.length > 0) {\n          const lastUserMessage = userMessages[userMessages.length - 1];\n          \n          // Find the node for the last user message\n          const userNodes = Object.values(nodes).filter(n => {\n            return n.messages && n.messages.some(m => m.id === lastUserMessage.id);\n          });\n          \n          if (userNodes.length > 0) {\n            await nodeIntegration.createNodeRelationship(\n              userNodes[0].id,\n              node.id,\n              'extends',\n              notebookId\n            );\n          }\n        }\n        \n        // Also add to chat messages store for consistency\n        await addChatMessage(messageObj, false); // false = don't create node (already created)\n      }\n      \n      // If we have an active thread, attempt to synchronize\n      if (getActiveThreadNodeId) {\n        try {\n          await syncActiveThreadFn();\n        } catch (syncError) {\n          console.error('Error syncing with active thread:', syncError);\n        }\n      }\n    } else if (message.content === 'New response') {\n      console.log('Skipping placeholder content \"New response\"');\n    } else {\n      console.error('Received empty message from AI', message);\n    }\n  } catch (error) {\n    console.error('Error processing AI response:', error);\n  } finally {\n    setIsProcessing(false);\n  }\n}\n```\n\n#### Hierarchy and Chat View Issues:\n\nLooking at how the hierarchy is implemented, there seems to be some confusion between \"threads\" and \"nodes\". In your system:\n\n1. The top level should be the main question node (tier 1)\n2. Under that are child nodes (tier 2) - agent, artifact, idea, questions\n3. Under each child node are chat messages (tier 3)\n\nI don't see a clear implementation of this hierarchy in the code.\n\n## Problems and Potential Fixes:\n\n### 1. Node Creation Issue:\n\n**Problem**: Nodes aren't being added to the store properly after chat messages.\n\n**Fix**: Ensure the `createNodeFromMessage` function successfully creates nodes and the created nodes are properly added to the nodeStore.\n\n### 2. Main Node (First Question) Issue:\n\n**Problem**: The main node (first question) isn't properly set up or displayed.\n\n**Fix**: Implement special handling for the initial question, ensuring it's marked as the main node and displayed prominently.\n\n### 3. Relationship Creation Issue:\n\n**Problem**: Relationships between messages aren't being created correctly.\n\n**Fix**: Fix the relationship creation logic to properly link messages in the hierarchy.\n\n### 4. Hierarchy Implementation:\n\n**Problem**: The tier hierarchy (tier 1, 2, 3) isn't clearly implemented.\n\n**Fix**: Refactor the code to properly implement the hierarchy as described.\n\n## Specific Implementation Plan:\n\n1. Fix the `LlamaChat` component to correctly handle message submission and response processing\n2. Ensure proper node creation and relationship establishment\n3. Implement the tier hierarchy as described\n4. Fix the chat view to properly display messages\n\nLet's develop concrete fixes for these issues:\n\n### Fix for `LlamaChat.tsx`:\n\nThe key issues appear to be:\n\n1. The `nodeIntegration.createNodeFromMessage` function might not be working correctly\n2. The relationship creation logic might be flawed\n3. The active thread/node management might be incorrect\n\nLet's focus on these areas.\n\n### Fix for Node Hierarchy:\n\nWe need to ensure the hierarchy is properly implemented:\n\n1. Main question node (tier 1)\n2. Child nodes for different categories (tier 2)\n3. Chat messages under each node (tier 3)\n\nThis requires changes to how nodes are created and related.\n\nBased on my analysis, I now understand the issues better. Let me create a plan for fixing these problems and then generate the script to export all relevant files.\n\n## Implementation Plan:\n\n1. Fix the `LlamaChat.tsx` component:\n   - Ensure proper node creation for messages\n   - Fix relationship creation between nodes\n   - Implement proper active thread/node management\n\n2. Fix the tier hierarchy:\n   - Update node creation logic to properly handle tier 1, 2, and 3 nodes\n   - Implement special handling for the main question node\n   - Update the UI to properly display the hierarchy\n\n3. Fix chat view:\n   - Ensure messages are properly displayed in the chat view\n   - Implement proper message appending when new messages are sent\n   - Fix synchronization between chat and nodes\n\n4. Create a script to export all relevant files.\n\nLet's proceed with these fixes.# Chat System Issues Analysis and Resolution Plan\n\nAfter analyzing your project code, I've identified several issues with the chat functionality. The primary problem is that messages sent in the chat aren't correctly being added as nodes in the canvas, and the relationship between the chat interface and node representation isn't working as expected.\n\n## Core Issues Identified\n\n1. **Node Creation Failure**: When a user sends a message, the node isn't being reliably created or added to the store\n2. **Relationship Hierarchy Problems**: The tier system (main question → sub-nodes → chats) isn't properly implemented\n3. **Sync Issues**: The chat view and canvas nodes aren't properly synchronized\n4. **Message Appending**: Messages aren't reliably being added to the chat list\n\n## Root Causes\n\n1. In `LlamaChat.tsx`, the node creation process has inconsistencies in the data flow\n2. The relationships between nodes aren't being properly established\n3. The active thread/node management isn't consistent\n4. There's confusion in the codebase between multiple implementations (legacy Thread vs Node)\n\n## Fix Implementation Plan\n\n1. **Fix Node Creation**:\n   - Ensure `createNodeFromMessage` properly creates nodes\n   - Fix error handling and data validation\n\n2. **Implement Clear Hierarchy**:\n   - Define a consistent model for tier 1 (main question), tier 2 (categories), and tier 3 (chats)\n   - Ensure the first message is properly set as the root node\n\n3. **Fix Synchronization**:\n   - Implement reliable bidirectional sync between chat view and node canvas\n   - Ensure new messages appear in both places\n\n4. **User Experience Improvements**:\n   - Add a clear UI for creating new category nodes\n   - Make relationship between main question and sub-nodes clearer\n\n## Specific Files to Modify\n\nThe core issues appear to be in these files:\n\n1. `src/components/ui/LlamaChat.tsx` - Main chat interface\n2. `src/lib/chat/nodeIntegration.ts` - Node creation from messages\n3. `src/hooks/useChatNodeSync.ts` - Synchronization between chat and nodes\n4. `src/stores/nodeStore.ts` - State management for nodes\n\nLet me create an updated version of `LlamaChat.tsx` with the key fixes:\n\n```typescript\n// Updated handleSubmit function\nconst handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n  e.preventDefault();\n  \n  // Get the message from the form\n  const formData = new FormData(e.currentTarget);\n  const content = formData.get('input')?.toString() || '';\n  \n  if (!content.trim() || isProcessing) return;\n  \n  try {\n    setIsProcessing(true);\n    \n    // Generate a unique ID for this message\n    const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Create message object\n    const messageObj = {\n      id: messageId,\n      role: 'user',\n      content: content.trim(),\n      created_at: new Date().toISOString()\n    };\n    \n    // Check if this is the first message - if so, mark it as the main question (tier 1)\n    const isFirstMessage = chatHandler.messages.filter(msg => msg.role !== 'system').length === 0;\n    const nodeType = isFirstMessage ? 'question' : 'response';\n    \n    console.log(`Creating ${isFirstMessage ? 'main question node' : 'response node'}`);\n    \n    // Create node with special metadata for tier information\n    const metadata = {\n      source: 'chat',\n      chatMessageId: messageId,\n      timestamp: new Date().toISOString(),\n      tier: isFirstMessage ? 1 : 3, // Mark as tier 1 (main) or tier 3 (chat)\n      isMainQuestion: isFirstMessage\n    };\n    \n    // Create node with position based on hierarchy\n    let position;\n    if (isFirstMessage) {\n      // Main question goes in center\n      position = { x: 350, y: 200 };\n    } else if (activeNode) {\n      // Responses go below parent\n      position = { \n        x: activeNode.position?.x || 350, \n        y: (activeNode.position?.y || 200) + 120 \n      };\n    } else {\n      // Fallback position\n      position = { x: 350, y: 350 };\n    }\n    \n    // Create node with correct tier and position\n    const node = await nodeIntegration.createNodeFromMessage(\n      messageObj,\n      notebookId,\n      position,\n      metadata,\n      nodeType // Pass the node type explicitly\n    );\n    \n    // Create relationship with active node if exists\n    if (node && activeNode) {\n      await nodeIntegration.createNodeRelationship(\n        activeNode.id,\n        node.id,\n        'extends',\n        notebookId,\n        {\n          direction: 'outgoing',\n          intention: 'conversation',\n          state: 'active'\n        }\n      );\n    }\n    \n    // Update the UI state with new active node\n    if (node) {\n      setSelectedNode(node.id);\n      setActiveNode(node.id);\n    }\n    \n    // Add to chat messages for UI consistency\n    await addChatMessage(messageObj, false);\n    \n    // Clear input and append message to chat interface\n    chatHandler.setInput('');\n    chatHandler.append({\n      id: messageId,\n      role: 'user',\n      content: content.trim(),\n    });\n    \n    console.log('Message processing complete, node created:', node?.id);\n  } catch (error) {\n    console.error('Error processing user message:', error);\n    setIsProcessing(false);\n  }\n}, [activeNode, addChatMessage, chatHandler, isProcessing, notebookId, setActiveNode, setSelectedNode]);\n```\n\n## Script to Export Chat-Related Files\n\nHere's a bash script to export all chat-related files into a single text file for easy editing:\n\n```bash\n#!/bin/bash\n\n# Create output directory if it doesn't exist\nmkdir -p ./export\n\n# Create the output file\nOUTPUT_FILE=\"./export/chat_system_files.txt\"\necho \"# Chat System Files Export\" > $OUTPUT_FILE\necho \"Generated: $(date)\" >> $OUTPUT_FILE\necho \"\" >> $OUTPUT_FILE\n\n# Function to append a file to the output\nappend_file() {\n  local file=$1\n  if [ -f \"$file\" ]; then\n    echo \"================================================================================\" >> $OUTPUT_FILE\n    echo \"FILE: $file\" >> $OUTPUT_FILE\n    echo \"================================================================================\" >> $OUTPUT_FILE\n    echo \"\" >> $OUTPUT_FILE\n    cat \"$file\" >> $OUTPUT_FILE\n    echo \"\" >> $OUTPUT_FILE\n  else\n    echo \"File not found: $file\" >> $OUTPUT_FILE\n  fi\n}\n\n# List of key chat-related files to export\nCHAT_FILES=(\n  \"src/components/ui/LlamaChat.tsx\"\n  \"src/components/ui/LlamaChat.updated.tsx\"\n  \"src/components/ui/SimpleChatPanel.tsx\"\n  \"src/lib/chat/nodeIntegration.ts\"\n  \"src/lib/chat/index.ts\"\n  \"src/lib/chat/chatService.ts\"\n  \"src/hooks/useChatNodeSync.ts\"\n  \"src/hooks/useAIChat.ts\"\n  \"src/pages/api/claude/chat.ts\"\n  \"src/pages/api/claude/chat-simple.ts\"\n  \"src/pages/api/claude/unified-chat.ts\"\n  \"src/pages/api/ai/chat.ts\"\n  \"src/stores/nodeStore.ts\"\n  \"src/stores/unifiedStore.ts\"\n  \"src/components/conversation/ChatInput.tsx\"\n  \"src/components/conversation/ChatMessage.tsx\"\n  \"src/components/conversation/ChatPanel.tsx\"\n  \"src/components/conversation/MessageInput.tsx\"\n  \"src/components/conversation/MessageList.tsx\"\n  \"src/components/canvas/ThreadedCardChat.tsx\"\n  \"src/components/canvas/ThreadCard.tsx\"\n  \"src/components/canvas/IntegratedChatCard.tsx\"\n  \"src/components/canvas/ThreadHistory.tsx\"\n)\n\n# Export each file\nfor file in \"${CHAT_FILES[@]}\"; do\n  append_file \"$file\"\ndone\n\necho \"Export complete! Check $OUTPUT_FILE\"\n```\n\n## Key Recommendations\n\n1. **Simplify the Implementation**: Your codebase has multiple overlapping concepts (threads, nodes, conversations). Standardize on one approach.\n\n2. **Fix Node Creation**: Update `nodeIntegration.ts` to ensure node creation with proper metadata and tier information.\n\n3. **Implement Clear UI**: Add a UI for creating tier 2 category nodes (agent, artifact, idea, question).\n\n4. **Fix the Message Flow**: Ensure messages are properly added to the chat list and synchronized with nodes.\n\nWould you like me to go deeper into any specific part of the implementation or provide more detailed fixes for particular files?",
      "created_at": "2025-05-14T08:43:21.430160Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-14T08:42:16.550809Z",
            "stop_timestamp": "2025-05-14T08:42:54.139771Z",
            "flags": null,
            "type": "thinking",
            "thinking": "You're asking me to help identify and fix issues with your chat functionality in your project. Your primary concerns appear to be:\n\n1. Nodes aren't being added when chatting\n2. The main node (first question) isn't correctly set up or displayed\n3. Messages aren't appearing in the chat view\n4. There might be confusion about the hierarchy of nodes/chats\n\nTo help solve these issues, I'll:\n1. Review the core chat-related files in your codebase\n2. Identify where the problems might be\n3. Propose specific fixes\n4. Create a plan for implementation\n5. Generate a script to export all chat-related files\n\nLet's start by understanding the key components and their roles in the chat functionality:\n\n## Key Components Analysis\n\n### Chat Integration\n\nLooking at `LlamaChat.tsx`, this seems to be your main chat component. It uses Vercel's AI SDK via the `useChat` hook. The component handles sending messages to the API, receiving responses, and creating nodes for messages.\n\n### Node Integration\n\nThe `nodeIntegration.ts` file provides functions to create nodes from messages, create relationships between nodes, and add messages to existing nodes.\n\n### Chat to Node Flow\n\nThe flow appears to be:\n1. User sends a message in the chat interface\n2. The message is processed by the AI\n3. Both the user message and AI response should be added as nodes\n4. Relationships should be created between these nodes\n\n### Issues I'm Noticing:\n\n1. There may be issues in how messages are being added to the nodeStore\n2. The synchronization between chat messages and nodes might not be working correctly\n3. The relationship creation between nodes might not be properly implemented\n4. There could be issues with how the active thread/node is being set\n\nLet's look at specific areas that might be problematic:\n\n#### In `LlamaChat.tsx`:\n\nThe `handleSubmit` function is responsible for creating nodes from messages, but there might be issues with how it's persisting data or creating the relationships.\n\n```javascript\n// This function handles submitting a user message and getting AI response\nconst handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Add user message to unified store and create node\n      const messageContent = content && typeof content === 'string' ? content.trim() : '';\n      if (!messageContent) {\n        console.error('Empty message content, skipping submission');\n        setIsProcessing(false);\n        return;\n      }\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: messageContent,\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node directly using nodeIntegration\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // If we have an active node, create a relationship\n      if (node && activeNode) {\n        await nodeIntegration.createNodeRelationship(\n          activeNode.id,\n          node.id,\n          'extends',\n          notebookId\n        );\n      }\n      \n      // Also add to chat messages store for consistency\n      await addChatMessage(messageObj, false); // false = don't create node (already created)\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Call the chat handler manually to avoid double-submission\n      // This will update messages array and trigger API call\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: messageContent,\n      });\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [addChatMessage, chatHandler, isProcessing, notebookId, activeNode]);\n```\n\n#### In `nodeIntegration.ts`:\n\nLooking at the `createNodeFromMessage` function, it creates a node from a message but there might be issues with how it's handling the message format or structuring the node:\n\n```javascript\nexport const createNodeFromMessage = async (\n  message: any, \n  notebookId: string,\n  position?: { x: number, y: number }\n): Promise<Node | null> => {\n  if (!notebookId || !message) return null;\n  \n  try {\n    // Determine node type based on message role\n    const nodeType = message.role === 'user' ? 'question' : 'response';\n    \n    // Use provided position or generate a default one\n    const nodePosition = position || { x: 100 + Math.random() * 200, y: 100 + Math.random() * 200 };\n    \n    // Create the node\n    const { data: node, error } = await supabase\n      .from('nodes')\n      .insert({\n        content: message.content,\n        type: nodeType,\n        notebook_id: notebookId,\n        position: nodePosition,\n        metadata: {\n          source: 'chat',\n          chatMessageId: message.id,\n          timestamp: message.created_at || new Date().toISOString()\n        },\n        messages: [{\n          id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n          role: message.role,\n          content: message.content,\n          created_at: message.created_at || new Date().toISOString()\n        }],\n        isConversationNode: true,\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return node;\n  } catch (error) {\n    console.error('Error creating node from message:', error);\n    return null;\n  }\n};\n```\n\n#### Issues with `onFinish` handler in `LlamaChat.tsx`:\n\nWhen an AI response is received, the `onFinish` handler should create a node for the response and link it to the user's question, but there might be issues:\n\n```javascript\nonFinish: async (message) => {\n  // Called when a message is completed\n  console.log('Message completed:', message);\n  console.log('Message content:', message.content);\n  \n  try {\n    // Create a node for the AI response message\n    if (message && message.content && message.content !== 'New response') {\n      // Ensure content is a valid string\n      const messageContent = typeof message.content === 'string' ? \n        message.content : \n        (message.content ? JSON.stringify(message.content) : 'Empty response');\n\n      // Create message object\n      const messageObj = {\n        id: message.id,\n        role: 'assistant',\n        content: messageContent,\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node from message directly using nodeIntegration\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // Create relationship with previous node if possible\n      if (node) {\n        // Get the last user message to create a relationship\n        const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n        if (userMessages.length > 0) {\n          const lastUserMessage = userMessages[userMessages.length - 1];\n          \n          // Find the node for the last user message\n          const userNodes = Object.values(nodes).filter(n => {\n            return n.messages && n.messages.some(m => m.id === lastUserMessage.id);\n          });\n          \n          if (userNodes.length > 0) {\n            await nodeIntegration.createNodeRelationship(\n              userNodes[0].id,\n              node.id,\n              'extends',\n              notebookId\n            );\n          }\n        }\n        \n        // Also add to chat messages store for consistency\n        await addChatMessage(messageObj, false); // false = don't create node (already created)\n      }\n      \n      // If we have an active thread, attempt to synchronize\n      if (getActiveThreadNodeId) {\n        try {\n          await syncActiveThreadFn();\n        } catch (syncError) {\n          console.error('Error syncing with active thread:', syncError);\n        }\n      }\n    } else if (message.content === 'New response') {\n      console.log('Skipping placeholder content \"New response\"');\n    } else {\n      console.error('Received empty message from AI', message);\n    }\n  } catch (error) {\n    console.error('Error processing AI response:', error);\n  } finally {\n    setIsProcessing(false);\n  }\n}\n```\n\n#### Hierarchy and Chat View Issues:\n\nLooking at how the hierarchy is implemented, there seems to be some confusion between \"threads\" and \"nodes\". In your system:\n\n1. The top level should be the main question node (tier 1)\n2. Under that are child nodes (tier 2) - agent, artifact, idea, questions\n3. Under each child node are chat messages (tier 3)\n\nI don't see a clear implementation of this hierarchy in the code.\n\n## Problems and Potential Fixes:\n\n### 1. Node Creation Issue:\n\n**Problem**: Nodes aren't being added to the store properly after chat messages.\n\n**Fix**: Ensure the `createNodeFromMessage` function successfully creates nodes and the created nodes are properly added to the nodeStore.\n\n### 2. Main Node (First Question) Issue:\n\n**Problem**: The main node (first question) isn't properly set up or displayed.\n\n**Fix**: Implement special handling for the initial question, ensuring it's marked as the main node and displayed prominently.\n\n### 3. Relationship Creation Issue:\n\n**Problem**: Relationships between messages aren't being created correctly.\n\n**Fix**: Fix the relationship creation logic to properly link messages in the hierarchy.\n\n### 4. Hierarchy Implementation:\n\n**Problem**: The tier hierarchy (tier 1, 2, 3) isn't clearly implemented.\n\n**Fix**: Refactor the code to properly implement the hierarchy as described.\n\n## Specific Implementation Plan:\n\n1. Fix the `LlamaChat` component to correctly handle message submission and response processing\n2. Ensure proper node creation and relationship establishment\n3. Implement the tier hierarchy as described\n4. Fix the chat view to properly display messages\n\nLet's develop concrete fixes for these issues:\n\n### Fix for `LlamaChat.tsx`:\n\nThe key issues appear to be:\n\n1. The `nodeIntegration.createNodeFromMessage` function might not be working correctly\n2. The relationship creation logic might be flawed\n3. The active thread/node management might be incorrect\n\nLet's focus on these areas.\n\n### Fix for Node Hierarchy:\n\nWe need to ensure the hierarchy is properly implemented:\n\n1. Main question node (tier 1)\n2. Child nodes for different categories (tier 2)\n3. Chat messages under each node (tier 3)\n\nThis requires changes to how nodes are created and related.\n\nBased on my analysis, I now understand the issues better. Let me create a plan for fixing these problems and then generate the script to export all relevant files.\n\n## Implementation Plan:\n\n1. Fix the `LlamaChat.tsx` component:\n   - Ensure proper node creation for messages\n   - Fix relationship creation between nodes\n   - Implement proper active thread/node management\n\n2. Fix the tier hierarchy:\n   - Update node creation logic to properly handle tier 1, 2, and 3 nodes\n   - Implement special handling for the main question node\n   - Update the UI to properly display the hierarchy\n\n3. Fix chat view:\n   - Ensure messages are properly displayed in the chat view\n   - Implement proper message appending when new messages are sent\n   - Fix synchronization between chat and nodes\n\n4. Create a script to export all relevant files.\n\nLet's proceed with these fixes.",
            "summaries": [
              {
                "summary": "Thinking about debugging chat functionality and node management in project structure"
              },
              {
                "summary": "Diagnosing chat functionality issues and potential fixes"
              },
              {
                "summary": "Investigating chat node creation and synchronization issues"
              },
              {
                "summary": "Diagnosing chat node creation and relationship issues"
              },
              {
                "summary": "Diagnosing chat node creation and integration issues"
              },
              {
                "summary": "Diagnosing chat node creation and relationship synchronization issues"
              },
              {
                "summary": "Diagnosing chat functionality and crafting comprehensive fix strategy"
              },
              {
                "summary": "Diagnosed chat functionality issues, proposed comprehensive node hierarchy fix"
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-05-14T08:42:54.365670Z",
            "stop_timestamp": "2025-05-14T08:43:21.295845Z",
            "flags": null,
            "type": "text",
            "text": "# Chat System Issues Analysis and Resolution Plan\n\nAfter analyzing your project code, I've identified several issues with the chat functionality. The primary problem is that messages sent in the chat aren't correctly being added as nodes in the canvas, and the relationship between the chat interface and node representation isn't working as expected.\n\n## Core Issues Identified\n\n1. **Node Creation Failure**: When a user sends a message, the node isn't being reliably created or added to the store\n2. **Relationship Hierarchy Problems**: The tier system (main question → sub-nodes → chats) isn't properly implemented\n3. **Sync Issues**: The chat view and canvas nodes aren't properly synchronized\n4. **Message Appending**: Messages aren't reliably being added to the chat list\n\n## Root Causes\n\n1. In `LlamaChat.tsx`, the node creation process has inconsistencies in the data flow\n2. The relationships between nodes aren't being properly established\n3. The active thread/node management isn't consistent\n4. There's confusion in the codebase between multiple implementations (legacy Thread vs Node)\n\n## Fix Implementation Plan\n\n1. **Fix Node Creation**:\n   - Ensure `createNodeFromMessage` properly creates nodes\n   - Fix error handling and data validation\n\n2. **Implement Clear Hierarchy**:\n   - Define a consistent model for tier 1 (main question), tier 2 (categories), and tier 3 (chats)\n   - Ensure the first message is properly set as the root node\n\n3. **Fix Synchronization**:\n   - Implement reliable bidirectional sync between chat view and node canvas\n   - Ensure new messages appear in both places\n\n4. **User Experience Improvements**:\n   - Add a clear UI for creating new category nodes\n   - Make relationship between main question and sub-nodes clearer\n\n## Specific Files to Modify\n\nThe core issues appear to be in these files:\n\n1. `src/components/ui/LlamaChat.tsx` - Main chat interface\n2. `src/lib/chat/nodeIntegration.ts` - Node creation from messages\n3. `src/hooks/useChatNodeSync.ts` - Synchronization between chat and nodes\n4. `src/stores/nodeStore.ts` - State management for nodes\n\nLet me create an updated version of `LlamaChat.tsx` with the key fixes:\n\n```typescript\n// Updated handleSubmit function\nconst handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n  e.preventDefault();\n  \n  // Get the message from the form\n  const formData = new FormData(e.currentTarget);\n  const content = formData.get('input')?.toString() || '';\n  \n  if (!content.trim() || isProcessing) return;\n  \n  try {\n    setIsProcessing(true);\n    \n    // Generate a unique ID for this message\n    const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Create message object\n    const messageObj = {\n      id: messageId,\n      role: 'user',\n      content: content.trim(),\n      created_at: new Date().toISOString()\n    };\n    \n    // Check if this is the first message - if so, mark it as the main question (tier 1)\n    const isFirstMessage = chatHandler.messages.filter(msg => msg.role !== 'system').length === 0;\n    const nodeType = isFirstMessage ? 'question' : 'response';\n    \n    console.log(`Creating ${isFirstMessage ? 'main question node' : 'response node'}`);\n    \n    // Create node with special metadata for tier information\n    const metadata = {\n      source: 'chat',\n      chatMessageId: messageId,\n      timestamp: new Date().toISOString(),\n      tier: isFirstMessage ? 1 : 3, // Mark as tier 1 (main) or tier 3 (chat)\n      isMainQuestion: isFirstMessage\n    };\n    \n    // Create node with position based on hierarchy\n    let position;\n    if (isFirstMessage) {\n      // Main question goes in center\n      position = { x: 350, y: 200 };\n    } else if (activeNode) {\n      // Responses go below parent\n      position = { \n        x: activeNode.position?.x || 350, \n        y: (activeNode.position?.y || 200) + 120 \n      };\n    } else {\n      // Fallback position\n      position = { x: 350, y: 350 };\n    }\n    \n    // Create node with correct tier and position\n    const node = await nodeIntegration.createNodeFromMessage(\n      messageObj,\n      notebookId,\n      position,\n      metadata,\n      nodeType // Pass the node type explicitly\n    );\n    \n    // Create relationship with active node if exists\n    if (node && activeNode) {\n      await nodeIntegration.createNodeRelationship(\n        activeNode.id,\n        node.id,\n        'extends',\n        notebookId,\n        {\n          direction: 'outgoing',\n          intention: 'conversation',\n          state: 'active'\n        }\n      );\n    }\n    \n    // Update the UI state with new active node\n    if (node) {\n      setSelectedNode(node.id);\n      setActiveNode(node.id);\n    }\n    \n    // Add to chat messages for UI consistency\n    await addChatMessage(messageObj, false);\n    \n    // Clear input and append message to chat interface\n    chatHandler.setInput('');\n    chatHandler.append({\n      id: messageId,\n      role: 'user',\n      content: content.trim(),\n    });\n    \n    console.log('Message processing complete, node created:', node?.id);\n  } catch (error) {\n    console.error('Error processing user message:', error);\n    setIsProcessing(false);\n  }\n}, [activeNode, addChatMessage, chatHandler, isProcessing, notebookId, setActiveNode, setSelectedNode]);\n```\n\n## Script to Export Chat-Related Files\n\nHere's a bash script to export all chat-related files into a single text file for easy editing:\n\n```bash\n#!/bin/bash\n\n# Create output directory if it doesn't exist\nmkdir -p ./export\n\n# Create the output file\nOUTPUT_FILE=\"./export/chat_system_files.txt\"\necho \"# Chat System Files Export\" > $OUTPUT_FILE\necho \"Generated: $(date)\" >> $OUTPUT_FILE\necho \"\" >> $OUTPUT_FILE\n\n# Function to append a file to the output\nappend_file() {\n  local file=$1\n  if [ -f \"$file\" ]; then\n    echo \"================================================================================\" >> $OUTPUT_FILE\n    echo \"FILE: $file\" >> $OUTPUT_FILE\n    echo \"================================================================================\" >> $OUTPUT_FILE\n    echo \"\" >> $OUTPUT_FILE\n    cat \"$file\" >> $OUTPUT_FILE\n    echo \"\" >> $OUTPUT_FILE\n  else\n    echo \"File not found: $file\" >> $OUTPUT_FILE\n  fi\n}\n\n# List of key chat-related files to export\nCHAT_FILES=(\n  \"src/components/ui/LlamaChat.tsx\"\n  \"src/components/ui/LlamaChat.updated.tsx\"\n  \"src/components/ui/SimpleChatPanel.tsx\"\n  \"src/lib/chat/nodeIntegration.ts\"\n  \"src/lib/chat/index.ts\"\n  \"src/lib/chat/chatService.ts\"\n  \"src/hooks/useChatNodeSync.ts\"\n  \"src/hooks/useAIChat.ts\"\n  \"src/pages/api/claude/chat.ts\"\n  \"src/pages/api/claude/chat-simple.ts\"\n  \"src/pages/api/claude/unified-chat.ts\"\n  \"src/pages/api/ai/chat.ts\"\n  \"src/stores/nodeStore.ts\"\n  \"src/stores/unifiedStore.ts\"\n  \"src/components/conversation/ChatInput.tsx\"\n  \"src/components/conversation/ChatMessage.tsx\"\n  \"src/components/conversation/ChatPanel.tsx\"\n  \"src/components/conversation/MessageInput.tsx\"\n  \"src/components/conversation/MessageList.tsx\"\n  \"src/components/canvas/ThreadedCardChat.tsx\"\n  \"src/components/canvas/ThreadCard.tsx\"\n  \"src/components/canvas/IntegratedChatCard.tsx\"\n  \"src/components/canvas/ThreadHistory.tsx\"\n)\n\n# Export each file\nfor file in \"${CHAT_FILES[@]}\"; do\n  append_file \"$file\"\ndone\n\necho \"Export complete! Check $OUTPUT_FILE\"\n```\n\n## Key Recommendations\n\n1. **Simplify the Implementation**: Your codebase has multiple overlapping concepts (threads, nodes, conversations). Standardize on one approach.\n\n2. **Fix Node Creation**: Update `nodeIntegration.ts` to ensure node creation with proper metadata and tier information.\n\n3. **Implement Clear UI**: Add a UI for creating tier 2 category nodes (agent, artifact, idea, question).\n\n4. **Fix the Message Flow**: Ensure messages are properly added to the chat list and synchronized with nodes.\n\nWould you like me to go deeper into any specific part of the implementation or provide more detailed fixes for particular files?",
            "citations": []
          }
        ],
        "updated_at": "2025-05-14T08:43:21.430160Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}