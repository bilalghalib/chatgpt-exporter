{
  "id": "43b88e59-8a9c-4985-a75f-5c2215ac36ef",
  "source": "claude",
  "title": "Chat Protocol Improvements",
  "created_at": "2023-05-12T10:03:21.912461Z",
  "updated_at": "2023-05-12T10:08:37.902389Z",
  "summary": "",
  "message_count": 8,
  "messages": [
    {
      "id": "98d21ff6-595d-452f-83e0-23db95f55f53",
      "role": "human",
      "content": "here's my chat.js:\n\nimport styles from './Chat.module.css';\n\nimport { debounce } from 'lodash';\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nimport { ListGroup, Form, Button, Spinner, ListGroupItem } from 'react-bootstrap';\n\nimport { FaTimes, FaReply } from 'react-icons/fa'; // Importing cross and reply icons\n\nimport { MentionsInput, Mention } from 'react-mentions';\n\nfunction Message({ message, sender, handleReply }) {\n\nreturn (\n\n<ListGroup.Item className={styles.messageItem}>\n\n<div className={styles.flexCenter}>\n\n<strong>{sender}:</strong>\n\n<Button\n\nvariant=\"link\"\n\nstyle={{ padding: 0, color: '#007bff', textDecoration: 'none' }}\n\nonClick={() => handleReply(sender)}\n\n\\>\n\n<FaReply />\n\n</Button>\n\n</div>\n\n{message.text}\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction AgentItem({ agent, handleClear, speakingQueue, handleReply }) {\n\nconst queueNumber = speakingQueue.indexOf(agent.name);\n\nreturn (\n\n<ListGroup.Item className={styles.agentItem}>\n\n{agent.name}\n\n{queueNumber !== -1 && <span> Queue: {queueNumber + 1}</span>}\n\n<FaReply style={{ color: 'blue', cursor: 'pointer', marginRight: '5px' }} onClick={() => handleReply(agent.name)} /> {/\\* Add this line \\*/}\n\n<FaTimes style={{ color: 'red', cursor: 'pointer' }} onClick={() => handleClear(agent.name)} />\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction Chat({ parliament, websocket }) {\n\nconst \\[messages, setMessages\\] = useState(\\[\\]);\n\nconst \\[messageInput, setMessageInput\\] = useState('');\n\nconst \\[isSending, setIsSending\\] = useState(false);\n\nconst \\[agents, setAgents\\] = useState(parliament.agents);\n\nconst \\[speakingQueue, setSpeakingQueue\\] = useState(\\[\\]); // Add this line\n\nconst chatContainer = useRef(null);\n\nconst \\[isTyping, setIsTyping\\] = useState(false);\n\nconst \\[typingTimeoutId, setTypingTimeoutId\\] = useState(null);\n\nconst debouncedSendTypingStatus = useCallback(debounce(sendTypingStatus, 300), \\[sendTypingStatus\\]);\n\nconst defaultStyle = {\n\nfontWeight: 'bold',\n\ncolor: 'black',\n\nfontSize: '16px',\n\npadding: '10px',\n\nborderRadius: '4px',\n\nborder: '1px solid #ccc',\n\nwidth: '100%',\n\nboxSizing: 'border-box',\n\noutline: 'none',\n\nresize: 'none',\n\n};\n\nfunction handleError(error) {\n\nconsole.error(\"Websocket error: \", error);\n\n}\n\nuseEffect(() => {\n\nif (websocket) {\n\nwebsocket.onmessage = handleReceiveMessage;\n\nwebsocket.onerror = handleError;\n\n}\n\nsetInitialMessages();\n\n}, \\[parliament, websocket\\]);\n\nuseEffect(() => {\n\nsendTypingStatus();\n\n}, \\[isTyping\\]);\n\nuseEffect(() => {\n\nchatContainer.current.scrollTop = chatContainer.current.scrollHeight;\n\n}, \\[messages\\]);\n\nfunction setInitialMessages() {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages,\n\n{\n\nsender: 'System',\n\ntext: `Parliament is in session, the topic of discussion is: ${parliament.topic}`,\n\n},\n\n{\n\nsender: 'System',\n\ntext: \\`The parliament members are ${parliament.agents\n\n.map((agent) => agent.name)\n\n.join(', ')}, and ${parliament.username}\\`,\n\n},\n\n\\]);\n\n}\n\nfunction handleReceiveMessage(event) {\n\nconst data = JSON.parse(event.data);\n\nconst { action, message, sender, updated\\_agents, queue } = data;\n\nif (action === \"receive\\_message\") {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages.filter((message) => message.sender !== parliament.username || message.text !== \"typing...\"),\n\n{ sender, text: message },\n\n\\]);\n\n} else if (action === \"typing\" && sender !== parliament.username) {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages.filter((message) => message.sender !== sender || message.text !== \"typing...\"),\n\n{ sender, text: \"typing...\" },\n\n\\]);\n\n} else if (action === \"update\\_queue\") {\n\nsetSpeakingQueue(queue);\n\n}\n\nif (updated\\_agents) {\n\nsetAgents(updated\\_agents);\n\n}\n\n}\n\nfunction handleClear(agentName) {\n\n// Send a clear event to the server\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'clear\\_agent',\n\nagent\\_name: agentName,\n\n}),\n\n);\n\n}\n\nfunction sendTypingStatus() {\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'typing',\n\nsender: parliament.username,\n\nis\\_typing: isTyping,\n\n}),\n\n);\n\n}\n\nasync function sendMessage() {\n\nif (!messageInput.trim() || isSending) return;\n\nsetIsSending(true);\n\ntry {\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'send\\_message',\n\nsender: parliament.username,\n\nmessage: messageInput,\n\n}),\n\n);\n\nsetMessageInput('');\n\nsetIsTyping(false); // Add this line\n\n} catch (error) {\n\nconsole.log('Failed to send message:', error);\n\n} finally {\n\nsetIsSending(false);\n\n}\n\n}\n\nfunction handleReply(sender) {\n\nsetMessageInput(\\`@${sender} \\`);\n\n}\n\nconst agentNames = agents.map(agent => ({ id: agent.name, display: agent.name }));\n\nreturn (\n\n<div style={{ display: 'flex', gap: '1em' }}>\n\n<div style={{ width: '70%' }}>\n\n<h1>Parliament Chat</h1>\n\n<ListGroup\n\nref={chatContainer}\n\nstyle={{ height: '400px', overflowY: 'scroll' }}>\n\n{messages.map((message, index) => (\n\n<Message\n\nkey={index}\n\nmessage={message}\n\nsender={message.sender}\n\nhandleReply={handleReply}\n\nuser={parliament.username}\n\n/>\n\n))}\n\n</ListGroup>\n\n<Form>\n\n<Form.Group controlId=\"messageInput\">\n\n<MentionsInput\n\nautoFocus\n\nvalue={messageInput}\n\nonChange={(event, value, plainTextValue) => {\n\nsetMessageInput(plainTextValue);\n\nsetIsTyping(true);\n\ndebouncedSendTypingStatus();\n\nclearTimeout(typingTimeoutId);\n\nsetTypingTimeoutId(setTimeout(() => setIsTyping(false), 2000));\n\n}}\n\nonKeyPress={(e) => {\n\nif (e.key === 'Enter') {\n\nsendMessage();\n\ne.preventDefault();\n\n}\n\n}}\n\nplaceholder=\"Type your message...\"\n\nstyle={defaultStyle} // styles for the input field\n\n\\>\n\n<Mention\n\ntrigger=\"@\"\n\ndata={agentNames}\n\ndisplayTransform={(id, display) => `@${display}`}\n\nclassName={styles.mentionStyle} // use your CSS module to style the mentions\n\n/>\n\n</MentionsInput>\n\n</Form.Group>\n\n</Form>\n\n<Button onClick={sendMessage} disabled={isSending}>\n\n{isSending ? <Spinner animation=\"border\" size=\"sm\" /> : 'Send Message'}\n\n</Button>\n\n</div>\n\n<div style={{ width: '20%', marginTop: '25px' }}> {/\\* You can adjust the marginTop as needed \\*/}\n\n<h2 style={{ fontSize: '1em' }}>Agents</h2>\n\n<ListGroup>\n\n{agents\n\n.sort((a, b) => {\n\nconst aQueueNumber = speakingQueue.indexOf(a.name);\n\nconst bQueueNumber = speakingQueue.indexOf(b.name);\n\n// If both agents are in the queue, compare their positions\n\nif (aQueueNumber !== -1 && bQueueNumber !== -1) {\n\nreturn aQueueNumber - bQueueNumber;\n\n}\n\n// If only one of the agents is in the queue, that agent comes first\n\nif (aQueueNumber !== -1) {\n\nreturn -1;\n\n}\n\nif (bQueueNumber !== -1) {\n\nreturn 1;\n\n}\n\n// If neither agent is in the queue, compare their names alphabetically\n\nreturn a.name.localeCompare(b.name);\n\n})\n\n.map((agent, index) => (\n\n<AgentItem\n\nkey={index}\n\nagent={agent}\n\nhandleClear={handleClear}\n\nspeakingQueue={speakingQueue}\n\nhandleReply={handleReply} // Add this line\n\n/>\n\n))}\n\n</ListGroup>\n\n</div>\n\n</div>\n\n);\n\n}\n\nexport default Chat;\n\nMy server.py:\n\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\n\nimport openai\n\n\\# Constants\n\nSET\\_PARLIAMENT = \"set\\_parliament\"\n\nSEND\\_MESSAGE = \"send\\_message\"\n\nADD\\_AGENTS = \"add\\_agents\"\n\nUPDATE\\_QUEUE = \"update\\_queue\"\n\nUPDATE\\_AGENTS = \"update\\_agents\"\n\nRECEIVE\\_MESSAGE = \"receive\\_message\"\n\nERROR = \"error\"\n\nTYPING = \"typing\"\n\nSTOPPED\\_TYPING = \"stopped\\_typing\"\n\nclass ParliamentServer:\n\ndef **init**(self, host=\"localhost\", port=8080):\n\nself.host = host\n\nself.port = port\n\nself.parliament = None\n\nself.start\\_server = serve(self.chat, self.host, self.port)\n\ndef configure\\_openai(self):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nasync def chat(self, websocket, path):\n\nasync for message in websocket:\n\ndata = json.loads(message)\n\naction = data.get(\"action\")\n\nif action == SET\\_PARLIAMENT:\n\nawait self.handle\\_set\\_parliament(websocket, data)\n\nelif action == SEND\\_MESSAGE:\n\nawait self.handle\\_send\\_message(websocket, data)\n\nelif action == ADD\\_AGENTS:\n\nawait self.handle\\_add\\_agents(websocket, data)\n\nelif action in \\[TYPING, STOPPED\\_TYPING\\]:\n\nawait self.handle\\_typing(websocket, data)\n\nasync def handle\\_typing(self, websocket, data):\n\nsender = data.get('sender')\n\naction = data.get('action')\n\nis\\_typing = action == TYPING\n\nself.parliament.set\\_typing\\_status(sender, is\\_typing)\n\n\\# Send the typing status update to other clients:\n\nawait websocket.send(json.dumps({\n\n\"action\": action,\n\n\"sender\": sender,\n\n\"is\\_typing\": is\\_typing\n\n}))\n\nasync def handle\\_set\\_parliament(self, websocket, data):\n\nparliament\\_name = data.get(\"name\")\n\nif parliament\\_name:\n\nself.parliament = Parliament(parliament\\_name)\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_send\\_message(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nsender = data.get(\"sender\")\n\nuser\\_message = data.get(\"message\")\n\ntimestamp = datetime.now()\n\nawait websocket.send(json.dumps({\n\n\"action\": RECEIVE\\_MESSAGE,\n\n\"message\": user\\_message,\n\n\"sender\": sender,\n\n\"timestamp\": timestamp.isoformat()}))\n\nawait self.parliament.broadcast\\_message(user\\_message, sender, timestamp)\n\n#asyncio.create\\_task(self.parliament.broadcast\\_message(user\\_message, sender, timestamp))\n\n\\# Sending agent info after broadcasting message\n\nagent\\_info = self.parliament.get\\_agents\\_info() # Assuming that this method returns agents' information\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_AGENTS, \"agents\": agent\\_info}))\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_add\\_agents(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nagents\\_data = data.get(\"agents\")\n\nif not agents\\_data:\n\nawait self.send\\_error(websocket, \"No agent data provided.\")\n\nreturn\n\nfor agent\\_data in agents\\_data:\n\nagent\\_name = agent\\_data.get(\"name\")\n\nspeaking\\_pressure\\_increment = int(agent\\_data.get(\"speaking\\_pressure\\_increment\"))\n\nother\\_agents = \", \".join(\\[agent\\['name'\\] for agent in agents\\_data if agent\\['name'\\] != agent\\_name\\])\n\ncontext = (\n\nf\"Hello assistant, your name is: @{agent\\_data.get('name')} and your context is \"\n\nf\"{agent\\_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n\nf\"alongside your fellow agents in a parliament, which is a sort \"\n\nf\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n\nf\"with you are {other\\_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n\nf\"{agent\\_data.get('speaking\\_pressure\\_increment')} out of 100\"\n\n)\n\nagent\\_type = agent\\_data.get(\"type\")\n\nagent\\_class = self.parliament.agent\\_types.get(agent\\_type)\n\nif not agent\\_class:\n\nawait self.send\\_error(websocket, f\"Unknown agent type: {agent\\_type}\")\n\n\\# Here, 'continue' is used within a loop, so it's okay\n\ncontinue\n\nagent\\_instance = agent\\_class(context) # Create a new instance of the agent class\n\nself.parliament.add\\_agent(agent\\_name, speaking\\_pressure\\_increment, context, agent\\_type, agent\\_instance, websocket)\n\nawait self.update\\_queue(websocket)\n\nasync def update\\_queue(self, websocket):\n\nif self.parliament:\n\nspeaking\\_queue = self.parliament.get\\_speaking\\_queue()\n\nprint(f\"Queue updated: {speaking\\_queue.to\\_json()}\")\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_QUEUE, \"queue\": speaking\\_queue.to\\_json()}))\n\nasync def send\\_error(self, websocket, message):\n\nawait websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\ndef run(self):\n\nself.configure\\_openai()\n\nasyncio.get\\_event\\_loop().run\\_until\\_complete(self.start\\_server)\n\nprint(\"Starting WebSocket server...\")\n\nprint(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n\nasyncio.get\\_event\\_loop().run\\_forever()\n\nif **name** == \"\\_\\_main\\_\\_\":\n\nserver = ParliamentServer()\n\nserver.run()\n\nparliament.py:\n\nimport asyncio\n\nimport random\n\nimport json\n\nimport openai\n\nfrom openai.error import RateLimitError\n\nimport time\n\nfrom typing import List\n\nfrom collections import deque\n\nPRESSURE\\_INCREMENT\\_INTERVAL = 15\n\nSPEAKING\\_PRESSURE\\_LIMIT = 100\n\nBROADCAST\\_DELAY = 10\n\nRELEVANCY\\_THRESHOLD = 100\n\nclass Agent:\n\ndef **init**(self, name: str, speaking\\_pressure\\_increment: int, context: str, agent\\_type: str, parliament, agent\\_instance=None, websocket=None):\n\nself.name = name\n\nself.speaking\\_pressure\\_increment = speaking\\_pressure\\_increment\n\nself.context = context\n\nself.speaking\\_pressure = speaking\\_pressure\\_increment\n\nself.tagged = False\n\nself.agent\\_type = agent\\_type\n\nself.agent\\_instance = agent\\_instance\n\nself.websocket = websocket\n\nself.parliament = parliament\n\nself.is\\_speaking = False\n\ndef should\\_speak(self):\n\nreturn self.parliament.speaker\\_manager.should\\_speak(self)\n\nasync def try\\_to\\_speak(self):\n\nif self.should\\_speak() and not self.is\\_speaking:\n\nawait self.speak()\n\nasync def increment\\_pressure(self):\n\nwhile True:\n\nawait asyncio.sleep(PRESSURE\\_INCREMENT\\_INTERVAL)\n\nself.speaking\\_pressure += self.speaking\\_pressure\\_increment\n\nawait self.try\\_to\\_speak()\n\ndef get\\_agent\\_message(self, chat\\_history):\n\n\"\"\"\n\nGenerate a message from this agent based on the current chat history.\n\n\"\"\"\n\nmessage = \"\"\n\nif isinstance(self.agent\\_instance, self.parliament.agent\\_types\\[self.agent\\_type\\]):\n\nresponse = self.agent\\_instance.get\\_response(chat\\_history)\n\nmessage = f\"{response}\"\n\nreturn message\n\ndef in\\_queue(self):\n\nreturn self.name in self.parliament.speaking\\_queue.queue\n\ndef calculate\\_relevancy(self, chat\\_context: str) -> int:\n\n\\# Replace this with your actual relevancy calculation logic\n\nreturn random.randint(0, 100)\n\nasync def speak(self):\n\nself.is\\_speaking = True\n\nawait self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n\nagent\\_message = self.get\\_agent\\_message(self.parliament.chat\\_history)\n\nawait self.websocket.send(json.dumps({\"action\": \"receive\\_message\", \"message\": agent\\_message, \"sender\": self.name}))\n\nself.speaking\\_pressure = 0\n\nself.is\\_speaking = False\n\nif self.in\\_queue():\n\nself.parliament.speaking\\_queue.remove(self.name)\n\ndef reset\\_pressure(self):\n\nself.speaking\\_pressure = 0\n\nclass ChatHistory:\n\ndef **init**(self):\n\nself.chat\\_history = \\[\\]\n\ndef add(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\ndef last\\_message(self):\n\nreturn self.chat\\_history\\[-1\\] if self.chat\\_history else None\n\nclass SpeakingQueue:\n\ndef **init**(self):\n\nself.queue = deque()\n\ndef add(self, agent\\_name):\n\nself.queue.append(agent\\_name)\n\ndef pop(self):\n\nif len(self.queue) > 0:\n\nreturn self.queue.pop()\n\nelse:\n\nreturn None\n\ndef enqueue(self, name):\n\nself.queue.append(name)\n\ndef dequeue(self):\n\nreturn self.queue.popleft() if self.queue else None\n\ndef front(self):\n\nreturn self.queue\\[0\\] if self.queue else None\n\ndef remove(self, name):\n\nself.queue.remove(name)\n\ndef contains(self, name):\n\nreturn name in self.queue\n\ndef to\\_json(self):\n\nreturn list(self.queue)\n\nclass SpeakerManager:\n\ndef **init**(self, parliament):\n\nself.parliament = parliament\n\ndef should\\_speak(self, agent):\n\nreturn self.parliament.speaking\\_queue.front() == agent.name and agent.speaking\\_pressure >= SPEAKING\\_PRESSURE\\_LIMIT\n\nclass OpenAIAgent:\n\ndef **init**(self, initial\\_context: str):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nself.model = \"gpt-3.5-turbo\"\n\nself.initial\\_context = initial\\_context\n\ndef get\\_response(self, chat\\_history):\n\nsystem\\_msg = self.initial\\_context\n\nmessages = \\[{\"role\": \"system\", \"content\": system\\_msg}\\]\n\nfor message in chat\\_history.chat\\_history:\n\nrole = message\\[\"sender\"\\]\n\nmsg = message\\[\"message\"\\]\n\nmessages.append({\"role\": \"assistant\" if role != \"assistant\" else role, \"content\": msg})\n\nmax\\_retries = 3\n\nretry\\_delay = 5\n\nfor i in range(max\\_retries):\n\ntry:\n\n\\# Call the OpenAI API with the messages array\n\nresponse = openai.ChatCompletion.create(\n\nmodel=self.model,\n\nmessages=messages,\n\nmax\\_tokens=150,\n\ntemperature=0.5,\n\ntop\\_p=1,\n\nfrequency\\_penalty=0,\n\npresence\\_penalty=0,\n\n)\n\n\\# Extract and return the assistant's response from the API response\n\nreturn response.choices\\[0\\].message\\[\"content\"\\].strip()\n\nexcept RateLimitError as e:\n\nprint(f\"Rate limit error: {e}. Retrying in {retry\\_delay} seconds...\")\n\nif i < max\\_retries - 1: # Don't sleep on the last iteration\n\ntime.sleep(retry\\_delay)\n\nelse:\n\nraise\n\nreturn \"Sorry, I am unable to respond at the moment.\"\n\nclass GPT4AllAgent:\n\ndef **init**(self):\n\n\\# Download and set up the GPT4All model\n\nself.\\_initialize\\_gpt4all\\_model()\n\nself.\\_initialize\\_llm\\_chain()\n\ndef _initialize_gpt4all\\_model(self):\n\nlocal\\_path = \"/Users/bilalghalib/Projects/scripts/models/ggml-gpt4all-j.bin\"\n\nPath(local\\_path).parent.mkdir(parents=True, exist\\_ok=True)\n\nurl = 'http://gpt4all.io/models/ggml-gpt4all-l13b-snoozy.bin'\n\nresponse = requests.get(url, stream=True)\n\nwith open(local\\_path, 'wb') as f:\n\nfor chunk in tqdm(response.iter\\_content(chunk\\_size=8192)):\n\nif chunk:\n\nf.write(chunk)\n\nself.model\\_path = local\\_path\n\ndef _initialize_llm\\_chain(self):\n\ntemplate = \"\"\"{chat\\_history}\n\nQuestion: {question}\n\nAnswer: Let's think step by step.\"\"\"\n\nprompt = PromptTemplate(template=template, input\\_variables=\\[\"chat\\_history\", \"question\"\\])\n\ncallbacks = \\[StreamingStdOutCallbackHandler()\\]\n\nllm = GPT4All(model=self.model\\_path, callbacks=callbacks, verbose=True)\n\nself.llm\\_chain = LLMChain(prompt=prompt, llm=llm)\n\ndef get\\_response(self, chat\\_history, question):\n\nreturn self.llm\\_chain.run(chat\\_history=chat\\_history, question=question)\n\nclass Parliament:\n\ndef **init**(self, name: str):\n\nself.name = name\n\nself.agents = {}\n\nself.chat\\_history = ChatHistory()\n\nself.speaking\\_queue = SpeakingQueue()\n\nself.speaker\\_manager = SpeakerManager(self)\n\nself.agent\\_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n\nself.typing\\_status = {}\n\ndef set\\_typing\\_status(self, agent\\_name: str, status: bool):\n\nself.typing\\_status\\[agent\\_name\\] = status\n\ndef get\\_typing\\_status(self, agent\\_name: str):\n\nreturn self.typing\\_status.get(agent\\_name, False)\n\nasync def broadcast\\_message(self, message, sender, timestamp):\n\nself.chat\\_history.add(message, sender, timestamp)\n\nmentioned\\_agents = self.identify\\_and\\_tag\\_mentioned\\_agents(message)\n\nself.increment\\_speaking\\_pressure(mentioned\\_agents)\n\nself.update\\_speaking\\_queue()\n\nfor agent in self.agents.values():\n\nif not self.get\\_typing\\_status(agent.name):\n\nawait agent.try\\_to\\_speak()\n\nawait asyncio.sleep(BROADCAST\\_DELAY)\n\nfirst\\_agent\\_in\\_queue = self.speaking\\_queue.dequeue()\n\nif first\\_agent\\_in\\_queue and not self.get\\_typing\\_status(first\\_agent\\_in\\_queue):\n\nawait self.agents\\[first\\_agent\\_in\\_queue\\].speak()\n\ndef add\\_to\\_speaking\\_queue(self, agent):\n\nif not self.speaking\\_queue.contains(agent.name):\n\nself.speaking\\_queue.enqueue(agent.name)\n\ndef update\\_speaking\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.tagged:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nagent.tagged = False\n\nfor agent in self.agents.values():\n\nif agent.speaking\\_pressure >= RELEVANCY\\_THRESHOLD:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nmost\\_relevant\\_agent = max(self.agents.values(), key=lambda agent: agent.calculate\\_relevancy(self.chat\\_history.last\\_message()), default=None)\n\nif most\\_relevant\\_agent:\n\nself.add\\_to\\_speaking\\_queue(most\\_relevant\\_agent)\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = SPEAKING\\_PRESSURE\\_LIMIT\n\nself.agents\\[agent\\_name\\].tagged = True\n\nreturn mentioned\\_agents\n\ndef get\\_speaking\\_queue(self):\n\nreturn self.speaking\\_queue\n\ndef add\\_agent(self, name: str, speaking\\_pressure\\_increment: int, context: str, agent\\_type: str, agent\\_instance=None, websocket=None):\n\nagent = Agent(name, speaking\\_pressure\\_increment, context, agent\\_type, self, agent\\_instance, websocket)\n\nself.agents\\[name\\] = agent\n\nself.typing\\_status\\[name\\] = False # Initialize typing status when adding an agent\n\nasyncio.create\\_task(agent.increment\\_pressure())\n\nself.update\\_speaking\\_queue()\n\ndef remove\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\ndel self.agents\\[agent\\_name\\]\n\ndef get\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\nreturn self.agents\\[agent\\_name\\]\n\ndef add\\_to\\_chat\\_history(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = 100\n\nself.agents\\[agent\\_name\\].tagged = True\n\nprint(f\"Tagged agent: {agent\\_name}\") # Debug print\n\nreturn mentioned\\_agents\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef add\\_tagged\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.tagged and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef add\\_high\\_pressure\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.speaking\\_pressure > 100 and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef trigger\\_next\\_speaker(self):\n\nif self.speaking\\_queue:\n\nnext\\_speaker = self.get\\_agent(self.speaking\\_queue.pop()) # Remove the agent from the queue\n\ndef update\\_speaking\\_queue(self):\n\nsorted\\_agents = self.get\\_sorted\\_agents\\_based\\_on\\_relevancy()\n\nmost\\_relevant\\_agent = sorted\\_agents\\[0\\]\n\nmost\\_relevant\\_agent.speaking\\_pressure = 100\n\nself.speaking\\_queue.add(most\\_relevant\\_agent.name)\n\nself.add\\_tagged\\_agents\\_to\\_queue()\n\nself.add\\_high\\_pressure\\_agents\\_to\\_queue()\n\nfor agent in self.agents.values():\n\nif agent.tagged and not agent.is\\_speaking:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\nself.trigger\\_next\\_speaker()\n\ndef get\\_sorted\\_agents\\_based\\_on\\_relevancy(self):\n\nreturn sorted(self.agents.values(), key=lambda agent: agent.calculate\\_relevancy(self.chat\\_history), reverse=True)\n\ndef get\\_agents\\_info(self) -> List\\[dict\\]:\n\nagents\\_info = \\[\\]\n\nfor agent\\_name, agent in self.agents.items():\n\nagents\\_info.append({\n\n\"name\": agent\\_name,\n\n\"speaking\\_pressure\": agent.speaking\\_pressure,\n\n\"speaking\\_pressure\\_increment\": agent.speaking\\_pressure\\_increment,\n\n\"context\": agent.context,\n\n\"agent\\_type\": agent.agent\\_type\n\n\\# Add more fields as needed\n\n})\n\nreturn agents\\_info",
      "created_at": "2023-05-12T10:03:54.089222Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:03:54.089222Z",
            "stop_timestamp": "2023-05-12T10:03:54.089222Z",
            "flags": null,
            "type": "text",
            "text": "here's my chat.js:\n\nimport styles from './Chat.module.css';\n\nimport { debounce } from 'lodash';\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nimport { ListGroup, Form, Button, Spinner, ListGroupItem } from 'react-bootstrap';\n\nimport { FaTimes, FaReply } from 'react-icons/fa'; // Importing cross and reply icons\n\nimport { MentionsInput, Mention } from 'react-mentions';\n\nfunction Message({ message, sender, handleReply }) {\n\nreturn (\n\n<ListGroup.Item className={styles.messageItem}>\n\n<div className={styles.flexCenter}>\n\n<strong>{sender}:</strong>\n\n<Button\n\nvariant=\"link\"\n\nstyle={{ padding: 0, color: '#007bff', textDecoration: 'none' }}\n\nonClick={() => handleReply(sender)}\n\n\\>\n\n<FaReply />\n\n</Button>\n\n</div>\n\n{message.text}\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction AgentItem({ agent, handleClear, speakingQueue, handleReply }) {\n\nconst queueNumber = speakingQueue.indexOf(agent.name);\n\nreturn (\n\n<ListGroup.Item className={styles.agentItem}>\n\n{agent.name}\n\n{queueNumber !== -1 && <span> Queue: {queueNumber + 1}</span>}\n\n<FaReply style={{ color: 'blue', cursor: 'pointer', marginRight: '5px' }} onClick={() => handleReply(agent.name)} /> {/\\* Add this line \\*/}\n\n<FaTimes style={{ color: 'red', cursor: 'pointer' }} onClick={() => handleClear(agent.name)} />\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction Chat({ parliament, websocket }) {\n\nconst \\[messages, setMessages\\] = useState(\\[\\]);\n\nconst \\[messageInput, setMessageInput\\] = useState('');\n\nconst \\[isSending, setIsSending\\] = useState(false);\n\nconst \\[agents, setAgents\\] = useState(parliament.agents);\n\nconst \\[speakingQueue, setSpeakingQueue\\] = useState(\\[\\]); // Add this line\n\nconst chatContainer = useRef(null);\n\nconst \\[isTyping, setIsTyping\\] = useState(false);\n\nconst \\[typingTimeoutId, setTypingTimeoutId\\] = useState(null);\n\nconst debouncedSendTypingStatus = useCallback(debounce(sendTypingStatus, 300), \\[sendTypingStatus\\]);\n\nconst defaultStyle = {\n\nfontWeight: 'bold',\n\ncolor: 'black',\n\nfontSize: '16px',\n\npadding: '10px',\n\nborderRadius: '4px',\n\nborder: '1px solid #ccc',\n\nwidth: '100%',\n\nboxSizing: 'border-box',\n\noutline: 'none',\n\nresize: 'none',\n\n};\n\nfunction handleError(error) {\n\nconsole.error(\"Websocket error: \", error);\n\n}\n\nuseEffect(() => {\n\nif (websocket) {\n\nwebsocket.onmessage = handleReceiveMessage;\n\nwebsocket.onerror = handleError;\n\n}\n\nsetInitialMessages();\n\n}, \\[parliament, websocket\\]);\n\nuseEffect(() => {\n\nsendTypingStatus();\n\n}, \\[isTyping\\]);\n\nuseEffect(() => {\n\nchatContainer.current.scrollTop = chatContainer.current.scrollHeight;\n\n}, \\[messages\\]);\n\nfunction setInitialMessages() {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages,\n\n{\n\nsender: 'System',\n\ntext: `Parliament is in session, the topic of discussion is: ${parliament.topic}`,\n\n},\n\n{\n\nsender: 'System',\n\ntext: \\`The parliament members are ${parliament.agents\n\n.map((agent) => agent.name)\n\n.join(', ')}, and ${parliament.username}\\`,\n\n},\n\n\\]);\n\n}\n\nfunction handleReceiveMessage(event) {\n\nconst data = JSON.parse(event.data);\n\nconst { action, message, sender, updated\\_agents, queue } = data;\n\nif (action === \"receive\\_message\") {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages.filter((message) => message.sender !== parliament.username || message.text !== \"typing...\"),\n\n{ sender, text: message },\n\n\\]);\n\n} else if (action === \"typing\" && sender !== parliament.username) {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages.filter((message) => message.sender !== sender || message.text !== \"typing...\"),\n\n{ sender, text: \"typing...\" },\n\n\\]);\n\n} else if (action === \"update\\_queue\") {\n\nsetSpeakingQueue(queue);\n\n}\n\nif (updated\\_agents) {\n\nsetAgents(updated\\_agents);\n\n}\n\n}\n\nfunction handleClear(agentName) {\n\n// Send a clear event to the server\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'clear\\_agent',\n\nagent\\_name: agentName,\n\n}),\n\n);\n\n}\n\nfunction sendTypingStatus() {\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'typing',\n\nsender: parliament.username,\n\nis\\_typing: isTyping,\n\n}),\n\n);\n\n}\n\nasync function sendMessage() {\n\nif (!messageInput.trim() || isSending) return;\n\nsetIsSending(true);\n\ntry {\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'send\\_message',\n\nsender: parliament.username,\n\nmessage: messageInput,\n\n}),\n\n);\n\nsetMessageInput('');\n\nsetIsTyping(false); // Add this line\n\n} catch (error) {\n\nconsole.log('Failed to send message:', error);\n\n} finally {\n\nsetIsSending(false);\n\n}\n\n}\n\nfunction handleReply(sender) {\n\nsetMessageInput(\\`@${sender} \\`);\n\n}\n\nconst agentNames = agents.map(agent => ({ id: agent.name, display: agent.name }));\n\nreturn (\n\n<div style={{ display: 'flex', gap: '1em' }}>\n\n<div style={{ width: '70%' }}>\n\n<h1>Parliament Chat</h1>\n\n<ListGroup\n\nref={chatContainer}\n\nstyle={{ height: '400px', overflowY: 'scroll' }}>\n\n{messages.map((message, index) => (\n\n<Message\n\nkey={index}\n\nmessage={message}\n\nsender={message.sender}\n\nhandleReply={handleReply}\n\nuser={parliament.username}\n\n/>\n\n))}\n\n</ListGroup>\n\n<Form>\n\n<Form.Group controlId=\"messageInput\">\n\n<MentionsInput\n\nautoFocus\n\nvalue={messageInput}\n\nonChange={(event, value, plainTextValue) => {\n\nsetMessageInput(plainTextValue);\n\nsetIsTyping(true);\n\ndebouncedSendTypingStatus();\n\nclearTimeout(typingTimeoutId);\n\nsetTypingTimeoutId(setTimeout(() => setIsTyping(false), 2000));\n\n}}\n\nonKeyPress={(e) => {\n\nif (e.key === 'Enter') {\n\nsendMessage();\n\ne.preventDefault();\n\n}\n\n}}\n\nplaceholder=\"Type your message...\"\n\nstyle={defaultStyle} // styles for the input field\n\n\\>\n\n<Mention\n\ntrigger=\"@\"\n\ndata={agentNames}\n\ndisplayTransform={(id, display) => `@${display}`}\n\nclassName={styles.mentionStyle} // use your CSS module to style the mentions\n\n/>\n\n</MentionsInput>\n\n</Form.Group>\n\n</Form>\n\n<Button onClick={sendMessage} disabled={isSending}>\n\n{isSending ? <Spinner animation=\"border\" size=\"sm\" /> : 'Send Message'}\n\n</Button>\n\n</div>\n\n<div style={{ width: '20%', marginTop: '25px' }}> {/\\* You can adjust the marginTop as needed \\*/}\n\n<h2 style={{ fontSize: '1em' }}>Agents</h2>\n\n<ListGroup>\n\n{agents\n\n.sort((a, b) => {\n\nconst aQueueNumber = speakingQueue.indexOf(a.name);\n\nconst bQueueNumber = speakingQueue.indexOf(b.name);\n\n// If both agents are in the queue, compare their positions\n\nif (aQueueNumber !== -1 && bQueueNumber !== -1) {\n\nreturn aQueueNumber - bQueueNumber;\n\n}\n\n// If only one of the agents is in the queue, that agent comes first\n\nif (aQueueNumber !== -1) {\n\nreturn -1;\n\n}\n\nif (bQueueNumber !== -1) {\n\nreturn 1;\n\n}\n\n// If neither agent is in the queue, compare their names alphabetically\n\nreturn a.name.localeCompare(b.name);\n\n})\n\n.map((agent, index) => (\n\n<AgentItem\n\nkey={index}\n\nagent={agent}\n\nhandleClear={handleClear}\n\nspeakingQueue={speakingQueue}\n\nhandleReply={handleReply} // Add this line\n\n/>\n\n))}\n\n</ListGroup>\n\n</div>\n\n</div>\n\n);\n\n}\n\nexport default Chat;\n\nMy server.py:\n\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\n\nimport openai\n\n\\# Constants\n\nSET\\_PARLIAMENT = \"set\\_parliament\"\n\nSEND\\_MESSAGE = \"send\\_message\"\n\nADD\\_AGENTS = \"add\\_agents\"\n\nUPDATE\\_QUEUE = \"update\\_queue\"\n\nUPDATE\\_AGENTS = \"update\\_agents\"\n\nRECEIVE\\_MESSAGE = \"receive\\_message\"\n\nERROR = \"error\"\n\nTYPING = \"typing\"\n\nSTOPPED\\_TYPING = \"stopped\\_typing\"\n\nclass ParliamentServer:\n\ndef **init**(self, host=\"localhost\", port=8080):\n\nself.host = host\n\nself.port = port\n\nself.parliament = None\n\nself.start\\_server = serve(self.chat, self.host, self.port)\n\ndef configure\\_openai(self):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nasync def chat(self, websocket, path):\n\nasync for message in websocket:\n\ndata = json.loads(message)\n\naction = data.get(\"action\")\n\nif action == SET\\_PARLIAMENT:\n\nawait self.handle\\_set\\_parliament(websocket, data)\n\nelif action == SEND\\_MESSAGE:\n\nawait self.handle\\_send\\_message(websocket, data)\n\nelif action == ADD\\_AGENTS:\n\nawait self.handle\\_add\\_agents(websocket, data)\n\nelif action in \\[TYPING, STOPPED\\_TYPING\\]:\n\nawait self.handle\\_typing(websocket, data)\n\nasync def handle\\_typing(self, websocket, data):\n\nsender = data.get('sender')\n\naction = data.get('action')\n\nis\\_typing = action == TYPING\n\nself.parliament.set\\_typing\\_status(sender, is\\_typing)\n\n\\# Send the typing status update to other clients:\n\nawait websocket.send(json.dumps({\n\n\"action\": action,\n\n\"sender\": sender,\n\n\"is\\_typing\": is\\_typing\n\n}))\n\nasync def handle\\_set\\_parliament(self, websocket, data):\n\nparliament\\_name = data.get(\"name\")\n\nif parliament\\_name:\n\nself.parliament = Parliament(parliament\\_name)\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_send\\_message(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nsender = data.get(\"sender\")\n\nuser\\_message = data.get(\"message\")\n\ntimestamp = datetime.now()\n\nawait websocket.send(json.dumps({\n\n\"action\": RECEIVE\\_MESSAGE,\n\n\"message\": user\\_message,\n\n\"sender\": sender,\n\n\"timestamp\": timestamp.isoformat()}))\n\nawait self.parliament.broadcast\\_message(user\\_message, sender, timestamp)\n\n#asyncio.create\\_task(self.parliament.broadcast\\_message(user\\_message, sender, timestamp))\n\n\\# Sending agent info after broadcasting message\n\nagent\\_info = self.parliament.get\\_agents\\_info() # Assuming that this method returns agents' information\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_AGENTS, \"agents\": agent\\_info}))\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_add\\_agents(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nagents\\_data = data.get(\"agents\")\n\nif not agents\\_data:\n\nawait self.send\\_error(websocket, \"No agent data provided.\")\n\nreturn\n\nfor agent\\_data in agents\\_data:\n\nagent\\_name = agent\\_data.get(\"name\")\n\nspeaking\\_pressure\\_increment = int(agent\\_data.get(\"speaking\\_pressure\\_increment\"))\n\nother\\_agents = \", \".join(\\[agent\\['name'\\] for agent in agents\\_data if agent\\['name'\\] != agent\\_name\\])\n\ncontext = (\n\nf\"Hello assistant, your name is: @{agent\\_data.get('name')} and your context is \"\n\nf\"{agent\\_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n\nf\"alongside your fellow agents in a parliament, which is a sort \"\n\nf\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n\nf\"with you are {other\\_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n\nf\"{agent\\_data.get('speaking\\_pressure\\_increment')} out of 100\"\n\n)\n\nagent\\_type = agent\\_data.get(\"type\")\n\nagent\\_class = self.parliament.agent\\_types.get(agent\\_type)\n\nif not agent\\_class:\n\nawait self.send\\_error(websocket, f\"Unknown agent type: {agent\\_type}\")\n\n\\# Here, 'continue' is used within a loop, so it's okay\n\ncontinue\n\nagent\\_instance = agent\\_class(context) # Create a new instance of the agent class\n\nself.parliament.add\\_agent(agent\\_name, speaking\\_pressure\\_increment, context, agent\\_type, agent\\_instance, websocket)\n\nawait self.update\\_queue(websocket)\n\nasync def update\\_queue(self, websocket):\n\nif self.parliament:\n\nspeaking\\_queue = self.parliament.get\\_speaking\\_queue()\n\nprint(f\"Queue updated: {speaking\\_queue.to\\_json()}\")\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_QUEUE, \"queue\": speaking\\_queue.to\\_json()}))\n\nasync def send\\_error(self, websocket, message):\n\nawait websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\ndef run(self):\n\nself.configure\\_openai()\n\nasyncio.get\\_event\\_loop().run\\_until\\_complete(self.start\\_server)\n\nprint(\"Starting WebSocket server...\")\n\nprint(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n\nasyncio.get\\_event\\_loop().run\\_forever()\n\nif **name** == \"\\_\\_main\\_\\_\":\n\nserver = ParliamentServer()\n\nserver.run()\n\nparliament.py:\n\nimport asyncio\n\nimport random\n\nimport json\n\nimport openai\n\nfrom openai.error import RateLimitError\n\nimport time\n\nfrom typing import List\n\nfrom collections import deque\n\nPRESSURE\\_INCREMENT\\_INTERVAL = 15\n\nSPEAKING\\_PRESSURE\\_LIMIT = 100\n\nBROADCAST\\_DELAY = 10\n\nRELEVANCY\\_THRESHOLD = 100\n\nclass Agent:\n\ndef **init**(self, name: str, speaking\\_pressure\\_increment: int, context: str, agent\\_type: str, parliament, agent\\_instance=None, websocket=None):\n\nself.name = name\n\nself.speaking\\_pressure\\_increment = speaking\\_pressure\\_increment\n\nself.context = context\n\nself.speaking\\_pressure = speaking\\_pressure\\_increment\n\nself.tagged = False\n\nself.agent\\_type = agent\\_type\n\nself.agent\\_instance = agent\\_instance\n\nself.websocket = websocket\n\nself.parliament = parliament\n\nself.is\\_speaking = False\n\ndef should\\_speak(self):\n\nreturn self.parliament.speaker\\_manager.should\\_speak(self)\n\nasync def try\\_to\\_speak(self):\n\nif self.should\\_speak() and not self.is\\_speaking:\n\nawait self.speak()\n\nasync def increment\\_pressure(self):\n\nwhile True:\n\nawait asyncio.sleep(PRESSURE\\_INCREMENT\\_INTERVAL)\n\nself.speaking\\_pressure += self.speaking\\_pressure\\_increment\n\nawait self.try\\_to\\_speak()\n\ndef get\\_agent\\_message(self, chat\\_history):\n\n\"\"\"\n\nGenerate a message from this agent based on the current chat history.\n\n\"\"\"\n\nmessage = \"\"\n\nif isinstance(self.agent\\_instance, self.parliament.agent\\_types\\[self.agent\\_type\\]):\n\nresponse = self.agent\\_instance.get\\_response(chat\\_history)\n\nmessage = f\"{response}\"\n\nreturn message\n\ndef in\\_queue(self):\n\nreturn self.name in self.parliament.speaking\\_queue.queue\n\ndef calculate\\_relevancy(self, chat\\_context: str) -> int:\n\n\\# Replace this with your actual relevancy calculation logic\n\nreturn random.randint(0, 100)\n\nasync def speak(self):\n\nself.is\\_speaking = True\n\nawait self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n\nagent\\_message = self.get\\_agent\\_message(self.parliament.chat\\_history)\n\nawait self.websocket.send(json.dumps({\"action\": \"receive\\_message\", \"message\": agent\\_message, \"sender\": self.name}))\n\nself.speaking\\_pressure = 0\n\nself.is\\_speaking = False\n\nif self.in\\_queue():\n\nself.parliament.speaking\\_queue.remove(self.name)\n\ndef reset\\_pressure(self):\n\nself.speaking\\_pressure = 0\n\nclass ChatHistory:\n\ndef **init**(self):\n\nself.chat\\_history = \\[\\]\n\ndef add(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\ndef last\\_message(self):\n\nreturn self.chat\\_history\\[-1\\] if self.chat\\_history else None\n\nclass SpeakingQueue:\n\ndef **init**(self):\n\nself.queue = deque()\n\ndef add(self, agent\\_name):\n\nself.queue.append(agent\\_name)\n\ndef pop(self):\n\nif len(self.queue) > 0:\n\nreturn self.queue.pop()\n\nelse:\n\nreturn None\n\ndef enqueue(self, name):\n\nself.queue.append(name)\n\ndef dequeue(self):\n\nreturn self.queue.popleft() if self.queue else None\n\ndef front(self):\n\nreturn self.queue\\[0\\] if self.queue else None\n\ndef remove(self, name):\n\nself.queue.remove(name)\n\ndef contains(self, name):\n\nreturn name in self.queue\n\ndef to\\_json(self):\n\nreturn list(self.queue)\n\nclass SpeakerManager:\n\ndef **init**(self, parliament):\n\nself.parliament = parliament\n\ndef should\\_speak(self, agent):\n\nreturn self.parliament.speaking\\_queue.front() == agent.name and agent.speaking\\_pressure >= SPEAKING\\_PRESSURE\\_LIMIT\n\nclass OpenAIAgent:\n\ndef **init**(self, initial\\_context: str):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nself.model = \"gpt-3.5-turbo\"\n\nself.initial\\_context = initial\\_context\n\ndef get\\_response(self, chat\\_history):\n\nsystem\\_msg = self.initial\\_context\n\nmessages = \\[{\"role\": \"system\", \"content\": system\\_msg}\\]\n\nfor message in chat\\_history.chat\\_history:\n\nrole = message\\[\"sender\"\\]\n\nmsg = message\\[\"message\"\\]\n\nmessages.append({\"role\": \"assistant\" if role != \"assistant\" else role, \"content\": msg})\n\nmax\\_retries = 3\n\nretry\\_delay = 5\n\nfor i in range(max\\_retries):\n\ntry:\n\n\\# Call the OpenAI API with the messages array\n\nresponse = openai.ChatCompletion.create(\n\nmodel=self.model,\n\nmessages=messages,\n\nmax\\_tokens=150,\n\ntemperature=0.5,\n\ntop\\_p=1,\n\nfrequency\\_penalty=0,\n\npresence\\_penalty=0,\n\n)\n\n\\# Extract and return the assistant's response from the API response\n\nreturn response.choices\\[0\\].message\\[\"content\"\\].strip()\n\nexcept RateLimitError as e:\n\nprint(f\"Rate limit error: {e}. Retrying in {retry\\_delay} seconds...\")\n\nif i < max\\_retries - 1: # Don't sleep on the last iteration\n\ntime.sleep(retry\\_delay)\n\nelse:\n\nraise\n\nreturn \"Sorry, I am unable to respond at the moment.\"\n\nclass GPT4AllAgent:\n\ndef **init**(self):\n\n\\# Download and set up the GPT4All model\n\nself.\\_initialize\\_gpt4all\\_model()\n\nself.\\_initialize\\_llm\\_chain()\n\ndef _initialize_gpt4all\\_model(self):\n\nlocal\\_path = \"/Users/bilalghalib/Projects/scripts/models/ggml-gpt4all-j.bin\"\n\nPath(local\\_path).parent.mkdir(parents=True, exist\\_ok=True)\n\nurl = 'http://gpt4all.io/models/ggml-gpt4all-l13b-snoozy.bin'\n\nresponse = requests.get(url, stream=True)\n\nwith open(local\\_path, 'wb') as f:\n\nfor chunk in tqdm(response.iter\\_content(chunk\\_size=8192)):\n\nif chunk:\n\nf.write(chunk)\n\nself.model\\_path = local\\_path\n\ndef _initialize_llm\\_chain(self):\n\ntemplate = \"\"\"{chat\\_history}\n\nQuestion: {question}\n\nAnswer: Let's think step by step.\"\"\"\n\nprompt = PromptTemplate(template=template, input\\_variables=\\[\"chat\\_history\", \"question\"\\])\n\ncallbacks = \\[StreamingStdOutCallbackHandler()\\]\n\nllm = GPT4All(model=self.model\\_path, callbacks=callbacks, verbose=True)\n\nself.llm\\_chain = LLMChain(prompt=prompt, llm=llm)\n\ndef get\\_response(self, chat\\_history, question):\n\nreturn self.llm\\_chain.run(chat\\_history=chat\\_history, question=question)\n\nclass Parliament:\n\ndef **init**(self, name: str):\n\nself.name = name\n\nself.agents = {}\n\nself.chat\\_history = ChatHistory()\n\nself.speaking\\_queue = SpeakingQueue()\n\nself.speaker\\_manager = SpeakerManager(self)\n\nself.agent\\_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n\nself.typing\\_status = {}\n\ndef set\\_typing\\_status(self, agent\\_name: str, status: bool):\n\nself.typing\\_status\\[agent\\_name\\] = status\n\ndef get\\_typing\\_status(self, agent\\_name: str):\n\nreturn self.typing\\_status.get(agent\\_name, False)\n\nasync def broadcast\\_message(self, message, sender, timestamp):\n\nself.chat\\_history.add(message, sender, timestamp)\n\nmentioned\\_agents = self.identify\\_and\\_tag\\_mentioned\\_agents(message)\n\nself.increment\\_speaking\\_pressure(mentioned\\_agents)\n\nself.update\\_speaking\\_queue()\n\nfor agent in self.agents.values():\n\nif not self.get\\_typing\\_status(agent.name):\n\nawait agent.try\\_to\\_speak()\n\nawait asyncio.sleep(BROADCAST\\_DELAY)\n\nfirst\\_agent\\_in\\_queue = self.speaking\\_queue.dequeue()\n\nif first\\_agent\\_in\\_queue and not self.get\\_typing\\_status(first\\_agent\\_in\\_queue):\n\nawait self.agents\\[first\\_agent\\_in\\_queue\\].speak()\n\ndef add\\_to\\_speaking\\_queue(self, agent):\n\nif not self.speaking\\_queue.contains(agent.name):\n\nself.speaking\\_queue.enqueue(agent.name)\n\ndef update\\_speaking\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.tagged:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nagent.tagged = False\n\nfor agent in self.agents.values():\n\nif agent.speaking\\_pressure >= RELEVANCY\\_THRESHOLD:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nmost\\_relevant\\_agent = max(self.agents.values(), key=lambda agent: agent.calculate\\_relevancy(self.chat\\_history.last\\_message()), default=None)\n\nif most\\_relevant\\_agent:\n\nself.add\\_to\\_speaking\\_queue(most\\_relevant\\_agent)\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = SPEAKING\\_PRESSURE\\_LIMIT\n\nself.agents\\[agent\\_name\\].tagged = True\n\nreturn mentioned\\_agents\n\ndef get\\_speaking\\_queue(self):\n\nreturn self.speaking\\_queue\n\ndef add\\_agent(self, name: str, speaking\\_pressure\\_increment: int, context: str, agent\\_type: str, agent\\_instance=None, websocket=None):\n\nagent = Agent(name, speaking\\_pressure\\_increment, context, agent\\_type, self, agent\\_instance, websocket)\n\nself.agents\\[name\\] = agent\n\nself.typing\\_status\\[name\\] = False # Initialize typing status when adding an agent\n\nasyncio.create\\_task(agent.increment\\_pressure())\n\nself.update\\_speaking\\_queue()\n\ndef remove\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\ndel self.agents\\[agent\\_name\\]\n\ndef get\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\nreturn self.agents\\[agent\\_name\\]\n\ndef add\\_to\\_chat\\_history(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = 100\n\nself.agents\\[agent\\_name\\].tagged = True\n\nprint(f\"Tagged agent: {agent\\_name}\") # Debug print\n\nreturn mentioned\\_agents\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef add\\_tagged\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.tagged and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef add\\_high\\_pressure\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.speaking\\_pressure > 100 and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef trigger\\_next\\_speaker(self):\n\nif self.speaking\\_queue:\n\nnext\\_speaker = self.get\\_agent(self.speaking\\_queue.pop()) # Remove the agent from the queue\n\ndef update\\_speaking\\_queue(self):\n\nsorted\\_agents = self.get\\_sorted\\_agents\\_based\\_on\\_relevancy()\n\nmost\\_relevant\\_agent = sorted\\_agents\\[0\\]\n\nmost\\_relevant\\_agent.speaking\\_pressure = 100\n\nself.speaking\\_queue.add(most\\_relevant\\_agent.name)\n\nself.add\\_tagged\\_agents\\_to\\_queue()\n\nself.add\\_high\\_pressure\\_agents\\_to\\_queue()\n\nfor agent in self.agents.values():\n\nif agent.tagged and not agent.is\\_speaking:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\nself.trigger\\_next\\_speaker()\n\ndef get\\_sorted\\_agents\\_based\\_on\\_relevancy(self):\n\nreturn sorted(self.agents.values(), key=lambda agent: agent.calculate\\_relevancy(self.chat\\_history), reverse=True)\n\ndef get\\_agents\\_info(self) -> List\\[dict\\]:\n\nagents\\_info = \\[\\]\n\nfor agent\\_name, agent in self.agents.items():\n\nagents\\_info.append({\n\n\"name\": agent\\_name,\n\n\"speaking\\_pressure\": agent.speaking\\_pressure,\n\n\"speaking\\_pressure\\_increment\": agent.speaking\\_pressure\\_increment,\n\n\"context\": agent.context,\n\n\"agent\\_type\": agent.agent\\_type\n\n\\# Add more fields as needed\n\n})\n\nreturn agents\\_info",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:03:54.089222Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "e67246bf-b69e-4218-a34e-97e2fc17aef8",
      "role": "assistant",
      "content": " Here are some issues I noticed in the code:\n\n1. There is a lot of duplicated logic in the Parliament class. Specifically, the methods add_to_speaking_queue, update_speaking_queue, increment_speaking_pressure, identify_and_tag_mentioned_agents contain a lot of duplicated logic. This can be refactored into reusable functions to avoid duplication and make the code more maintainable.\n\n2. The methods in Parliament class are very long, exceeding 50-100 lines in some cases. These methods can be split up into smaller, reusable functions to make the code more readable and maintainable.\n\n3. The ParliamentServer class also contains some long methods, specifically handle_set_parliament and handle_add_agents. These methods can be split up into smaller functions.\n\n4. There are a few magic strings used in the code, e.g. \"openai\" and \"gpt4all\" for agent types. It is better to define constants for these to avoid typos and make the code more robust.\n\n5. The code can use some additional type hints to make the intentions more clear and catch type errors early.\n\n6. Additional comments can be added, especially in complex parts of the code, to make it more readable for other developers.\n\n7. The websocket handling logic can be extracted into a separate WebSocketManager class to keep the ParliamentServer class focused on the main logic. This follows the single responsibility principle.\n\n8. Additional tests can be written to verify the logic and catch any issues early on.\n\n9. The API provided by the server is not very flexible. It may be better to define the API and data models first before implementing the logic. This follows the API-first approach and leads to a more flexible API.\n\nDoes this help? Let me know if you have any other questions!",
      "created_at": "2023-05-12T10:04:12.940676Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:04:12.940676Z",
            "stop_timestamp": "2023-05-12T10:04:12.940676Z",
            "flags": null,
            "type": "text",
            "text": " Here are some issues I noticed in the code:\n\n1. There is a lot of duplicated logic in the Parliament class. Specifically, the methods add_to_speaking_queue, update_speaking_queue, increment_speaking_pressure, identify_and_tag_mentioned_agents contain a lot of duplicated logic. This can be refactored into reusable functions to avoid duplication and make the code more maintainable.\n\n2. The methods in Parliament class are very long, exceeding 50-100 lines in some cases. These methods can be split up into smaller, reusable functions to make the code more readable and maintainable.\n\n3. The ParliamentServer class also contains some long methods, specifically handle_set_parliament and handle_add_agents. These methods can be split up into smaller functions.\n\n4. There are a few magic strings used in the code, e.g. \"openai\" and \"gpt4all\" for agent types. It is better to define constants for these to avoid typos and make the code more robust.\n\n5. The code can use some additional type hints to make the intentions more clear and catch type errors early.\n\n6. Additional comments can be added, especially in complex parts of the code, to make it more readable for other developers.\n\n7. The websocket handling logic can be extracted into a separate WebSocketManager class to keep the ParliamentServer class focused on the main logic. This follows the single responsibility principle.\n\n8. Additional tests can be written to verify the logic and catch any issues early on.\n\n9. The API provided by the server is not very flexible. It may be better to define the API and data models first before implementing the logic. This follows the API-first approach and leads to a more flexible API.\n\nDoes this help? Let me know if you have any other questions!",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:04:12.940676Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "454a83fc-d6c5-47ce-bd95-1e7404f36d2c",
      "role": "human",
      "content": "can you help me do this: The API provided by the server is not very flexible. It may be better to define the API and data models first before implementing the logic. This follows the API-first approach and leads to a more flexible API.\n\nAnd\n\n1.  The websocket handling logic can be extracted into a separate WebSocketManager class to keep the ParliamentServer class focused on the main logic. This follows the single responsibility principle.",
      "created_at": "2023-05-12T10:05:00.714970Z",
      "sequence_order": 2,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:05:00.714970Z",
            "stop_timestamp": "2023-05-12T10:05:00.714970Z",
            "flags": null,
            "type": "text",
            "text": "can you help me do this: The API provided by the server is not very flexible. It may be better to define the API and data models first before implementing the logic. This follows the API-first approach and leads to a more flexible API.\n\nAnd\n\n1.  The websocket handling logic can be extracted into a separate WebSocketManager class to keep the ParliamentServer class focused on the main logic. This follows the single responsibility principle.",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:05:00.714970Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "0668f414-7918-4aad-bf60-c227e7dcc9b8",
      "role": "assistant",
      "content": " Here are some suggestions to improve the API and extract the WebSocket logic:\n\nFor the API, I would define data models for:\n\n- Agents: Contains name, speaking_pressure, context, agent_type, etc.\n- Messages: Contains sender, message text, timestamp, etc. \n- Speaking Queue: Contains a list of agent names.\n\nThe endpoints could be:\n\n- /parliaments: To create a new parliament. Request body would contain the parliament name and topic. Response would contain the parliament ID.\n- /parliaments/{id}: To get details of a specific parliament. \n- /parliaments/{id}/agents: To add agents to a parliament. Request body would contain a list of Agent objects. \n- /parliaments/{id}/messages: To get messages for a parliament. Query parameters can be used to filter by sender, timestamp, etc.\n- /parliaments/{id}/speaking-queue: To get the speaking queue for a parliament.\n\nThis API would be more flexible and robust compared to using websockets for everything. Websockets can then be used to push real-time updates to clients.\n\nTo extract the WebSocket logic, you can create a WebSocketManager class like this:\n\n```python\nclass WebSocketManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    async def handle_connection(self, websocket, path):\n        # Register handler methods\n        websocket.onmessage = self.handle_message\n        websocket.onerror = self.handle_error\n\n        # Handle incoming messages\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == \"send_message\":\n                await self.handle_send_message(websocket, data)\n            elif action == \"typing\":\n                await self.handle_typing(websocket, data)\n            # Other action handlers...\n\n    async def handle_send_message(self, websocket, data):\n        # Logic to handle sending a message\n        ...\n```\n\nThe ParliamentServer class can then instantiate a WebSocketManager and call `await websocket_manager.handle_connection(websocket, path)` to delegate websocket handling to it.\n\nThis follows the single responsibility principle by separating the websocket and API logic into separate classes. Let me know if you have any other questions!",
      "created_at": "2023-05-12T10:05:20.433371Z",
      "sequence_order": 3,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:05:20.433371Z",
            "stop_timestamp": "2023-05-12T10:05:20.433371Z",
            "flags": null,
            "type": "text",
            "text": " Here are some suggestions to improve the API and extract the WebSocket logic:\n\nFor the API, I would define data models for:\n\n- Agents: Contains name, speaking_pressure, context, agent_type, etc.\n- Messages: Contains sender, message text, timestamp, etc. \n- Speaking Queue: Contains a list of agent names.\n\nThe endpoints could be:\n\n- /parliaments: To create a new parliament. Request body would contain the parliament name and topic. Response would contain the parliament ID.\n- /parliaments/{id}: To get details of a specific parliament. \n- /parliaments/{id}/agents: To add agents to a parliament. Request body would contain a list of Agent objects. \n- /parliaments/{id}/messages: To get messages for a parliament. Query parameters can be used to filter by sender, timestamp, etc.\n- /parliaments/{id}/speaking-queue: To get the speaking queue for a parliament.\n\nThis API would be more flexible and robust compared to using websockets for everything. Websockets can then be used to push real-time updates to clients.\n\nTo extract the WebSocket logic, you can create a WebSocketManager class like this:\n\n```python\nclass WebSocketManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    async def handle_connection(self, websocket, path):\n        # Register handler methods\n        websocket.onmessage = self.handle_message\n        websocket.onerror = self.handle_error\n\n        # Handle incoming messages\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == \"send_message\":\n                await self.handle_send_message(websocket, data)\n            elif action == \"typing\":\n                await self.handle_typing(websocket, data)\n            # Other action handlers...\n\n    async def handle_send_message(self, websocket, data):\n        # Logic to handle sending a message\n        ...\n```\n\nThe ParliamentServer class can then instantiate a WebSocketManager and call `await websocket_manager.handle_connection(websocket, path)` to delegate websocket handling to it.\n\nThis follows the single responsibility principle by separating the websocket and API logic into separate classes. Let me know if you have any other questions!",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:05:20.433371Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "64709b1b-e6b4-4d1f-9053-ca042f2c3593",
      "role": "human",
      "content": "can you create the entire file for websockets?",
      "created_at": "2023-05-12T10:05:59.580663Z",
      "sequence_order": 4,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:05:59.580663Z",
            "stop_timestamp": "2023-05-12T10:05:59.580663Z",
            "flags": null,
            "type": "text",
            "text": "can you create the entire file for websockets?",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:05:59.580663Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "1b9ef5c9-fc87-4c0d-9dfc-ffbc69dae439",
      "role": "assistant",
      "content": " Here is a WebSocketManager class:\n\n```python\nimport json\nimport asyncio\n\nclass WebSocketManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    async def handle_connection(self, websocket, path):\n        # Register handler methods\n        websocket.onmessage = self.handle_message\n        websocket.onerror = self.handle_error\n\n        # Handle incoming messages\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == \"send_message\":\n                await self.handle_send_message(websocket, data)\n            elif action == \"typing\":\n                await self.handle_typing(websocket, data)\n            elif action == \"set_parliament\":\n                await self.handle_set_parliament(websocket, data)\n            elif action == \"add_agents\":\n                await self.handle_add_agents(websocket, data)\n\n    async def handle_send_message(self, websocket, data):\n        sender = data.get(\"sender\")\n        message = data.get(\"message\")\n        # Broadcast the message to other clients\n        await websocket.send(json.dumps({\n            \"action\": \"receive_message\",\n            \"message\": message, \n            \"sender\": sender\n        }))\n        # Add the message to the parliament chat history\n        await self.parliament.add_message(message, sender)        \n\n    async def handle_typing(self, websocket, data):\n        sender = data.get(\"sender\")\n        is_typing = data.get(\"is_typing\")\n        # Broadcast the typing status to other clients\n        await websocket.send(json.dumps({\n            \"action\": \"typing\",\n            \"sender\": sender,\n            \"is_typing\": is_typing\n        }))        \n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        self.parliament = Parliament(parliament_name)\n        # Send inital state to client\n        await websocket.send(json.dumps({\n            \"action\": \"set_parliament\",\n            \"name\": parliament_name,\n            \"agents\": self.parliament.get_agents_info(),\n            \"speaking_queue\": self.parliament.get_speaking_queue()\n        }))\n\n    async def handle_add_agents(self, websocket, data):\n        # Add the agents to the parliament\n        await self.parliament.add_agents(data.get(\"agents\"))\n        # Send updated agent info to client\n        await websocket.send(json.dumps({\n            \"action\": \"update_agents\",\n            \"agents\": self.parliament.get_agents_info()\n        }))\n\n\n```\n\nThis exposes the main actions required for the chat application over the WebSocket. Let me know if you would like me to clarify or expand on any part of this code!",
      "created_at": "2023-05-12T10:06:19.521816Z",
      "sequence_order": 5,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:06:19.521816Z",
            "stop_timestamp": "2023-05-12T10:06:19.521816Z",
            "flags": null,
            "type": "text",
            "text": " Here is a WebSocketManager class:\n\n```python\nimport json\nimport asyncio\n\nclass WebSocketManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    async def handle_connection(self, websocket, path):\n        # Register handler methods\n        websocket.onmessage = self.handle_message\n        websocket.onerror = self.handle_error\n\n        # Handle incoming messages\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == \"send_message\":\n                await self.handle_send_message(websocket, data)\n            elif action == \"typing\":\n                await self.handle_typing(websocket, data)\n            elif action == \"set_parliament\":\n                await self.handle_set_parliament(websocket, data)\n            elif action == \"add_agents\":\n                await self.handle_add_agents(websocket, data)\n\n    async def handle_send_message(self, websocket, data):\n        sender = data.get(\"sender\")\n        message = data.get(\"message\")\n        # Broadcast the message to other clients\n        await websocket.send(json.dumps({\n            \"action\": \"receive_message\",\n            \"message\": message, \n            \"sender\": sender\n        }))\n        # Add the message to the parliament chat history\n        await self.parliament.add_message(message, sender)        \n\n    async def handle_typing(self, websocket, data):\n        sender = data.get(\"sender\")\n        is_typing = data.get(\"is_typing\")\n        # Broadcast the typing status to other clients\n        await websocket.send(json.dumps({\n            \"action\": \"typing\",\n            \"sender\": sender,\n            \"is_typing\": is_typing\n        }))        \n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        self.parliament = Parliament(parliament_name)\n        # Send inital state to client\n        await websocket.send(json.dumps({\n            \"action\": \"set_parliament\",\n            \"name\": parliament_name,\n            \"agents\": self.parliament.get_agents_info(),\n            \"speaking_queue\": self.parliament.get_speaking_queue()\n        }))\n\n    async def handle_add_agents(self, websocket, data):\n        # Add the agents to the parliament\n        await self.parliament.add_agents(data.get(\"agents\"))\n        # Send updated agent info to client\n        await websocket.send(json.dumps({\n            \"action\": \"update_agents\",\n            \"agents\": self.parliament.get_agents_info()\n        }))\n\n\n```\n\nThis exposes the main actions required for the chat application over the WebSocket. Let me know if you would like me to clarify or expand on any part of this code!",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:06:19.521816Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "51cad5a9-af14-4991-bf94-50eedbcb40c9",
      "role": "human",
      "content": "now how do I include this new file that I called websockets.py into my server.py code?\n\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\n\nimport openai\n\n\\# Constants\n\nSET\\_PARLIAMENT = \"set\\_parliament\"\n\nSEND\\_MESSAGE = \"send\\_message\"\n\nADD\\_AGENTS = \"add\\_agents\"\n\nUPDATE\\_QUEUE = \"update\\_queue\"\n\nUPDATE\\_AGENTS = \"update\\_agents\"\n\nRECEIVE\\_MESSAGE = \"receive\\_message\"\n\nERROR = \"error\"\n\nTYPING = \"typing\"\n\nSTOPPED\\_TYPING = \"stopped\\_typing\"\n\nclass ParliamentServer:\n\ndef **init**(self, host=\"localhost\", port=8080):\n\nself.host = host\n\nself.port = port\n\nself.parliament = None\n\nself.start\\_server = serve(self.chat, self.host, self.port)\n\ndef configure\\_openai(self):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nasync def chat(self, websocket, path):\n\nasync for message in websocket:\n\ndata = json.loads(message)\n\naction = data.get(\"action\")\n\nif action == SET\\_PARLIAMENT:\n\nawait self.handle\\_set\\_parliament(websocket, data)\n\nelif action == SEND\\_MESSAGE:\n\nawait self.handle\\_send\\_message(websocket, data)\n\nelif action == ADD\\_AGENTS:\n\nawait self.handle\\_add\\_agents(websocket, data)\n\nelif action in \\[TYPING, STOPPED\\_TYPING\\]:\n\nawait self.handle\\_typing(websocket, data)\n\nasync def handle\\_typing(self, websocket, data):\n\nsender = data.get('sender')\n\naction = data.get('action')\n\nis\\_typing = action == TYPING\n\nself.parliament.set\\_typing\\_status(sender, is\\_typing)\n\n\\# Send the typing status update to other clients:\n\nawait websocket.send(json.dumps({\n\n\"action\": action,\n\n\"sender\": sender,\n\n\"is\\_typing\": is\\_typing\n\n}))\n\nasync def handle\\_set\\_parliament(self, websocket, data):\n\nparliament\\_name = data.get(\"name\")\n\nif parliament\\_name:\n\nself.parliament = Parliament(parliament\\_name)\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_send\\_message(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nsender = data.get(\"sender\")\n\nuser\\_message = data.get(\"message\")\n\ntimestamp = datetime.now()\n\nawait websocket.send(json.dumps({\n\n\"action\": RECEIVE\\_MESSAGE,\n\n\"message\": user\\_message,\n\n\"sender\": sender,\n\n\"timestamp\": timestamp.isoformat()}))\n\nawait self.parliament.broadcast\\_message(user\\_message, sender, timestamp)\n\n#asyncio.create\\_task(self.parliament.broadcast\\_message(user\\_message, sender, timestamp))\n\n\\# Sending agent info after broadcasting message\n\nagent\\_info = self.parliament.get\\_agents\\_info() # Assuming that this method returns agents' information\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_AGENTS, \"agents\": agent\\_info}))\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_add\\_agents(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nagents\\_data = data.get(\"agents\")\n\nif not agents\\_data:\n\nawait self.send\\_error(websocket, \"No agent data provided.\")\n\nreturn\n\nfor agent\\_data in agents\\_data:\n\nagent\\_name = agent\\_data.get(\"name\")\n\nspeaking\\_pressure\\_increment = int(agent\\_data.get(\"speaking\\_pressure\\_increment\"))\n\nother\\_agents = \", \".join(\\[agent\\['name'\\] for agent in agents\\_data if agent\\['name'\\] != agent\\_name\\])\n\ncontext = (\n\nf\"Hello assistant, your name is: @{agent\\_data.get('name')} and your context is \"\n\nf\"{agent\\_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n\nf\"alongside your fellow agents in a parliament, which is a sort \"\n\nf\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n\nf\"with you are {other\\_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n\nf\"{agent\\_data.get('speaking\\_pressure\\_increment')} out of 100\"\n\n)\n\nagent\\_type = agent\\_data.get(\"type\")\n\nagent\\_class = self.parliament.agent\\_types.get(agent\\_type)\n\nif not agent\\_class:\n\nawait self.send\\_error(websocket, f\"Unknown agent type: {agent\\_type}\")\n\n\\# Here, 'continue' is used within a loop, so it's okay\n\ncontinue\n\nagent\\_instance = agent\\_class(context) # Create a new instance of the agent class\n\nself.parliament.add\\_agent(agent\\_name, speaking\\_pressure\\_increment, context, agent\\_type, agent\\_instance, websocket)\n\nawait self.update\\_queue(websocket)\n\nasync def update\\_queue(self, websocket):\n\nif self.parliament:\n\nspeaking\\_queue = self.parliament.get\\_speaking\\_queue()\n\nprint(f\"Queue updated: {speaking\\_queue.to\\_json()}\")\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_QUEUE, \"queue\": speaking\\_queue.to\\_json()}))\n\nasync def send\\_error(self, websocket, message):\n\nawait websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\ndef run(self):\n\nself.configure\\_openai()\n\nasyncio.get\\_event\\_loop().run\\_until\\_complete(self.start\\_server)\n\nprint(\"Starting WebSocket server...\")\n\nprint(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n\nasyncio.get\\_event\\_loop().run\\_forever()\n\nif **name** == \"\\_\\_main\\_\\_\":\n\nserver = ParliamentServer()\n\nserver.run()\n\nCan you update my server.py code to use this new websockets class?",
      "created_at": "2023-05-12T10:08:01.338146Z",
      "sequence_order": 6,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:08:01.338146Z",
            "stop_timestamp": "2023-05-12T10:08:01.338146Z",
            "flags": null,
            "type": "text",
            "text": "now how do I include this new file that I called websockets.py into my server.py code?\n\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\n\nimport openai\n\n\\# Constants\n\nSET\\_PARLIAMENT = \"set\\_parliament\"\n\nSEND\\_MESSAGE = \"send\\_message\"\n\nADD\\_AGENTS = \"add\\_agents\"\n\nUPDATE\\_QUEUE = \"update\\_queue\"\n\nUPDATE\\_AGENTS = \"update\\_agents\"\n\nRECEIVE\\_MESSAGE = \"receive\\_message\"\n\nERROR = \"error\"\n\nTYPING = \"typing\"\n\nSTOPPED\\_TYPING = \"stopped\\_typing\"\n\nclass ParliamentServer:\n\ndef **init**(self, host=\"localhost\", port=8080):\n\nself.host = host\n\nself.port = port\n\nself.parliament = None\n\nself.start\\_server = serve(self.chat, self.host, self.port)\n\ndef configure\\_openai(self):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nasync def chat(self, websocket, path):\n\nasync for message in websocket:\n\ndata = json.loads(message)\n\naction = data.get(\"action\")\n\nif action == SET\\_PARLIAMENT:\n\nawait self.handle\\_set\\_parliament(websocket, data)\n\nelif action == SEND\\_MESSAGE:\n\nawait self.handle\\_send\\_message(websocket, data)\n\nelif action == ADD\\_AGENTS:\n\nawait self.handle\\_add\\_agents(websocket, data)\n\nelif action in \\[TYPING, STOPPED\\_TYPING\\]:\n\nawait self.handle\\_typing(websocket, data)\n\nasync def handle\\_typing(self, websocket, data):\n\nsender = data.get('sender')\n\naction = data.get('action')\n\nis\\_typing = action == TYPING\n\nself.parliament.set\\_typing\\_status(sender, is\\_typing)\n\n\\# Send the typing status update to other clients:\n\nawait websocket.send(json.dumps({\n\n\"action\": action,\n\n\"sender\": sender,\n\n\"is\\_typing\": is\\_typing\n\n}))\n\nasync def handle\\_set\\_parliament(self, websocket, data):\n\nparliament\\_name = data.get(\"name\")\n\nif parliament\\_name:\n\nself.parliament = Parliament(parliament\\_name)\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_send\\_message(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nsender = data.get(\"sender\")\n\nuser\\_message = data.get(\"message\")\n\ntimestamp = datetime.now()\n\nawait websocket.send(json.dumps({\n\n\"action\": RECEIVE\\_MESSAGE,\n\n\"message\": user\\_message,\n\n\"sender\": sender,\n\n\"timestamp\": timestamp.isoformat()}))\n\nawait self.parliament.broadcast\\_message(user\\_message, sender, timestamp)\n\n#asyncio.create\\_task(self.parliament.broadcast\\_message(user\\_message, sender, timestamp))\n\n\\# Sending agent info after broadcasting message\n\nagent\\_info = self.parliament.get\\_agents\\_info() # Assuming that this method returns agents' information\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_AGENTS, \"agents\": agent\\_info}))\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_add\\_agents(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nagents\\_data = data.get(\"agents\")\n\nif not agents\\_data:\n\nawait self.send\\_error(websocket, \"No agent data provided.\")\n\nreturn\n\nfor agent\\_data in agents\\_data:\n\nagent\\_name = agent\\_data.get(\"name\")\n\nspeaking\\_pressure\\_increment = int(agent\\_data.get(\"speaking\\_pressure\\_increment\"))\n\nother\\_agents = \", \".join(\\[agent\\['name'\\] for agent in agents\\_data if agent\\['name'\\] != agent\\_name\\])\n\ncontext = (\n\nf\"Hello assistant, your name is: @{agent\\_data.get('name')} and your context is \"\n\nf\"{agent\\_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n\nf\"alongside your fellow agents in a parliament, which is a sort \"\n\nf\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n\nf\"with you are {other\\_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n\nf\"{agent\\_data.get('speaking\\_pressure\\_increment')} out of 100\"\n\n)\n\nagent\\_type = agent\\_data.get(\"type\")\n\nagent\\_class = self.parliament.agent\\_types.get(agent\\_type)\n\nif not agent\\_class:\n\nawait self.send\\_error(websocket, f\"Unknown agent type: {agent\\_type}\")\n\n\\# Here, 'continue' is used within a loop, so it's okay\n\ncontinue\n\nagent\\_instance = agent\\_class(context) # Create a new instance of the agent class\n\nself.parliament.add\\_agent(agent\\_name, speaking\\_pressure\\_increment, context, agent\\_type, agent\\_instance, websocket)\n\nawait self.update\\_queue(websocket)\n\nasync def update\\_queue(self, websocket):\n\nif self.parliament:\n\nspeaking\\_queue = self.parliament.get\\_speaking\\_queue()\n\nprint(f\"Queue updated: {speaking\\_queue.to\\_json()}\")\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_QUEUE, \"queue\": speaking\\_queue.to\\_json()}))\n\nasync def send\\_error(self, websocket, message):\n\nawait websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\ndef run(self):\n\nself.configure\\_openai()\n\nasyncio.get\\_event\\_loop().run\\_until\\_complete(self.start\\_server)\n\nprint(\"Starting WebSocket server...\")\n\nprint(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n\nasyncio.get\\_event\\_loop().run\\_forever()\n\nif **name** == \"\\_\\_main\\_\\_\":\n\nserver = ParliamentServer()\n\nserver.run()\n\nCan you update my server.py code to use this new websockets class?",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:08:01.338146Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "d0a97394-1c92-43cb-9ce5-b6fbbd86dc05",
      "role": "assistant",
      "content": " Here's how you can update server.py to use the WebSocketManager class:\n\n```python\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent  \n\nimport openai\n\nfrom websockets import WebSocketManager  # Import the WebSocketManager class\n\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.web_socket_manager = None  # Add this\n        \n        ...\n        \n    def configure_openai(self):\n        ...\n        \n    async def chat(self, websocket, path):\n        # Instead of handling websocket messages directly, delegate to WebSocketManager\n        await self.web_socket_manager.handle_connection(websocket, path)\n        \n    def run(self):\n        ...\n        # Instantiate WebSocketManager and pass the parliament\n        self.web_socket_manager = WebSocketManager(self.parliament)  \n        \n        ...\n\n# Remove the following methods since the logic is handled by WebSocketManager now:\n# - async def handle_send_message()  \n# - async def handle_typing()\n# - async def handle_set_parliament()  \n# - async def handle_add_agents()\n# - async def update_queue()\n# - async def send_error() \n        \nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()  \n```\n\nThe main changes are:\n\n1. Import the WebSocketManager class\n2. Add an attribute self.web_socket_manager to store the WebSocketManager instance\n3. In the chat() method, call await self.web_socket_manager.handle_connection(websocket, path) to delegate websocket handling \n4. Instantiate WebSocketManager and pass the parliament\n5. Remove the methods that were handling websocket actions previously\n\nThis follows the single responsibility principle by extracting the websocket handling logic into the separate WebSocketManager class. Let me know if you have any other questions!",
      "created_at": "2023-05-12T10:08:37.902389Z",
      "sequence_order": 7,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-12T10:08:37.902389Z",
            "stop_timestamp": "2023-05-12T10:08:37.902389Z",
            "flags": null,
            "type": "text",
            "text": " Here's how you can update server.py to use the WebSocketManager class:\n\n```python\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent  \n\nimport openai\n\nfrom websockets import WebSocketManager  # Import the WebSocketManager class\n\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.web_socket_manager = None  # Add this\n        \n        ...\n        \n    def configure_openai(self):\n        ...\n        \n    async def chat(self, websocket, path):\n        # Instead of handling websocket messages directly, delegate to WebSocketManager\n        await self.web_socket_manager.handle_connection(websocket, path)\n        \n    def run(self):\n        ...\n        # Instantiate WebSocketManager and pass the parliament\n        self.web_socket_manager = WebSocketManager(self.parliament)  \n        \n        ...\n\n# Remove the following methods since the logic is handled by WebSocketManager now:\n# - async def handle_send_message()  \n# - async def handle_typing()\n# - async def handle_set_parliament()  \n# - async def handle_add_agents()\n# - async def update_queue()\n# - async def send_error() \n        \nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()  \n```\n\nThe main changes are:\n\n1. Import the WebSocketManager class\n2. Add an attribute self.web_socket_manager to store the WebSocketManager instance\n3. In the chat() method, call await self.web_socket_manager.handle_connection(websocket, path) to delegate websocket handling \n4. Instantiate WebSocketManager and pass the parliament\n5. Remove the methods that were handling websocket actions previously\n\nThis follows the single responsibility principle by extracting the websocket handling logic into the separate WebSocketManager class. Let me know if you have any other questions!",
            "citations": []
          }
        ],
        "updated_at": "2023-05-12T10:08:37.902389Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}