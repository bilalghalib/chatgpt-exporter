{
  "id": "904d6700-cfe8-46af-91b6-eb367e466e3a",
  "source": "claude",
  "title": "Knowledge Graph Visualization System",
  "created_at": "2025-06-13T21:44:55.355529Z",
  "updated_at": "2025-06-13T21:50:10.737425Z",
  "summary": "",
  "message_count": 2,
  "messages": [
    {
      "id": "45a7c059-5e7b-47c4-b640-eba46992f324",
      "role": "human",
      "content": "Can you help me actually run the fuseki knowledge graph ontology extractor with our code and to make a great visualizer of concepts in space, it's a bit messy now and i need to clean up my codebase - i want it to be able to also create artifacts like google slides with nested mermaid digrams processed and turned into actual pngs inside of it - can you return any files needed in full and tell me how to clean and organize my code, it doesn't need to be backward compatible",
      "created_at": "2025-06-13T21:44:58.149054Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-06-13T21:44:58.145611Z",
            "stop_timestamp": "2025-06-13T21:44:58.145611Z",
            "flags": null,
            "type": "text",
            "text": "Can you help me actually run the fuseki knowledge graph ontology extractor with our code and to make a great visualizer of concepts in space, it's a bit messy now and i need to clean up my codebase - i want it to be able to also create artifacts like google slides with nested mermaid digrams processed and turned into actual pngs inside of it - can you return any files needed in full and tell me how to clean and organize my code, it doesn't need to be backward compatible",
            "citations": []
          }
        ],
        "updated_at": "2025-06-13T21:44:58.149054Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "b8ba85d7-4d0b-463c-b1e2-4c172f62b1da",
      "role": "assistant",
      "content": "The user has a Knowledge Garden v3 project that:\n1. Extracts concepts from documents using NLP/ML\n2. Stores them in a Fuseki triplestore (SPARQL database)\n3. Generates artifacts like presentations with nested diagrams\n4. Has a web interface for visualization\n\nThey want help with:\n1. Running the Fuseki knowledge graph ontology extractor\n2. Creating a better visualizer of concepts in 3D space\n3. Cleaning up the codebase\n4. Making Google Slides with nested Mermaid diagrams converted to PNGs\n\nLooking at their code, I can see several issues:\n1. The codebase has duplicated files and services\n2. Import paths are inconsistent\n3. Services are scattered across different locations\n4. The visualization is basic and could be improved\n5. Google Slides integration exists but needs proper diagram rendering\n\nI'll provide:\n1. A clean project structure\n2. Instructions for running Fuseki\n3. An improved 3D visualizer\n4. Proper Google Slides generation with rendered diagrams\n5. A cleanup script to reorganize everythingLooking at your Knowledge Garden codebase, I can see it needs significant cleanup and better organization. Let me help you restructure it properly and create a great 3D visualizer with working Google Slides generation.\n\n## Project Cleanup and Reorganization\n\nFirst, let's create a cleanup script to reorganize your codebase:\n\n```bash\n#!/bin/bash\n# cleanup_knowledge_garden.sh\n\necho \"ðŸ§¹ Cleaning up Knowledge Garden v3...\"\n\n# 1. Remove all duplicate and obsolete files\nfind . -name \"*.pyc\" -delete\nfind . -name \"__pycache__\" -type d -exec rm -rf {} +\nfind . -name \".pytest_cache\" -type d -exec rm -rf {} +\n\n# 2. Remove duplicate service implementations\nrm -rf services/artifacts/services/\nrm -rf services/artifacts/artifact_core_backup/\nrm -rf services/artifacts/models/base.py  # Use core/models instead\n\n# 3. Create proper directory structure\nmkdir -p {data/{artifacts/{diagram,summary,presentation,report,image},embeddings,fuseki},logs,static/js,templates/components}\n\necho \"âœ… Cleanup complete!\"\n```\n\n## 1. Docker Compose for Fuseki\n\nCreate `docker-compose.yml`:\n\n```yaml\nversion: '3.8'\n\nservices:\n  fuseki:\n    image: stain/jena-fuseki:latest\n    container_name: kg_fuseki\n    ports:\n      - \"3030:3030\"\n    environment:\n      - ADMIN_PASSWORD=admin\n      - FUSEKI_DATASET_1=kg\n    volumes:\n      - ./data/fuseki:/fuseki\n      - ./core/ontology:/fuseki/ontology\n    command: /jena-fuseki/fuseki-server --update --loc=/fuseki/databases/kg /kg\n\n  extraction:\n    build: ./services/extraction\n    ports:\n      - \"8001:8001\"\n    environment:\n      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}\n      - FUSEKI_URL=http://fuseki:3030\n    depends_on:\n      - fuseki\n\n  artifacts:\n    build: ./services/artifacts\n    ports:\n      - \"8002:8002\"\n    environment:\n      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}\n      - FUSEKI_URL=http://fuseki:3030\n      - EXTRACTION_SERVICE_URL=http://extraction:8001\n    volumes:\n      - ./data/artifacts:/app/data/artifacts\n      - ./static:/app/static\n    depends_on:\n      - extraction\n      - fuseki\n\n  webapp:\n    build: .\n    ports:\n      - \"5050:5050\"\n    environment:\n      - FUSEKI_URL=http://fuseki:3030\n      - EXTRACTION_SERVICE_URL=http://extraction:8001\n      - ARTIFACTS_SERVICE_URL=http://artifacts:8002\n    volumes:\n      - ./uploads:/app/uploads\n      - ./static:/app/static\n      - ./data:/app/data\n    depends_on:\n      - fuseki\n      - extraction\n      - artifacts\n\nnetworks:\n  default:\n    name: knowledge-garden\n```\n\n## 2. Improved 3D Concept Visualizer\n\nCreate `static/js/concept-visualizer.js`:\n\n```javascript\n// Advanced 3D Concept Visualizer using Three.js\nclass ConceptVisualizer {\n    constructor(containerId) {\n        this.container = document.getElementById(containerId);\n        this.concepts = [];\n        this.connections = [];\n        this.selectedConcept = null;\n        \n        this.init();\n    }\n    \n    init() {\n        // Scene setup\n        this.scene = new THREE.Scene();\n        this.scene.background = new THREE.Color(0x0a0a0a);\n        \n        // Camera\n        this.camera = new THREE.PerspectiveCamera(\n            75, \n            this.container.clientWidth / this.container.clientHeight, \n            0.1, \n            1000\n        );\n        this.camera.position.set(0, 0, 50);\n        \n        // Renderer\n        this.renderer = new THREE.WebGLRenderer({ antialias: true });\n        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n        this.container.appendChild(this.renderer.domElement);\n        \n        // Controls\n        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\n        this.controls.enableDamping = true;\n        this.controls.dampingFactor = 0.05;\n        \n        // Lights\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        this.scene.add(ambientLight);\n        \n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\n        directionalLight.position.set(10, 10, 10);\n        this.scene.add(directionalLight);\n        \n        // Raycaster for mouse interaction\n        this.raycaster = new THREE.Raycaster();\n        this.mouse = new THREE.Vector2();\n        \n        // Concept type materials\n        this.materials = {\n            entity: new THREE.MeshPhongMaterial({ color: 0x9C27B0, emissive: 0x4A148C }),\n            cap: new THREE.MeshPhongMaterial({ color: 0x4CAF50, emissive: 0x1B5E20 }),\n            insight: new THREE.MeshPhongMaterial({ color: 0x2196F3, emissive: 0x0D47A1 }),\n            tension: new THREE.MeshPhongMaterial({ color: 0xFF5722, emissive: 0xBF360C }),\n            question: new THREE.MeshPhongMaterial({ color: 0xFFC107, emissive: 0xF57C00 }),\n            value: new THREE.MeshPhongMaterial({ color: 0x00BCD4, emissive: 0x006064 })\n        };\n        \n        // Event listeners\n        this.container.addEventListener('mousemove', this.onMouseMove.bind(this), false);\n        this.container.addEventListener('click', this.onClick.bind(this), false);\n        window.addEventListener('resize', this.onWindowResize.bind(this), false);\n        \n        // Start animation loop\n        this.animate();\n    }\n    \n    loadConcepts(concepts) {\n        // Clear existing concepts\n        this.clearScene();\n        \n        // Create concept meshes\n        concepts.forEach((concept, index) => {\n            const geometry = this.getGeometryForType(concept.type);\n            const material = this.materials[concept.type] || this.materials.entity;\n            const mesh = new THREE.Mesh(geometry, material);\n            \n            // Position based on embedding\n            if (concept.embedding && concept.embedding.length >= 3) {\n                mesh.position.set(\n                    concept.embedding[0] * 20,\n                    concept.embedding[1] * 20,\n                    concept.embedding[2] * 20\n                );\n            } else {\n                // Fallback positioning\n                const angle = (index / concepts.length) * Math.PI * 2;\n                const radius = 20;\n                mesh.position.set(\n                    Math.cos(angle) * radius,\n                    Math.sin(angle) * radius,\n                    (Math.random() - 0.5) * 10\n                );\n            }\n            \n            // Store concept data\n            mesh.userData = concept;\n            this.concepts.push(mesh);\n            this.scene.add(mesh);\n            \n            // Add label\n            this.addLabel(mesh, concept.text);\n        });\n        \n        // Create connections between related concepts\n        this.createConnections();\n    }\n    \n    getGeometryForType(type) {\n        switch(type) {\n            case 'entity':\n                return new THREE.SphereGeometry(1, 32, 32);\n            case 'cap':\n                return new THREE.BoxGeometry(1.5, 1.5, 1.5);\n            case 'insight':\n                return new THREE.ConeGeometry(1, 2, 8);\n            case 'tension':\n                return new THREE.OctahedronGeometry(1.2);\n            case 'question':\n                return new THREE.TorusGeometry(0.8, 0.3, 8, 16);\n            case 'value':\n                return new THREE.DodecahedronGeometry(1);\n            default:\n                return new THREE.SphereGeometry(1, 16, 16);\n        }\n    }\n    \n    addLabel(mesh, text) {\n        // Create sprite label\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        canvas.width = 256;\n        canvas.height = 64;\n        \n        context.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        context.font = '16px Arial';\n        context.textAlign = 'center';\n        \n        // Truncate text if too long\n        const maxLength = 20;\n        const displayText = text.length > maxLength ? \n            text.substring(0, maxLength) + '...' : text;\n        \n        context.fillText(displayText, 128, 32);\n        \n        const texture = new THREE.CanvasTexture(canvas);\n        const spriteMaterial = new THREE.SpriteMaterial({ \n            map: texture, \n            transparent: true \n        });\n        const sprite = new THREE.Sprite(spriteMaterial);\n        sprite.scale.set(8, 2, 1);\n        sprite.position.y = 2;\n        \n        mesh.add(sprite);\n    }\n    \n    createConnections() {\n        // Clear existing connections\n        this.connections.forEach(line => this.scene.remove(line));\n        this.connections = [];\n        \n        // Create connections based on similarity or clustering\n        for (let i = 0; i < this.concepts.length; i++) {\n            for (let j = i + 1; j < this.concepts.length; j++) {\n                const concept1 = this.concepts[i];\n                const concept2 = this.concepts[j];\n                \n                // Connect if same cluster or high similarity\n                if (concept1.userData.cluster === concept2.userData.cluster) {\n                    const geometry = new THREE.BufferGeometry().setFromPoints([\n                        concept1.position,\n                        concept2.position\n                    ]);\n                    \n                    const material = new THREE.LineBasicMaterial({ \n                        color: 0x444444,\n                        opacity: 0.3,\n                        transparent: true\n                    });\n                    \n                    const line = new THREE.Line(geometry, material);\n                    this.connections.push(line);\n                    this.scene.add(line);\n                }\n            }\n        }\n    }\n    \n    onMouseMove(event) {\n        const rect = this.container.getBoundingClientRect();\n        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n        \n        // Update raycaster\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Check for intersections\n        const intersects = this.raycaster.intersectObjects(this.concepts);\n        \n        // Reset all materials\n        this.concepts.forEach(concept => {\n            const type = concept.userData.type;\n            concept.material = this.materials[type];\n        });\n        \n        // Highlight hovered concept\n        if (intersects.length > 0) {\n            const hoveredConcept = intersects[0].object;\n            hoveredConcept.material = hoveredConcept.material.clone();\n            hoveredConcept.material.emissive = new THREE.Color(0xffffff);\n            hoveredConcept.material.emissiveIntensity = 0.3;\n            \n            this.container.style.cursor = 'pointer';\n        } else {\n            this.container.style.cursor = 'default';\n        }\n    }\n    \n    onClick(event) {\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        const intersects = this.raycaster.intersectObjects(this.concepts);\n        \n        if (intersects.length > 0) {\n            const clickedConcept = intersects[0].object;\n            this.selectConcept(clickedConcept.userData);\n            \n            // Emit custom event\n            this.container.dispatchEvent(new CustomEvent('conceptSelected', {\n                detail: clickedConcept.userData\n            }));\n        }\n    }\n    \n    selectConcept(concept) {\n        this.selectedConcept = concept;\n        \n        // Highlight selected concept and dim others\n        this.concepts.forEach(mesh => {\n            if (mesh.userData.id === concept.id) {\n                mesh.material = mesh.material.clone();\n                mesh.material.emissive = new THREE.Color(0xffffff);\n                mesh.material.emissiveIntensity = 0.5;\n            } else {\n                mesh.material = mesh.material.clone();\n                mesh.material.opacity = 0.3;\n                mesh.material.transparent = true;\n            }\n        });\n    }\n    \n    clearScene() {\n        this.concepts.forEach(mesh => {\n            this.scene.remove(mesh);\n        });\n        this.connections.forEach(line => {\n            this.scene.remove(line);\n        });\n        this.concepts = [];\n        this.connections = [];\n    }\n    \n    onWindowResize() {\n        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n    }\n    \n    animate() {\n        requestAnimationFrame(this.animate.bind(this));\n        \n        // Auto-rotate when not interacting\n        if (!this.controls.enabled) {\n            this.scene.rotation.y += 0.001;\n        }\n        \n        this.controls.update();\n        this.renderer.render(this.scene, this.camera);\n    }\n    \n    // Filtering methods\n    filterByType(type) {\n        this.concepts.forEach(mesh => {\n            mesh.visible = type === 'all' || mesh.userData.type === type;\n        });\n        this.updateConnections();\n    }\n    \n    filterByCluster(clusterId) {\n        this.concepts.forEach(mesh => {\n            mesh.visible = clusterId === 'all' || mesh.userData.cluster === clusterId;\n        });\n        this.updateConnections();\n    }\n    \n    updateConnections() {\n        this.connections.forEach(line => {\n            // Hide connections if either concept is hidden\n            const positions = line.geometry.attributes.position.array;\n            let visible = true;\n            \n            this.concepts.forEach(mesh => {\n                const meshPos = mesh.position;\n                if (!mesh.visible && \n                    (Math.abs(positions[0] - meshPos.x) < 0.01 ||\n                     Math.abs(positions[3] - meshPos.x) < 0.01)) {\n                    visible = false;\n                }\n            });\n            \n            line.visible = visible;\n        });\n    }\n}\n```\n\n## 3. Enhanced Google Slides Generator with Mermaid Diagrams\n\nCreate `services/artifacts/core/generators/implementations/google_slides_enhanced.py`:\n\n```python\n\"\"\"Enhanced Google Slides generator with proper Mermaid diagram rendering.\"\"\"\nimport logging\nimport asyncio\nimport base64\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\nimport httpx\nimport tempfile\n\nfrom ....models import ArtifactType\nfrom ..base_generator import BaseGenerator, ArtifactRequest, ArtifactResult\nfrom ....exceptions import GenerationFailure, ArtifactError\n\nlogger = logging.getLogger(__name__)\n\nclass EnhancedGoogleSlidesGenerator(BaseGenerator):\n    \"\"\"Generate Google Slides presentations with rendered diagrams.\"\"\"\n    \n    @property\n    def artifact_type(self) -> ArtifactType:\n        return ArtifactType.PRESENTATION\n    \n    async def generate(\n        self, \n        request: ArtifactRequest, \n        artifact_id: Optional[str] = None\n    ) -> Union[ArtifactResult, GenerationFailure]:\n        \"\"\"Generate a Google Slides presentation with nested diagrams.\"\"\"\n        try:\n            # Validate request\n            validation_error = self.validate_request(request)\n            if validation_error:\n                return GenerationFailure(validation_error)\n            \n            # Generate artifact ID\n            artifact_id = self.create_artifact_id(artifact_id)\n            \n            # Get options\n            access_token = request.options.get(\"google_access_token\")\n            if not access_token:\n                return GenerationFailure(\n                    ArtifactError(\"Google access token required for Slides generation\")\n                )\n            \n            title = request.options.get(\"title\", \"Knowledge Garden Presentation\")\n            include_diagrams = request.options.get(\"include_diagrams\", True)\n            \n            # Generate presentation structure\n            presentation_data = await self._generate_presentation_structure(\n                request.content, title\n            )\n            \n            # Process nested diagrams if requested\n            if include_diagrams and request.nested_requests:\n                presentation_data = await self._process_nested_diagrams(\n                    presentation_data, request.nested_requests\n                )\n            \n            # Create Google Slides presentation\n            result = await self._create_google_slides(\n                presentation_data, access_token\n            )\n            \n            if result[\"success\"]:\n                return ArtifactResult(\n                    artifact_id=artifact_id,\n                    artifact_type=self.artifact_type,\n                    title=title,\n                    content=presentation_data,\n                    format=\"google_slides\",\n                    url=result[\"url\"],\n                    metadata={\n                        \"google_slides_id\": result[\"presentation_id\"],\n                        \"slide_count\": result[\"slide_count\"],\n                        \"diagrams_rendered\": len(result.get(\"diagrams\", []))\n                    }\n                )\n            else:\n                return GenerationFailure(\n                    ArtifactError(f\"Failed to create presentation: {result['error']}\")\n                )\n                \n        except Exception as e:\n            logger.error(f\"Error generating Google Slides: {e}\")\n            return GenerationFailure(\n                ArtifactError(f\"Failed to generate presentation: {e}\")\n            )\n    \n    async def _generate_presentation_structure(\n        self, content: str, title: str\n    ) -> Dict[str, Any]:\n        \"\"\"Generate presentation structure from content.\"\"\"\n        from shared.services.llm.service import LLMService\n        llm = LLMService()\n        \n        prompt = f\"\"\"\n        Create a presentation structure for \"{title}\" based on this content:\n        {content}\n        \n        Return a JSON structure with slides that include placeholders for diagrams.\n        Mark diagram placeholders as {{DIAGRAM_N}} where N is the diagram number.\n        \n        Example:\n        {{\n            \"title\": \"...\",\n            \"slides\": [\n                {{\n                    \"title\": \"Architecture Overview\",\n                    \"content\": \"Our system consists of three main components:\\\\n{{DIAGRAM_1}}\",\n                    \"layout\": \"TITLE_AND_BODY\",\n                    \"notes\": \"Explain the architecture diagram\",\n                    \"diagram_request\": {{\n                        \"type\": \"flowchart\",\n                        \"content\": \"User -> API Gateway -> Services -> Database\"\n                    }}\n                }}\n            ]\n        }}\n        \"\"\"\n        \n        response = await llm.generate(prompt)\n        \n        # Parse response\n        import json\n        try:\n            return json.loads(response)\n        except:\n            # Fallback structure\n            return {\n                \"title\": title,\n                \"slides\": [\n                    {\n                        \"title\": \"Title Slide\",\n                        \"content\": title,\n                        \"layout\": \"TITLE\"\n                    },\n                    {\n                        \"title\": \"Overview\",\n                        \"content\": \"{{DIAGRAM_1}}\",\n                        \"layout\": \"TITLE_AND_BODY\",\n                        \"diagram_request\": {\n                            \"type\": \"mindmap\",\n                            \"content\": content[:200]\n                        }\n                    }\n                ]\n            }\n    \n    async def _process_nested_diagrams(\n        self,\n        presentation_data: Dict[str, Any],\n        nested_requests: List[Dict[str, Any]]\n    ) -> Dict[str, Any]:\n        \"\"\"Process and render nested Mermaid diagrams.\"\"\"\n        diagrams = []\n        \n        # Extract diagram requests from slides\n        for i, slide in enumerate(presentation_data[\"slides\"]):\n            if \"diagram_request\" in slide:\n                diagram_req = slide[\"diagram_request\"]\n                \n                # Generate Mermaid code\n                mermaid_code = await self._generate_mermaid_code(\n                    diagram_req[\"content\"],\n                    diagram_req.get(\"type\", \"flowchart\")\n                )\n                \n                # Render diagram to PNG\n                png_path = await self._render_mermaid_to_png(\n                    mermaid_code, f\"diagram_{i+1}\"\n                )\n                \n                # Upload to temporary hosting\n                image_url = await self._upload_image(png_path)\n                \n                diagrams.append({\n                    \"slide_index\": i,\n                    \"placeholder\": f\"{{DIAGRAM_{i+1}}}\",\n                    \"image_url\": image_url,\n                    \"mermaid_code\": mermaid_code\n                })\n        \n        presentation_data[\"diagrams\"] = diagrams\n        return presentation_data\n    \n    async def _generate_mermaid_code(\n        self, content: str, diagram_type: str\n    ) -> str:\n        \"\"\"Generate Mermaid diagram code from content.\"\"\"\n        from shared.services.llm.service import LLMService\n        llm = LLMService()\n        \n        prompt = f\"\"\"\n        Generate a Mermaid {diagram_type} diagram for:\n        {content}\n        \n        Return ONLY the Mermaid code, no explanations.\n        \"\"\"\n        \n        response = await llm.generate(prompt)\n        \n        # Clean response\n        if \"```\" in response:\n            response = response.split(\"```\")[1]\n            if response.startswith(\"mermaid\"):\n                response = response[7:]\n        \n        return response.strip()\n    \n    async def _render_mermaid_to_png(\n        self, mermaid_code: str, filename: str\n    ) -> Path:\n        \"\"\"Render Mermaid diagram to PNG using mermaid.ink API.\"\"\"\n        # Encode diagram\n        encoded = base64.urlsafe_b64encode(\n            mermaid_code.encode()\n        ).decode().rstrip(\"=\")\n        \n        # Use mermaid.ink API\n        url = f\"https://mermaid.ink/img/{encoded}?type=png&theme=dark\"\n        \n        # Download PNG\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            \n            if response.status_code == 200:\n                # Save to temp file\n                temp_dir = Path(tempfile.gettempdir()) / \"kg_diagrams\"\n                temp_dir.mkdir(exist_ok=True)\n                \n                png_path = temp_dir / f\"{filename}.png\"\n                png_path.write_bytes(response.content)\n                \n                return png_path\n            else:\n                raise Exception(f\"Failed to render diagram: {response.status_code}\")\n    \n    async def _upload_image(self, image_path: Path) -> str:\n        \"\"\"Upload image to temporary hosting (e.g., imgur).\"\"\"\n        # For production, use a proper image hosting service\n        # For now, return a data URL\n        import base64\n        \n        with open(image_path, \"rb\") as f:\n            image_data = f.read()\n        \n        base64_data = base64.b64encode(image_data).decode()\n        return f\"data:image/png;base64,{base64_data}\"\n    \n    async def _create_google_slides(\n        self,\n        presentation_data: Dict[str, Any],\n        access_token: str\n    ) -> Dict[str, Any]:\n        \"\"\"Create the actual Google Slides presentation.\"\"\"\n        try:\n            # Create presentation\n            slides_api = \"https://slides.googleapis.com/v1/presentations\"\n            headers = {\n                \"Authorization\": f\"Bearer {access_token}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            # Create empty presentation\n            create_response = await self._api_request(\n                \"POST\", slides_api, headers, \n                json={\"title\": presentation_data[\"title\"]}\n            )\n            \n            presentation_id = create_response[\"presentationId\"]\n            \n            # Add slides with content\n            requests = []\n            \n            for i, slide in enumerate(presentation_data[\"slides\"]):\n                slide_id = f\"slide_{i}\"\n                \n                # Create slide\n                requests.append({\n                    \"createSlide\": {\n                        \"objectId\": slide_id,\n                        \"slideLayoutReference\": {\n                            \"predefinedLayout\": slide.get(\"layout\", \"TITLE_AND_BODY\")\n                        }\n                    }\n                })\n            \n            # Execute batch update\n            if requests:\n                await self._batch_update(presentation_id, requests, headers)\n            \n            # Add content and images\n            await self._add_slide_content(\n                presentation_id, \n                presentation_data, \n                headers\n            )\n            \n            return {\n                \"success\": True,\n                \"presentation_id\": presentation_id,\n                \"url\": f\"https://docs.google.com/presentation/d/{presentation_id}/edit\",\n                \"slide_count\": len(presentation_data[\"slides\"]),\n                \"diagrams\": presentation_data.get(\"diagrams\", [])\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error creating Google Slides: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def _add_slide_content(\n        self,\n        presentation_id: str,\n        presentation_data: Dict[str, Any],\n        headers: Dict[str, str]\n    ):\n        \"\"\"Add content and images to slides.\"\"\"\n        # Get presentation structure\n        presentation = await self._api_request(\n            \"GET\",\n            f\"https://slides.googleapis.com/v1/presentations/{presentation_id}\",\n            headers\n        )\n        \n        requests = []\n        diagrams_by_slide = {}\n        \n        # Index diagrams by slide\n        for diagram in presentation_data.get(\"diagrams\", []):\n            diagrams_by_slide[diagram[\"slide_index\"]] = diagram\n        \n        # Add content to each slide\n        for i, slide_data in enumerate(presentation_data[\"slides\"]):\n            slide = presentation[\"slides\"][i+1]  # Skip title slide\n            \n            # Find text placeholders\n            for element in slide.get(\"pageElements\", []):\n                shape = element.get(\"shape\", {})\n                if shape.get(\"placeholder\"):\n                    placeholder_type = shape[\"placeholder\"][\"type\"]\n                    object_id = element[\"objectId\"]\n                    \n                    if placeholder_type == \"TITLE\" and slide_data.get(\"title\"):\n                        requests.append({\n                            \"insertText\": {\n                                \"objectId\": object_id,\n                                \"text\": slide_data[\"title\"]\n                            }\n                        })\n                    \n                    elif placeholder_type in [\"BODY\", \"CONTENT\"]:\n                        content = slide_data.get(\"content\", \"\")\n                        \n                        # Replace diagram placeholders\n                        if i in diagrams_by_slide:\n                            diagram = diagrams_by_slide[i]\n                            # Add image instead of placeholder\n                            requests.append({\n                                \"createImage\": {\n                                    \"url\": diagram[\"image_url\"],\n                                    \"elementProperties\": {\n                                        \"pageObjectId\": slide[\"objectId\"],\n                                        \"size\": {\n                                            \"width\": {\"magnitude\": 400, \"unit\": \"PT\"},\n                                            \"height\": {\"magnitude\": 300, \"unit\": \"PT\"}\n                                        },\n                                        \"transform\": {\n                                            \"scaleX\": 1,\n                                            \"scaleY\": 1,\n                                            \"translateX\": 150,\n                                            \"translateY\": 150,\n                                            \"unit\": \"PT\"\n                                        }\n                                    }\n                                }\n                            })\n                            \n                            # Remove placeholder from content\n                            content = content.replace(diagram[\"placeholder\"], \"\")\n                        \n                        if content.strip():\n                            requests.append({\n                                \"insertText\": {\n                                    \"objectId\": object_id,\n                                    \"text\": content\n                                }\n                            })\n        \n        # Execute all updates\n        if requests:\n            await self._batch_update(presentation_id, requests, headers)\n    \n    async def _api_request(\n        self, method: str, url: str, headers: Dict, **kwargs\n    ) -> Dict[str, Any]:\n        \"\"\"Make API request with error handling.\"\"\"\n        async with httpx.AsyncClient() as client:\n            response = await client.request(\n                method, url, headers=headers, **kwargs\n            )\n            response.raise_for_status()\n            return response.json()\n    \n    async def _batch_update(\n        self, presentation_id: str, requests: List[Dict], headers: Dict\n    ):\n        \"\"\"Execute batch update on presentation.\"\"\"\n        url = f\"https://slides.googleapis.com/v1/presentations/{presentation_id}:batchUpdate\"\n        body = {\"requests\": requests}\n        \n        await self._api_request(\"POST\", url, headers, json=body)\n```\n\n## 4. Improved Web Application\n\nCreate an updated `knowledge_garden_web_enhanced.py`:\n\n```python\n\"\"\"Enhanced Knowledge Garden Web Interface with 3D visualization.\"\"\"\nimport os\nimport uuid\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom flask import Flask, request, render_template, redirect, url_for, jsonify, send_from_directory\nimport aiohttp\nimport asyncio\nfrom typing import Dict, Any, List\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = 'uploads'\napp.config['OUTPUT_FOLDER'] = 'output'\napp.config['STATIC_FOLDER'] = 'static'\n\n# Service URLs from environment\nFUSEKI_URL = os.getenv('FUSEKI_URL', 'http://localhost:3030')\nEXTRACTION_SERVICE_URL = os.getenv('EXTRACTION_SERVICE_URL', 'http://localhost:8001')\nARTIFACTS_SERVICE_URL = os.getenv('ARTIFACTS_SERVICE_URL', 'http://localhost:8002')\n\n# Create required directories\nfor folder in [app.config['UPLOAD_FOLDER'], app.config['OUTPUT_FOLDER'], app.config['STATIC_FOLDER']]:\n    os.makedirs(folder, exist_ok=True)\n\n@app.route('/')\ndef index():\n    \"\"\"Render the enhanced main page.\"\"\"\n    return render_template('index_enhanced.html')\n\n@app.route('/visualize')\ndef visualize():\n    \"\"\"Render the 3D visualization page.\"\"\"\n    return render_template('visualize_3d.html')\n\n@app.route('/api/concepts')\nasync def get_concepts():\n    \"\"\"Get concepts from Fuseki knowledge graph.\"\"\"\n    graph_id = request.args.get('graph_id', 'main')\n    \n    # Query Fuseki for concepts\n    query = \"\"\"\n    PREFIX kg: <urn:knowledgegarden:ontology#>\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n    \n    SELECT ?concept ?type ?label ?embedding ?cluster ?confidence\n    WHERE {\n        ?concept rdf:type ?type ;\n                 rdfs:label ?label .\n        OPTIONAL { ?concept kg:embedding ?embedding }\n        OPTIONAL { ?concept kg:cluster ?cluster }\n        OPTIONAL { ?concept kg:confidence ?confidence }\n        FILTER(?type IN (kg:CAP, kg:Insight, kg:Tension, kg:Question, kg:Concept))\n    }\n    LIMIT 1000\n    \"\"\"\n    \n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"{FUSEKI_URL}/kg/sparql\",\n                data={'query': query},\n                headers={'Accept': 'application/sparql-results+json'}\n            ) as response:\n                if response.status == 200:\n                    results = await response.json()\n                    concepts = _process_sparql_results(results)\n                    return jsonify(concepts)\n    except Exception as e:\n        app.logger.error(f\"Error querying Fuseki: {e}\")\n    \n    # Return empty array on error\n    return jsonify([])\n\n@app.route('/api/generate_presentation', methods=['POST'])\nasync def generate_presentation():\n    \"\"\"Generate a Google Slides presentation with diagrams.\"\"\"\n    data = request.get_json()\n    \n    # Prepare nested diagram requests\n    nested_requests = []\n    if data.get('include_diagrams', True):\n        # Get concepts for the document\n        concepts = await _get_document_concepts(data['document_id'])\n        \n        # Create diagram requests based on concepts\n        nested_requests = [\n            {\n                \"content\": _create_mindmap_content(concepts),\n                \"artifact_type\": \"diagram\",\n                \"options\": {\"diagram_type\": \"mindmap\"}\n            },\n            {\n                \"content\": _create_flowchart_content(concepts),\n                \"artifact_type\": \"diagram\", \n                \"options\": {\"diagram_type\": \"flowchart\"}\n            }\n        ]\n    \n    # Call artifacts service\n    artifact_request = {\n        \"content\": data.get('content', ''),\n        \"artifact_type\": \"presentation\",\n        \"options\": {\n            \"output_format\": \"google_slides\",\n            \"google_access_token\": data.get('access_token'),\n            \"title\": data.get('title', 'Knowledge Garden Presentation'),\n            \"include_diagrams\": True\n        },\n        \"nested_requests\": nested_requests\n    }\n    \n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"{ARTIFACTS_SERVICE_URL}/generate\",\n                json=artifact_request\n            ) as response:\n                if response.status == 200:\n                    result = await response.json()\n                    return jsonify(result)\n                else:\n                    error = await response.text()\n                    return jsonify({\"error\": error}), response.status\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\ndef _process_sparql_results(results: Dict[str, Any]) -> List[Dict[str, Any]]:\n    \"\"\"Process SPARQL results into concept objects.\"\"\"\n    concepts = []\n    \n    for binding in results.get('results', {}).get('bindings', []):\n        concept = {\n            'id': binding['concept']['value'].split('#')[-1],\n            'type': binding['type']['value'].split('#')[-1].lower(),\n            'text': binding['label']['value'],\n            'confidence': float(binding.get('confidence', {}).get('value', 0.8)),\n            'cluster': int(binding.get('cluster', {}).get('value', 0))\n        }\n        \n        # Parse embedding if available\n        if 'embedding' in binding:\n            try:\n                concept['embedding'] = json.loads(binding['embedding']['value'])\n            except:\n                # Generate random embedding as fallback\n                import random\n                concept['embedding'] = [\n                    random.uniform(-1, 1) for _ in range(3)\n                ]\n        \n        concepts.append(concept)\n    \n    return concepts\n\ndef _create_mindmap_content(concepts: List[Dict[str, Any]]) -> str:\n    \"\"\"Create mindmap content from concepts.\"\"\"\n    # Group by type\n    by_type = {}\n    for c in concepts:\n        by_type.setdefault(c['type'], []).append(c['text'])\n    \n    # Build mindmap structure\n    lines = [\"Knowledge Garden Mindmap\"]\n    for concept_type, items in by_type.items():\n        lines.append(f\"- {concept_type.upper()}\")\n        for item in items[:5]:  # Limit to 5 per type\n            lines.append(f\"  - {item}\")\n    \n    return \"\\n\".join(lines)\n\ndef _create_flowchart_content(concepts: List[Dict[str, Any]]) -> str:\n    \"\"\"Create flowchart content from concepts.\"\"\"\n    # Extract entities and relationships\n    entities = [c for c in concepts if c['type'] == 'entity'][:5]\n    caps = [c for c in concepts if c['type'] == 'cap'][:3]\n    \n    if not entities:\n        return \"Start -> Process -> End\"\n    \n    # Build simple flow\n    flow_parts = []\n    for i, entity in enumerate(entities[:-1]):\n        next_entity = entities[i+1]\n        connector = caps[i % len(caps)]['text'] if caps else \"leads to\"\n        flow_parts.append(f\"{entity['text']} --{connector}--> {next_entity['text']}\")\n    \n    return \" \\n\".join(flow_parts)\n\nasync def _get_document_concepts(document_id: str) -> List[Dict[str, Any]]:\n    \"\"\"Get concepts for a specific document from Fuseki.\"\"\"\n    query = f\"\"\"\n    PREFIX kg: <urn:knowledgegarden:ontology#>\n    \n    SELECT ?concept ?type ?label\n    WHERE {{\n        ?concept kg:extractedFrom <urn:document:{document_id}> ;\n                 rdf:type ?type ;\n                 rdfs:label ?label .\n    }}\n    \"\"\"\n    \n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"{FUSEKI_URL}/kg/sparql\",\n                data={'query': query},\n                headers={'Accept': 'application/sparql-results+json'}\n            ) as response:\n                if response.status == 200:\n                    results = await response.json()\n                    return _process_sparql_results(results)\n    except Exception as e:\n        app.logger.error(f\"Error getting document concepts: {e}\")\n    \n    return []\n\nif __name__ == '__main__':\n    # Use asyncio event loop\n    import asyncio\n    from flask import Flask\n    from asgiref.wsgi import WsgiToAsgi\n    \n    asgi_app = WsgiToAsgi(app)\n    \n    async def main():\n        config = {\n            \"host\": \"0.0.0.0\",\n            \"port\": 5050,\n            \"debug\": True\n        }\n        \n        import uvicorn\n        await uvicorn.Server(\n            uvicorn.Config(asgi_app, **config)\n        ).serve()\n    \n    asyncio.run(main())\n```\n\n## 5. Enhanced Visualization Template\n\nCreate `templates/visualize_3d.html`:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Knowledge Garden - 3D Concept Visualization</title>\n    \n    <!-- Three.js -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\n    \n    <!-- Bootstrap -->\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    \n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #0a0a0a;\n            color: #e0e0e0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            overflow: hidden;\n        }\n        \n        #container {\n            position: relative;\n            width: 100vw;\n            height: 100vh;\n        }\n        \n        #visualization {\n            width: 100%;\n            height: 100%;\n        }\n        \n        .controls-panel {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 20px;\n            min-width: 250px;\n            backdrop-filter: blur(10px);\n        }\n        \n        .info-panel {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 20px;\n            width: 300px;\n            max-height: 80vh;\n            overflow-y: auto;\n            backdrop-filter: blur(10px);\n            display: none;\n        }\n        \n        .info-panel.active {\n            display: block;\n        }\n        \n        .control-group {\n            margin-bottom: 15px;\n        }\n        \n        .control-group label {\n            display: block;\n            margin-bottom: 5px;\n            color: #bbb;\n            font-size: 14px;\n        }\n        \n        .control-group select,\n        .control-group input {\n            width: 100%;\n            background: #2a2a2a;\n            color: #fff;\n            border: 1px solid #444;\n            padding: 8px;\n            border-radius: 4px;\n        }\n        \n        .legend {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 15px;\n            backdrop-filter: blur(10px);\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            margin-bottom: 8px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            margin-right: 10px;\n            border-radius: 4px;\n        }\n        \n        .stats-panel {\n            position: absolute;\n            bottom: 20px;\n            right: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 15px;\n            backdrop-filter: blur(10px);\n        }\n        \n        .stat-item {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 8px;\n        }\n        \n        .stat-label {\n            color: #888;\n            font-size: 14px;\n        }\n        \n        .stat-value {\n            color: #4CAF50;\n            font-weight: bold;\n        }\n        \n        .loading-overlay {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.8);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 1000;\n        }\n        \n        .loading-spinner {\n            width: 50px;\n            height: 50px;\n            border: 3px solid #333;\n            border-top-color: #4CAF50;\n            border-radius: 50%;\n            animation: spin 1s linear infinite;\n        }\n        \n        @keyframes spin {\n            to { transform: rotate(360deg); }\n        }\n        \n        .btn-action {\n            background: #2d7bb7;\n            color: white;\n            border: none;\n            padding: 8px 16px;\n            border-radius: 4px;\n            cursor: pointer;\n            margin-top: 10px;\n            width: 100%;\n        }\n        \n        .btn-action:hover {\n            background: #1c6ca7;\n        }\n        \n        .concept-badge {\n            display: inline-block;\n            padding: 4px 8px;\n            border-radius: 4px;\n            font-size: 12px;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\">\n        <!-- Loading overlay -->\n        <div class=\"loading-overlay\" id=\"loadingOverlay\">\n            <div class=\"loading-spinner\"></div>\n        </div>\n        \n        <!-- 3D Visualization -->\n        <div id=\"visualization\"></div>\n        \n        <!-- Controls Panel -->\n        <div class=\"controls-panel\">\n            <h5>Visualization Controls</h5>\n            \n            <div class=\"control-group\">\n                <label>Knowledge Graph</label>\n                <select id=\"graphSelect\">\n                    <option value=\"main\">Main Knowledge Graph</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Filter by Type</label>\n                <select id=\"typeFilter\">\n                    <option value=\"all\">All Types</option>\n                    <option value=\"entity\">Entities</option>\n                    <option value=\"cap\">CAPs</option>\n                    <option value=\"insight\">Insights</option>\n                    <option value=\"tension\">Tensions</option>\n                    <option value=\"question\">Questions</option>\n                    <option value=\"value\">Values</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Filter by Cluster</label>\n                <select id=\"clusterFilter\">\n                    <option value=\"all\">All Clusters</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Connection Threshold</label>\n                <input type=\"range\" id=\"connectionThreshold\" min=\"0\" max=\"1\" step=\"0.1\" value=\"0.7\">\n                <span id=\"thresholdValue\">0.7</span>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>\n                    <input type=\"checkbox\" id=\"autoRotate\" checked> Auto-rotate\n                </label>\n            </div>\n            \n            <button class=\"btn-action\" onclick=\"resetView()\">Reset View</button>\n            <button class=\"btn-action\" onclick=\"exportVisualization()\">Export Image</button>\n        </div>\n        \n        <!-- Info Panel -->\n        <div class=\"info-panel\" id=\"infoPanel\">\n            <h5>Concept Details</h5>\n            <div id=\"conceptDetails\"></div>\n            \n            <button class=\"btn-action\" onclick=\"generateArtifact()\">\n                Generate Artifact\n            </button>\n            \n            <select id=\"artifactType\" class=\"form-select mt-2\">\n                <option value=\"diagram\">Diagram</option>\n                <option value=\"summary\">Summary</option>\n                <option value=\"presentation\">Presentation</option>\n            </select>\n        </div>\n        \n        <!-- Legend -->\n        <div class=\"legend\">\n            <h6>Concept Types</h6>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #9C27B0\"></div>\n                <span>Entity</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #4CAF50\"></div>\n                <span>CAP</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #2196F3\"></div>\n                <span>Insight</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #FF5722\"></div>\n                <span>Tension</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #FFC107\"></div>\n                <span>Question</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #00BCD4\"></div>\n                <span>Value</span>\n            </div>\n        </div>\n        \n        <!-- Stats Panel -->\n        <div class=\"stats-panel\">\n            <h6>Statistics</h6>\n            <div class=\"stat-item\">\n                <span class=\"stat-label\">Total Concepts:</span>\n                <span class=\"stat-value\" id=\"totalConcepts\">0</span>\n            </div>\n            <div class=\"stat-item\">\n                <span class=\"stat-label\">Clusters:</span>\n                <span class=\"stat-value\" id=\"totalClusters\">0</span>\n            </div>\n            <div class=\"stat-item\">\n                <span class=\"stat-label\">Connections:</span>\n                <span class=\"stat-value\" id=\"totalConnections\">0</span>\n            </div>\n        </div>\n    </div>\n\n    <!-- Include the visualizer script -->\n    <script src=\"/static/js/concept-visualizer.js\"></script>\n    \n    <script>\n        let visualizer;\n        let concepts = [];\n        let selectedConcept = null;\n        \n        // Initialize\n        document.addEventListener('DOMContentLoaded', async () => {\n            // Create visualizer\n            visualizer = new ConceptVisualizer('visualization');\n            \n            // Load concepts\n            await loadConcepts();\n            \n            // Set up event listeners\n            document.getElementById('typeFilter').addEventListener('change', filterConcepts);\n            document.getElementById('clusterFilter').addEventListener('change', filterConcepts);\n            document.getElementById('connectionThreshold').addEventListener('input', updateThreshold);\n            document.getElementById('autoRotate').addEventListener('change', toggleAutoRotate);\n            \n            // Listen for concept selection\n            document.getElementById('visualization').addEventListener('conceptSelected', (e) => {\n                selectedConcept = e.detail;\n                showConceptDetails(e.detail);\n            });\n        });\n        \n        async function loadConcepts() {\n            // Show loading\n            document.getElementById('loadingOverlay').style.display = 'flex';\n            \n            try {\n                const response = await fetch('/api/concepts');\n                concepts = await response.json();\n                \n                // Load into visualizer\n                visualizer.loadConcepts(concepts);\n                \n                // Update UI\n                updateStats();\n                populateClusterFilter();\n                \n            } catch (error) {\n                console.error('Error loading concepts:', error);\n                alert('Failed to load concepts');\n            } finally {\n                // Hide loading\n                document.getElementById('loadingOverlay').style.display = 'none';\n            }\n        }\n        \n        function updateStats() {\n            document.getElementById('totalConcepts').textContent = concepts.length;\n            \n            const clusters = new Set(concepts.map(c => c.cluster));\n            document.getElementById('totalClusters').textContent = clusters.size;\n            \n            document.getElementById('totalConnections').textContent = \n                visualizer.connections.length;\n        }\n        \n        function populateClusterFilter() {\n            const clusterFilter = document.getElementById('clusterFilter');\n            const clusters = [...new Set(concepts.map(c => c.cluster))].sort();\n            \n            clusters.forEach(cluster => {\n                const option = document.createElement('option');\n                option.value = cluster;\n                option.textContent = `Cluster ${cluster}`;\n                clusterFilter.appendChild(option);\n            });\n        }\n        \n        function filterConcepts() {\n            const typeFilter = document.getElementById('typeFilter').value;\n            const clusterFilter = document.getElementById('clusterFilter').value;\n            \n            if (typeFilter !== 'all') {\n                visualizer.filterByType(typeFilter);\n            }\n            \n            if (clusterFilter !== 'all') {\n                visualizer.filterByCluster(parseInt(clusterFilter));\n            }\n        }\n        \n        function updateThreshold(e) {\n            const threshold = parseFloat(e.target.value);\n            document.getElementById('thresholdValue').textContent = threshold;\n            \n            // Update connections based on threshold\n            visualizer.updateConnections(threshold);\n        }\n        \n        function toggleAutoRotate(e) {\n            visualizer.controls.enabled = !e.target.checked;\n        }\n        \n        function resetView() {\n            visualizer.camera.position.set(0, 0, 50);\n            visualizer.controls.reset();\n        }\n        \n        function exportVisualization() {\n            // Export as image\n            const dataURL = visualizer.renderer.domElement.toDataURL('image/png');\n            const link = document.createElement('a');\n            link.download = 'knowledge-garden-visualization.png';\n            link.href = dataURL;\n            link.click();\n        }\n        \n        function showConceptDetails(concept) {\n            const infoPanel = document.getElementById('infoPanel');\n            const detailsDiv = document.getElementById('conceptDetails');\n            \n            // Create badge HTML\n            const badgeClass = `badge-${concept.type}`;\n            const badgeStyle = getBadgeStyle(concept.type);\n            \n            detailsDiv.innerHTML = `\n                <div class=\"concept-badge\" style=\"background: ${badgeStyle.color}; color: ${badgeStyle.textColor}\">\n                    ${concept.type.toUpperCase()}\n                </div>\n                <h6>${concept.text}</h6>\n                <div class=\"mt-3\">\n                    <p><strong>Confidence:</strong> ${concept.confidence.toFixed(2)}</p>\n                    <p><strong>Cluster:</strong> ${concept.cluster}</p>\n                    <p><strong>ID:</strong> <small>${concept.id}</small></p>\n                </div>\n            `;\n            \n            infoPanel.classList.add('active');\n        }\n        \n        function getBadgeStyle(type) {\n            const styles = {\n                entity: { color: '#9C27B0', textColor: 'white' },\n                cap: { color: '#4CAF50', textColor: 'white' },\n                insight: { color: '#2196F3', textColor: 'white' },\n                tension: { color: '#FF5722', textColor: 'white' },\n                question: { color: '#FFC107', textColor: 'black' },\n                value: { color: '#00BCD4', textColor: 'white' }\n            };\n            \n            return styles[type] || { color: '#666', textColor: 'white' };\n        }\n        \n        async function generateArtifact() {\n            if (!selectedConcept) return;\n            \n            const artifactType = document.getElementById('artifactType').value;\n            \n            // Call API to generate artifact\n            try {\n                const response = await fetch('/api/generate_artifact', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        concept: selectedConcept,\n                        type: artifactType\n                    })\n                });\n                \n                const result = await response.json();\n                \n                if (result.url) {\n                    window.open(result.url, '_blank');\n                } else {\n                    alert('Failed to generate artifact');\n                }\n            } catch (error) {\n                console.error('Error generating artifact:', error);\n                alert('Error generating artifact');\n            }\n        }\n    </script>\n</body>\n</html>\n```\n\n## Setup Instructions\n\n1. **Clean up your project:**\n```bash\nchmod +x cleanup_knowledge_garden.sh\n./cleanup_knowledge_garden.sh\n```\n\n2. **Set up environment variables:**\n```bash\n# Create .env file\ncat > .env << EOF\nANTHROPIC_API_KEY=your_key_here\nFUSEKI_URL=http://localhost:3030\nFUSEKI_DATASET=kg\nFUSEKI_USER=admin\nFUSEKI_PASSWORD=admin\nEOF\n```\n\n3. **Start services with Docker:**\n```bash\n# Start Fuseki and all services\ndocker-compose up -d\n\n# Initialize Fuseki dataset\ncurl -X POST http://localhost:3030/$/datasets \\\n  -u admin:admin \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"dbName=kg&dbType=tdb2\"\n\n# Load ontology\ncurl -X POST http://localhost:3030/kg/data \\\n  -u admin:admin \\\n  -H \"Content-Type: text/turtle\" \\\n  --data-binary @core/ontology/kg_core.ttl\n```\n\n4. **Run the web application:**\n```bash\npython knowledge_garden_web_enhanced.py\n```\n\n5. **For Google Slides integration:**\n   - Set up Google Cloud project\n   - Enable Google Slides API\n   - Create OAuth credentials\n   - Add redirect URI: `http://localhost:8080`\n\nThe enhanced system now provides:\n- Clean, organized codebase\n- Working Fuseki integration\n- Beautiful 3D concept visualization\n- Google Slides generation with rendered Mermaid diagrams\n- Proper service separation and Docker setup",
      "created_at": "2025-06-13T21:49:39.092344Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-06-13T21:45:07.187938Z",
            "stop_timestamp": "2025-06-13T21:45:15.305126Z",
            "flags": null,
            "type": "thinking",
            "thinking": "The user has a Knowledge Garden v3 project that:\n1. Extracts concepts from documents using NLP/ML\n2. Stores them in a Fuseki triplestore (SPARQL database)\n3. Generates artifacts like presentations with nested diagrams\n4. Has a web interface for visualization\n\nThey want help with:\n1. Running the Fuseki knowledge graph ontology extractor\n2. Creating a better visualizer of concepts in 3D space\n3. Cleaning up the codebase\n4. Making Google Slides with nested Mermaid diagrams converted to PNGs\n\nLooking at their code, I can see several issues:\n1. The codebase has duplicated files and services\n2. Import paths are inconsistent\n3. Services are scattered across different locations\n4. The visualization is basic and could be improved\n5. Google Slides integration exists but needs proper diagram rendering\n\nI'll provide:\n1. A clean project structure\n2. Instructions for running Fuseki\n3. An improved 3D visualizer\n4. Proper Google Slides generation with rendered diagrams\n5. A cleanup script to reorganize everything",
            "summaries": [
              {
                "summary": "Thinking about extracting and visualizing knowledge graph concepts with code organization"
              },
              {
                "summary": "Strategizing project cleanup and artifact generation techniques"
              },
              {
                "summary": "Strategized project restructuring and advanced knowledge visualization techniques."
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-06-13T21:45:15.903992Z",
            "stop_timestamp": "2025-06-13T21:49:38.960330Z",
            "flags": null,
            "type": "text",
            "text": "Looking at your Knowledge Garden codebase, I can see it needs significant cleanup and better organization. Let me help you restructure it properly and create a great 3D visualizer with working Google Slides generation.\n\n## Project Cleanup and Reorganization\n\nFirst, let's create a cleanup script to reorganize your codebase:\n\n```bash\n#!/bin/bash\n# cleanup_knowledge_garden.sh\n\necho \"ðŸ§¹ Cleaning up Knowledge Garden v3...\"\n\n# 1. Remove all duplicate and obsolete files\nfind . -name \"*.pyc\" -delete\nfind . -name \"__pycache__\" -type d -exec rm -rf {} +\nfind . -name \".pytest_cache\" -type d -exec rm -rf {} +\n\n# 2. Remove duplicate service implementations\nrm -rf services/artifacts/services/\nrm -rf services/artifacts/artifact_core_backup/\nrm -rf services/artifacts/models/base.py  # Use core/models instead\n\n# 3. Create proper directory structure\nmkdir -p {data/{artifacts/{diagram,summary,presentation,report,image},embeddings,fuseki},logs,static/js,templates/components}\n\necho \"âœ… Cleanup complete!\"\n```\n\n## 1. Docker Compose for Fuseki\n\nCreate `docker-compose.yml`:\n\n```yaml\nversion: '3.8'\n\nservices:\n  fuseki:\n    image: stain/jena-fuseki:latest\n    container_name: kg_fuseki\n    ports:\n      - \"3030:3030\"\n    environment:\n      - ADMIN_PASSWORD=admin\n      - FUSEKI_DATASET_1=kg\n    volumes:\n      - ./data/fuseki:/fuseki\n      - ./core/ontology:/fuseki/ontology\n    command: /jena-fuseki/fuseki-server --update --loc=/fuseki/databases/kg /kg\n\n  extraction:\n    build: ./services/extraction\n    ports:\n      - \"8001:8001\"\n    environment:\n      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}\n      - FUSEKI_URL=http://fuseki:3030\n    depends_on:\n      - fuseki\n\n  artifacts:\n    build: ./services/artifacts\n    ports:\n      - \"8002:8002\"\n    environment:\n      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}\n      - FUSEKI_URL=http://fuseki:3030\n      - EXTRACTION_SERVICE_URL=http://extraction:8001\n    volumes:\n      - ./data/artifacts:/app/data/artifacts\n      - ./static:/app/static\n    depends_on:\n      - extraction\n      - fuseki\n\n  webapp:\n    build: .\n    ports:\n      - \"5050:5050\"\n    environment:\n      - FUSEKI_URL=http://fuseki:3030\n      - EXTRACTION_SERVICE_URL=http://extraction:8001\n      - ARTIFACTS_SERVICE_URL=http://artifacts:8002\n    volumes:\n      - ./uploads:/app/uploads\n      - ./static:/app/static\n      - ./data:/app/data\n    depends_on:\n      - fuseki\n      - extraction\n      - artifacts\n\nnetworks:\n  default:\n    name: knowledge-garden\n```\n\n## 2. Improved 3D Concept Visualizer\n\nCreate `static/js/concept-visualizer.js`:\n\n```javascript\n// Advanced 3D Concept Visualizer using Three.js\nclass ConceptVisualizer {\n    constructor(containerId) {\n        this.container = document.getElementById(containerId);\n        this.concepts = [];\n        this.connections = [];\n        this.selectedConcept = null;\n        \n        this.init();\n    }\n    \n    init() {\n        // Scene setup\n        this.scene = new THREE.Scene();\n        this.scene.background = new THREE.Color(0x0a0a0a);\n        \n        // Camera\n        this.camera = new THREE.PerspectiveCamera(\n            75, \n            this.container.clientWidth / this.container.clientHeight, \n            0.1, \n            1000\n        );\n        this.camera.position.set(0, 0, 50);\n        \n        // Renderer\n        this.renderer = new THREE.WebGLRenderer({ antialias: true });\n        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n        this.container.appendChild(this.renderer.domElement);\n        \n        // Controls\n        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);\n        this.controls.enableDamping = true;\n        this.controls.dampingFactor = 0.05;\n        \n        // Lights\n        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n        this.scene.add(ambientLight);\n        \n        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);\n        directionalLight.position.set(10, 10, 10);\n        this.scene.add(directionalLight);\n        \n        // Raycaster for mouse interaction\n        this.raycaster = new THREE.Raycaster();\n        this.mouse = new THREE.Vector2();\n        \n        // Concept type materials\n        this.materials = {\n            entity: new THREE.MeshPhongMaterial({ color: 0x9C27B0, emissive: 0x4A148C }),\n            cap: new THREE.MeshPhongMaterial({ color: 0x4CAF50, emissive: 0x1B5E20 }),\n            insight: new THREE.MeshPhongMaterial({ color: 0x2196F3, emissive: 0x0D47A1 }),\n            tension: new THREE.MeshPhongMaterial({ color: 0xFF5722, emissive: 0xBF360C }),\n            question: new THREE.MeshPhongMaterial({ color: 0xFFC107, emissive: 0xF57C00 }),\n            value: new THREE.MeshPhongMaterial({ color: 0x00BCD4, emissive: 0x006064 })\n        };\n        \n        // Event listeners\n        this.container.addEventListener('mousemove', this.onMouseMove.bind(this), false);\n        this.container.addEventListener('click', this.onClick.bind(this), false);\n        window.addEventListener('resize', this.onWindowResize.bind(this), false);\n        \n        // Start animation loop\n        this.animate();\n    }\n    \n    loadConcepts(concepts) {\n        // Clear existing concepts\n        this.clearScene();\n        \n        // Create concept meshes\n        concepts.forEach((concept, index) => {\n            const geometry = this.getGeometryForType(concept.type);\n            const material = this.materials[concept.type] || this.materials.entity;\n            const mesh = new THREE.Mesh(geometry, material);\n            \n            // Position based on embedding\n            if (concept.embedding && concept.embedding.length >= 3) {\n                mesh.position.set(\n                    concept.embedding[0] * 20,\n                    concept.embedding[1] * 20,\n                    concept.embedding[2] * 20\n                );\n            } else {\n                // Fallback positioning\n                const angle = (index / concepts.length) * Math.PI * 2;\n                const radius = 20;\n                mesh.position.set(\n                    Math.cos(angle) * radius,\n                    Math.sin(angle) * radius,\n                    (Math.random() - 0.5) * 10\n                );\n            }\n            \n            // Store concept data\n            mesh.userData = concept;\n            this.concepts.push(mesh);\n            this.scene.add(mesh);\n            \n            // Add label\n            this.addLabel(mesh, concept.text);\n        });\n        \n        // Create connections between related concepts\n        this.createConnections();\n    }\n    \n    getGeometryForType(type) {\n        switch(type) {\n            case 'entity':\n                return new THREE.SphereGeometry(1, 32, 32);\n            case 'cap':\n                return new THREE.BoxGeometry(1.5, 1.5, 1.5);\n            case 'insight':\n                return new THREE.ConeGeometry(1, 2, 8);\n            case 'tension':\n                return new THREE.OctahedronGeometry(1.2);\n            case 'question':\n                return new THREE.TorusGeometry(0.8, 0.3, 8, 16);\n            case 'value':\n                return new THREE.DodecahedronGeometry(1);\n            default:\n                return new THREE.SphereGeometry(1, 16, 16);\n        }\n    }\n    \n    addLabel(mesh, text) {\n        // Create sprite label\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        canvas.width = 256;\n        canvas.height = 64;\n        \n        context.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        context.font = '16px Arial';\n        context.textAlign = 'center';\n        \n        // Truncate text if too long\n        const maxLength = 20;\n        const displayText = text.length > maxLength ? \n            text.substring(0, maxLength) + '...' : text;\n        \n        context.fillText(displayText, 128, 32);\n        \n        const texture = new THREE.CanvasTexture(canvas);\n        const spriteMaterial = new THREE.SpriteMaterial({ \n            map: texture, \n            transparent: true \n        });\n        const sprite = new THREE.Sprite(spriteMaterial);\n        sprite.scale.set(8, 2, 1);\n        sprite.position.y = 2;\n        \n        mesh.add(sprite);\n    }\n    \n    createConnections() {\n        // Clear existing connections\n        this.connections.forEach(line => this.scene.remove(line));\n        this.connections = [];\n        \n        // Create connections based on similarity or clustering\n        for (let i = 0; i < this.concepts.length; i++) {\n            for (let j = i + 1; j < this.concepts.length; j++) {\n                const concept1 = this.concepts[i];\n                const concept2 = this.concepts[j];\n                \n                // Connect if same cluster or high similarity\n                if (concept1.userData.cluster === concept2.userData.cluster) {\n                    const geometry = new THREE.BufferGeometry().setFromPoints([\n                        concept1.position,\n                        concept2.position\n                    ]);\n                    \n                    const material = new THREE.LineBasicMaterial({ \n                        color: 0x444444,\n                        opacity: 0.3,\n                        transparent: true\n                    });\n                    \n                    const line = new THREE.Line(geometry, material);\n                    this.connections.push(line);\n                    this.scene.add(line);\n                }\n            }\n        }\n    }\n    \n    onMouseMove(event) {\n        const rect = this.container.getBoundingClientRect();\n        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n        \n        // Update raycaster\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        \n        // Check for intersections\n        const intersects = this.raycaster.intersectObjects(this.concepts);\n        \n        // Reset all materials\n        this.concepts.forEach(concept => {\n            const type = concept.userData.type;\n            concept.material = this.materials[type];\n        });\n        \n        // Highlight hovered concept\n        if (intersects.length > 0) {\n            const hoveredConcept = intersects[0].object;\n            hoveredConcept.material = hoveredConcept.material.clone();\n            hoveredConcept.material.emissive = new THREE.Color(0xffffff);\n            hoveredConcept.material.emissiveIntensity = 0.3;\n            \n            this.container.style.cursor = 'pointer';\n        } else {\n            this.container.style.cursor = 'default';\n        }\n    }\n    \n    onClick(event) {\n        this.raycaster.setFromCamera(this.mouse, this.camera);\n        const intersects = this.raycaster.intersectObjects(this.concepts);\n        \n        if (intersects.length > 0) {\n            const clickedConcept = intersects[0].object;\n            this.selectConcept(clickedConcept.userData);\n            \n            // Emit custom event\n            this.container.dispatchEvent(new CustomEvent('conceptSelected', {\n                detail: clickedConcept.userData\n            }));\n        }\n    }\n    \n    selectConcept(concept) {\n        this.selectedConcept = concept;\n        \n        // Highlight selected concept and dim others\n        this.concepts.forEach(mesh => {\n            if (mesh.userData.id === concept.id) {\n                mesh.material = mesh.material.clone();\n                mesh.material.emissive = new THREE.Color(0xffffff);\n                mesh.material.emissiveIntensity = 0.5;\n            } else {\n                mesh.material = mesh.material.clone();\n                mesh.material.opacity = 0.3;\n                mesh.material.transparent = true;\n            }\n        });\n    }\n    \n    clearScene() {\n        this.concepts.forEach(mesh => {\n            this.scene.remove(mesh);\n        });\n        this.connections.forEach(line => {\n            this.scene.remove(line);\n        });\n        this.concepts = [];\n        this.connections = [];\n    }\n    \n    onWindowResize() {\n        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;\n        this.camera.updateProjectionMatrix();\n        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n    }\n    \n    animate() {\n        requestAnimationFrame(this.animate.bind(this));\n        \n        // Auto-rotate when not interacting\n        if (!this.controls.enabled) {\n            this.scene.rotation.y += 0.001;\n        }\n        \n        this.controls.update();\n        this.renderer.render(this.scene, this.camera);\n    }\n    \n    // Filtering methods\n    filterByType(type) {\n        this.concepts.forEach(mesh => {\n            mesh.visible = type === 'all' || mesh.userData.type === type;\n        });\n        this.updateConnections();\n    }\n    \n    filterByCluster(clusterId) {\n        this.concepts.forEach(mesh => {\n            mesh.visible = clusterId === 'all' || mesh.userData.cluster === clusterId;\n        });\n        this.updateConnections();\n    }\n    \n    updateConnections() {\n        this.connections.forEach(line => {\n            // Hide connections if either concept is hidden\n            const positions = line.geometry.attributes.position.array;\n            let visible = true;\n            \n            this.concepts.forEach(mesh => {\n                const meshPos = mesh.position;\n                if (!mesh.visible && \n                    (Math.abs(positions[0] - meshPos.x) < 0.01 ||\n                     Math.abs(positions[3] - meshPos.x) < 0.01)) {\n                    visible = false;\n                }\n            });\n            \n            line.visible = visible;\n        });\n    }\n}\n```\n\n## 3. Enhanced Google Slides Generator with Mermaid Diagrams\n\nCreate `services/artifacts/core/generators/implementations/google_slides_enhanced.py`:\n\n```python\n\"\"\"Enhanced Google Slides generator with proper Mermaid diagram rendering.\"\"\"\nimport logging\nimport asyncio\nimport base64\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\nimport httpx\nimport tempfile\n\nfrom ....models import ArtifactType\nfrom ..base_generator import BaseGenerator, ArtifactRequest, ArtifactResult\nfrom ....exceptions import GenerationFailure, ArtifactError\n\nlogger = logging.getLogger(__name__)\n\nclass EnhancedGoogleSlidesGenerator(BaseGenerator):\n    \"\"\"Generate Google Slides presentations with rendered diagrams.\"\"\"\n    \n    @property\n    def artifact_type(self) -> ArtifactType:\n        return ArtifactType.PRESENTATION\n    \n    async def generate(\n        self, \n        request: ArtifactRequest, \n        artifact_id: Optional[str] = None\n    ) -> Union[ArtifactResult, GenerationFailure]:\n        \"\"\"Generate a Google Slides presentation with nested diagrams.\"\"\"\n        try:\n            # Validate request\n            validation_error = self.validate_request(request)\n            if validation_error:\n                return GenerationFailure(validation_error)\n            \n            # Generate artifact ID\n            artifact_id = self.create_artifact_id(artifact_id)\n            \n            # Get options\n            access_token = request.options.get(\"google_access_token\")\n            if not access_token:\n                return GenerationFailure(\n                    ArtifactError(\"Google access token required for Slides generation\")\n                )\n            \n            title = request.options.get(\"title\", \"Knowledge Garden Presentation\")\n            include_diagrams = request.options.get(\"include_diagrams\", True)\n            \n            # Generate presentation structure\n            presentation_data = await self._generate_presentation_structure(\n                request.content, title\n            )\n            \n            # Process nested diagrams if requested\n            if include_diagrams and request.nested_requests:\n                presentation_data = await self._process_nested_diagrams(\n                    presentation_data, request.nested_requests\n                )\n            \n            # Create Google Slides presentation\n            result = await self._create_google_slides(\n                presentation_data, access_token\n            )\n            \n            if result[\"success\"]:\n                return ArtifactResult(\n                    artifact_id=artifact_id,\n                    artifact_type=self.artifact_type,\n                    title=title,\n                    content=presentation_data,\n                    format=\"google_slides\",\n                    url=result[\"url\"],\n                    metadata={\n                        \"google_slides_id\": result[\"presentation_id\"],\n                        \"slide_count\": result[\"slide_count\"],\n                        \"diagrams_rendered\": len(result.get(\"diagrams\", []))\n                    }\n                )\n            else:\n                return GenerationFailure(\n                    ArtifactError(f\"Failed to create presentation: {result['error']}\")\n                )\n                \n        except Exception as e:\n            logger.error(f\"Error generating Google Slides: {e}\")\n            return GenerationFailure(\n                ArtifactError(f\"Failed to generate presentation: {e}\")\n            )\n    \n    async def _generate_presentation_structure(\n        self, content: str, title: str\n    ) -> Dict[str, Any]:\n        \"\"\"Generate presentation structure from content.\"\"\"\n        from shared.services.llm.service import LLMService\n        llm = LLMService()\n        \n        prompt = f\"\"\"\n        Create a presentation structure for \"{title}\" based on this content:\n        {content}\n        \n        Return a JSON structure with slides that include placeholders for diagrams.\n        Mark diagram placeholders as {{DIAGRAM_N}} where N is the diagram number.\n        \n        Example:\n        {{\n            \"title\": \"...\",\n            \"slides\": [\n                {{\n                    \"title\": \"Architecture Overview\",\n                    \"content\": \"Our system consists of three main components:\\\\n{{DIAGRAM_1}}\",\n                    \"layout\": \"TITLE_AND_BODY\",\n                    \"notes\": \"Explain the architecture diagram\",\n                    \"diagram_request\": {{\n                        \"type\": \"flowchart\",\n                        \"content\": \"User -> API Gateway -> Services -> Database\"\n                    }}\n                }}\n            ]\n        }}\n        \"\"\"\n        \n        response = await llm.generate(prompt)\n        \n        # Parse response\n        import json\n        try:\n            return json.loads(response)\n        except:\n            # Fallback structure\n            return {\n                \"title\": title,\n                \"slides\": [\n                    {\n                        \"title\": \"Title Slide\",\n                        \"content\": title,\n                        \"layout\": \"TITLE\"\n                    },\n                    {\n                        \"title\": \"Overview\",\n                        \"content\": \"{{DIAGRAM_1}}\",\n                        \"layout\": \"TITLE_AND_BODY\",\n                        \"diagram_request\": {\n                            \"type\": \"mindmap\",\n                            \"content\": content[:200]\n                        }\n                    }\n                ]\n            }\n    \n    async def _process_nested_diagrams(\n        self,\n        presentation_data: Dict[str, Any],\n        nested_requests: List[Dict[str, Any]]\n    ) -> Dict[str, Any]:\n        \"\"\"Process and render nested Mermaid diagrams.\"\"\"\n        diagrams = []\n        \n        # Extract diagram requests from slides\n        for i, slide in enumerate(presentation_data[\"slides\"]):\n            if \"diagram_request\" in slide:\n                diagram_req = slide[\"diagram_request\"]\n                \n                # Generate Mermaid code\n                mermaid_code = await self._generate_mermaid_code(\n                    diagram_req[\"content\"],\n                    diagram_req.get(\"type\", \"flowchart\")\n                )\n                \n                # Render diagram to PNG\n                png_path = await self._render_mermaid_to_png(\n                    mermaid_code, f\"diagram_{i+1}\"\n                )\n                \n                # Upload to temporary hosting\n                image_url = await self._upload_image(png_path)\n                \n                diagrams.append({\n                    \"slide_index\": i,\n                    \"placeholder\": f\"{{DIAGRAM_{i+1}}}\",\n                    \"image_url\": image_url,\n                    \"mermaid_code\": mermaid_code\n                })\n        \n        presentation_data[\"diagrams\"] = diagrams\n        return presentation_data\n    \n    async def _generate_mermaid_code(\n        self, content: str, diagram_type: str\n    ) -> str:\n        \"\"\"Generate Mermaid diagram code from content.\"\"\"\n        from shared.services.llm.service import LLMService\n        llm = LLMService()\n        \n        prompt = f\"\"\"\n        Generate a Mermaid {diagram_type} diagram for:\n        {content}\n        \n        Return ONLY the Mermaid code, no explanations.\n        \"\"\"\n        \n        response = await llm.generate(prompt)\n        \n        # Clean response\n        if \"```\" in response:\n            response = response.split(\"```\")[1]\n            if response.startswith(\"mermaid\"):\n                response = response[7:]\n        \n        return response.strip()\n    \n    async def _render_mermaid_to_png(\n        self, mermaid_code: str, filename: str\n    ) -> Path:\n        \"\"\"Render Mermaid diagram to PNG using mermaid.ink API.\"\"\"\n        # Encode diagram\n        encoded = base64.urlsafe_b64encode(\n            mermaid_code.encode()\n        ).decode().rstrip(\"=\")\n        \n        # Use mermaid.ink API\n        url = f\"https://mermaid.ink/img/{encoded}?type=png&theme=dark\"\n        \n        # Download PNG\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            \n            if response.status_code == 200:\n                # Save to temp file\n                temp_dir = Path(tempfile.gettempdir()) / \"kg_diagrams\"\n                temp_dir.mkdir(exist_ok=True)\n                \n                png_path = temp_dir / f\"{filename}.png\"\n                png_path.write_bytes(response.content)\n                \n                return png_path\n            else:\n                raise Exception(f\"Failed to render diagram: {response.status_code}\")\n    \n    async def _upload_image(self, image_path: Path) -> str:\n        \"\"\"Upload image to temporary hosting (e.g., imgur).\"\"\"\n        # For production, use a proper image hosting service\n        # For now, return a data URL\n        import base64\n        \n        with open(image_path, \"rb\") as f:\n            image_data = f.read()\n        \n        base64_data = base64.b64encode(image_data).decode()\n        return f\"data:image/png;base64,{base64_data}\"\n    \n    async def _create_google_slides(\n        self,\n        presentation_data: Dict[str, Any],\n        access_token: str\n    ) -> Dict[str, Any]:\n        \"\"\"Create the actual Google Slides presentation.\"\"\"\n        try:\n            # Create presentation\n            slides_api = \"https://slides.googleapis.com/v1/presentations\"\n            headers = {\n                \"Authorization\": f\"Bearer {access_token}\",\n                \"Content-Type\": \"application/json\"\n            }\n            \n            # Create empty presentation\n            create_response = await self._api_request(\n                \"POST\", slides_api, headers, \n                json={\"title\": presentation_data[\"title\"]}\n            )\n            \n            presentation_id = create_response[\"presentationId\"]\n            \n            # Add slides with content\n            requests = []\n            \n            for i, slide in enumerate(presentation_data[\"slides\"]):\n                slide_id = f\"slide_{i}\"\n                \n                # Create slide\n                requests.append({\n                    \"createSlide\": {\n                        \"objectId\": slide_id,\n                        \"slideLayoutReference\": {\n                            \"predefinedLayout\": slide.get(\"layout\", \"TITLE_AND_BODY\")\n                        }\n                    }\n                })\n            \n            # Execute batch update\n            if requests:\n                await self._batch_update(presentation_id, requests, headers)\n            \n            # Add content and images\n            await self._add_slide_content(\n                presentation_id, \n                presentation_data, \n                headers\n            )\n            \n            return {\n                \"success\": True,\n                \"presentation_id\": presentation_id,\n                \"url\": f\"https://docs.google.com/presentation/d/{presentation_id}/edit\",\n                \"slide_count\": len(presentation_data[\"slides\"]),\n                \"diagrams\": presentation_data.get(\"diagrams\", [])\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error creating Google Slides: {e}\")\n            return {\n                \"success\": False,\n                \"error\": str(e)\n            }\n    \n    async def _add_slide_content(\n        self,\n        presentation_id: str,\n        presentation_data: Dict[str, Any],\n        headers: Dict[str, str]\n    ):\n        \"\"\"Add content and images to slides.\"\"\"\n        # Get presentation structure\n        presentation = await self._api_request(\n            \"GET\",\n            f\"https://slides.googleapis.com/v1/presentations/{presentation_id}\",\n            headers\n        )\n        \n        requests = []\n        diagrams_by_slide = {}\n        \n        # Index diagrams by slide\n        for diagram in presentation_data.get(\"diagrams\", []):\n            diagrams_by_slide[diagram[\"slide_index\"]] = diagram\n        \n        # Add content to each slide\n        for i, slide_data in enumerate(presentation_data[\"slides\"]):\n            slide = presentation[\"slides\"][i+1]  # Skip title slide\n            \n            # Find text placeholders\n            for element in slide.get(\"pageElements\", []):\n                shape = element.get(\"shape\", {})\n                if shape.get(\"placeholder\"):\n                    placeholder_type = shape[\"placeholder\"][\"type\"]\n                    object_id = element[\"objectId\"]\n                    \n                    if placeholder_type == \"TITLE\" and slide_data.get(\"title\"):\n                        requests.append({\n                            \"insertText\": {\n                                \"objectId\": object_id,\n                                \"text\": slide_data[\"title\"]\n                            }\n                        })\n                    \n                    elif placeholder_type in [\"BODY\", \"CONTENT\"]:\n                        content = slide_data.get(\"content\", \"\")\n                        \n                        # Replace diagram placeholders\n                        if i in diagrams_by_slide:\n                            diagram = diagrams_by_slide[i]\n                            # Add image instead of placeholder\n                            requests.append({\n                                \"createImage\": {\n                                    \"url\": diagram[\"image_url\"],\n                                    \"elementProperties\": {\n                                        \"pageObjectId\": slide[\"objectId\"],\n                                        \"size\": {\n                                            \"width\": {\"magnitude\": 400, \"unit\": \"PT\"},\n                                            \"height\": {\"magnitude\": 300, \"unit\": \"PT\"}\n                                        },\n                                        \"transform\": {\n                                            \"scaleX\": 1,\n                                            \"scaleY\": 1,\n                                            \"translateX\": 150,\n                                            \"translateY\": 150,\n                                            \"unit\": \"PT\"\n                                        }\n                                    }\n                                }\n                            })\n                            \n                            # Remove placeholder from content\n                            content = content.replace(diagram[\"placeholder\"], \"\")\n                        \n                        if content.strip():\n                            requests.append({\n                                \"insertText\": {\n                                    \"objectId\": object_id,\n                                    \"text\": content\n                                }\n                            })\n        \n        # Execute all updates\n        if requests:\n            await self._batch_update(presentation_id, requests, headers)\n    \n    async def _api_request(\n        self, method: str, url: str, headers: Dict, **kwargs\n    ) -> Dict[str, Any]:\n        \"\"\"Make API request with error handling.\"\"\"\n        async with httpx.AsyncClient() as client:\n            response = await client.request(\n                method, url, headers=headers, **kwargs\n            )\n            response.raise_for_status()\n            return response.json()\n    \n    async def _batch_update(\n        self, presentation_id: str, requests: List[Dict], headers: Dict\n    ):\n        \"\"\"Execute batch update on presentation.\"\"\"\n        url = f\"https://slides.googleapis.com/v1/presentations/{presentation_id}:batchUpdate\"\n        body = {\"requests\": requests}\n        \n        await self._api_request(\"POST\", url, headers, json=body)\n```\n\n## 4. Improved Web Application\n\nCreate an updated `knowledge_garden_web_enhanced.py`:\n\n```python\n\"\"\"Enhanced Knowledge Garden Web Interface with 3D visualization.\"\"\"\nimport os\nimport uuid\nimport json\nfrom datetime import datetime\nfrom pathlib import Path\nfrom flask import Flask, request, render_template, redirect, url_for, jsonify, send_from_directory\nimport aiohttp\nimport asyncio\nfrom typing import Dict, Any, List\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = 'uploads'\napp.config['OUTPUT_FOLDER'] = 'output'\napp.config['STATIC_FOLDER'] = 'static'\n\n# Service URLs from environment\nFUSEKI_URL = os.getenv('FUSEKI_URL', 'http://localhost:3030')\nEXTRACTION_SERVICE_URL = os.getenv('EXTRACTION_SERVICE_URL', 'http://localhost:8001')\nARTIFACTS_SERVICE_URL = os.getenv('ARTIFACTS_SERVICE_URL', 'http://localhost:8002')\n\n# Create required directories\nfor folder in [app.config['UPLOAD_FOLDER'], app.config['OUTPUT_FOLDER'], app.config['STATIC_FOLDER']]:\n    os.makedirs(folder, exist_ok=True)\n\n@app.route('/')\ndef index():\n    \"\"\"Render the enhanced main page.\"\"\"\n    return render_template('index_enhanced.html')\n\n@app.route('/visualize')\ndef visualize():\n    \"\"\"Render the 3D visualization page.\"\"\"\n    return render_template('visualize_3d.html')\n\n@app.route('/api/concepts')\nasync def get_concepts():\n    \"\"\"Get concepts from Fuseki knowledge graph.\"\"\"\n    graph_id = request.args.get('graph_id', 'main')\n    \n    # Query Fuseki for concepts\n    query = \"\"\"\n    PREFIX kg: <urn:knowledgegarden:ontology#>\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n    \n    SELECT ?concept ?type ?label ?embedding ?cluster ?confidence\n    WHERE {\n        ?concept rdf:type ?type ;\n                 rdfs:label ?label .\n        OPTIONAL { ?concept kg:embedding ?embedding }\n        OPTIONAL { ?concept kg:cluster ?cluster }\n        OPTIONAL { ?concept kg:confidence ?confidence }\n        FILTER(?type IN (kg:CAP, kg:Insight, kg:Tension, kg:Question, kg:Concept))\n    }\n    LIMIT 1000\n    \"\"\"\n    \n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"{FUSEKI_URL}/kg/sparql\",\n                data={'query': query},\n                headers={'Accept': 'application/sparql-results+json'}\n            ) as response:\n                if response.status == 200:\n                    results = await response.json()\n                    concepts = _process_sparql_results(results)\n                    return jsonify(concepts)\n    except Exception as e:\n        app.logger.error(f\"Error querying Fuseki: {e}\")\n    \n    # Return empty array on error\n    return jsonify([])\n\n@app.route('/api/generate_presentation', methods=['POST'])\nasync def generate_presentation():\n    \"\"\"Generate a Google Slides presentation with diagrams.\"\"\"\n    data = request.get_json()\n    \n    # Prepare nested diagram requests\n    nested_requests = []\n    if data.get('include_diagrams', True):\n        # Get concepts for the document\n        concepts = await _get_document_concepts(data['document_id'])\n        \n        # Create diagram requests based on concepts\n        nested_requests = [\n            {\n                \"content\": _create_mindmap_content(concepts),\n                \"artifact_type\": \"diagram\",\n                \"options\": {\"diagram_type\": \"mindmap\"}\n            },\n            {\n                \"content\": _create_flowchart_content(concepts),\n                \"artifact_type\": \"diagram\", \n                \"options\": {\"diagram_type\": \"flowchart\"}\n            }\n        ]\n    \n    # Call artifacts service\n    artifact_request = {\n        \"content\": data.get('content', ''),\n        \"artifact_type\": \"presentation\",\n        \"options\": {\n            \"output_format\": \"google_slides\",\n            \"google_access_token\": data.get('access_token'),\n            \"title\": data.get('title', 'Knowledge Garden Presentation'),\n            \"include_diagrams\": True\n        },\n        \"nested_requests\": nested_requests\n    }\n    \n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"{ARTIFACTS_SERVICE_URL}/generate\",\n                json=artifact_request\n            ) as response:\n                if response.status == 200:\n                    result = await response.json()\n                    return jsonify(result)\n                else:\n                    error = await response.text()\n                    return jsonify({\"error\": error}), response.status\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500\n\ndef _process_sparql_results(results: Dict[str, Any]) -> List[Dict[str, Any]]:\n    \"\"\"Process SPARQL results into concept objects.\"\"\"\n    concepts = []\n    \n    for binding in results.get('results', {}).get('bindings', []):\n        concept = {\n            'id': binding['concept']['value'].split('#')[-1],\n            'type': binding['type']['value'].split('#')[-1].lower(),\n            'text': binding['label']['value'],\n            'confidence': float(binding.get('confidence', {}).get('value', 0.8)),\n            'cluster': int(binding.get('cluster', {}).get('value', 0))\n        }\n        \n        # Parse embedding if available\n        if 'embedding' in binding:\n            try:\n                concept['embedding'] = json.loads(binding['embedding']['value'])\n            except:\n                # Generate random embedding as fallback\n                import random\n                concept['embedding'] = [\n                    random.uniform(-1, 1) for _ in range(3)\n                ]\n        \n        concepts.append(concept)\n    \n    return concepts\n\ndef _create_mindmap_content(concepts: List[Dict[str, Any]]) -> str:\n    \"\"\"Create mindmap content from concepts.\"\"\"\n    # Group by type\n    by_type = {}\n    for c in concepts:\n        by_type.setdefault(c['type'], []).append(c['text'])\n    \n    # Build mindmap structure\n    lines = [\"Knowledge Garden Mindmap\"]\n    for concept_type, items in by_type.items():\n        lines.append(f\"- {concept_type.upper()}\")\n        for item in items[:5]:  # Limit to 5 per type\n            lines.append(f\"  - {item}\")\n    \n    return \"\\n\".join(lines)\n\ndef _create_flowchart_content(concepts: List[Dict[str, Any]]) -> str:\n    \"\"\"Create flowchart content from concepts.\"\"\"\n    # Extract entities and relationships\n    entities = [c for c in concepts if c['type'] == 'entity'][:5]\n    caps = [c for c in concepts if c['type'] == 'cap'][:3]\n    \n    if not entities:\n        return \"Start -> Process -> End\"\n    \n    # Build simple flow\n    flow_parts = []\n    for i, entity in enumerate(entities[:-1]):\n        next_entity = entities[i+1]\n        connector = caps[i % len(caps)]['text'] if caps else \"leads to\"\n        flow_parts.append(f\"{entity['text']} --{connector}--> {next_entity['text']}\")\n    \n    return \" \\n\".join(flow_parts)\n\nasync def _get_document_concepts(document_id: str) -> List[Dict[str, Any]]:\n    \"\"\"Get concepts for a specific document from Fuseki.\"\"\"\n    query = f\"\"\"\n    PREFIX kg: <urn:knowledgegarden:ontology#>\n    \n    SELECT ?concept ?type ?label\n    WHERE {{\n        ?concept kg:extractedFrom <urn:document:{document_id}> ;\n                 rdf:type ?type ;\n                 rdfs:label ?label .\n    }}\n    \"\"\"\n    \n    try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(\n                f\"{FUSEKI_URL}/kg/sparql\",\n                data={'query': query},\n                headers={'Accept': 'application/sparql-results+json'}\n            ) as response:\n                if response.status == 200:\n                    results = await response.json()\n                    return _process_sparql_results(results)\n    except Exception as e:\n        app.logger.error(f\"Error getting document concepts: {e}\")\n    \n    return []\n\nif __name__ == '__main__':\n    # Use asyncio event loop\n    import asyncio\n    from flask import Flask\n    from asgiref.wsgi import WsgiToAsgi\n    \n    asgi_app = WsgiToAsgi(app)\n    \n    async def main():\n        config = {\n            \"host\": \"0.0.0.0\",\n            \"port\": 5050,\n            \"debug\": True\n        }\n        \n        import uvicorn\n        await uvicorn.Server(\n            uvicorn.Config(asgi_app, **config)\n        ).serve()\n    \n    asyncio.run(main())\n```\n\n## 5. Enhanced Visualization Template\n\nCreate `templates/visualize_3d.html`:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Knowledge Garden - 3D Concept Visualization</title>\n    \n    <!-- Three.js -->\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js\"></script>\n    \n    <!-- Bootstrap -->\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    \n    <style>\n        body {\n            margin: 0;\n            padding: 0;\n            background-color: #0a0a0a;\n            color: #e0e0e0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            overflow: hidden;\n        }\n        \n        #container {\n            position: relative;\n            width: 100vw;\n            height: 100vh;\n        }\n        \n        #visualization {\n            width: 100%;\n            height: 100%;\n        }\n        \n        .controls-panel {\n            position: absolute;\n            top: 20px;\n            left: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 20px;\n            min-width: 250px;\n            backdrop-filter: blur(10px);\n        }\n        \n        .info-panel {\n            position: absolute;\n            top: 20px;\n            right: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 20px;\n            width: 300px;\n            max-height: 80vh;\n            overflow-y: auto;\n            backdrop-filter: blur(10px);\n            display: none;\n        }\n        \n        .info-panel.active {\n            display: block;\n        }\n        \n        .control-group {\n            margin-bottom: 15px;\n        }\n        \n        .control-group label {\n            display: block;\n            margin-bottom: 5px;\n            color: #bbb;\n            font-size: 14px;\n        }\n        \n        .control-group select,\n        .control-group input {\n            width: 100%;\n            background: #2a2a2a;\n            color: #fff;\n            border: 1px solid #444;\n            padding: 8px;\n            border-radius: 4px;\n        }\n        \n        .legend {\n            position: absolute;\n            bottom: 20px;\n            left: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 15px;\n            backdrop-filter: blur(10px);\n        }\n        \n        .legend-item {\n            display: flex;\n            align-items: center;\n            margin-bottom: 8px;\n        }\n        \n        .legend-color {\n            width: 20px;\n            height: 20px;\n            margin-right: 10px;\n            border-radius: 4px;\n        }\n        \n        .stats-panel {\n            position: absolute;\n            bottom: 20px;\n            right: 20px;\n            background: rgba(26, 26, 26, 0.95);\n            border: 1px solid #333;\n            border-radius: 8px;\n            padding: 15px;\n            backdrop-filter: blur(10px);\n        }\n        \n        .stat-item {\n            display: flex;\n            justify-content: space-between;\n            margin-bottom: 8px;\n        }\n        \n        .stat-label {\n            color: #888;\n            font-size: 14px;\n        }\n        \n        .stat-value {\n            color: #4CAF50;\n            font-weight: bold;\n        }\n        \n        .loading-overlay {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.8);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            z-index: 1000;\n        }\n        \n        .loading-spinner {\n            width: 50px;\n            height: 50px;\n            border: 3px solid #333;\n            border-top-color: #4CAF50;\n            border-radius: 50%;\n            animation: spin 1s linear infinite;\n        }\n        \n        @keyframes spin {\n            to { transform: rotate(360deg); }\n        }\n        \n        .btn-action {\n            background: #2d7bb7;\n            color: white;\n            border: none;\n            padding: 8px 16px;\n            border-radius: 4px;\n            cursor: pointer;\n            margin-top: 10px;\n            width: 100%;\n        }\n        \n        .btn-action:hover {\n            background: #1c6ca7;\n        }\n        \n        .concept-badge {\n            display: inline-block;\n            padding: 4px 8px;\n            border-radius: 4px;\n            font-size: 12px;\n            font-weight: bold;\n            margin-bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\">\n        <!-- Loading overlay -->\n        <div class=\"loading-overlay\" id=\"loadingOverlay\">\n            <div class=\"loading-spinner\"></div>\n        </div>\n        \n        <!-- 3D Visualization -->\n        <div id=\"visualization\"></div>\n        \n        <!-- Controls Panel -->\n        <div class=\"controls-panel\">\n            <h5>Visualization Controls</h5>\n            \n            <div class=\"control-group\">\n                <label>Knowledge Graph</label>\n                <select id=\"graphSelect\">\n                    <option value=\"main\">Main Knowledge Graph</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Filter by Type</label>\n                <select id=\"typeFilter\">\n                    <option value=\"all\">All Types</option>\n                    <option value=\"entity\">Entities</option>\n                    <option value=\"cap\">CAPs</option>\n                    <option value=\"insight\">Insights</option>\n                    <option value=\"tension\">Tensions</option>\n                    <option value=\"question\">Questions</option>\n                    <option value=\"value\">Values</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Filter by Cluster</label>\n                <select id=\"clusterFilter\">\n                    <option value=\"all\">All Clusters</option>\n                </select>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>Connection Threshold</label>\n                <input type=\"range\" id=\"connectionThreshold\" min=\"0\" max=\"1\" step=\"0.1\" value=\"0.7\">\n                <span id=\"thresholdValue\">0.7</span>\n            </div>\n            \n            <div class=\"control-group\">\n                <label>\n                    <input type=\"checkbox\" id=\"autoRotate\" checked> Auto-rotate\n                </label>\n            </div>\n            \n            <button class=\"btn-action\" onclick=\"resetView()\">Reset View</button>\n            <button class=\"btn-action\" onclick=\"exportVisualization()\">Export Image</button>\n        </div>\n        \n        <!-- Info Panel -->\n        <div class=\"info-panel\" id=\"infoPanel\">\n            <h5>Concept Details</h5>\n            <div id=\"conceptDetails\"></div>\n            \n            <button class=\"btn-action\" onclick=\"generateArtifact()\">\n                Generate Artifact\n            </button>\n            \n            <select id=\"artifactType\" class=\"form-select mt-2\">\n                <option value=\"diagram\">Diagram</option>\n                <option value=\"summary\">Summary</option>\n                <option value=\"presentation\">Presentation</option>\n            </select>\n        </div>\n        \n        <!-- Legend -->\n        <div class=\"legend\">\n            <h6>Concept Types</h6>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #9C27B0\"></div>\n                <span>Entity</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #4CAF50\"></div>\n                <span>CAP</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #2196F3\"></div>\n                <span>Insight</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #FF5722\"></div>\n                <span>Tension</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #FFC107\"></div>\n                <span>Question</span>\n            </div>\n            <div class=\"legend-item\">\n                <div class=\"legend-color\" style=\"background: #00BCD4\"></div>\n                <span>Value</span>\n            </div>\n        </div>\n        \n        <!-- Stats Panel -->\n        <div class=\"stats-panel\">\n            <h6>Statistics</h6>\n            <div class=\"stat-item\">\n                <span class=\"stat-label\">Total Concepts:</span>\n                <span class=\"stat-value\" id=\"totalConcepts\">0</span>\n            </div>\n            <div class=\"stat-item\">\n                <span class=\"stat-label\">Clusters:</span>\n                <span class=\"stat-value\" id=\"totalClusters\">0</span>\n            </div>\n            <div class=\"stat-item\">\n                <span class=\"stat-label\">Connections:</span>\n                <span class=\"stat-value\" id=\"totalConnections\">0</span>\n            </div>\n        </div>\n    </div>\n\n    <!-- Include the visualizer script -->\n    <script src=\"/static/js/concept-visualizer.js\"></script>\n    \n    <script>\n        let visualizer;\n        let concepts = [];\n        let selectedConcept = null;\n        \n        // Initialize\n        document.addEventListener('DOMContentLoaded', async () => {\n            // Create visualizer\n            visualizer = new ConceptVisualizer('visualization');\n            \n            // Load concepts\n            await loadConcepts();\n            \n            // Set up event listeners\n            document.getElementById('typeFilter').addEventListener('change', filterConcepts);\n            document.getElementById('clusterFilter').addEventListener('change', filterConcepts);\n            document.getElementById('connectionThreshold').addEventListener('input', updateThreshold);\n            document.getElementById('autoRotate').addEventListener('change', toggleAutoRotate);\n            \n            // Listen for concept selection\n            document.getElementById('visualization').addEventListener('conceptSelected', (e) => {\n                selectedConcept = e.detail;\n                showConceptDetails(e.detail);\n            });\n        });\n        \n        async function loadConcepts() {\n            // Show loading\n            document.getElementById('loadingOverlay').style.display = 'flex';\n            \n            try {\n                const response = await fetch('/api/concepts');\n                concepts = await response.json();\n                \n                // Load into visualizer\n                visualizer.loadConcepts(concepts);\n                \n                // Update UI\n                updateStats();\n                populateClusterFilter();\n                \n            } catch (error) {\n                console.error('Error loading concepts:', error);\n                alert('Failed to load concepts');\n            } finally {\n                // Hide loading\n                document.getElementById('loadingOverlay').style.display = 'none';\n            }\n        }\n        \n        function updateStats() {\n            document.getElementById('totalConcepts').textContent = concepts.length;\n            \n            const clusters = new Set(concepts.map(c => c.cluster));\n            document.getElementById('totalClusters').textContent = clusters.size;\n            \n            document.getElementById('totalConnections').textContent = \n                visualizer.connections.length;\n        }\n        \n        function populateClusterFilter() {\n            const clusterFilter = document.getElementById('clusterFilter');\n            const clusters = [...new Set(concepts.map(c => c.cluster))].sort();\n            \n            clusters.forEach(cluster => {\n                const option = document.createElement('option');\n                option.value = cluster;\n                option.textContent = `Cluster ${cluster}`;\n                clusterFilter.appendChild(option);\n            });\n        }\n        \n        function filterConcepts() {\n            const typeFilter = document.getElementById('typeFilter').value;\n            const clusterFilter = document.getElementById('clusterFilter').value;\n            \n            if (typeFilter !== 'all') {\n                visualizer.filterByType(typeFilter);\n            }\n            \n            if (clusterFilter !== 'all') {\n                visualizer.filterByCluster(parseInt(clusterFilter));\n            }\n        }\n        \n        function updateThreshold(e) {\n            const threshold = parseFloat(e.target.value);\n            document.getElementById('thresholdValue').textContent = threshold;\n            \n            // Update connections based on threshold\n            visualizer.updateConnections(threshold);\n        }\n        \n        function toggleAutoRotate(e) {\n            visualizer.controls.enabled = !e.target.checked;\n        }\n        \n        function resetView() {\n            visualizer.camera.position.set(0, 0, 50);\n            visualizer.controls.reset();\n        }\n        \n        function exportVisualization() {\n            // Export as image\n            const dataURL = visualizer.renderer.domElement.toDataURL('image/png');\n            const link = document.createElement('a');\n            link.download = 'knowledge-garden-visualization.png';\n            link.href = dataURL;\n            link.click();\n        }\n        \n        function showConceptDetails(concept) {\n            const infoPanel = document.getElementById('infoPanel');\n            const detailsDiv = document.getElementById('conceptDetails');\n            \n            // Create badge HTML\n            const badgeClass = `badge-${concept.type}`;\n            const badgeStyle = getBadgeStyle(concept.type);\n            \n            detailsDiv.innerHTML = `\n                <div class=\"concept-badge\" style=\"background: ${badgeStyle.color}; color: ${badgeStyle.textColor}\">\n                    ${concept.type.toUpperCase()}\n                </div>\n                <h6>${concept.text}</h6>\n                <div class=\"mt-3\">\n                    <p><strong>Confidence:</strong> ${concept.confidence.toFixed(2)}</p>\n                    <p><strong>Cluster:</strong> ${concept.cluster}</p>\n                    <p><strong>ID:</strong> <small>${concept.id}</small></p>\n                </div>\n            `;\n            \n            infoPanel.classList.add('active');\n        }\n        \n        function getBadgeStyle(type) {\n            const styles = {\n                entity: { color: '#9C27B0', textColor: 'white' },\n                cap: { color: '#4CAF50', textColor: 'white' },\n                insight: { color: '#2196F3', textColor: 'white' },\n                tension: { color: '#FF5722', textColor: 'white' },\n                question: { color: '#FFC107', textColor: 'black' },\n                value: { color: '#00BCD4', textColor: 'white' }\n            };\n            \n            return styles[type] || { color: '#666', textColor: 'white' };\n        }\n        \n        async function generateArtifact() {\n            if (!selectedConcept) return;\n            \n            const artifactType = document.getElementById('artifactType').value;\n            \n            // Call API to generate artifact\n            try {\n                const response = await fetch('/api/generate_artifact', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        concept: selectedConcept,\n                        type: artifactType\n                    })\n                });\n                \n                const result = await response.json();\n                \n                if (result.url) {\n                    window.open(result.url, '_blank');\n                } else {\n                    alert('Failed to generate artifact');\n                }\n            } catch (error) {\n                console.error('Error generating artifact:', error);\n                alert('Error generating artifact');\n            }\n        }\n    </script>\n</body>\n</html>\n```\n\n## Setup Instructions\n\n1. **Clean up your project:**\n```bash\nchmod +x cleanup_knowledge_garden.sh\n./cleanup_knowledge_garden.sh\n```\n\n2. **Set up environment variables:**\n```bash\n# Create .env file\ncat > .env << EOF\nANTHROPIC_API_KEY=your_key_here\nFUSEKI_URL=http://localhost:3030\nFUSEKI_DATASET=kg\nFUSEKI_USER=admin\nFUSEKI_PASSWORD=admin\nEOF\n```\n\n3. **Start services with Docker:**\n```bash\n# Start Fuseki and all services\ndocker-compose up -d\n\n# Initialize Fuseki dataset\ncurl -X POST http://localhost:3030/$/datasets \\\n  -u admin:admin \\\n  -H \"Content-Type: application/x-www-form-urlencoded\" \\\n  -d \"dbName=kg&dbType=tdb2\"\n\n# Load ontology\ncurl -X POST http://localhost:3030/kg/data \\\n  -u admin:admin \\\n  -H \"Content-Type: text/turtle\" \\\n  --data-binary @core/ontology/kg_core.ttl\n```\n\n4. **Run the web application:**\n```bash\npython knowledge_garden_web_enhanced.py\n```\n\n5. **For Google Slides integration:**\n   - Set up Google Cloud project\n   - Enable Google Slides API\n   - Create OAuth credentials\n   - Add redirect URI: `http://localhost:8080`\n\nThe enhanced system now provides:\n- Clean, organized codebase\n- Working Fuseki integration\n- Beautiful 3D concept visualization\n- Google Slides generation with rendered Mermaid diagrams\n- Proper service separation and Docker setup",
            "citations": []
          }
        ],
        "updated_at": "2025-06-13T21:49:39.092344Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}