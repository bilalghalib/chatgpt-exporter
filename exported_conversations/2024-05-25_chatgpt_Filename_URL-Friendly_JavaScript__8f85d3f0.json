{
  "id": "8f85d3f0-b9d6-4040-adb6-4f6ab73acd57",
  "source": "chatgpt",
  "title": "Filename URL-Friendly JavaScript.",
  "created_at": "2024-05-25T14:26:22.499508",
  "updated_at": "2024-05-25T15:01:57.760858",
  "summary": null,
  "message_count": 12,
  "messages": [
    {
      "id": "aaa2b449-5803-474a-8e6c-9a6522f8b1e1",
      "role": "user",
      "content": "use javascript to make this filename urlfriendly:     let svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\n",
      "created_at": "2024-05-25T14:26:22.507071",
      "sequence_order": 0,
      "parent_id": "b92d0e29-3dda-479e-9555-67986991844e",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "1befea74-5c14-4938-bab2-f409b0672afe",
      "role": "assistant",
      "content": "Sure, let's create a JavaScript function that makes a filename URL-friendly by encoding special characters and converting it to a safe format. Here's how you can do it:\n\n```javascript\nfunction makeUrlFriendly(filename) {\n    return encodeURIComponent(filename)\n        .replace(/[!'()*]/g, escape)\n        .replace(/%20/g, '_'); // Optionally replace spaces with underscores\n}\n\nlet seoSlug = \"example-seo-slug\";\nlet badgeRequested = \"requested-badge\";\nlet requestDate = new Date().toISOString().split('T')[0]; // e.g., \"2024-05-25\"\n\nlet svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\nlet urlFriendlyFilename = makeUrlFriendly(svgFilename);\n\nconsole.log(urlFriendlyFilename);\n```\n\nIn this code:\n\n1. `encodeURIComponent` is used to encode the filename, making it URL-friendly.\n2. Special characters like `!'()*` are further encoded using `escape` to ensure full URL compatibility.\n3. Spaces are replaced with underscores for better readability (optional, based on preference).\n\nThis will ensure the filename is safe to use in URLs.",
      "created_at": "2024-05-25T14:26:29.006470",
      "sequence_order": 1,
      "parent_id": "aaa2b449-5803-474a-8e6c-9a6522f8b1e1",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa23d89-f0a7-4e32-a878-e3e980ecd43d",
      "role": "user",
      "content": "can'y i just do this:\nlet svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\nsvgFilename = encodeURIComponent(svgFilename);",
      "created_at": "2024-05-25T14:27:07.519601",
      "sequence_order": 2,
      "parent_id": "1befea74-5c14-4938-bab2-f409b0672afe",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "7f6dba4e-0258-47c6-9237-8905cdddc5cc",
      "role": "assistant",
      "content": "Yes, you can simplify the process by directly using `encodeURIComponent` on the constructed filename. Here’s how you can do it:\n\n```javascript\nlet seoSlug = \"example-seo-slug\";\nlet badgeRequested = \"requested-badge\";\nlet requestDate = new Date().toISOString().split('T')[0]; // e.g., \"2024-05-25\"\n\nlet svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\nsvgFilename = encodeURIComponent(svgFilename);\n\nconsole.log(svgFilename);\n```\n\nThis approach will encode the entire filename, making it URL-friendly. However, `encodeURIComponent` does not replace spaces with underscores. If you want spaces to be replaced with underscores, you can add a replace method as follows:\n\n```javascript\nlet seoSlug = \"example-seo-slug\";\nlet badgeRequested = \"requested-badge\";\nlet requestDate = new Date().toISOString().split('T')[0]; // e.g., \"2024-05-25\"\n\nlet svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\nsvgFilename = encodeURIComponent(svgFilename).replace(/%20/g, '_');\n\nconsole.log(svgFilename);\n```\n\nThis will ensure that any spaces in the filename are replaced with underscores, maintaining readability while ensuring URL safety.",
      "created_at": "2024-05-25T14:27:14.204000",
      "sequence_order": 3,
      "parent_id": "aaa23d89-f0a7-4e32-a878-e3e980ecd43d",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa22926-54fe-4f39-8d26-eeb3a61f80b3",
      "role": "user",
      "content": "why is my script uploading a different filename to wayway.ai than the svgFilename?",
      "created_at": "2024-05-25T14:30:44.312459",
      "sequence_order": 4,
      "parent_id": "7f6dba4e-0258-47c6-9237-8905cdddc5cc",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "d74212a8-36b5-44aa-852c-c3b889374797",
      "role": "assistant",
      "content": "There could be several reasons why the filename being uploaded to Wayway.ai differs from `svgFilename`. Here are some potential causes and how you might address them:\n\n1. **Encoding and Decoding Issues**: If there is additional encoding or decoding happening during the upload process, it might alter the filename.\n\n2. **Filename Overwriting**: Another part of your script or a library you're using might be modifying the filename before the upload.\n\n3. **Server-Side Processing**: The server (Wayway.ai) might be altering the filename for various reasons, such as to sanitize input, avoid conflicts, or meet specific naming conventions.\n\n4. **Variable Scope or Assignment**: Ensure that `svgFilename` is not being reassigned or shadowed elsewhere in your script.\n\nTo diagnose and fix the issue, follow these steps:\n\n### Step 1: Debugging\nAdd logging to verify the filename at different stages of your script.\n\n```javascript\nconsole.log('Before encoding:', svgFilename);\nsvgFilename = encodeURIComponent(svgFilename);\nconsole.log('After encoding:', svgFilename);\n\n// Add logging before the upload function\nconsole.log('Filename before upload:', svgFilename);\n\n// Your upload function\nuploadFile(svgFilename);\n```\n\n### Step 2: Check the Upload Function\nEnsure that the filename being passed to the upload function is correctly set.\n\n```javascript\nfunction uploadFile(filename) {\n    console.log('Uploading file with filename:', filename);\n    // Your upload logic here\n}\n```\n\n### Step 3: Review the Upload Logic\nExamine the code responsible for uploading the file to Wayway.ai. Ensure that no transformations are applied to the filename during this process.\n\n### Example Integration:\nHere’s a complete example to ensure the filename remains consistent throughout:\n\n```javascript\nlet seoSlug = \"example-seo-slug\";\nlet badgeRequested = \"requested-badge\";\nlet requestDate = new Date().toISOString().split('T')[0]; // e.g., \"2024-05-25\"\n\nlet svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\n\nconsole.log('Before encoding:', svgFilename);\nsvgFilename = encodeURIComponent(svgFilename).replace(/%20/g, '_');\nconsole.log('After encoding:', svgFilename);\n\n// Function to simulate file upload\nfunction uploadFile(filename) {\n    console.log('Uploading file with filename:', filename);\n    // Simulate the upload process\n    // Example: Send a POST request with the file and filename\n}\n\n// Ensure the correct filename is passed\nuploadFile(svgFilename);\n```\n\n### Step 4: Server-Side Checks\nIf the problem persists, investigate the server-side code or the Wayway.ai documentation to understand any potential filename modifications performed by the server.\n\nBy following these steps, you should be able to identify where the filename is being changed and ensure that `svgFilename` is uploaded correctly.",
      "created_at": "2024-05-25T14:31:02.338298",
      "sequence_order": 5,
      "parent_id": "aaa22926-54fe-4f39-8d26-eeb3a61f80b3",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2e65d-2c92-4636-8417-b3e4036f7112",
      "role": "user",
      "content": "I want the baked svg attachment filename saved here to be different than the one on the URL\n            await table.updateRecordAsync(record, { 'Level Icon Online': svgUploadUrl, 'Baked SVG Attachment': [{ url: uploadedFileUrl }], 'Baked SVG Data URL': svgDataUrl });\n\nto have the fields: \nFor This First Name\nand \nBadge_and_Level_Formula\nappended together with a \"_\"\nbefore ending with a \".svg\"\n\nTo be the filename saved to the Baked SVG Attachment\nlet inputConfig = input.config();\nlet table = base.getTable(\"Requests\");\nlet usersTable = base.getTable(\"Users\");\nlet recordId = inputConfig.scriptRecordID;\nlet queryResult = await table.selectRecordsAsync();\n// Find the specific record by recordId\nlet record = queryResult.getRecord(recordId);\n\n// Check if the record exists and log it\nif (record) {\n    console.log(record);\n} else {\n    console.log(\"Record not found\");\n}\n\nconst githubToken = 'ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED';\nconst owner = 'bloom-pm';\nconst repo = 'badges';\n\nasync function uploadFileAndGetUrl(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    const fileIoUrl = 'https://file.io';\n    try {\n        const response = await fetch(fileIoUrl, { method: 'POST', body: formData });\n        if (!response.ok) throw new Error(`Error uploading file: HTTP Status ${response.status}`);\n        return await response.json().then(data => data.link);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadToPastebin(data) {\n    const pasteData = new URLSearchParams();\n    pasteData.append('api_dev_key', 'br8Eql2caUTF9pzA6VXyTFnZP2HOcfUa'); // Your Pastebin API Developer Key\n    pasteData.append('api_option', 'paste');\n    pasteData.append('api_paste_code', data);\n    pasteData.append('api_paste_private', '1'); // Unlisted\n    pasteData.append('api_paste_expire_date', 'N'); // Never expire\n\n    try {\n        const response = await fetch('https://pastebin.com/api/api_post.php', {\n            method: 'POST',\n            body: pasteData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.text();\n        return result; // Return the Pastebin URL\n    } catch (error) {\n        console.error('Error uploading to Pastebin:', error);\n    }\n}\n\nasync function uploadToGitHub(filename, data, isFile = false) {\n    const path = (isFile ? 'svg/' : 'assertions/') + filename;\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n    let sha = await getGithubFileSha(url);\n    let bodyData = prepareGithubRequestBody(data, sha, filename, isFile);\n    try {\n        const response = await fetch(url, {\n            method: 'PUT',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(bodyData)\n        });\n        if (!response.ok) throw new Error(`Error uploading to GitHub: HTTP Status ${response.status}`);\n        const responseData = await response.json();\n        return isFile ? responseData.content.download_url.replace('blob/', '') : responseData.content.html_url;\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl, filename) {\n    let phpUploadServiceUrl = 'http://draw.wayway.ai/makefile.php'; // URL to your PHP script\n\n    // Prepare the JSON payload\n    let payload = JSON.stringify({\n        svgString: svgFileString,\n        recordID: recordId,\n    });\n\n    console.log(\"Sending payload:\", payload);\n\n    // Send the data to your PHP server\n    try {\n        const response = await fetch(phpUploadServiceUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: payload\n        });\n\n        console.log('Response status:', response.status);\n        console.log('Response headers:', response.headers);\n\n        if (!response.ok) {\n            throw new Error(`HTTP status ${response.status}`);\n        }\n\n        const data = await response.json(); // Parse the response as JSON\n        console.log('Server response:', data);\n\n        if (data.status === \"error\") {\n            console.error('Error from server:', data.message);\n        } else {\n            console.log('File uploaded successfully:', data.message);\n            let uploadedFileUrl = `https://draw.wayway.ai/uploads/${filename}`;\n            console.log('Uploaded File URL:', uploadedFileUrl);\n            console.log('SVG Data URL:', svgDataUrl);\n            await table.updateRecordAsync(record, { 'Level Icon Online': svgUploadUrl, 'Baked SVG Attachment': [{ url: uploadedFileUrl }], 'Baked SVG Data URL': svgDataUrl });\n        }\n    } catch (error) {\n        console.error('Error uploading file:', error);\n    }\n}\n\nasync function getGithubFileSha(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' }\n        });\n        if (response.ok) {\n            const fileData = await response.json();\n            return fileData.sha;\n        }\n    } catch (error) {\n        console.error('Error checking for existing file on GitHub:', error.message);\n    }\n    return null;\n}\n\nfunction prepareGithubRequestBody(data, sha, filename, isFile) {\n    let content = isFile ? base64Encode(data) : base64Encode(unescape(encodeURIComponent(JSON.stringify(data))));\n    let bodyData = { message: `Creating or updating file ${filename}`, content: content };\n    if (sha) bodyData.sha = sha;\n    return bodyData;\n}\n\nfunction base64Encode(str) {\n    // Define the base64 characters\n    const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    // Convert the input string into an array of character codes\n    const bytes = [];\n    for (let i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n\n    // Convert bytes to base64\n    let base64 = '';\n    for (let i = 0; i < bytes.length; i += 3) {\n        // Combine the next three bytes (24 bits) into one number\n        const triple = (bytes[i] << 16) + ((bytes[i + 1] || 0) << 8) + (bytes[i + 2] || 0);\n\n        // Extract four 6-bit segments and map to base64 characters\n        base64 += base64Chars[(triple >> 18) & 0x3F] +\n                  base64Chars[(triple >> 12) & 0x3F] +\n                  (i + 1 < bytes.length ? base64Chars[(triple >> 6) & 0x3F] : '=') +\n                  (i + 2 < bytes.length ? base64Chars[triple & 0x3F] : '=');\n    }\n\n    return base64;\n}\nvar hashEmail = function hashEmail(ascii) {\n    function rightRotate(value, amount) {\n        return (value>>>amount) | (value<<(32 - amount));\n    };\n    \n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length'\n    var i, j; // Used as a counter across the whole file\n    var result = ''\n\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty]*8;\n    \n    //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n    var hash = hashEmail.h = hashEmail.h || [];\n    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n    var k = hashEmail.k = hashEmail.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\n    var hash = [], k = [];\n    var primeCounter = 0;\n    //*/\n\n    var isComposite = {};\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n        if (!isComposite[candidate]) {\n            for (i = 0; i < 313; i += candidate) {\n                isComposite[i] = candidate;\n            }\n            hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\n            k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\n        }\n    }\n    \n    ascii += '\\x80' // Append Ƈ' bit (plus zero padding)\n    while (ascii[lengthProperty]%64 - 56) ascii += '\\x00' // More zero padding\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n        j = ascii.charCodeAt(i);\n        if (j>>8) return; // ASCII check: only accept characters in range 0-255\n        words[i>>2] |= j << ((3 - i)%4)*8;\n    }\n    words[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\n    words[words[lengthProperty]] = (asciiBitLength)\n    \n    // process each chunk\n    for (j = 0; j < words[lengthProperty];) {\n        var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n        var oldHash = hash;\n        // This is now the working hash\", often labelled as variables a...g\n        // (we have to truncate as well, otherwise extra entries at the end accumulate\n        hash = hash.slice(0, 8);\n        \n        for (i = 0; i < 64; i++) {\n            var i2 = i + j;\n            // Expand the message into 64 words\n            // Used below if \n            var w15 = w[i - 15], w2 = w[i - 2];\n\n            // Iterate\n            var a = hash[0], e = hash[4];\n            var temp1 = hash[7]\n                + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n                + ((e&hash[5])^((~e)&hash[6])) // ch\n                + k[i]\n                // Expand the message schedule if needed\n                + (w[i] = (i < 16) ? w[i] : (\n                        w[i - 16]\n                        + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\n                        + w[i - 7]\n                        + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\n                    )|0\n                );\n            // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n            var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\n                + ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\n            \n            hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n            hash[4] = (hash[4] + temp1)|0;\n        }\n        \n        for (i = 0; i < 8; i++) {\n            hash[i] = (hash[i] + oldHash[i])|0;\n        }\n    }\n    \n    for (i = 0; i < 8; i++) {\n        for (j = 3; j + 1; j--) {\n            var b = (hash[i]>>(j*8))&255;\n            result += ((b < 16) ? 0 : '') + b.toString(16);\n        }\n    }\n    return result;\n};\n\nasync function processRecord(record) {\n    if (!record) {\n        console.error(\"No record selected or found\");\n        return;\n    }\n\n    let originalSVG = record.getCellValueAsString('SVG Text Unbaked');\n    if (!originalSVG) {\n        console.error(\"SVG Text Unbaked is missing from the record\");\n        return;\n    }\n\n    let badgeName = record.getCellValueAsString('Badge Name');\n    let earnerEmail = record.getCellValueAsString('For This User');\n    let hashedEmail = await hashEmail(earnerEmail);\n\n    let recordID = record.id;\n\n    let seoSlug = record.getCellValueAsString('SEO:Slug') || record.getCellValueAsString('For This First Name');\n    let badgeRequested = record.getCellValueAsString('Badge Requested');\n    let requestDate = record.getCellValueAsString('Request Date');\n    let svgFilename = recordID+'.svg';\n    svgFilename = encodeURIComponent(svgFilename);\n    let svgUploadUrl = await uploadToGitHub(svgFilename, originalSVG, true);\n    if (!svgUploadUrl) throw new Error(\"Failed to upload SVG to GitHub\");\n\n    // Upload Badge Assertion JSON to Pastebin and get the URL\n    let evidenceURL = await uploadToPastebin(record.getCellValueAsString('Evidence'));\n    evidenceURL = evidenceURL.replace('https://pastebin.com/', 'https://pastebin.com/raw/'); // Modify to use the raw URL\n\n    let badgeData = {\n        \"@context\": \"https://w3id.org/openbadges/v2\",\n        \"type\": \"Assertion\",\n        \"uid\": recordID,\n        \"id\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`,\n        \"recipient\": {\n            \"type\": \"email\",\n            \"hashed\": true,\n            \"identity\": \"sha256$\"+hashedEmail\n        },\n        \"badge\": svgUploadUrl,\n        \"verification\": {\n            \"type\": \"hosted\",\n            \"url\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`\n        },\n        \"issuedOn\": new Date().toISOString(),\n        \"issuer\": {\n            \"id\": \"https://bloom.pm\",\n            \"name\": \"Bloom.pm\",\n            \"email\": \"bilal@bloom.pm\",\n            \"url\": \"https://bloom.pm\"\n        },\n        \"evidence\": evidenceURL,\n        \"narrative\": record.getCellValueAsString('Target Description'),\n        \"alignment\": {\n            \"targetName\": record.getCellValueAsString('Target Name'),\n            \"targetUrl\": record.getCellValueAsString('Target URL'),\n            \"targetDescription\": record.getCellValueAsString('Target Description'),\n            \"targetFramework\": record.getCellValueAsString('Target Framework')\n        }\n    };\n\n    let assertionFilename = `assertion_${recordID}.json`;\n    let assertionURL = await uploadToGitHub(assertionFilename, badgeData);\n\n    await table.updateRecordAsync(record, { \n        'Badge Assertion JSON URL': assertionURL \n    });\n\n    let updatedBadgeDataString = JSON.stringify(badgeData, null, 4);\n    let svgTagWithNamespace = '<svg xmlns:openbadges=\"http://openbadges.org\"';\n    if (!originalSVG.includes(svgTagWithNamespace)) {\n        originalSVG = originalSVG.replace('<svg', svgTagWithNamespace);\n    }\n\n    let bakedSVG = originalSVG.replace('</svg>', `<openbadges:assertion verification=\"${badgeData.verification.url}\"><![CDATA[${updatedBadgeDataString}]]></openbadges:assertion></svg>`);\n    let svgDataUrl = `data:image/svg+xml;base64,${base64Encode(unescape(encodeURIComponent(bakedSVG)))}`;\n\n    console.log('Baked SVG:', bakedSVG);\n    console.log('SVG Upload URL:', svgUploadUrl);\n    console.log('Record ID:', recordID);\n\n    await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl, svgFilename);\n}\n\nawait processRecord(record);\n",
      "created_at": "2024-05-25T14:49:09.085624",
      "sequence_order": 6,
      "parent_id": "d74212a8-36b5-44aa-852c-c3b889374797",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "464e1c32-1d73-4cc3-9c82-9ad41aa95162",
      "role": "assistant",
      "content": "To ensure the filename saved to the \"Baked SVG Attachment\" field has the \"For This First Name\" and \"Badge_and_Level_Formula\" appended together with an underscore and ending with \".svg,\" you can modify the `processRecord` function accordingly. Here’s the revised version of your script with the necessary changes:\n\n```javascript\nlet inputConfig = input.config();\nlet table = base.getTable(\"Requests\");\nlet usersTable = base.getTable(\"Users\");\nlet recordId = inputConfig.scriptRecordID;\nlet queryResult = await table.selectRecordsAsync();\n\n// Find the specific record by recordId\nlet record = queryResult.getRecord(recordId);\n\n// Check if the record exists and log it\nif (record) {\n    console.log(record);\n} else {\n    console.log(\"Record not found\");\n}\n\nconst githubToken = 'ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED';\nconst owner = 'bloom-pm';\nconst repo = 'badges';\n\nasync function uploadFileAndGetUrl(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    const fileIoUrl = 'https://file.io';\n    try {\n        const response = await fetch(fileIoUrl, { method: 'POST', body: formData });\n        if (!response.ok) throw new Error(`Error uploading file: HTTP Status ${response.status}`);\n        return await response.json().then(data => data.link);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadToPastebin(data) {\n    const pasteData = new URLSearchParams();\n    pasteData.append('api_dev_key', 'br8Eql2caUTF9pzA6VXyTFnZP2HOcfUa'); // Your Pastebin API Developer Key\n    pasteData.append('api_option', 'paste');\n    pasteData.append('api_paste_code', data);\n    pasteData.append('api_paste_private', '1'); // Unlisted\n    pasteData.append('api_paste_expire_date', 'N'); // Never expire\n\n    try {\n        const response = await fetch('https://pastebin.com/api/api_post.php', {\n            method: 'POST',\n            body: pasteData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.text();\n        return result; // Return the Pastebin URL\n    } catch (error) {\n        console.error('Error uploading to Pastebin:', error);\n    }\n}\n\nasync function uploadToGitHub(filename, data, isFile = false) {\n    const path = (isFile ? 'svg/' : 'assertions/') + filename;\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n    let sha = await getGithubFileSha(url);\n    let bodyData = prepareGithubRequestBody(data, sha, filename, isFile);\n    try {\n        const response = await fetch(url, {\n            method: 'PUT',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(bodyData)\n        });\n        if (!response.ok) throw new Error(`Error uploading to GitHub: HTTP Status ${response.status}`);\n        const responseData = await response.json();\n        return isFile ? responseData.content.download_url.replace('blob/', '') : responseData.content.html_url;\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl, filename, bakedSvgFilename) {\n    let phpUploadServiceUrl = 'http://draw.wayway.ai/makefile.php'; // URL to your PHP script\n\n    // Prepare the JSON payload\n    let payload = JSON.stringify({\n        svgString: svgFileString,\n        recordID: recordId,\n    });\n\n    console.log(\"Sending payload:\", payload);\n\n    // Send the data to your PHP server\n    try {\n        const response = await fetch(phpUploadServiceUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: payload\n        });\n\n        console.log('Response status:', response.status);\n        console.log('Response headers:', response.headers);\n\n        if (!response.ok) {\n            throw new Error(`HTTP status ${response.status}`);\n        }\n\n        const data = await response.json(); // Parse the response as JSON\n        console.log('Server response:', data);\n\n        if (data.status === \"error\") {\n            console.error('Error from server:', data.message);\n        } else {\n            console.log('File uploaded successfully:', data.message);\n            let uploadedFileUrl = `https://draw.wayway.ai/uploads/${bakedSvgFilename}`;\n            console.log('Uploaded File URL:', uploadedFileUrl);\n            console.log('SVG Data URL:', svgDataUrl);\n            await table.updateRecordAsync(record, { \n                'Level Icon Online': svgUploadUrl, \n                'Baked SVG Attachment': [{ url: uploadedFileUrl }], \n                'Baked SVG Data URL': svgDataUrl \n            });\n        }\n    } catch (error) {\n        console.error('Error uploading file:', error);\n    }\n}\n\nasync function getGithubFileSha(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' }\n        });\n        if (response.ok) {\n            const fileData = await response.json();\n            return fileData.sha;\n        }\n    } catch (error) {\n        console.error('Error checking for existing file on GitHub:', error.message);\n    }\n    return null;\n}\n\nfunction prepareGithubRequestBody(data, sha, filename, isFile) {\n    let content = isFile ? base64Encode(data) : base64Encode(unescape(encodeURIComponent(JSON.stringify(data))));\n    let bodyData = { message: `Creating or updating file ${filename}`, content: content };\n    if (sha) bodyData.sha = sha;\n    return bodyData;\n}\n\nfunction base64Encode(str) {\n    // Define the base64 characters\n    const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    // Convert the input string into an array of character codes\n    const bytes = [];\n    for (let i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n\n    // Convert bytes to base64\n    let base64 = '';\n    for (let i = 0; i < bytes.length; i += 3) {\n        // Combine the next three bytes (24 bits) into one number\n        const triple = (bytes[i] << 16) + ((bytes[i + 1] || 0) << 8) + (bytes[i + 2] || 0);\n\n        // Extract four 6-bit segments and map to base64 characters\n        base64 += base64Chars[(triple >> 18) & 0x3F] +\n                  base64Chars[(triple >> 12) & 0x3F] +\n                  (i + 1 < bytes.length ? base64Chars[(triple >> 6) & 0x3F] : '=') +\n                  (i + 2 < bytes.length ? base64Chars[triple & 0x3F] : '=');\n    }\n\n    return base64;\n}\n\nvar hashEmail = function hashEmail(ascii) {\n    function rightRotate(value, amount) {\n        return (value>>>amount) | (value<<(32 - amount));\n    };\n    \n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length'\n    var i, j; // Used as a counter across the whole file\n    var result = ''\n\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty]*8;\n    \n    //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n    var hash = hashEmail.h = hashEmail.h || [];\n    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n    var k = hashEmail.k = hashEmail.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\n    var hash = [], k = [];\n    var primeCounter = 0;\n    //*/\n\n    var isComposite = {};\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n        if (!isComposite[candidate]) {\n            for (i = 0; i < 313; i += candidate) {\n                isComposite[i] = candidate;\n            }\n            hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\n            k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\n        }\n    }\n    \n    ascii += '\\x80' // Append Ƈ' bit (plus zero padding)\n    while (ascii[lengthProperty]%64 - 56) ascii += '\\x00' // More zero padding\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n        j = ascii.charCodeAt(i);\n        if (j>>8) return; // ASCII check: only accept characters in range 0-255\n        words[i>>2] |= j << ((3 - i)%4)*8;\n   ",
      "created_at": "2024-05-25T14:50:00.124426",
      "sequence_order": 7,
      "parent_id": "aaa2e65d-2c92-4636-8417-b3e4036f7112",
      "metadata": {
        "status": "finished_partial_completion",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "206404ac-8309-4480-a038-0975ccfbcf1e",
      "role": "assistant",
      "content": " }\n    words[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\n    words[words[lengthProperty]] = (asciiBitLength)\n    \n    // process each chunk\n    for (j = 0; j < words[lengthProperty];) {\n        var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n        var oldHash = hash;\n        // This is now the working hash\", often labelled as variables a...g\n        // (we have to truncate as well, otherwise extra entries at the end accumulate\n        hash = hash.slice(0, 8);\n        \n        for (i = 0; i < 64; i++) {\n            var i2 = i + j;\n            // Expand the message into 64 words\n            // Used below if \n            var w15 = w[i - 15], w2 = w[i - 2];\n\n            // Iterate\n            var a = hash[0], e = hash[4];\n            var temp1 = hash[7]\n                + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n                + ((e&hash[5])^((~e)&hash[6])) // ch\n                + k[i]\n                // Expand the message schedule if needed\n                + (w[i] = (i < 16) ? w[i] : (\n                        w[i - 16]\n                        + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\n                        + w[i - 7]\n                        + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\n                    )|0\n                );\n            // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n            var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\n                + ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\n            \n            hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n            hash[4] = (hash[4] + temp1)|0;\n        }\n        \n        for (i = 0; i < 8; i++) {\n            hash[i] = (hash[i] + oldHash[i])|0;\n        }\n    }\n    \n    for (i = 0; i < 8; i++) {\n        for (j = 3; j + 1; j--) {\n            var b = (hash[i]>>(j*8))&255;\n            result += ((b < 16) ? 0 : '') + b.toString(16);\n        }\n    }\n    return result;\n};\n\nasync function processRecord(record) {\n    if (!record) {\n        console.error(\"No record selected or found\");\n        return;\n    }\n\n    let originalSVG = record.getCellValueAsString('SVG Text Unbaked');\n    if (!originalSVG) {\n        console.error(\"SVG Text Unbaked is missing from the record\");\n        return;\n    }\n\n    let badgeName = record.getCellValueAsString('Badge Name');\n    let earnerEmail = record.getCellValueAsString('For This User');\n    let hashedEmail = await hashEmail(earnerEmail);\n\n    let recordID = record.id;\n\n    let seoSlug = record.getCellValueAsString('SEO:Slug') || record.getCellValueAsString('For This First Name');\n    let badgeRequested = record.getCellValueAsString('Badge Requested');\n    let requestDate = record.getCellValueAsString('Request Date');\n    let bakedSvgFilename = `${seoSlug}_${record.getCellValueAsString('Badge_and_Level_Formula')}.svg`;\n    let svgFilename = `${recordID}.svg`;\n    svgFilename = encodeURIComponent(svgFilename);\n    let svgUploadUrl = await uploadToGitHub(svgFilename, originalSVG, true);\n    if (!svgUploadUrl) throw new Error(\"Failed to upload SVG to GitHub\");\n\n    // Upload Badge Assertion JSON to Pastebin and get the URL\n    let evidenceURL = await uploadToPastebin(record.getCellValueAsString('Evidence'));\n    evidenceURL = evidenceURL.replace('https://pastebin.com/', 'https://pastebin.com/raw/'); // Modify to use the raw URL\n\n    let badgeData = {\n        \"@context\": \"https://w3id.org/openbadges/v2\",\n        \"type\": \"Assertion\",\n        \"uid\": recordID,\n        \"id\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`,\n        \"recipient\": {\n            \"type\": \"email\",\n            \"hashed\": true,\n            \"identity\": \"sha256$\"+hashedEmail\n        },\n        \"badge\": svgUploadUrl,\n        \"verification\": {\n            \"type\": \"hosted\",\n            \"url\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`\n        },\n        \"issuedOn\": new Date().toISOString(),\n        \"issuer\": {\n            \"id\": \"https://bloom.pm\",\n            \"name\": \"Bloom.pm\",\n            \"email\": \"bilal@bloom.pm\",\n            \"url\": \"https://bloom.pm\"\n        },\n        \"evidence\": evidenceURL,\n        \"narrative\": record.getCellValueAsString('Target Description'),\n        \"alignment\": {\n            \"targetName\": record.getCellValueAsString('Target Name'),\n            \"targetUrl\": record.getCellValueAsString('Target URL'),\n            \"targetDescription\": record.getCellValueAsString('Target Description'),\n            \"targetFramework\": record.getCellValueAsString('Target Framework')\n        }\n    };\n\n    let assertionFilename = `assertion_${recordID}.json`;\n    let assertionURL = await uploadToGitHub(assertionFilename, badgeData);\n\n    await table.updateRecordAsync(record, { \n        'Badge Assertion JSON URL': assertionURL \n    });\n\n    let updatedBadgeDataString = JSON.stringify(badgeData, null, 4);\n    let svgTagWithNamespace = '<svg xmlns:openbadges=\"http://openbadges.org\"';\n    if (!originalSVG.includes(svgTagWithNamespace)) {\n        originalSVG = originalSVG.replace('<svg', svgTagWithNamespace);\n    }\n\n    let bakedSVG = originalSVG.replace('</svg>', `<openbadges:assertion verification=\"${badgeData.verification.url}\"><![CDATA[${updatedBadgeDataString}]]></openbadges:assertion></svg>`);\n    let svgDataUrl = `data:image/svg+xml;base64,${base64Encode(unescape(encodeURIComponent(bakedSVG)))}`;\n\n    console.log('Baked SVG:', bakedSVG);\n    console.log('SVG Upload URL:', svgUploadUrl);\n    console.log('Record ID:', recordID);\n\n    await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl, svgFilename, bakedSvgFilename);\n}\n\nawait processRecord(record);\n```\n\n### Explanation of Changes:\n\n1. **Baked SVG Filename**: The baked SVG filename is created by appending the \"For This First Name\" and \"Badge_and_Level_Formula\" fields together with an underscore, followed by `.svg`:\n   ```javascript\n   let bakedSvgFilename = `${seoSlug}_${record.getCellValueAsString('Badge_and_Level_Formula')}.svg`;\n   ```\n\n2. **Update Function Call**: The `uploadFileAndSaveIt` function is called with the additional `bakedSvgFilename` argument to ensure the correct filename is saved to the \"Baked SVG Attachment\" field:\n   ```javascript\n   await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl, svgFilename, bakedSvgFilename);\n   ```\n\n3. **Upload and Save Function**: The `uploadFileAndSaveIt` function is updated to accept `bakedSvgFilename` and use it for saving the file:\n   ```javascript\n   async function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl, filename, bakedSvgFilename) {\n       ...\n       let uploadedFileUrl = `https://draw.wayway.ai/uploads/${bakedSvgFilename}`;\n       console.log('Uploaded File URL:', uploadedFileUrl);\n       console.log('SVG Data URL:', svgDataUrl);\n       await table.updateRecordAsync(record, { \n           'Level Icon Online': svgUploadUrl, \n           'Baked SVG Attachment': [{ url: uploadedFileUrl }], \n           'Baked SVG Data URL': svgDataUrl \n       });\n       ...\n   }\n   ```\n\nThis ensures that the filename saved in the \"Baked SVG Attachment\" field will be in the desired format.",
      "created_at": "2024-05-25T14:51:14.739418",
      "sequence_order": 8,
      "parent_id": "464e1c32-1d73-4cc3-9c82-9ad41aa95162",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2a670-8383-4799-9921-6de3e5f05bcf",
      "role": "user",
      "content": "I want the file on wayway.ai that's uploaded to be the recordID while the file in the Baked SVG Attachment to be for this first name and badge and level formula as described earlier. \nYou can see how to set the name different to the file using airtable javascript here:\nlet inVar = input.config();\nlet url = inVar.Attachment_URL;\nlet companyname = inVar.Company\nlet datename = inVar.Created_Time.toString().substring(0,10);\nlet filename = `Result ${companyname} ${datename}.png`;\n\nlet attachmentUrl = [{url: url, filename: filename}];",
      "created_at": "2024-05-25T14:57:23.232060",
      "sequence_order": 9,
      "parent_id": "206404ac-8309-4480-a038-0975ccfbcf1e",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "f7dcb3c5-bd6d-44f5-bd9c-a732ed026fe2",
      "role": "assistant",
      "content": "Got it. Here’s the updated script that will ensure the file uploaded to wayway.ai uses the `recordID` for the filename, while the file saved in the \"Baked SVG Attachment\" field will use the \"For This First Name\" and \"Badge_and_Level_Formula\" fields combined with an underscore:\n\n```javascript\nlet inputConfig = input.config();\nlet table = base.getTable(\"Requests\");\nlet usersTable = base.getTable(\"Users\");\nlet recordId = inputConfig.scriptRecordID;\nlet queryResult = await table.selectRecordsAsync();\n\n// Find the specific record by recordId\nlet record = queryResult.getRecord(recordId);\n\n// Check if the record exists and log it\nif (record) {\n    console.log(record);\n} else {\n    console.log(\"Record not found\");\n}\n\nconst githubToken = 'ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED';\nconst owner = 'bloom-pm';\nconst repo = 'badges';\n\nasync function uploadFileAndGetUrl(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    const fileIoUrl = 'https://file.io';\n    try {\n        const response = await fetch(fileIoUrl, { method: 'POST', body: formData });\n        if (!response.ok) throw new Error(`Error uploading file: HTTP Status ${response.status}`);\n        return await response.json().then(data => data.link);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadToPastebin(data) {\n    const pasteData = new URLSearchParams();\n    pasteData.append('api_dev_key', 'br8Eql2caUTF9pzA6VXyTFnZP2HOcfUa'); // Your Pastebin API Developer Key\n    pasteData.append('api_option', 'paste');\n    pasteData.append('api_paste_code', data);\n    pasteData.append('api_paste_private', '1'); // Unlisted\n    pasteData.append('api_paste_expire_date', 'N'); // Never expire\n\n    try {\n        const response = await fetch('https://pastebin.com/api/api_post.php', {\n            method: 'POST',\n            body: pasteData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.text();\n        return result; // Return the Pastebin URL\n    } catch (error) {\n        console.error('Error uploading to Pastebin:', error);\n    }\n}\n\nasync function uploadToGitHub(filename, data, isFile = false) {\n    const path = (isFile ? 'svg/' : 'assertions/') + filename;\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n    let sha = await getGithubFileSha(url);\n    let bodyData = prepareGithubRequestBody(data, sha, filename, isFile);\n    try {\n        const response = await fetch(url, {\n            method: 'PUT',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(bodyData)\n        });\n        if (!response.ok) throw new Error(`Error uploading to GitHub: HTTP Status ${response.status}`);\n        const responseData = await response.json();\n        return isFile ? responseData.content.download_url.replace('blob/', '') : responseData.content.html_url;\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl, filename, bakedSvgFilename) {\n    let phpUploadServiceUrl = 'http://draw.wayway.ai/makefile.php'; // URL to your PHP script\n\n    // Prepare the JSON payload\n    let payload = JSON.stringify({\n        svgString: svgFileString,\n        recordID: recordId,\n    });\n\n    console.log(\"Sending payload:\", payload);\n\n    // Send the data to your PHP server\n    try {\n        const response = await fetch(phpUploadServiceUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: payload\n        });\n\n        console.log('Response status:', response.status);\n        console.log('Response headers:', response.headers);\n\n        if (!response.ok) {\n            throw new Error(`HTTP status ${response.status}`);\n        }\n\n        const data = await response.json(); // Parse the response as JSON\n        console.log('Server response:', data);\n\n        if (data.status === \"error\") {\n            console.error('Error from server:', data.message);\n        } else {\n            console.log('File uploaded successfully:', data.message);\n            let uploadedFileUrl = `https://draw.wayway.ai/uploads/${filename}`;\n            console.log('Uploaded File URL:', uploadedFileUrl);\n            console.log('SVG Data URL:', svgDataUrl);\n            await table.updateRecordAsync(record, { \n                'Level Icon Online': svgUploadUrl, \n                'Baked SVG Attachment': [{ url: uploadedFileUrl, filename: bakedSvgFilename }], \n                'Baked SVG Data URL': svgDataUrl \n            });\n        }\n    } catch (error) {\n        console.error('Error uploading file:', error);\n    }\n}\n\nasync function getGithubFileSha(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' }\n        });\n        if (response.ok) {\n            const fileData = await response.json();\n            return fileData.sha;\n        }\n    } catch (error) {\n        console.error('Error checking for existing file on GitHub:', error.message);\n    }\n    return null;\n}\n\nfunction prepareGithubRequestBody(data, sha, filename, isFile) {\n    let content = isFile ? base64Encode(data) : base64Encode(unescape(encodeURIComponent(JSON.stringify(data))));\n    let bodyData = { message: `Creating or updating file ${filename}`, content: content };\n    if (sha) bodyData.sha = sha;\n    return bodyData;\n}\n\nfunction base64Encode(str) {\n    // Define the base64 characters\n    const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    // Convert the input string into an array of character codes\n    const bytes = [];\n    for (let i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n\n    // Convert bytes to base64\n    let base64 = '';\n    for (let i = 0; i < bytes.length; i += 3) {\n        // Combine the next three bytes (24 bits) into one number\n        const triple = (bytes[i] << 16) + ((bytes[i + 1] || 0) << 8) + (bytes[i + 2] || 0);\n\n        // Extract four 6-bit segments and map to base64 characters\n        base64 += base64Chars[(triple >> 18) & 0x3F] +\n                  base64Chars[(triple >> 12) & 0x3F] +\n                  (i + 1 < bytes.length ? base64Chars[(triple >> 6) & 0x3F] : '=') +\n                  (i + 2 < bytes.length ? base64Chars[triple & 0x3F] : '=');\n    }\n\n    return base64;\n}\n\nvar hashEmail = function hashEmail(ascii) {\n    function rightRotate(value, amount) {\n        return (value>>>amount) | (value<<(32 - amount));\n    };\n    \n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length'\n    var i, j; // Used as a counter across the whole file\n    var result = ''\n\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty]*8;\n    \n    //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n    var hash = hashEmail.h = hashEmail.h || [];\n    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n    var k = hashEmail.k = hashEmail.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\n    var hash = [], k = [];\n    var primeCounter = 0;\n    //*/\n\n    var isComposite = {};\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n        if (!isComposite[candidate]) {\n            for (i = 0; i < 313; i += candidate) {\n                isComposite[i] = candidate;\n            }\n            hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\n            k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\n        }\n    }\n    \n    ascii += '\\x80' // Append Ƈ' bit (plus zero padding)\n    while (ascii[lengthProperty]%64 - 56) ascii += '\\x00' // More zero padding\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n        j = ascii.charCodeAt(i);\n        if (j>>8) return; // ASCII check: only accept characters in range 0-255\n        words[i>>2] |= j << ((3 - i)%4)*8",
      "created_at": "2024-05-25T14:58:17.627476",
      "sequence_order": 10,
      "parent_id": "aaa2a670-8383-4799-9921-6de3e5f05bcf",
      "metadata": {
        "status": "finished_partial_completion",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "2b6e6ec3-b45c-403f-a836-53e7f56905b0",
      "role": "assistant",
      "content": ";\n    }\n    words[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\n    words[words[lengthProperty]] = (asciiBitLength)\n    \n    // process each chunk\n    for (j = 0; j < words[lengthProperty];) {\n        var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n        var oldHash = hash;\n        // This is now the working hash\", often labelled as variables a...g\n        // (we have to truncate as well, otherwise extra entries at the end accumulate\n        hash = hash.slice(0, 8);\n        \n        for (i = 0; i < 64; i++) {\n            var i2 = i + j;\n            // Expand the message into 64 words\n            // Used below if \n            var w15 = w[i - 15], w2 = w[i - 2];\n\n            // Iterate\n            var a = hash[0], e = hash[4];\n            var temp1 = hash[7]\n                + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n                + ((e&hash[5])^((~e)&hash[6])) // ch\n                + k[i]\n                // Expand the message schedule if needed\n                + (w[i] = (i < 16) ? w[i] : (\n                        w[i - 16]\n                        + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\n                        + w[i - 7]\n                        + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\n                    )|0\n                );\n            // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n            var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\n                + ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\n            \n            hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n            hash[4] = (hash[4] + temp1)|0;\n        }\n        \n        for (i = 0; i < 8; i++) {\n            hash[i] = (hash[i] + oldHash[i])|0;\n        }\n    }\n    \n    for (i = 0; i < 8; i++) {\n        for (j = 3; j + 1; j--) {\n            var b = (hash[i]>>(j*8))&255;\n            result += ((b < 16) ? 0 : '') + b.toString(16);\n        }\n    }\n    return result;\n};\n\nasync function processRecord(record) {\n    if (!record) {\n        console.error(\"No record selected or found\");\n        return;\n    }\n\n    let originalSVG = record.getCellValueAsString('SVG Text Unbaked');\n    if (!originalSVG) {\n        console.error(\"SVG Text Unbaked is missing from the record\");\n        return;\n    }\n\n    let badgeName = record.getCellValueAsString('Badge Name');\n    let earnerEmail = record.getCellValueAsString('For This User');\n    let hashedEmail = await hashEmail(earnerEmail);\n\n    let recordID = record.id;\n\n    let seoSlug = record.getCellValueAsString('SEO:Slug') || record.getCellValueAsString('For This First Name');\n    let badgeRequested = record.getCellValueAsString('Badge Requested');\n    let requestDate = record.getCellValueAsString('Request Date');\n    let bakedSvgFilename = `${seoSlug}_${record.getCellValueAsString('Badge_and_Level_Formula')}.svg`;\n    let svgFilename = `${recordID}.svg`;\n    svgFilename = encodeURIComponent(svgFilename);\n    let svgUploadUrl = await uploadToGitHub(svgFilename, originalSVG, true);\n    if (!svgUploadUrl) throw new Error(\"Failed to upload SVG to GitHub\");\n\n    // Upload Badge Assertion JSON to Pastebin and get the URL\n    let evidenceURL = await uploadToPastebin(record.getCellValueAsString('Evidence'));\n    evidenceURL = evidenceURL.replace('https://pastebin.com/', 'https://pastebin.com/raw/'); // Modify to use the raw URL\n\n    let badgeData = {\n        \"@context\": \"https://w3id.org/openbadges/v2\",\n        \"type\": \"Assertion\",\n        \"uid\": recordID,\n        \"id\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`,\n        \"recipient\": {\n            \"type\": \"email\",\n            \"hashed\": true,\n            \"identity\": \"sha256$\"+hashedEmail\n        },\n        \"badge\": svgUploadUrl,\n        \"verification\": {\n            \"type\": \"hosted\",\n            \"url\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`\n        },\n        \"issuedOn\": new Date().toISOString(),\n        \"issuer\": {\n            \"id\": \"https://bloom.pm\",\n            \"name\": \"Bloom.pm\",\n            \"email\": \"bilal@bloom.pm\",\n            \"url\": \"https://bloom.pm\"\n        },\n        \"evidence\": evidenceURL,\n        \"narrative\": record.getCellValueAsString('Target Description'),\n        \"alignment\": {\n            \"targetName\": record.getCellValueAsString('Target Name'),\n            \"targetUrl\": record.getCellValueAsString('Target URL'),\n            \"targetDescription\": record.getCellValueAsString('Target Description'),\n            \"targetFramework\": record.getCellValueAsString('Target Framework')\n        }\n    };\n\n    let assertionFilename = `assertion_${recordID}.json`;\n    let assertionURL = await uploadToGitHub(assertionFilename, badgeData);\n\n    await table.updateRecordAsync(record, { \n        'Badge Assertion JSON URL': assertionURL \n    });\n\n    let updatedBadgeDataString = JSON.stringify(badgeData, null, 4);\n    let svgTagWithNamespace = '<svg xmlns:openbadges=\"http://openbadges.org\"';\n    if (!originalSVG.includes(svgTagWithNamespace)) {\n        originalSVG = originalSVG.replace('<svg', svgTagWithNamespace);\n    }\n\n    let bakedSVG = originalSVG.replace('</svg>', `<openbadges:assertion verification=\"${badgeData.verification.url}\"><![CDATA[${updatedBadgeDataString}]]></openbadges:assertion></svg>`);\n    let svgDataUrl = `data:image/svg+xml;base64,${base64Encode(unescape(encodeURIComponent(bakedSVG)))}`;\n\n    console.log('Baked SVG:', bakedSVG);\n    console.log('SVG Upload URL:', svgUploadUrl);\n    console.log('Record ID:', recordID);\n\n    await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl, svgFilename, bakedSvgFilename);\n}\n\nawait processRecord(record);\n```\n\n### Explanation of Changes:\n1. **Filename for Upload**: The filename for the uploaded file to wayway.ai is set to the `recordID`:\n   ```javascript\n   let svgFilename = `${recordID}.svg`;\n   svgFilename = encodeURIComponent(svgFilename);\n   ```\n\n2. **Filename for Baked SVG Attachment**: The filename for the baked SVG attachment is created by combining the \"For This First Name\" and \"Badge_and_Level_Formula\" fields with an underscore and ending with `.svg`:\n   ```javascript\n   let bakedSvgFilename = `${seoSlug}_${record.getCellValueAsString('Badge_and_Level_Formula')}.svg`;\n   ```\n\n3. **Updating Airtable Record**: The update to the Airtable record includes setting the filename for the baked SVG attachment:\n   ```javascript\n   await table.updateRecordAsync(record, { \n       'Level Icon Online': svgUploadUrl, \n       'Baked SVG Attachment': [{ url: uploadedFileUrl, filename: bakedSvgFilename }], \n       'Baked SVG Data URL': svgDataUrl \n   });\n   ```\n\nBy following these steps, the file uploaded to wayway.ai will have the `recordID` as the filename, while the file saved in the \"Baked SVG Attachment\" field will have the \"For This First Name\" and \"Badge_and_Level_Formula\" fields combined.",
      "created_at": "2024-05-25T15:01:57.056461",
      "sequence_order": 11,
      "parent_id": "f7dcb3c5-bd6d-44f5-bd9c-a732ed026fe2",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    }
  ]
}