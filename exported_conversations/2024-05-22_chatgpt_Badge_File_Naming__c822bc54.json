{
  "id": "c822bc54-6128-45fb-a2a0-220c3c79aa27",
  "source": "chatgpt",
  "title": "Badge File Naming.",
  "created_at": "2024-05-22T15:18:44.252434",
  "updated_at": "2024-05-22T22:49:06.481105",
  "summary": null,
  "message_count": 7,
  "messages": [
    {
      "id": "aaa27c81-bdf3-46c4-9beb-9c6dcb78c069",
      "role": "user",
      "content": "can you help me make it so when this script saves the badge it saves it with the fields:\neither \"SEO:Slug\" or if that doesn't exist \"For This First Name\" and then \"_\" then Badge Requested then \"_\" then \"Request Date\"\n?\n\nHere is the script:\nlet inputConfig = input.config();\nlet table = base.getTable(\"Requests\");\nlet usersTable = base.getTable(\"Users\");\nlet recordId = inputConfig.scriptRecordID;\n    let queryResult = await table.selectRecordsAsync();\n    // Find the specific record by IptoD\n    let record = queryResult.getRecord(recordId);\n\n    // Check if the record exists and log it\n    if (record) {\n        console.log(record);\n    } else {\n        console.log(\"Record not found\");\n    }\n\nconst githubToken = 'ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED';\nconst owner = 'bloom-pm';\nconst repo = 'badges';\n\nasync function uploadFileAndGetUrl(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    const fileIoUrl = 'https://file.io';\n    try {\n        const response = await fetch(fileIoUrl, { method: 'POST', body: formData });\n        if (!response.ok) throw new Error(`Error uploading file: HTTP Status ${response.status}`);\n        return await response.json().then(data => data.link);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadToPastebin(data) {\n    const pasteData = new URLSearchParams();\n    pasteData.append('api_dev_key', 'br8Eql2caUTF9pzA6VXyTFnZP2HOcfUa'); // Your Pastebin API Developer Key\n    pasteData.append('api_option', 'paste');\n    pasteData.append('api_paste_code', data);\n    pasteData.append('api_paste_private', '1'); // Unlisted\n    pasteData.append('api_paste_expire_date', 'N'); // Never expire\n\n    try {\n        const response = await fetch('https://pastebin.com/api/api_post.php', {\n            method: 'POST',\n            body: pasteData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.text();\n        return result; // Return the Pastebin URL\n    } catch (error) {\n        console.error('Error uploading to Pastebin:', error);\n    }\n}\n\nasync function uploadToGitHub(filename, data, isFile = false) {\n    const path = (isFile ? 'svg/' : 'assertions/') + filename;\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n    let sha = await getGithubFileSha(url);\n    let bodyData = prepareGithubRequestBody(data, sha, filename, isFile);\n    try {\n        const response = await fetch(url, {\n            method: 'PUT',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(bodyData)\n        });\n        if (!response.ok) throw new Error(`Error uploading to GitHub: HTTP Status ${response.status}`);\n        const responseData = await response.json();\n        return isFile ? responseData.content.download_url.replace('blob/', '') : responseData.content.html_url;\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl) {\n    let phpUploadServiceUrl = 'http://draw.wayway.ai/makefile.php'; // URL to your PHP script\n\n    // Prepare the JSON payload\n    let payload = JSON.stringify({\n        svgString: svgFileString,\n        recordID: recordId,\n    });\n\n    console.log(\"Sending payload:\", payload);\n\n    // Send the data to your PHP server\n    try {\n        const response = await fetch(phpUploadServiceUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: payload\n        });\n\n        console.log('Response status:', response.status);\n        console.log('Response headers:', response.headers);\n\n        if (!response.ok) {\n            throw new Error(`HTTP status ${response.status}`);\n        }\n\n        const data = await response.json(); // Parse the response as JSON\n        console.log('Server response:', data);\n\n        if (data.status === \"error\") {\n            console.error('Error from server:', data.message);\n        } else {\n            console.log('File uploaded successfully:', data.message);\n            let uploadedFileUrl = `https://draw.wayway.ai/uploads/${recordId}.svg`;\n            console.log('Uploaded File URL:', uploadedFileUrl);\n            console.log('SVG Data URL:', svgDataUrl);\n            await table.updateRecordAsync(record, { 'Level Icon Online': svgUploadUrl, 'Baked SVG Attachment': [{ url: uploadedFileUrl }], 'Baked SVG Data URL': svgDataUrl });\n        }\n    } catch (error) {\n        console.error('Error uploading file:', error);\n    }\n}\n\nasync function getGithubFileSha(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' }\n        });\n        if (response.ok) {\n            const fileData = await response.json();\n            return fileData.sha;\n        }\n    } catch (error) {\n        console.error('Error checking for existing file on GitHub:', error.message);\n    }\n    return null;\n}\n\nfunction prepareGithubRequestBody(data, sha, filename, isFile) {\n    let content = isFile ? base64Encode(data) : base64Encode(unescape(encodeURIComponent(JSON.stringify(data))));\n    let bodyData = { message: `Creating or updating file ${filename}`, content: content };\n    if (sha) bodyData.sha = sha;\n    return bodyData;\n}\n\nfunction base64Encode(str) {\n    // Define the base64 characters\n    const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    // Convert the input string into an array of character codes\n    const bytes = [];\n    for (let i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n\n    // Convert bytes to base64\n    let base64 = '';\n    for (let i = 0; i < bytes.length; i += 3) {\n        // Combine the next three bytes (24 bits) into one number\n        const triple = (bytes[i] << 16) + ((bytes[i + 1] || 0) << 8) + (bytes[i + 2] || 0);\n\n        // Extract four 6-bit segments and map to base64 characters\n        base64 += base64Chars[(triple >> 18) & 0x3F] +\n                  base64Chars[(triple >> 12) & 0x3F] +\n                  (i + 1 < bytes.length ? base64Chars[(triple >> 6) & 0x3F] : '=') +\n                  (i + 2 < bytes.length ? base64Chars[triple & 0x3F] : '=');\n    }\n\n    return base64;\n}\nvar hashEmail = function hashEmail(ascii) {\n\tfunction rightRotate(value, amount) {\n\t\treturn (value>>>amount) | (value<<(32 - amount));\n\t};\n\t\n\tvar mathPow = Math.pow;\n\tvar maxWord = mathPow(2, 32);\n\tvar lengthProperty = 'length'\n\tvar i, j; // Used as a counter across the whole file\n\tvar result = ''\n\n\tvar words = [];\n\tvar asciiBitLength = ascii[lengthProperty]*8;\n\t\n\t//* caching results is optional - remove/add slash from front of this line to toggle\n\t// Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n\t// (we actually calculate the first 64, but extra values are just ignored)\n\tvar hash = hashEmail.h = hashEmail.h || [];\n\t// Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n\tvar k = hashEmail.k = hashEmail.k || [];\n\tvar primeCounter = k[lengthProperty];\n\t/*/\n\tvar hash = [], k = [];\n\tvar primeCounter = 0;\n\t//*/\n\n\tvar isComposite = {};\n\tfor (var candidate = 2; primeCounter < 64; candidate++) {\n\t\tif (!isComposite[candidate]) {\n\t\t\tfor (i = 0; i < 313; i += candidate) {\n\t\t\t\tisComposite[i] = candidate;\n\t\t\t}\n\t\t\thash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\n\t\t\tk[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\n\t\t}\n\t}\n\t\n\tascii += '\\x80' // Append Ƈ' bit (plus zero padding)\n\twhile (ascii[lengthProperty]%64 - 56) ascii += '\\x00' // More zero padding\n\tfor (i = 0; i < ascii[lengthProperty]; i++) {\n\t\tj = ascii.charCodeAt(i);\n\t\tif (j>>8) return; // ASCII check: only accept characters in range 0-255\n\t\twords[i>>2] |= j << ((3 - i)%4)*8;\n\t}\n\twords[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\n\twords[words[lengthProperty]] = (asciiBitLength)\n\t\n\t// process each chunk\n\tfor (j = 0; j < words[lengthProperty];) {\n\t\tvar w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n\t\tvar oldHash = hash;\n\t\t// This is now the undefinedworking hash\", often labelled as variables a...g\n\t\t// (we have to truncate as well, otherwise extra entries at the end accumulate\n\t\thash = hash.slice(0, 8);\n\t\t\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tvar i2 = i + j;\n\t\t\t// Expand the message into 64 words\n\t\t\t// Used below if \n\t\t\tvar w15 = w[i - 15], w2 = w[i - 2];\n\n\t\t\t// Iterate\n\t\t\tvar a = hash[0], e = hash[4];\n\t\t\tvar temp1 = hash[7]\n\t\t\t\t+ (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n\t\t\t\t+ ((e&hash[5])^((~e)&hash[6])) // ch\n\t\t\t\t+ k[i]\n\t\t\t\t// Expand the message schedule if needed\n\t\t\t\t+ (w[i] = (i < 16) ? w[i] : (\n\t\t\t\t\t\tw[i - 16]\n\t\t\t\t\t\t+ (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\n\t\t\t\t\t\t+ w[i - 7]\n\t\t\t\t\t\t+ (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\n\t\t\t\t\t)|0\n\t\t\t\t);\n\t\t\t// This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n\t\t\tvar temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\n\t\t\t\t+ ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\n\t\t\t\n\t\t\thash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n\t\t\thash[4] = (hash[4] + temp1)|0;\n\t\t}\n\t\t\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\thash[i] = (hash[i] + oldHash[i])|0;\n\t\t}\n\t}\n\t\n\tfor (i = 0; i < 8; i++) {\n\t\tfor (j = 3; j + 1; j--) {\n\t\t\tvar b = (hash[i]>>(j*8))&255;\n\t\t\tresult += ((b < 16) ? 0 : '') + b.toString(16);\n\t\t}\n\t}\n\treturn result;\n};\n\n\nasync function processRecord(record) {\n    if (!record) {\n        console.error(\"No record selected or found\");\n        return;\n    }\n\n    let originalSVG = record.getCellValueAsString('SVG Text Unbaked');\n    if (!originalSVG) {\n        console.error(\"SVG Text Unbaked is missing from the record\");\n        return;\n    }\n\n    let badgeName = record.getCellValueAsString('Badge Name');\n    let earnerEmail = record.getCellValueAsString('For This User');\n    let hashedEmail = await hashEmail(earnerEmail);\n\n    let recordID = record.id;\n\n    let svgFilename = `${badgeName.replace(/\\s+/g, '_')}_badge.svg`;\n    let svgUploadUrl = await uploadToGitHub(svgFilename, originalSVG, true);\n    if (!svgUploadUrl) throw new Error(\"Failed to upload SVG to GitHub\");\n    // Upload Badge Assertion JSON to Pastebin and get the URL\n    let evidenceURL = await uploadToPastebin(record.getCellValueAsString('Evidence'));\n    evidenceURL = evidenceURL.replace('https://pastebin.com/', 'https://pastebin.com/raw/'); // Modify to use the raw URL\n\n    let badgeData = {\n        \"@context\": \"https://w3id.org/openbadges/v2\",\n        \"uid\": recordID,\n        \"recipient\": {\n            \"type\": \"email\",\n            \"hashed\": true,\n            \"identity\": hashedEmail\n        },\n        \"badge\": svgUploadUrl,\n        \"verification\": {\n            \"type\": \"hosted\",\n            \"url\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`\n        },\n        \"issuedOn\": new Date().toISOString(),\n        \"issuer\": {\n            \"id\": \"https://bloom.pm\",\n            \"name\": \"Bloom.pm\",\n            \"email\": \"bilal@bloom.pm\",\n            \"url\": \"https://bloom.pm\"\n        },\n        \"evidence\": evidenceURL,\n        \"narrative\": record.getCellValueAsString('Target Description'),\n        \"alignment\": {\n            \"targetName\": record.getCellValueAsString('Target Name'),\n            \"targetUrl\": record.getCellValueAsString('Target URL'),\n            \"targetDescription\": record.getCellValueAsString('Target Description'),\n            \"targetFramework\": record.getCellValueAsString('Target Framework')\n        }\n    };\n\n    let assertionFilename = `assertion_${recordID}.json`;\n    let assertionURL = await uploadToGitHub(assertionFilename, badgeData);\n\n    await table.updateRecordAsync(record, { \n        'Badge Assertion JSON URL': assertionURL \n    });\n\n    let updatedBadgeDataString = JSON.stringify(badgeData, null, 4);\n    let svgTagWithNamespace = '<svg xmlns:openbadges=\"http://openbadges.org\"';\n    if (!originalSVG.includes(svgTagWithNamespace)) {\n        originalSVG = originalSVG.replace('<svg', svgTagWithNamespace);\n    }\n\n    let bakedSVG = originalSVG.replace('</svg>', `<openbadges:assertion verification=\"${badgeData.verification.url}\"><![CDATA[${updatedBadgeDataString}]]></openbadges:assertion></svg>`);\n    let svgDataUrl = `data:image/svg+xml;base64,${base64Encode(unescape(encodeURIComponent(bakedSVG)))}`;\n\n    console.log('Baked SVG:', bakedSVG);\n    console.log('SVG Upload URL:', svgUploadUrl);\n    console.log('Record ID:', recordID);\n\n    await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl);\n}\n\nawait processRecord(record);",
      "created_at": "2024-05-22T15:18:44.260977",
      "sequence_order": 0,
      "parent_id": "05b6739c-3fd6-47ab-b01e-d6e64b9cde06",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "6ced9342-5b4a-4e8c-8e28-7dcfb9e69f0c",
      "role": "assistant",
      "content": "Sure, let's modify your script to save the badge file name with the specified fields: \"SEO:Slug\" or if that doesn't exist, \"For This First Name\", followed by an underscore, then \"Badge Requested\", another underscore, and finally \"Request Date\".\n\nHere's the updated script:\n\n```javascript\nlet inputConfig = input.config();\nlet table = base.getTable(\"Requests\");\nlet usersTable = base.getTable(\"Users\");\nlet recordId = inputConfig.scriptRecordID;\nlet queryResult = await table.selectRecordsAsync();\n// Find the specific record by recordId\nlet record = queryResult.getRecord(recordId);\n\n// Check if the record exists and log it\nif (record) {\n    console.log(record);\n} else {\n    console.log(\"Record not found\");\n}\n\nconst githubToken = 'ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED';\nconst owner = 'bloom-pm';\nconst repo = 'badges';\n\nasync function uploadFileAndGetUrl(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    const fileIoUrl = 'https://file.io';\n    try {\n        const response = await fetch(fileIoUrl, { method: 'POST', body: formData });\n        if (!response.ok) throw new Error(`Error uploading file: HTTP Status ${response.status}`);\n        return await response.json().then(data => data.link);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadToPastebin(data) {\n    const pasteData = new URLSearchParams();\n    pasteData.append('api_dev_key', 'br8Eql2caUTF9pzA6VXyTFnZP2HOcfUa'); // Your Pastebin API Developer Key\n    pasteData.append('api_option', 'paste');\n    pasteData.append('api_paste_code', data);\n    pasteData.append('api_paste_private', '1'); // Unlisted\n    pasteData.append('api_paste_expire_date', 'N'); // Never expire\n\n    try {\n        const response = await fetch('https://pastebin.com/api/api_post.php', {\n            method: 'POST',\n            body: pasteData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.text();\n        return result; // Return the Pastebin URL\n    } catch (error) {\n        console.error('Error uploading to Pastebin:', error);\n    }\n}\n\nasync function uploadToGitHub(filename, data, isFile = false) {\n    const path = (isFile ? 'svg/' : 'assertions/') + filename;\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n    let sha = await getGithubFileSha(url);\n    let bodyData = prepareGithubRequestBody(data, sha, filename, isFile);\n    try {\n        const response = await fetch(url, {\n            method: 'PUT',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(bodyData)\n        });\n        if (!response.ok) throw new Error(`Error uploading to GitHub: HTTP Status ${response.status}`);\n        const responseData = await response.json();\n        return isFile ? responseData.content.download_url.replace('blob/', '') : responseData.content.html_url;\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl) {\n    let phpUploadServiceUrl = 'http://draw.wayway.ai/makefile.php'; // URL to your PHP script\n\n    // Prepare the JSON payload\n    let payload = JSON.stringify({\n        svgString: svgFileString,\n        recordID: recordId,\n    });\n\n    console.log(\"Sending payload:\", payload);\n\n    // Send the data to your PHP server\n    try {\n        const response = await fetch(phpUploadServiceUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: payload\n        });\n\n        console.log('Response status:', response.status);\n        console.log('Response headers:', response.headers);\n\n        if (!response.ok) {\n            throw new Error(`HTTP status ${response.status}`);\n        }\n\n        const data = await response.json(); // Parse the response as JSON\n        console.log('Server response:', data);\n\n        if (data.status === \"error\") {\n            console.error('Error from server:', data.message);\n        } else {\n            console.log('File uploaded successfully:', data.message);\n            let uploadedFileUrl = `https://draw.wayway.ai/uploads/${recordId}.svg`;\n            console.log('Uploaded File URL:', uploadedFileUrl);\n            console.log('SVG Data URL:', svgDataUrl);\n            await table.updateRecordAsync(record, { 'Level Icon Online': svgUploadUrl, 'Baked SVG Attachment': [{ url: uploadedFileUrl }], 'Baked SVG Data URL': svgDataUrl });\n        }\n    } catch (error) {\n        console.error('Error uploading file:', error);\n    }\n}\n\nasync function getGithubFileSha(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' }\n        });\n        if (response.ok) {\n            const fileData = await response.json();\n            return fileData.sha;\n        }\n    } catch (error) {\n        console.error('Error checking for existing file on GitHub:', error.message);\n    }\n    return null;\n}\n\nfunction prepareGithubRequestBody(data, sha, filename, isFile) {\n    let content = isFile ? base64Encode(data) : base64Encode(unescape(encodeURIComponent(JSON.stringify(data))));\n    let bodyData = { message: `Creating or updating file ${filename}`, content: content };\n    if (sha) bodyData.sha = sha;\n    return bodyData;\n}\n\nfunction base64Encode(str) {\n    // Define the base64 characters\n    const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    // Convert the input string into an array of character codes\n    const bytes = [];\n    for (let i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n\n    // Convert bytes to base64\n    let base64 = '';\n    for (let i = 0; i < bytes.length; i += 3) {\n        // Combine the next three bytes (24 bits) into one number\n        const triple = (bytes[i] << 16) + ((bytes[i + 1] || 0) << 8) + (bytes[i + 2] || 0);\n\n        // Extract four 6-bit segments and map to base64 characters\n        base64 += base64Chars[(triple >> 18) & 0x3F] +\n                  base64Chars[(triple >> 12) & 0x3F] +\n                  (i + 1 < bytes.length ? base64Chars[(triple >> 6) & 0x3F] : '=') +\n                  (i + 2 < bytes.length ? base64Chars[triple & 0x3F] : '=');\n    }\n\n    return base64;\n}\nvar hashEmail = function hashEmail(ascii) {\n    function rightRotate(value, amount) {\n        return (value>>>amount) | (value<<(32 - amount));\n    };\n    \n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length'\n    var i, j; // Used as a counter across the whole file\n    var result = ''\n\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty]*8;\n    \n    //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n    var hash = hashEmail.h = hashEmail.h || [];\n    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n    var k = hashEmail.k = hashEmail.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\n    var hash = [], k = [];\n    var primeCounter = 0;\n    //*/\n\n    var isComposite = {};\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n        if (!isComposite[candidate]) {\n            for (i = 0; i < 313; i += candidate) {\n                isComposite[i] = candidate;\n            }\n            hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\n            k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\n        }\n    }\n    \n    ascii += '\\x80' // Append Ƈ' bit (plus zero padding)\n    while (ascii[lengthProperty]%64 - 56) ascii += '\\x00' // More zero padding\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n        j = ascii.charCodeAt(i);\n        if (j>>8) return; // ASCII check: only accept characters in range 0-255\n        words[i>>2] |= j << ((3 - i)%4)*8;\n    }\n    words[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\n    words[",
      "created_at": "2024-05-22T15:20:03.886694",
      "sequence_order": 1,
      "parent_id": "aaa27c81-bdf3-46c4-9beb-9c6dcb78c069",
      "metadata": {
        "status": "finished_partial_completion",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "5ce3dd10-f4ac-4141-a324-820b934e69fe",
      "role": "assistant",
      "content": "words[lengthProperty]] = (asciiBitLength)\n    \n    // process each chunk\n    for (j = 0; j < words[lengthProperty];) {\n        var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n        var oldHash = hash;\n        // This is now the working hash\", often labelled as variables a...g\n        // (we have to truncate as well, otherwise extra entries at the end accumulate\n        hash = hash.slice(0, 8);\n        \n        for (i = 0; i < 64; i++) {\n            var i2 = i + j;\n            // Expand the message into 64 words\n            // Used below if \n            var w15 = w[i - 15], w2 = w[i - 2];\n\n            // Iterate\n            var a = hash[0], e = hash[4];\n            var temp1 = hash[7]\n                + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n                + ((e&hash[5])^((~e)&hash[6])) // ch\n                + k[i]\n                // Expand the message schedule if needed\n                + (w[i] = (i < 16) ? w[i] : (\n                        w[i - 16]\n                        + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\n                        + w[i - 7]\n                        + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\n                    )|0\n                );\n            // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadable\n            var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\n                + ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\n            \n            hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n            hash[4] = (hash[4] + temp1)|0;\n        }\n        \n        for (i = 0; i < 8; i++) {\n            hash[i] = (hash[i] + oldHash[i])|0;\n        }\n    }\n    \n    for (i = 0; i < 8; i++) {\n        for (j = 3; j + 1; j--) {\n            var b = (hash[i]>>(j*8))&255;\n            result += ((b < 16) ? 0 : '') + b.toString(16);\n        }\n    }\n    return result;\n};\n\nasync function processRecord(record) {\n    if (!record) {\n        console.error(\"No record selected or found\");\n        return;\n    }\n\n    let originalSVG = record.getCellValueAsString('SVG Text Unbaked');\n    if (!originalSVG) {\n        console.error(\"SVG Text Unbaked is missing from the record\");\n        return;\n    }\n\n    let badgeName = record.getCellValueAsString('Badge Name');\n    let earnerEmail = record.getCellValueAsString('For This User');\n    let hashedEmail = await hashEmail(earnerEmail);\n\n    let recordID = record.id;\n\n    let seoSlug = record.getCellValueAsString('SEO:Slug') || record.getCellValueAsString('For This First Name');\n    let badgeRequested = record.getCellValueAsString('Badge Requested');\n    let requestDate = record.getCellValueAsString('Request Date');\n    let svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\n\n    let svgUploadUrl = await uploadToGitHub(svgFilename, originalSVG, true);\n    if (!svgUploadUrl) throw new Error(\"Failed to upload SVG to GitHub\");\n\n    // Upload Badge Assertion JSON to Pastebin and get the URL\n    let evidenceURL = await uploadToPastebin(record.getCellValueAsString('Evidence'));\n    evidenceURL = evidenceURL.replace('https://pastebin.com/', 'https://pastebin.com/raw/'); // Modify to use the raw URL\n\n    let badgeData = {\n        \"@context\": \"https://w3id.org/openbadges/v2\",\n        \"uid\": recordID,\n        \"recipient\": {\n            \"type\": \"email\",\n            \"hashed\": true,\n            \"identity\": hashedEmail\n        },\n        \"badge\": svgUploadUrl,\n        \"verification\": {\n            \"type\": \"hosted\",\n            \"url\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`\n        },\n        \"issuedOn\": new Date().toISOString(),\n        \"issuer\": {\n            \"id\": \"https://bloom.pm\",\n            \"name\": \"Bloom.pm\",\n            \"email\": \"bilal@bloom.pm\",\n            \"url\": \"https://bloom.pm\"\n        },\n        \"evidence\": evidenceURL,\n        \"narrative\": record.getCellValueAsString('Target Description'),\n        \"alignment\": {\n            \"targetName\": record.getCellValueAsString('Target Name'),\n            \"targetUrl\": record.getCellValueAsString('Target URL'),\n            \"targetDescription\": record.getCellValueAsString('Target Description'),\n            \"targetFramework\": record.getCellValueAsString('Target Framework')\n        }\n    };\n\n    let assertionFilename = `assertion_${recordID}.json`;\n    let assertionURL = await uploadToGitHub(assertionFilename, badgeData);\n\n    await table.updateRecordAsync(record, { \n        'Badge Assertion JSON URL': assertionURL \n    });\n\n    let updatedBadgeDataString = JSON.stringify(badgeData, null, 4);\n    let svgTagWithNamespace = '<svg xmlns:openbadges=\"http://openbadges.org\"';\n    if (!originalSVG.includes(svgTagWithNamespace)) {\n        originalSVG = originalSVG.replace('<svg', svgTagWithNamespace);\n    }\n\n    let bakedSVG = originalSVG.replace('</svg>', `<openbadges:assertion verification=\"${badgeData.verification.url}\"><![CDATA[${updatedBadgeDataString}]]></openbadges:assertion></svg>`);\n    let svgDataUrl = `data:image/svg+xml;base64,${base64Encode(unescape(encodeURIComponent(bakedSVG)))}`;\n\n    console.log('Baked SVG:', bakedSVG);\n    console.log('SVG Upload URL:', svgUploadUrl);\n    console.log('Record ID:', recordID);\n\n    await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl);\n}\n\nawait processRecord(record);\n```\n\nIn this updated script, the `svgFilename` is constructed using the \"SEO:Slug\" if it exists, or \"For This First Name\" if it doesn't, followed by \"Badge Requested\" and \"Request Date\" separated by underscores. This filename is then used in the `uploadToGitHub` function call.",
      "created_at": "2024-05-22T15:55:41.983342",
      "sequence_order": 2,
      "parent_id": "6ced9342-5b4a-4e8c-8e28-7dcfb9e69f0c",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2418d-2934-44b3-90d4-964c17ec65b8",
      "role": "user",
      "content": "Baked SVG Attachment is still being uploaded with the recordid",
      "created_at": "2024-05-22T22:40:03.539345",
      "sequence_order": 3,
      "parent_id": "5ce3dd10-f4ac-4141-a324-820b934e69fe",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "bff93ce6-6433-4714-9ba7-20768c1fbd5c",
      "role": "assistant",
      "content": "",
      "created_at": "2024-05-22T22:40:59.584625",
      "sequence_order": 4,
      "parent_id": "bb816d81-ff7a-4105-8782-13b3daf859ea",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "3c57eca4-184b-43c3-aa0c-dfd33116cdb2",
      "role": "assistant",
      "content": "To ensure the `Baked SVG Attachment` is uploaded with the correct filename format, let's update the function `uploadFileAndSaveIt` to use the new filename convention. We will also pass the `seoSlug`, `badgeRequested`, and `requestDate` values to the function. Here’s the revised script:\n\n```javascript\nlet inputConfig = input.config();\nlet table = base.getTable(\"Requests\");\nlet usersTable = base.getTable(\"Users\");\nlet recordId = inputConfig.scriptRecordID;\nlet queryResult = await table.selectRecordsAsync();\n// Find the specific record by recordId\nlet record = queryResult.getRecord(recordId);\n\n// Check if the record exists and log it\nif (record) {\n    console.log(record);\n} else {\n    console.log(\"Record not found\");\n}\n\nconst githubToken = 'ghp_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED';\nconst owner = 'bloom-pm';\nconst repo = 'badges';\n\nasync function uploadFileAndGetUrl(file) {\n    const formData = new FormData();\n    formData.append('file', file);\n    const fileIoUrl = 'https://file.io';\n    try {\n        const response = await fetch(fileIoUrl, { method: 'POST', body: formData });\n        if (!response.ok) throw new Error(`Error uploading file: HTTP Status ${response.status}`);\n        return await response.json().then(data => data.link);\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadToPastebin(data) {\n    const pasteData = new URLSearchParams();\n    pasteData.append('api_dev_key', 'br8Eql2caUTF9pzA6VXyTFnZP2HOcfUa'); // Your Pastebin API Developer Key\n    pasteData.append('api_option', 'paste');\n    pasteData.append('api_paste_code', data);\n    pasteData.append('api_paste_private', '1'); // Unlisted\n    pasteData.append('api_paste_expire_date', 'N'); // Never expire\n\n    try {\n        const response = await fetch('https://pastebin.com/api/api_post.php', {\n            method: 'POST',\n            body: pasteData,\n        });\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n\n        const result = await response.text();\n        return result; // Return the Pastebin URL\n    } catch (error) {\n        console.error('Error uploading to Pastebin:', error);\n    }\n}\n\nasync function uploadToGitHub(filename, data, isFile = false) {\n    const path = (isFile ? 'svg/' : 'assertions/') + filename;\n    const url = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n    let sha = await getGithubFileSha(url);\n    let bodyData = prepareGithubRequestBody(data, sha, filename, isFile);\n    try {\n        const response = await fetch(url, {\n            method: 'PUT',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' },\n            body: JSON.stringify(bodyData)\n        });\n        if (!response.ok) throw new Error(`Error uploading to GitHub: HTTP Status ${response.status}`);\n        const responseData = await response.json();\n        return isFile ? responseData.content.download_url.replace('blob/', '') : responseData.content.html_url;\n    } catch (error) {\n        console.error(error.message);\n    }\n}\n\nasync function uploadFileAndSaveIt(svgFileString, svgUploadUrl, recordId, svgDataUrl, filename) {\n    let phpUploadServiceUrl = 'http://draw.wayway.ai/makefile.php'; // URL to your PHP script\n\n    // Prepare the JSON payload\n    let payload = JSON.stringify({\n        svgString: svgFileString,\n        recordID: recordId,\n    });\n\n    console.log(\"Sending payload:\", payload);\n\n    // Send the data to your PHP server\n    try {\n        const response = await fetch(phpUploadServiceUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: payload\n        });\n\n        console.log('Response status:', response.status);\n        console.log('Response headers:', response.headers);\n\n        if (!response.ok) {\n            throw new Error(`HTTP status ${response.status}`);\n        }\n\n        const data = await response.json(); // Parse the response as JSON\n        console.log('Server response:', data);\n\n        if (data.status === \"error\") {\n            console.error('Error from server:', data.message);\n        } else {\n            console.log('File uploaded successfully:', data.message);\n            let uploadedFileUrl = `https://draw.wayway.ai/uploads/${filename}.svg`;\n            console.log('Uploaded File URL:', uploadedFileUrl);\n            console.log('SVG Data URL:', svgDataUrl);\n            await table.updateRecordAsync(record, { 'Level Icon Online': svgUploadUrl, 'Baked SVG Attachment': [{ url: uploadedFileUrl }], 'Baked SVG Data URL': svgDataUrl });\n        }\n    } catch (error) {\n        console.error('Error uploading file:', error);\n    }\n}\n\nasync function getGithubFileSha(url) {\n    try {\n        const response = await fetch(url, {\n            method: 'GET',\n            headers: { 'Authorization': `Bearer ${githubToken}`, 'Content-Type': 'application/json' }\n        });\n        if (response.ok) {\n            const fileData = await response.json();\n            return fileData.sha;\n        }\n    } catch (error) {\n        console.error('Error checking for existing file on GitHub:', error.message);\n    }\n    return null;\n}\n\nfunction prepareGithubRequestBody(data, sha, filename, isFile) {\n    let content = isFile ? base64Encode(data) : base64Encode(unescape(encodeURIComponent(JSON.stringify(data))));\n    let bodyData = { message: `Creating or updating file ${filename}`, content: content };\n    if (sha) bodyData.sha = sha;\n    return bodyData;\n}\n\nfunction base64Encode(str) {\n    // Define the base64 characters\n    const base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    // Convert the input string into an array of character codes\n    const bytes = [];\n    for (let i = 0; i < str.length; i++) {\n        bytes.push(str.charCodeAt(i));\n    }\n\n    // Convert bytes to base64\n    let base64 = '';\n    for (let i = 0; i < bytes.length; i += 3) {\n        // Combine the next three bytes (24 bits) into one number\n        const triple = (bytes[i] << 16) + ((bytes[i + 1] || 0) << 8) + (bytes[i + 2] || 0);\n\n        // Extract four 6-bit segments and map to base64 characters\n        base64 += base64Chars[(triple >> 18) & 0x3F] +\n                  base64Chars[(triple >> 12) & 0x3F] +\n                  (i + 1 < bytes.length ? base64Chars[(triple >> 6) & 0x3F] : '=') +\n                  (i + 2 < bytes.length ? base64Chars[triple & 0x3F] : '=');\n    }\n\n    return base64;\n}\nvar hashEmail = function hashEmail(ascii) {\n    function rightRotate(value, amount) {\n        return (value>>>amount) | (value<<(32 - amount));\n    };\n    \n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length'\n    var i, j; // Used as a counter across the whole file\n    var result = ''\n\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty]*8;\n    \n    //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n    var hash = hashEmail.h = hashEmail.h || [];\n    // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n    var k = hashEmail.k = hashEmail.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\n    var hash = [], k = [];\n    var primeCounter = 0;\n    //*/\n\n    var isComposite = {};\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n        if (!isComposite[candidate]) {\n            for (i = 0; i < 313; i += candidate) {\n                isComposite[i] = candidate;\n            }\n            hash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\n            k[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\n        }\n    }\n    \n    ascii += '\\x80' // Append Ƈ' bit (plus zero padding)\n    while (ascii[lengthProperty]%64 - 56) ascii += '\\x00' // More zero padding\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n        j = ascii.charCodeAt(i);\n        if (j>>8) return; // ASCII check: only accept characters in range 0-255\n        words[i>>2] |= j << ((3 - i)%4)*8;\n    }\n    words[words[lengthProperty]] = ((asciiBitLength/max",
      "created_at": "2024-05-22T22:40:59.584810",
      "sequence_order": 5,
      "parent_id": "bff93ce6-6433-4714-9ba7-20768c1fbd5c",
      "metadata": {
        "status": "finished_partial_completion",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "26670d18-adb3-497e-84ed-6cdb2513749a",
      "role": "assistant",
      "content": "Word)|0);\n    words[words[lengthProperty]] = (asciiBitLength)\n    \n    // process each chunk\n    for (j = 0; j < words[lengthProperty];) {\n        var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n        var oldHash = hash;\n        // This is now the working hash\", often labelled as variables a...g\n        // (we have to truncate as well, otherwise extra entries at the end accumulate\n        hash = hash.slice(0, 8);\n        \n        for (i = 0; i < 64; i++) {\n            var i2 = i + j;\n            // Expand the message into 64 words\n            // Used below if \n            var w15 = w[i - 15], w2 = w[i - 2];\n\n            // Iterate\n            var a = hash[0], e = hash[4];\n            var temp1 = hash[7]\n                + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n                + ((e&hash[5])^((~e)&hash[6])) // ch\n                + k[i]\n                // Expand the message schedule if needed\n                + (w[i] = (i < 16) ? w[i] : (\n                        w[i - 16]\n                        + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\n                        + w[i - 7]\n                        + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\n                    )|0\n                );\n            // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n            var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\n                + ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\n            \n            hash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n            hash[4] = (hash[4] + temp1)|0;\n        }\n        \n        for (i = 0; i < 8; i++) {\n            hash[i] = (hash[i] + oldHash[i])|0;\n        }\n    }\n    \n    for (i = 0; i < 8; i++) {\n        for (j = 3; j + 1; j--) {\n            var b = (hash[i]>>(j*8))&255;\n            result += ((b < 16) ? 0 : '') + b.toString(16);\n        }\n    }\n    return result;\n};\n\nasync function processRecord(record) {\n    if (!record) {\n        console.error(\"No record selected or found\");\n        return;\n    }\n\n    let originalSVG = record.getCellValueAsString('SVG Text Unbaked');\n    if (!originalSVG) {\n        console.error(\"SVG Text Unbaked is missing from the record\");\n        return;\n    }\n\n    let badgeName = record.getCellValueAsString('Badge Name');\n    let earnerEmail = record.getCellValueAsString('For This User');\n    let hashedEmail = await hashEmail(earnerEmail);\n\n    let recordID = record.id;\n\n    let seoSlug = record.getCellValueAsString('SEO:Slug') || record.getCellValueAsString('For This First Name');\n    let badgeRequested = record.getCellValueAsString('Badge Requested');\n    let requestDate = record.getCellValueAsString('Request Date');\n    let svgFilename = `${seoSlug}_${badgeRequested}_${requestDate}.svg`;\n\n    let svgUploadUrl = await uploadToGitHub(svgFilename, originalSVG, true);\n    if (!svgUploadUrl) throw new Error(\"Failed to upload SVG to GitHub\");\n\n    // Upload Badge Assertion JSON to Pastebin and get the URL\n    let evidenceURL = await uploadToPastebin(record.getCellValueAsString('Evidence'));\n    evidenceURL = evidenceURL.replace('https://pastebin.com/', 'https://pastebin.com/raw/'); // Modify to use the raw URL\n\n    let badgeData = {\n        \"@context\": \"https://w3id.org/openbadges/v2\",\n        \"uid\": recordID,\n        \"recipient\": {\n            \"type\": \"email\",\n            \"hashed\": true,\n            \"identity\": hashedEmail\n        },\n        \"badge\": svgUploadUrl,\n        \"verification\": {\n            \"type\": \"hosted\",\n            \"url\": `https://raw.githubusercontent.com/${owner}/${repo}/main/assertions/assertion_${recordID}.json`\n        },\n        \"issuedOn\": new Date().toISOString(),\n        \"issuer\": {\n            \"id\": \"https://bloom.pm\",\n            \"name\": \"Bloom.pm\",\n            \"email\": \"bilal@bloom.pm\",\n            \"url\": \"https://bloom.pm\"\n        },\n        \"evidence\": evidenceURL,\n        \"narrative\": record.getCellValueAsString('Target Description'),\n        \"alignment\": {\n            \"targetName\": record.getCellValueAsString('Target Name'),\n            \"targetUrl\": record.getCellValueAsString('Target URL'),\n            \"targetDescription\": record.getCellValueAsString('Target Description'),\n            \"targetFramework\": record.getCellValueAsString('Target Framework')\n        }\n    };\n\n    let assertionFilename = `assertion_${recordID}.json`;\n    let assertionURL = await uploadToGitHub(assertionFilename, badgeData);\n\n    await table.updateRecordAsync(record, { \n        'Badge Assertion JSON URL': assertionURL \n    });\n\n    let updatedBadgeDataString = JSON.stringify(badgeData, null, 4);\n    let svgTagWithNamespace = '<svg xmlns:openbadges=\"http://openbadges.org\"';\n    if (!originalSVG.includes(svgTagWithNamespace)) {\n        originalSVG = originalSVG.replace('<svg', svgTagWithNamespace);\n    }\n\n    let bakedSVG = originalSVG.replace('</svg>', `<openbadges:assertion verification=\"${badgeData.verification.url}\"><![CDATA[${updatedBadgeDataString}]]></openbadges:assertion></svg>`);\n    let svgDataUrl = `data:image/svg+xml;base64,${base64Encode(unescape(encodeURIComponent(bakedSVG)))}`;\n\n    console.log('Baked SVG:', bakedSVG);\n    console.log('SVG Upload URL:', svgUploadUrl);\n    console.log('Record ID:', recordID);\n\n    await uploadFileAndSaveIt(bakedSVG, svgUploadUrl, recordID, svgDataUrl, svgFilename);\n}\n\nawait processRecord(record);\n```\n\nIn this updated script, `uploadFileAndSaveIt` now takes an additional `filename` parameter and uses it to construct the correct URL for the uploaded file. The `filename` is passed from the `processRecord` function, ensuring the correct naming convention is maintained throughout the process.",
      "created_at": "2024-05-22T22:49:05.817618",
      "sequence_order": 6,
      "parent_id": "3c57eca4-184b-43c3-aa0c-dfd33116cdb2",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    }
  ]
}