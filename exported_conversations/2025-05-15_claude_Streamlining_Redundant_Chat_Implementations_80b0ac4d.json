{
  "id": "80b0ac4d-171d-42ff-85e1-2bfabc9f6111",
  "source": "claude",
  "title": "Streamlining Redundant Chat Implementations",
  "created_at": "2025-05-15T20:39:37.129262Z",
  "updated_at": "2025-05-15T21:00:57.173097Z",
  "summary": "",
  "message_count": 4,
  "messages": [
    {
      "id": "d5dcb9d5-8dca-4d7a-88c6-6cbe7a179de2",
      "role": "human",
      "content": "",
      "created_at": "2025-05-15T20:43:20.922497Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-15T20:43:20.917902Z",
            "stop_timestamp": "2025-05-15T20:43:20.917902Z",
            "flags": null,
            "type": "text",
            "text": "",
            "citations": []
          }
        ],
        "updated_at": "2025-05-15T20:43:20.922497Z",
        "attachments": [
          {
            "file_name": "paste.txt",
            "file_size": 487058,
            "file_type": "txt",
            "extracted_content": "can you fix and streamline the streaming text issue in my code: [[[# Look for chat panel components\nfind ./src -type f -name \"*.tsx\" -o -name \"*.jsx\" | grep -i \"chatpanel\\|chatinterface\" | sort\nzsh: command not found: #\n\n        content: answer,\n        timestamp: new Date().toISOString()\n      };\n      \n      setMessages(prev => [...prev, aiMessage]);\n      \n      // Update the node content if we're editing an existing node\n      if (activeNodeId) {\n        await updateNode(activeNodeId, {\n          content: answer\n        });\n      }\n      \n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-200 px-4 py-3\">\n        <div className=\"flex items-center\">\n          <h3 className=\"font-medium text-gray-800\">\n            {activeNodeId \n              ? `Chat with ${nodes[activeNodeId]?.type || 'Node'}`\n              : 'Notebook Chat'\n            }\n          </h3>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className={`text-xs px-2 py-1 rounded ${\n              contextMode === 'thread'\n                ? 'bg-blue-100 text-blue-800'\n                : 'bg-gray-100 text-gray-600'\n            }`}\n            onClick={() => setContextMode('thread')}\n            title=\"Only include messages in the current thread\"\n          >\n            Thread\n          </button>\n          <button\n            className={`text-xs px-2 py-1 rounded ${\n              contextMode === 'all'\n                ? 'bg-blue-100 text-blue-800'\n                : 'bg-gray-100 text-gray-600'\n            }`}\n            onClick={() => setContextMode('all')}\n            title=\"Include all messages in the notebook\"\n          >\n            All\n          </button>\n          <button\n            className=\"ml-2 text-gray-500 hover:text-gray-700\"\n            onClick={onClose}\n            aria-label=\"Close chat panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {/* System message indicator */}\n        {systemPrompt && (\n          <div className=\"flex justify-center mb-4\">\n            <span className=\"text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full\">\n              Using custom system prompt\n            </span>\n          </div>\n        )}\n        \n        {/* Message list */}\n        {messages\n          .filter(msg => msg.role !== 'system') // Don't show system messages\n          .map((message) => (\n            <ChatMessage\n              key={message.id}\n              message={message}\n              isHighlighted={message.nodeId === activeNodeId}\n            />\n          ))}\n        \n        {/* Loading indicator */}\n        {isLoading && (\n          <div className=\"flex justify-center\">\n            <div className=\"animate-pulse flex space-x-2\">\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n            </div>\n          </div>\n        )}\n        \n        {/* Element to scroll to */}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input */}\n      <ChatInput\n        notebookId={notebookId}\n        onSendMessage={handleSendMessage}\n        activeNodeId={activeNodeId}\n        disabled={isLoading}\n      />\n    </div>\n  );\n};\n\nexport default ChatPanel;\nðŸ“„ --- File: ./src/components/conversation/MessageInput.tsx ---\n/**\n * MessageInput Component\n * \n * A reusable component for sending messages in a conversation.\n * Supports auto-expanding textarea, keyboard shortcuts, and loading states.\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\n\nexport interface MessageInputProps {\n  onSendMessage: (message: string) => void;\n  isLoading?: boolean;\n  placeholder?: string;\n  initialValue?: string;\n  autoFocus?: boolean;\n  disabled?: boolean;\n  maxRows?: number;\n  sendOnEnter?: boolean;\n  className?: string;\n}\n\nexport const MessageInput: React.FC<MessageInputProps> = ({\n  onSendMessage,\n  isLoading = false,\n  placeholder = 'Type a message...',\n  initialValue = '',\n  autoFocus = false,\n  disabled = false,\n  maxRows = 5,\n  sendOnEnter = true,\n  className = '',\n}) => {\n  const [message, setMessage] = useState(initialValue);\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n  \n  // Auto-focus the textarea when the component mounts\n  useEffect(() => {\n    if (autoFocus && textareaRef.current) {\n      textareaRef.current.focus();\n    }\n  }, [autoFocus]);\n  \n  // Auto-resize the textarea as content grows\n  const resizeTextarea = () => {\n    const textarea = textareaRef.current;\n    if (!textarea) return;\n    \n    // Reset height to get the correct scrollHeight\n    textarea.style.height = 'auto';\n    \n    // Calculate the number of rows\n    const lineHeight = parseInt(getComputedStyle(textarea).lineHeight) || 20;\n    const paddingTop = parseInt(getComputedStyle(textarea).paddingTop) || 0;\n    const paddingBottom = parseInt(getComputedStyle(textarea).paddingBottom) || 0;\n    const rows = Math.min(\n      maxRows,\n      Math.floor((textarea.scrollHeight - paddingTop - paddingBottom) / lineHeight)\n    );\n    \n    // Set the height based on rows\n    textarea.style.height = `${rows * lineHeight + paddingTop + paddingBottom}px`;\n  };\n  \n  // Handle input changes and resize the textarea\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setMessage(e.target.value);\n    resizeTextarea();\n  };\n  \n  // Send the message\n  const sendMessage = () => {\n    const trimmedMessage = message.trim();\n    if (trimmedMessage && !isLoading && !disabled) {\n      onSendMessage(trimmedMessage);\n      setMessage('');\n      \n      // Reset textarea height\n      if (textareaRef.current) {\n        textareaRef.current.style.height = 'auto';\n      }\n    }\n  };\n  \n  // Handle key press events (Enter to send)\n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (sendOnEnter && e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      sendMessage();\n    }\n  };\n  \n  return (\n    <div className={`relative ${className}`}>\n      <textarea\n        ref={textareaRef}\n        value={message}\n        onChange={handleChange}\n        onKeyDown={handleKeyDown}\n        placeholder={placeholder}\n        disabled={isLoading || disabled}\n        className={`w-full p-3 pr-12 border rounded-lg shadow-sm resize-none focus:outline-none focus:ring-2 focus:ring-blue-500 \n          ${isLoading || disabled ? 'bg-gray-100 text-gray-500' : 'bg-white text-gray-900'}`}\n        rows={1}\n        aria-label=\"Message input\"\n      />\n      \n      {/* Send button */}\n      <button\n        onClick={sendMessage}\n        disabled={!message.trim() || isLoading || disabled}\n        className={`absolute right-2 bottom-2 p-2 rounded-full\n          ${!message.trim() || isLoading || disabled\n            ? 'bg-gray-300 text-gray-500 cursor-not-allowed'\n            : 'bg-blue-600 text-white hover:bg-blue-700'\n          } transition-colors`}\n        aria-label=\"Send message\"\n      >\n        {isLoading ? (\n          <div className=\"h-5 w-5 animate-spin rounded-full border-b-2 border-white\"></div>\n        ) : (\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n          </svg>\n        )}\n      </button>\n    </div>\n  );\n};\nðŸ“„ --- File: ./src/components/shadcn/input.tsx ---\nimport * as React from \"react\"\n\nimport { cn } from \"@/lib/utils\"\n\nexport type InputProps =\n  React.InputHTMLAttributes<HTMLInputElement>\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nInput.displayName = \"Input\"\n\nexport { Input }\nðŸ“„ --- File: ./src/components/ui/AISdkChat.tsx ---\n/**\n * AISdkChat Component\n * \n * Modern chat implementation using @ai-sdk/react and @llamaindex/chat-ui\n * Integrates with Shadcn components and supports AI SDK streaming\n */\nimport React, { useCallback, useEffect, useRef } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\nimport { useActiveNode, useSetActiveNode } from '@/stores';\nimport { useAISDKChat } from '@/hooks/useAISDKChat';\n\n// Model selector component with shadcn styles\nconst ModelSelector = ({ selectedModel, onChangeModel }: { \n  selectedModel: string; \n  onChangeModel: (model: string) => void;\n}) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\n// Custom file upload button\nconst FileUploadButton = () => {\n  return (\n    <div className=\"flex items-center\">\n      <button\n        type=\"button\"\n        className=\"inline-flex items-center p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100\"\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-5 w-5\"\n          viewBox=\"0 0 20 20\"\n          fill=\"currentColor\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      </button>\n    </div>\n  );\n};\n\ninterface AISdkChatProps {\n  notebookId: string;\n  systemPrompt?: string;\n  fullScreen?: boolean;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string;\n}\n\n// Error boundary component\nclass AISdkChatErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, info: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(\"ðŸ”´ AISdkChat Error:\", error);\n    console.error(\"Error info:\", info);\n    this.setState({ info });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-4 text-red-500 bg-red-50 rounded border border-red-200\">\n          <h3 className=\"font-bold\">Chat Component Error</h3>\n          <p className=\"text-sm mb-2\">There was an error loading the chat component.</p>\n          <details className=\"text-xs\">\n            <summary>Error details (for developers)</summary>\n            <pre className=\"mt-2 p-2 bg-gray-100 rounded overflow-x-auto\">\n              {this.state.error?.toString()}\n            </pre>\n            <div className=\"mt-2\">\n              Component Stack: {this.state.info?.componentStack}\n            </div>\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nconst AISdkChat: React.FC<AISdkChatProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  console.log(\"ðŸ”· AISdkChat: Initializing with\", { notebookId, initialQuestion });\n  \n  // Validate notebookId early\n  if (!notebookId) {\n    console.error('ðŸ”´ AISdkChat received empty notebookId');\n    return <div className=\"p-4 text-red-500\">Error: Missing notebook ID</div>;\n  }\n  \n  // State management\n  const initialQuestionCreatedRef = useRef(false);\n  \n  // Get active node\n  const activeNode = useActiveNode();\n  const setActiveNode = useSetActiveNode();\n  \n  // Event logging removed to simplify code\n\n  // Use our custom AI SDK hook\n  const { \n    messages,\n    input,\n    handleInputChange,\n    isLoading,\n    setMessages,\n    error,\n    currentModel,\n    handleModelChange,\n    handleSubmit,\n    isProcessing,\n    sendMessage\n  } = useAISDKChat({\n    notebookId,\n    systemPrompt,\n    modelId: 'claude-3-5-sonnet-20240620'\n  });\n\n  // Create a new thread or conversation\n  const handleCreateNewThread = useCallback(() => {\n    // Clear active node selection\n    setActiveNode(null);\n    \n    // Reset chat history but keep system message\n    const systemMessages = messages.filter(msg => msg.role === 'system');\n    setMessages(systemMessages);\n  }, [setActiveNode, messages, setMessages]);\n  \n  // Send initial question if provided\n  useEffect(() => {\n    const createInitialQuestion = async () => {\n      // Skip if already created, no initial question, or processing\n      if (initialQuestionCreatedRef.current || !initialQuestion || isProcessing || isLoading) {\n        return;\n      }\n\n      // Skip if any messages already exist\n      if (messages.length > 1) { // More than just system message\n        initialQuestionCreatedRef.current = true;\n        return;\n      }\n\n      try {\n        initialQuestionCreatedRef.current = true;\n        await sendMessage(initialQuestion);\n      } catch (error) {\n        console.error('Error creating initial question:', error);\n      }\n    };\n\n    createInitialQuestion();\n  }, [initialQuestion, isProcessing, isLoading, messages.length, sendMessage]);\n  \n  // Display error if AI SDK has one\n  if (error) {\n    console.error('ðŸ”´ AISdkChat error:', error);\n  }\n\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (\n            <>\n              {activeNode.type === 'question' ? 'Question' : 'Conversation'}\n              {activeNode.metadata?.tier && (\n                <span className=\"ml-2 text-xs bg-blue-100 px-2 py-0.5 rounded-full text-blue-800\">\n                  Tier {activeNode.metadata.tier}\n                </span>\n              )}\n            </>\n          ) : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={handleCreateNewThread}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"New conversation\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n          {onClose && (\n            <button \n              onClick={onClose}\n              className=\"text-gray-500 hover:text-gray-700\"\n              aria-label=\"Close panel\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n      \n      {/* Chat UI */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ChatSection \n          handler={{ \n            messages, \n            input, \n            handleInputChange, \n            handleSubmit,\n            isLoading: isLoading || isProcessing\n          }} \n          className=\"h-full\"\n        >\n          <ChatMessages className=\"h-[calc(100%-80px)] overflow-y-auto p-4\" />\n          <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n            <ChatInput.Form className=\"px-3 py-2\">\n              <ChatInput.Field \n                type=\"textarea\" \n                placeholder=\"Type your message...\" \n                className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n                disabled={isLoading || isProcessing}\n                onChange={handleInputChange}\n                value={input}\n              />\n              <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n                <ModelSelector\n                  selectedModel={currentModel}\n                  onChangeModel={handleModelChange}\n                />\n                <ChatInput.Upload>\n                  <FileUploadButton />\n                </ChatInput.Upload>\n              </div>\n              <ChatInput.Submit\n                disabled={isLoading || isProcessing}\n                className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n              >\n                {isLoading || isProcessing ? (\n  \n  // Scroll to bottom when new messages arrive\n  useEffect(() => {\n    messageEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [threads]);\n  \n  // Create a new thread or add message to existing thread\n  const handleSendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!message.trim() || !user) return;\n    \n    setIsLoading(true);\n    \n    try {\n      // Implement thread creation or message adding logic here\n      console.log('Sending message:', message);\n      \n      // Create a placeholder thread for demo purposes\n      const newThread: Thread = {\n        id: `thread-${Date.now()}`,\n        notebookId,\n        title: 'New Thread',\n        position: { x: 100, y: 100 },\n        messages: [\n          {\n            id: `msg-${Date.now()}`,\n            threadId: `thread-${Date.now()}`,\n            content: message,\n            role: 'user',\n            createdAt: new Date().toISOString()\n          }\n        ],\n        parentId: undefined,\n        referencedThreads: [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        cardType: 'note',\n        handwritingStyle: 'neat',\n        isMinimized: false,\n        zIndex: 1\n      };\n      \n      // Add the new thread to our local state\n      setThreads(prev => [...prev, newThread]);\n      \n      // Notify parent component\n      onNewThreadCreated(newThread);\n      \n      // Clear the input\n      setMessage('');\n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"w-80 h-full bg-white border-l border-gray-200 flex flex-col\">\n      {/* Header */}\n      <div className=\"p-4 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-lg\">Notebook Chat</h2>\n        <button\n          onClick={onClose}\n          className=\"rounded-full p-1 hover:bg-gray-100\"\n          aria-label=\"Close panel\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 text-gray-500\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n          </svg>\n        </button>\n      </div>\n      \n      {/* Chat messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {isLoading && threads.length === 0 ? (\n          <div className=\"flex justify-center py-10\">\n            <Spinner size=\"md\" color=\"primary\" label=\"Loading conversations...\" />\n          </div>\n        ) : threads.length === 0 ? (\n          <div className=\"text-center py-10 text-gray-500\">\n            <p>No conversations yet. Start by sending a message.</p>\n          </div>\n        ) : (\n          threads.map(thread => (\n            <div \n              key={thread.id} \n              className={`p-3 rounded-lg ${thread.id === activeThreadId ? 'bg-blue-50 border border-blue-100' : 'bg-gray-50'}`}\n            >\n              <div className=\"font-medium text-sm text-gray-700 mb-1\">{thread.title}</div>\n              <div className=\"space-y-2\">\n                {thread.messages.map(msg => (\n                  <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>\n                    <div className={`max-w-[80%] px-3 py-2 rounded-lg ${\n                      msg.role === 'user' \n                        ? 'bg-blue-600 text-white' \n                        : 'bg-gray-200 text-gray-800'\n                    }`}>\n                      {msg.content}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          ))\n        )}\n        <div ref={messageEndRef} />\n      </div>\n      \n      {/* Input area */}\n      <div className=\"p-4 border-t border-gray-200\">\n        <form onSubmit={handleSendMessage} className=\"flex\">\n          <input\n            type=\"text\"\n            placeholder=\"Type a message...\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n            disabled={isLoading}\n          />\n          <button\n            type=\"submit\"\n            className=\"px-4 py-2 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50\"\n            disabled={!message.trim() || isLoading}\n          >\n            {isLoading ? (\n              <Spinner size=\"sm\" color=\"white\" />\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            )}\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatPanel;\nðŸ“„ --- File: ./src/components/ui/DirectChatPanel.tsx ---\n/**\n * DirectChatPanel - Simple chat panel using direct fetch instead of the AI SDK\n */\nimport React, { useState, useRef } from 'react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface Message {\n  role: 'user' | 'assistant';\n  content: string;\n}\n\ninterface DirectChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst DirectChatPanel: React.FC<DirectChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Send a message to the API\n  const sendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!input.trim() || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Add the user message to the list\n      const userMessage: Message = {\n        role: 'user',\n        content: input.trim()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare the messages to send to the API\n      const messagesToSend = [\n        { role: 'system', content: systemPrompt },\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        userMessage\n      ];\n      \n      // Make the API request\n      const response = await fetch('/api/claude/chat-simple', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: messagesToSend,\n          notebookId,\n          model: 'claude-3-5-sonnet-20240620',\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      console.log('API response:', result);\n      \n      // Handle the assistant's response\n      if (Array.isArray(result) && result.length > 0) {\n        const assistantMessage = result[0];\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: assistantMessage.content\n        }]);\n      } else if (result.content) {\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: result.content\n        }]);\n      } else {\n        setError('Received unexpected response format from API');\n      }\n      \n      // Clear the input\n      setInput(\"\");\n      \n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Direct Chat</h2>\n        <p className=\"text-xs text-gray-500\">Using Claude 3.5 Sonnet</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {isLoading && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={sendMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            disabled={isLoading}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Error Display */}\n        {error && (\n          <div className=\"mt-2 p-2 text-sm text-red-600 bg-red-50 rounded\">\n            Error: {error}\n          </div>\n        )}\n        \n        {/* Debug Info */}\n        <div className=\"mt-2 text-xs text-gray-500\">\n          Status: {isLoading ? \"Loading\" : \"Ready\"} | Messages: {messages.length}\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default DirectChatPanel;\nðŸ“„ --- File: ./src/components/ui/input.tsx ---\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}\n\nconst Input = React.forwardRef<HTMLInputElement, InputProps>(\n  ({ className, type, ...props }, ref) => {\n    return (\n      <input\n        type={type}\n        className={cn(\n          \"flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50\",\n          className\n        )}\n        ref={ref}\n        {...props}\n      />\n    );\n  }\n);\nInput.displayName = \"Input\";\n\nexport { Input };\nðŸ“„ --- File: ./src/components/ui/LlamaChat.tsx ---\n// src/components/ui/LlamaChat.tsx\n'use client';\n\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\nimport { \n  useNodes, \n  useNodeActions, \n  useSelectedNode, \n  useActiveNode,\n  useUnifiedStore,\n  useUnifiedActions,\n  useChatMessages,\n  useRelationships\n} from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { Node } from '@/types/thread';\n\n// Custom file upload button component\nconst FileUploadButton = () => {\n  return (\n    <div className=\"flex items-center\">\n      <button\n        type=\"button\"\n        className=\"inline-flex items-center p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100\"\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-5 w-5\"\n          viewBox=\"0 0 20 20\"\n          fill=\"currentColor\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      </button>\n    </div>\n  );\n};\n\n// Model selector component\nconst ModelSelector = ({ selectedModel, onChangeModel }: { \n  selectedModel: string; \n  onChangeModel: (model: string) => void;\n}) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\ninterface LlamaChatProps {\n  notebookId: string;\n  systemPrompt?: string;\n  fullScreen?: boolean;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string; // Add initial question parameter\n}\n\n// Error boundary component\nclass LlamaChatErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, info: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(\"ðŸ”´ LlamaChat Error:\", error);\n    console.error(\"Error info:\", info);\n    this.setState({ info });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-4 text-red-500 bg-red-50 rounded border border-red-200\">\n          <h3 className=\"font-bold\">Chat Component Error</h3>\n          <p className=\"text-sm mb-2\">There was an error loading the chat component.</p>\n          <details className=\"text-xs\">\n            <summary>Error details (for developers)</summary>\n            <pre className=\"mt-2 p-2 bg-gray-100 rounded overflow-x-auto\">\n              {this.state.error?.toString()}\n            </pre>\n            <div className=\"mt-2\">\n              Component Stack: {this.state.info?.componentStack}\n            </div>\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nconst LlamaChat: React.FC<LlamaChatProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  console.log(\"ðŸ”· LlamaChat: Initializing with\", { notebookId, initialQuestion });\n  \n  // Validate notebookId early\n  if (!notebookId) {\n    console.error('ðŸ”´ LlamaChat received empty notebookId');\n    return <div className=\"p-4 text-red-500\">Error: Missing notebook ID</div>;\n  }\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionCreatedRef = useRef(false);\n  const syncedNodeRef = useRef(null);\n  const didInitialSyncRef = useRef(false);\n  \n  // Get nodes and actions from the node store\n  const nodes = useNodes();\n  const relationships = useRelationships();\n  const activeNode = useActiveNode();\n  const selectedNode = useSelectedNode();\n  const { \n    addNode, \n    createNodeRelationship, \n    setSelectedNode, \n    setActiveNode \n  } = useNodeActions();\n  \n  // Get unified store actions\n  const unifiedActions = useUnifiedActions();\n  \n  // Enhanced sync function that respects the hierarchy tiers\n  const syncChatWithNodes = async (notebookId: string) => {\n    try {\n      console.log('Synchronizing chat with nodes...');\n      \n      // First ensure nodes are loaded\n      if (Object.keys(nodes).length === 0) {\n        console.log('No nodes loaded, skipping sync');\n        return;\n      }\n      \n      // Step 1: Get the main question node (tier 1)\n      const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n      \n      if (!mainQuestionNode) {\n        console.log('No main question node found, showing all conversation nodes');\n        \n        // Fallback: Find all conversation nodes\n        const conversationNodes = Object.values(nodes)\n          .filter(node => node.isConversationNode || node.messages?.length > 0)\n          .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n        \n        // Extract all messages\n        let allMessages = [];\n        \n        for (const node of conversationNodes) {\n          if (node.messages && node.messages.length > 0) {\n            allMessages = [\n              ...allMessages,\n              ...node.messages.map((msg) => ({\n                ...msg,\n                nodeId: node.id\n              }))\n            ];\n          } else {\n            allMessages.push({\n              id: `node_${node.id}`,\n              role: node.type === 'question' ? 'user' : 'assistant',\n              content: node.content,\n              created_at: node.created_at,\n              nodeId: node.id\n            });\n          }\n        }\n        \n        // Add system prompt at the beginning if not present\n        const hasSystemMessage = allMessages.some(msg => msg.role === 'system');\n        if (!hasSystemMessage) {\n          allMessages.unshift({\n            id: `system_${Date.now()}`,\n            role: 'system',\n            content: systemPrompt,\n            created_at: new Date().toISOString()\n          });\n        }\n        \n        // Sort messages by creation time\n        allMessages.sort((a, b) => \n          new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n        );\n        \n        // Update chat messages\n        setChatMessages(allMessages);\n        return;\n      }\n      \n      // Step 2: Build a hierarchical view with main question at the root\n      console.log(`Found main question node: ${mainQuestionNode.id}`);\n      \n      // Collect main question messages\n      let hierarchicalMessages = [];\n      \n      // Add main question's messages\n      if (mainQuestionNode.messages && mainQuestionNode.messages.length > 0) {\n        hierarchicalMessages = [\n          ...hierarchicalMessages,\n          ...mainQuestionNode.messages.map(msg => ({\n            ...msg,\n            nodeId: mainQuestionNode.id,\n            tier: 1\n          }))\n        ];\n      } else {\n        // Create synthetic message for main question\n        hierarchicalMessages.push({\n          id: `node_${mainQuestionNode.id}`,\n          role: 'user',\n          content: mainQuestionNode.content,\n          created_at: mainQuestionNode.created_at,\n          nodeId: mainQuestionNode.id,\n          tier: 1\n        });\n      }\n      \n      // Find direct responses to the main question (tier 3 nodes)\n      const directResponses = Object.values(nodes).filter(node => {\n        return node.metadata?.parentNodeId === mainQuestionNode.id &&\n               node.metadata?.tier === 3;\n      }).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n      \n      // Add direct responses to the chat\n      for (const responseNode of directResponses) {\n        if (responseNode.messages && responseNode.messages.length > 0) {\n          hierarchicalMessages = [\n            ...hierarchicalMessages,\n            ...responseNode.messages.map(msg => ({\n              ...msg,\n              nodeId: responseNode.id,\n              tier: 3\n            }))\n          ];\n        } else {\n          hierarchicalMessages.push({\n            id: `node_${responseNode.id}`,\n            role: responseNode.type === 'question' ? 'user' : 'assistant',\n            content: responseNode.content,\n            created_at: responseNode.created_at,\n            nodeId: responseNode.id,\n            tier: 3\n          });\n        }\n      }\n      \n      // Sort all messages by creation time\n      hierarchicalMessages.sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n      \n      // Add system prompt at the beginning if not present\n      const hasSystemMessage = hierarchicalMessages.some(msg => msg.role === 'system');\n      if (!hasSystemMessage) {\n        hierarchicalMessages.unshift({\n          id: `system_${Date.now()}`,\n          role: 'system',\n          content: systemPrompt,\n          created_at: new Date().toISOString()\n        });\n      }\n      \n      // Update chat messages\n      setChatMessages(hierarchicalMessages);\n      console.log(`Synchronized ${hierarchicalMessages.length} messages`);\n    } catch (error) {\n      console.error('Error syncing chat with nodes:', error);\n    }\n  };\n  \n  // Improved sync function to display conversation based on active node\n  const syncNodesToChat = async (threadNodeId: string) => {\n    try {\n      console.log(`Synchronizing node ${threadNodeId} to chat...`);\n      \n      // Get the thread node\n      const threadNode = nodes[threadNodeId];\n      if (!threadNode) {\n        console.error(`Thread node ${threadNodeId} not found`);\n        return;\n      }\n      \n      // Different sync strategies based on node tier\n      const nodeTier = threadNode.metadata?.tier || 3;\n      console.log(`Syncing tier ${nodeTier} node`);\n      \n      let threadMessages = [];\n      \n      if (nodeTier === 1) {\n        // This is a main question node - show all direct children\n        \n        // Add main question messages\n        if (threadNode.messages && threadNode.messages.length > 0) {\n          threadMessages = [\n            ...threadMessages,\n            ...threadNode.messages.map(msg => ({\n              ...msg,\n              nodeId: threadNode.id\n            }))\n          ];\n        } else {\n          threadMessages.push({\n            id: `node_${threadNode.id}`,\n            role: 'user',\n            content: threadNode.content,\n            created_at: threadNode.created_at,\n            nodeId: threadNode.id\n          });\n        }\n        \n        // Find direct responses\n        const directResponses = Object.values(nodes).filter(node => {\n          return node.metadata?.parentNodeId === threadNode.id &&\n                 node.metadata?.tier === 3;\n        }).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n        \n        // Add direct responses\n        for (const responseNode of directResponses) {\n          if (responseNode.messages && responseNode.messages.length > 0) {\n            threadMessages = [\n              ...threadMessages,\n              ...responseNode.messages.map(msg => ({\n                ...msg,\n                nodeId: responseNode.id\n              }))\n            ];\n          } else {\n            threadMessages.push({\n              id: `node_${responseNode.id}`,\n              role: responseNode.type === 'question' ? 'user' : 'assistant',\n              content: responseNode.content,\n              created_at: responseNode.created_at,\n              nodeId: responseNode.id\n            });\n          }\n        }\n      } else if (nodeTier === 2) {\n        // This is a category node - show its own messages and children\n        \n        // Add a label message to indicate we're in a category\n        threadMessages.push({\n          id: `cat_${threadNode.id}`,\n          role: 'system',\n          content: `[Category: ${threadNode.content}]`,\n          created_at: threadNode.created_at,\n          nodeId: threadNode.id\n        });\n        \n        // Add category node messages \n        if (threadNode.messages && threadNode.messages.length > 0) {\n          threadMessages = [\n            ...threadMessages,\n            ...threadNode.messages.map(msg => ({\n              ...msg,\n              nodeId: threadNode.id\n            }))\n          ];\n        } else {\n          threadMessages.push({\n            id: `node_${threadNode.id}`,\n            role: threadNode.type === 'question' ? 'user' : 'assistant',\n            content: threadNode.content,\n            created_at: threadNode.created_at,\n            nodeId: threadNode.id\n          });\n        }\n        \n        // Find direct children (conversations within this category)\n        const categoryChildren = Object.values(nodes).filter(node => {\n          return node.metadata?.parentNodeId === threadNode.id &&\n                 node.metadata?.tier === 3;\n        }).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n        \n        // Add children messages\n        for (const childNode of categoryChildren) {\n          if (childNode.messages && childNode.messages.length > 0) {\n            threadMessages = [\n              ...threadMessages,\n              ...childNode.messages.map(msg => ({\n                ...msg,\n                nodeId: childNode.id\n              }))\n            ];\n          } else {\n            threadMessages.push({\n              id: `node_${childNode.id}`,\n              role: childNode.type === 'question' ? 'user' : 'assistant',\n              content: childNode.content,\n              created_at: childNode.created_at,\n              nodeId: childNode.id\n            });\n          }\n        }\n      } else {\n        // This is a conversation node (tier 3) - show its own messages and connected nodes\n        \n        // For conversation nodes, try to find its parent first\n        let parentNode = null;\n        if (threadNode.metadata?.parentNodeId) {\n          parentNode = nodes[threadNode.metadata.parentNodeId];\n        }\n        \n        if (parentNode && parentNode.metadata?.tier === 1) {\n          // If parent is main question, add a label\n          threadMessages.push({\n            id: `parent_${parentNode.id}`,\n            role: 'system',\n            content: `[In context of: ${parentNode.content}]`,\n            created_at: parentNode.created_at,\n            nodeId: parentNode.id\n          });\n        } else if (parentNode && parentNode.metadata?.tier === 2) {\n          // If parent is a category, add a label\n          threadMessages.push({\n            id: `parent_${parentNode.id}`,\n            role: 'system',\n            content: `[Category: ${parentNode.content}]`,\n            created_at: parentNode.created_at,\n            nodeId: parentNode.id\n          });\n        }\n        \n        // Add this node's messages\n        if (threadNode.messages && threadNode.messages.length > 0) {\n          threadMessages = [\n            ...threadMessages,\n            ...threadNode.messages.map(msg => ({\n              ...msg,\n              nodeId: threadNode.id\n            }))\n          ];\n        } else {\n          threadMessages.push({\n            id: `node_${threadNode.id}`,\n            role: threadNode.type === 'question' ? 'user' : 'assistant',\n            content: threadNode.content,\n            created_at: threadNode.created_at,\n            nodeId: threadNode.id\n          });\n        }\n        \n        // Find directly connected conversation nodes\n        // Look for nodes that this node has relationships with\n        const connectedNodeIds = relationships\n          .filter(rel => rel.from_node_id === threadNode.id || rel.to_node_id === threadNode.id)\n          .map(rel => rel.from_node_id === threadNode.id ? rel.to_node_id : rel.from_node_id);\n        \n        const connectedNodes = Object.values(nodes)\n          .filter(node => connectedNodeIds.includes(node.id))\n          .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n        \n        // Add connected nodes' messages\n        for (const connectedNode of connectedNodes) {\n          if (connectedNode.messages && connectedNode.messages.length > 0) {\n            threadMessages = [\n              ...threadMessages,\n              ...connectedNode.messages.map(msg => ({\n                ...msg,\n                nodeId: connectedNode.id\n              }))\n            ];\n          } else {\n            threadMessages.push({\n              id: `node_${connectedNode.id}`,\n              role: connectedNode.type === 'question' ? 'user' : 'assistant',\n              content: connectedNode.content,\n              created_at: connectedNode.created_at,\n              nodeId: connectedNode.id\n            });\n          }\n        }\n      }\n      \n      // Sort all messages by creation time\n      threadMessages.sort((a, b) => \n        new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n      );\n      \n      // Add system prompt at the beginning if not present\n      const hasSystemMessage = threadMessages.some(msg => msg.role === 'system' && msg.content.includes('You are a helpful'));\n      if (!hasSystemMessage) {\n        threadMessages.unshift({\n          id: `system_${Date.now()}`,\n          role: 'system',\n          content: systemPrompt,\n          created_at: new Date().toISOString()\n        });\n      }\n      \n      // Update chat messages\n      setChatMessages(threadMessages);\n      console.log(`Synchronized ${threadMessages.length} messages for node ${threadNodeId}`);\n    } catch (error) {\n      console.error('Error syncing nodes to chat:', error);\n    }\n  };\n  \n  // Custom implementation of missing functions\n  const createNodeFromMessage = async (message: any, position?: any) => {\n    if (!notebookId) return null;\n    \n    // Determine node type based on message role\n    const nodeType = message.role === 'user' ? 'question' : 'response';\n    \n    // Find a position if not provided\n    if (!position) {\n      // Find open space on the canvas - simple algorithm for now\n      const allNodes = Object.values(nodes);\n      const avgX = allNodes.length > 0 \n        ? allNodes.reduce((sum, node) => sum + (node.position?.x || 0), 0) / allNodes.length \n        : 100;\n      const avgY = allNodes.length > 0 \n        ? allNodes.reduce((sum, node) => sum + (node.position?.y || 0), 0) / allNodes.length \n        : 100;\n      \n      // Position new nodes near the average position with some offset\n      position = {\n        x: avgX + (Math.random() * 200 - 100),\n        y: avgY + (Math.random() * 200 - 100)\n      };\n    }\n    \n    // Create a new node\n    const nodePayload: Partial<Node> = {\n      content: message.content,\n      type: nodeType,\n      notebook_id: notebookId,\n      position,\n      metadata: {\n        source: 'chat',\n        chatMessageId: message.id,\n        timestamp: message.created_at\n      },\n      // Store this as a conversation node with messages\n      messages: [{\n        id: message.id,\n        role: message.role,\n        content: message.content,\n        created_at: message.created_at\n      }],\n      isConversationNode: true\n    };\n    \n    try {\n      // Add node (also persists to database)\n      return await addNode(nodePayload as Node);\n    } catch (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n  };\n  \n  // Get all unified store methods at component level\n  const setNotebookId = useUnifiedStore(state => state.setNotebookId);\n  const setActiveThread = useUnifiedStore(state => state.setActiveThread);\n  const getActiveThreadNodeId = useUnifiedStore(state => state.activeThreadNodeId);\n  const isInitialized = useUnifiedStore(state => state.isInitialized);\n  \n  // Create the sync active thread function using our local methods\n  const syncActiveThreadFn = async () => {\n    const activeThreadId = getActiveThreadNodeId;\n    if (activeThreadId) {\n      try {\n        await syncNodesToChat(activeThreadId);\n      } catch (error) {\n        console.error('Error syncing active thread:', error);\n      }\n    }\n  };\n  \n  // Override unifiedStore's implementation functions with our local implementations\n  const unifiedStoreActions = {\n    ...unifiedActions,\n    createNodeFromMessage,\n    syncChatWithNodes,\n    syncNodesToChat,\n    syncActiveThread: syncActiveThreadFn\n  };\n  \n  // Use the overridden store actions\n  const { \n    addChatMessage = unifiedStoreActions.addChatMessage, \n    setChatMessages = unifiedStoreActions.setChatMessages\n  } = unifiedStoreActions;\n  \n  // Get chat messages and store instance\n  const chatMessages = useChatMessages();\n  \n  // Initialize the unified store with the notebook ID\n  useEffect(() => {\n    if (setNotebookId) {\n      setNotebookId(notebookId);\n    }\n  }, [notebookId, setNotebookId]);\n\n  // Initialize the chat handler with our simplified, more reliable API endpoint\n  console.log(\"ðŸ“Š LlamaChat: Setting up chat handler with:\", { \n    api: '/api/claude/chat-simple',\n    notebookId,\n    modelId,\n    useStream: true \n  });\n  \n  useEffect(() => {\n    // One-time debug check of environment \n    console.log(\"ðŸ“Š LlamaChat: Environment check:\", { \n      window: typeof window !== 'undefined',\n      fetch: typeof fetch !== 'undefined',\n      notebookId,\n      apiUrl: window.location.origin + '/api/claude/chat-simple'\n    });\n    \n    // Make test request to check API health - use chat-simple for testing\n    fetch('/api/claude/chat-simple', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ \n        messages: [{ role: 'user', content: 'Test request' }],\n        notebookId,\n        stream: false,\n        test: true\n      })\n    })\n    .then(res => {\n      console.log('ðŸ“Š LlamaChat: API test response:', { \n        status: res.status, \n        statusText: res.statusText,\n        ok: res.ok\n      });\n    })\n    .catch(err => {\n      console.error('ðŸ”´ LlamaChat: API test error:', err);\n    });\n  }, [notebookId]);\n  \n  // Get system prompt from the config file and use it instead of hardcoding\n  // The system prompt will be sent to the API but not displayed in the UI\n  const chatHandler = useChat({\n    api: '/api/claude/chat-simple', // Use simpler endpoint that doesn't use streaming\n    initialMessages: [], // Do not send system message via initialMessages\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: false, // Disable streaming to avoid parsing issues\n      systemPrompt // Pass system prompt in the body instead\n    },\n    headers: {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n    },\n    onError: (error) => {\n      console.error(\"ðŸ”´ LlamaChat: Chat error:\", error);\n    },\n    onMessage: (message) => {\n      console.log(\"ðŸŸ¡ LlamaChat: Message received:\", {\n        type: typeof message,\n        snippet: typeof message === 'string' ? message.substring(0, 30) : JSON.stringify(message).substring(0, 30)\n      });\n    },\n    onResponse: (response) => {\n      // Called when a response is received\n      console.log('ðŸ”µ LlamaChat: Chat response started:', {\n        status: response.status,\n        statusText: response.statusText,\n        headers: Array.from(response.headers.entries()),\n        notebookId\n      });\n    },\n    onFinish: async (message) => {\n      // Called when a message is completed\n      console.log('ðŸŸ¢ LlamaChat: Message completed:', {\n        id: message.id,\n        role: message.role,\n        contentLength: message.content?.length || 0,\n        contentPreview: message.content?.substring(0, 50) + '...' || 'No content'\n      });\n      \n      try {\n        // Create a node for the AI response message\n        if (message && message.content && message.content !== 'New response') {\n          // Ensure content is a valid string\n          const messageContent = typeof message.content === 'string' ? \n            message.content : \n            (message.content ? JSON.stringify(message.content) : 'Empty response');\n\n          // Create message object\n          const messageObj = {\n            id: message.id,\n            role: 'assistant',\n            content: messageContent,\n            created_at: new Date().toISOString()\n          };\n          \n          // Get the last user message to create proper relationship\n          const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n          if (userMessages.length === 0) {\n            console.error('No user messages found to respond to');\n            setIsProcessing(false);\n            return;\n          }\n          \n          const lastUserMessage = userMessages[userMessages.length - 1];\n          \n          // Find the node for the last user message\n          const userNodes = Object.values(nodes).filter(n => {\n            return n.messages && n.messages.some(m => m.id === lastUserMessage.id);\n          });\n          \n          // Handle based on the user's node tier\n          if (userNodes.length > 0) {\n            const userNode = userNodes[0];\n            const userNodeTier = userNode.metadata?.tier || 3;\n            \n            // Three cases: tier 1 (main question), tier 2 (category), tier 3 (conversation)\n            if (userNodeTier === 1) {\n              // This is a response to the main question\n              console.log('Adding response to main question (tier 1 node)');\n              \n              // Create a tier 3 node with relationship to main question\n              const position = { \n                x: userNode.position?.x || 350, \n                y: (userNode.position?.y || 200) + 120 \n              };\n              \n              // Create node from message with right tier and metadata\n              const responseNode = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                position,\n                {\n                  parentNodeId: userNode.id,\n                  mainQuestionId: userNode.id,\n                  isAnswerToMainQuestion: true,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              // Create relationship from main question to response\n              if (responseNode) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  responseNode.id,\n                  'supports', // AI response supports the question\n                  notebookId,\n                  {\n                    direction: 'resolving',\n                    intention: 'answer',\n                    state: 'active'\n                  }\n                );\n                \n                // Update active node to this response\n                setSelectedNode(responseNode.id);\n                setActiveNode(responseNode.id);\n              }\n              \n              // Add to chat messages store for consistency\n              await addChatMessage(messageObj, false);\n            } else if (userNodeTier === 2) {\n              // This is a response to a category question\n              console.log('Adding response to category node (tier 2 node)');\n              \n              // Position relative to category node\n              const position = { \n                x: userNode.position?.x || 400, \n                y: (userNode.position?.y || 300) + 80 \n              };\n              \n              // Create response node with proper metadata\n              const responseNode = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                position,\n                {\n                  parentNodeId: userNode.id,\n                  categoryNodeId: userNode.id,\n                  mainQuestionId: userNode.metadata?.parentNodeId,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              // Create relationship\n              if (responseNode) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  responseNode.id,\n                  'supports', // AI response supports the category question\n                  notebookId,\n                  {\n                    direction: 'resolving',\n                    intention: 'answer',\n                    state: 'active'\n                  }\n                );\n                \n                // Update active node\n                setSelectedNode(responseNode.id);\n                setActiveNode(responseNode.id);\n              }\n              \n              // Add to chat messages store for consistency\n              await addChatMessage(messageObj, false);\n            } else {\n              // This is a response to a regular conversation message (tier 3)\n              // Check if this is a standalone node or part of a conversation\n              \n              if (userNode.isConversationNode && userNode.messages && userNode.messages.length > 0) {\n                // This is part of an existing conversation - add to the same node\n                console.log('Adding response to existing conversation node');\n                \n                // Add message to the existing node instead of creating a new one\n                const success = await nodeIntegration.addMessageToNode(\n                  userNode.id, \n                  messageObj,\n                  lastUserMessage.id // parent message ID for threading\n                );\n                \n                if (!success) {\n                  console.error('Failed to add message to node, falling back to new node creation');\n                  \n                  // Fallback - create a new node\n                  const position = { \n                    x: userNode.position?.x || 450, \n                    y: (userNode.position?.y || 350) + 60 \n                  };\n                  \n                  const responseNode = await nodeIntegration.createNodeFromMessage(\n                    messageObj,\n                    notebookId,\n                    position,\n                    {\n                      parentNodeId: userNode.metadata?.parentNodeId,\n                      respondingToNodeId: userNode.id,\n                      source: 'chat',\n                      timestamp: new Date().toISOString()\n                    },\n                    'response',\n                    3 // tier 3\n                  );\n                  \n                  // Create relationship\n                  if (responseNode) {\n                    await nodeIntegration.createNodeRelationship(\n                      userNode.id,\n                      responseNode.id,\n                      'supports',\n                      notebookId,\n                      {\n                        direction: 'resolving',\n                        intention: 'answer',\n                        state: 'active'\n                      }\n                    );\n                  }\n                }\n              } else {\n                // This is a response to a standalone message - create a new node\n                console.log('Creating response node for standalone message');\n                \n                const position = { \n                  x: userNode.position?.x || 450, \n                  y: (userNode.position?.y || 350) + 60 \n                };\n                \n                const responseNode = await nodeIntegration.createNodeFromMessage(\n                  messageObj,\n                  notebookId,\n                  position,\n                  {\n                    parentNodeId: userNode.metadata?.parentNodeId,\n                    respondingToNodeId: userNode.id,\n                    source: 'chat',\n                    timestamp: new Date().toISOString()\n                  },\n                  'response',\n                  3 // tier 3\n                );\n                \n                // Create relationship\n                if (responseNode) {\n                  await nodeIntegration.createNodeRelationship(\n                    userNode.id,\n                    responseNode.id,\n                    'supports',\n                    notebookId,\n                    {\n                      direction: 'resolving',\n                      intention: 'answer',\n                      state: 'active'\n                    }\n                  );\n                  \n                  // Update active node\n                  setSelectedNode(responseNode.id);\n                  setActiveNode(responseNode.id);\n                }\n              }\n              \n              // Add to chat messages store for consistency\n              await addChatMessage(messageObj, false);\n            }\n          } else {\n            // No user node found - create a standalone response\n            console.warn('No user node found for message', lastUserMessage.id);\n            \n            // Create node as a fallback\n            const node = await nodeIntegration.createNodeFromMessage(\n              messageObj,\n              notebookId\n            );\n            \n            // Find main question node to at least attach it somewhere\n            const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n            if (node && mainQuestionNode) {\n              await nodeIntegration.createNodeRelationship(\n                mainQuestionNode.id,\n                node.id,\n                'supports',\n                notebookId\n              );\n            }\n            \n            // Add to chat messages\n            await addChatMessage(messageObj, false);\n          }\n          \n          // If we have an active thread, attempt to synchronize\n          if (getActiveThreadNodeId) {\n            try {\n              await syncActiveThreadFn();\n            } catch (syncError) {\n              console.error('Error syncing with active thread:', syncError);\n            }\n          }\n        } else if (message.content === 'New response') {\n          console.log('Skipping placeholder content \"New response\"');\n        } else {\n          console.error('Received empty message from AI', message);\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n  \n  // Sync chat handler messages with unified store (one-way, unified store -> chat handler)\n  useEffect(() => {\n    // When unified store messages change, update chat handler if significantly different\n    const unifiedMessages = chatMessages;\n    const chatHandlerMessages = chatHandler.messages;\n    \n    // Skip if no messages or if processing - prevent loop\n    if (unifiedMessages.length === 0 || isProcessing) return;\n    \n    // Check if significantly different (different number of messages or last message content differs)\n    const isDifferent = \n      unifiedMessages.length !== chatHandlerMessages.length ||\n      (unifiedMessages.length > 0 && chatHandlerMessages.length > 0 &&\n       unifiedMessages[unifiedMessages.length - 1].content !== \n       chatHandlerMessages[chatHandlerMessages.length - 1].content);\n    \n    if (isDifferent) {\n      // Convert from unified store format to chat handler format\n      const newChatMessages = unifiedMessages.map(msg => ({\n        id: msg.id,\n        role: msg.role,\n        content: msg.content\n      }));\n      \n      // Set messages in chat handler\n      chatHandler.setMessages(newChatMessages);\n    }\n  }, [chatMessages, chatHandler, isProcessing]);\n\n  // Handle model change\n  const handleModelChange = useCallback((model: string) => {\n    setModelId(model);\n  }, []);\n\n  // Override the submit handler to create nodes with proper tier hierarchy\n  const handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      console.log('Processing user message...');\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n        created_at: new Date().toISOString()\n      };\n      \n      // Check if this is the first message - if so, mark it as the main question (tier 1)\n      // First, count existing question nodes\n      const existingQuestionNodes = Object.values(nodes).filter(n => \n        n.type === 'question' && n.notebook_id === notebookId\n      );\n      const isFirstMessage = existingQuestionNodes.length === 0;\n      \n      // Find main question node if it exists\n      let mainQuestionNode = null;\n      if (!isFirstMessage) {\n        mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n      }\n      \n      let node = null;\n      \n      if (isFirstMessage) {\n        // This is the first question - create as tier 1 (main question)\n        console.log('Creating main question node (tier 1)');\n        \n        // Position in center\n        const position = { x: 350, y: 200 };\n        \n        // Create with tier 1 metadata\n        node = await nodeIntegration.createNodeFromMessage(\n          messageObj,\n          notebookId,\n          position,\n          {\n            isMainQuestion: true,\n            source: 'chat',\n            timestamp: new Date().toISOString()\n          },\n          'question',\n          1 // tier 1\n        );\n      } else if (activeNode) {\n        // We have an active node to attach to\n        const activeTier = activeNode.metadata?.tier || 3;\n        \n        if (activeTier === 1) {\n          // Adding to the main question - create as tier 3 (conversation)\n          console.log('Creating conversation node under main question (tier 3)');\n          \n          // Position below the active node\n          const position = { \n            x: activeNode.position?.x || 350, \n            y: (activeNode.position?.y || 200) + 100 \n          };\n          \n          // Create as tier 3 (conversation node)\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId,\n            position,\n            {\n              parentNodeId: activeNode.id,\n              source: 'chat',\n              timestamp: new Date().toISOString()\n            },\n            'question',\n            3 // tier 3\n          );\n          \n          // Create relationship to parent\n          if (node) {\n            await nodeIntegration.createNodeRelationship(\n              activeNode.id,\n              node.id,\n              'extends',\n              notebookId,\n              {\n                direction: 'outgoing',\n                intention: 'conversation',\n                state: 'active'\n              }\n            );\n          }\n        } else if (activeTier === 2) {\n          // Adding to a category node - create as tier 3 (conversation)\n          console.log('Creating conversation node under category (tier 3)');\n          \n          // Position below the category node\n          const position = { \n            x: activeNode.position?.x || 400, \n            y: (activeNode.position?.y || 300) + 80 \n          };\n          \n          // Create as tier 3 (conversation node)\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId,\n            position,\n            {\n              parentNodeId: activeNode.id,\n              categoryNodeId: activeNode.id,\n              mainQuestionId: activeNode.metadata?.parentNodeId,\n              source: 'chat',\n              timestamp: new Date().toISOString()\n            },\n            'question',\n            3 // tier 3\n          );\n          \n          // Create relationship to parent category\n          if (node) {\n            await nodeIntegration.createNodeRelationship(\n              activeNode.id,\n              node.id,\n              'extends',\n              notebookId,\n              {\n                direction: 'outgoing',\n                intention: 'conversation',\n                state: 'active'\n              }\n            );\n          }\n        } else {\n          // Adding to a conversation node - create as continuation (tier 3)\n          console.log('Adding to existing conversation (tier 3)');\n          \n          // Instead of creating a new node, add message to existing node\n          if (await nodeIntegration.addMessageToNode(activeNode.id, messageObj)) {\n            // Using existing node\n            node = activeNode;\n          } else {\n            // Fallback - create new node\n            const position = { \n              x: activeNode.position?.x || 450, \n              y: (activeNode.position?.y || 350) + 60 \n            };\n            \n            node = await nodeIntegration.createNodeFromMessage(\n              messageObj,\n              notebookId,\n              position,\n              {\n                parentNodeId: activeNode.metadata?.parentNodeId,\n                source: 'chat',\n                timestamp: new Date().toISOString()\n              },\n              'question',\n              3 // tier 3\n            );\n            \n            // Create relationship\n            if (node) {\n              await nodeIntegration.createNodeRelationship(\n                activeNode.id,\n                node.id,\n                'extends',\n                notebookId\n              );\n            }\n          }\n        }\n      } else if (mainQuestionNode) {\n        // No active node but we have a main question - attach to it\n        console.log('Attaching to main question node (no active node)');\n        \n        // Position relative to main question\n        const position = { \n          x: mainQuestionNode.position?.x || 350, \n          y: (mainQuestionNode.position?.y || 200) + 120 \n        };\n        \n        // Create as tier 3 (conversation node)\n        node = await nodeIntegration.createNodeFromMessage(\n          messageObj,\n          notebookId,\n          position,\n          {\n            parentNodeId: mainQuestionNode.id,\n            source: 'chat',\n            timestamp: new Date().toISOString()\n          },\n          'question',\n          3 // tier 3\n        );\n        \n        // Create relationship to main question\n        if (node) {\n          await nodeIntegration.createNodeRelationship(\n            mainQuestionNode.id,\n            node.id,\n            'extends',\n            notebookId,\n            {\n              direction: 'outgoing',\n              intention: 'conversation',\n              state: 'active'\n            }\n          );\n        }\n      } else {\n        // Fallback - create as a standard question node\n        console.log('Creating standard node (no hierarchy found)');\n        \n        // Create node with default settings\n        node = await nodeIntegration.createNodeFromMessage(\n          messageObj,\n          notebookId\n        );\n      }\n      \n      // Also add to chat messages store for consistency\n      await addChatMessage(messageObj, false); // false = don't create node (already created)\n      \n      // Update the UI state with new active node\n      if (node && node.id !== activeNode?.id) {\n        setSelectedNode(node.id);\n        setActiveNode(node.id);\n      }\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Call the chat handler manually to avoid double-submission\n      // This will update messages array and trigger API call\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n      });\n      \n      console.log('User message processed, node created:', node?.id);\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [activeNode, addChatMessage, chatHandler, isProcessing, nodes, notebookId, setActiveNode, setSelectedNode]);\n\n  // Create a new thread or conversation\n  const handleCreateNewThread = useCallback(() => {\n    // Clear active node selection\n    setSelectedNode(null);\n    setActiveNode(null);\n    if (setActiveThread) {\n      setActiveThread(null);\n    }\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n    setChatMessages(systemMessages.map(msg => ({\n      ...msg,\n      created_at: new Date().toISOString()\n    })));\n  }, [setSelectedNode, setActiveNode, chatHandler, setChatMessages, setActiveThread]);\n  \n  // Create a tier 2 category node\n  const handleCreateCategoryNode = useCallback(async (\n    type: 'question' | 'response' | 'note' | 'drawing',\n    defaultContent: string\n  ) => {\n    try {\n      // First find the main question node (tier 1)\n      const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n      \n      if (!mainQuestionNode) {\n        console.error('Cannot create category node - no main question found');\n        alert('Please create a main question first before adding category nodes');\n        return;\n      }\n      \n      // Create a dialog to get the content for the node\n      const content = window.prompt(`Enter content for the new ${type} node:`, defaultContent);\n      \n      if (!content) {\n        console.log('Category node creation cancelled');\n        return; // User cancelled\n      }\n      \n      console.log(`Creating tier 2 ${type} node with content: ${content}`);\n      \n      // Create the tier 2 node\n      const categoryNode = await nodeIntegration.createTier2Node(\n        mainQuestionNode.id,\n        type,\n        content,\n        notebookId\n      );\n      \n      if (!categoryNode) {\n        console.error('Failed to create category node');\n        return;\n      }\n      \n      // Set this as the active node\n      setSelectedNode(categoryNode.id);\n      setActiveNode(categoryNode.id);\n      \n      // Update the chat view to reflect this node\n      if (setActiveThread) {\n        setActiveThread(categoryNode.id);\n      }\n      \n      // Reset chat to only system message + new prompt about this category\n      const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n      \n      // Append a message about the category\n      const categoryMessage = {\n        id: `cat_${Date.now()}`,\n        role: 'system' as const,\n        content: `You are now working in the category: ${content} (${type}). This is a tier 2 node organized under the main question.`\n      };\n      \n      chatHandler.setMessages([...systemMessages, categoryMessage]);\n      \n      console.log(`Created and activated tier 2 node: ${categoryNode.id}`);\n    } catch (error) {\n      console.error('Error creating category node:', error);\n    }\n  }, [nodeIntegration, notebookId, setSelectedNode, setActiveNode, setActiveThread, chatHandler]);\n  \n  // Create initial question node if provided\n  useEffect(() => {\n    const createInitialQuestion = async () => {\n      // Skip if already created, no initial question, or processing\n      if (initialQuestionCreatedRef.current || !initialQuestion || isProcessing) {\n        return;\n      }\n\n      // Skip if any messages already exist\n      if (chatMessages.length > 1) { // More than just system message\n        initialQuestionCreatedRef.current = true;\n        return;\n      }\n\n      // Create the initial question\n      try {\n        setIsProcessing(true);\n        initialQuestionCreatedRef.current = true;\n        \n        // Add initial question to chat\n        await addChatMessage({\n          role: 'user',\n          content: initialQuestion\n        }, true);\n        \n        // Update chat handler\n        chatHandler.setInput('');\n        chatHandler.setMessages([\n          ...chatHandler.messages,\n          {\n            id: `initial-question-${Date.now()}`,\n            role: 'user',\n            content: initialQuestion\n          }\n        ]);\n        \n        // Trigger AI response using the simpler API endpoint\n        const response = await fetch('/api/claude/chat-simple', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            messages: [\n              { role: 'system', content: systemPrompt },\n              { role: 'user', content: initialQuestion }\n            ],\n            notebookId,\n            model: modelId,\n            includeUserContext: true,\n            stream: false // Disable streaming for reliability\n          })\n        });\n        \n        if (response.ok) {\n          const responseData = await response.json();\n          \n          // Extract text content from response\n          let aiResponseText = '';\n          if (responseData.content && Array.isArray(responseData.content)) {\n            aiResponseText = responseData.content\n              .filter((block: any) => block.type === 'text')\n              .map((block: any) => block.text)\n              .join('\\n');\n          } else if (typeof responseData.content === 'string') {\n            aiResponseText = responseData.content;\n          }\n          \n          // Add AI response to chat\n          if (aiResponseText) {\n            await addChatMessage({\n              role: 'assistant',\n              content: aiResponseText\n            }, true);\n            \n            // Update chat handler messages\n            chatHandler.setMessages([\n              ...chatHandler.messages,\n              {\n                id: `initial-response-${Date.now()}`,\n                role: 'assistant',\n                content: aiResponseText\n              }\n            ]);\n          }\n        }\n      } catch (error) {\n        console.error('Error creating initial question:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    };\n\n    createInitialQuestion();\n  }, [initialQuestion, notebookId, modelId, systemPrompt, chatMessages, addChatMessage, chatHandler, isProcessing]);\n  \n  // REMOVED sync with active thread - this causes infinite loops\n  // Instead, set active thread once when node changes\n  useEffect(() => {\n    if (activeNode && !isProcessing) {\n      const activeNodeId = activeNode.id;\n      if (setActiveThread) {\n        setActiveThread(activeNodeId);\n      }\n    }\n  }, [activeNode, isProcessing, setActiveThread]);\n  \n  // REMOVED automatic sync on mount - caused infinite loops\n  // User can manually sync with the button when needed\n\n  // Debug information for development\n  const nodeCount = Object.keys(nodes).length;\n  const messageCount = chatHandler.messages.length;\n  const visibleMessages = chatHandler.messages.filter(msg => msg.role !== 'system' && msg.content !== 'New response');\n  \n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (\n            <>\n              {activeNode.type === 'question' ? 'Question' : 'Conversation'}\n              {activeNode.metadata?.tier && (\n                <span className=\"ml-2 text-xs bg-blue-100 px-2 py-0.5 rounded-full text-blue-800\">\n                  Tier {activeNode.metadata.tier}\n                </span>\n              )}\n            </>\n          ) : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          {/* Create category node dropdown (only visible when main question exists) */}\n          {Object.values(nodes).some(n => n.metadata?.tier === 1) && (\n            <div className=\"relative group\">\n              <button\n                className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n                title=\"Create category node\"\n              >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path d=\"M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM14 11a1 1 0 011 1v1h1a1 1 0 110 2h-1v1a1 1 0 11-2 0v-1h-1a1 1 0 110-2h1v-1a1 1 0 011-1z\" />\n                </svg>\n              </button>\n              <div className=\"absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden group-hover:block z-10\">\n                <div className=\"py-1\" role=\"menu\" aria-orientation=\"vertical\">\n                  <button\n                    onClick={() => handleCreateCategoryNode('question', 'New Question')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸ¤” New Question\n                  </button>\n                  <button\n                    onClick={() => handleCreateCategoryNode('note', 'Research Notes')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸ“ Research Notes\n                  </button>\n                  <button\n                    onClick={() => handleCreateCategoryNode('drawing', 'Visual Map')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸŽ¨ Visual Map\n                  </button>\n                  <button\n                    onClick={() => handleCreateCategoryNode('response', 'Agent')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸ¤– Agent\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n          \n          <button\n            onClick={handleCreateNewThread}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"New conversation\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n          {onClose && (\n            <button \n              onClick={onClose}\n              className=\"text-gray-500 hover:text-gray-700\"\n              aria-label=\"Close panel\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n      \n      {/* Chat UI */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ChatSection handler={chatHandler} className=\"h-full\">\n          <ChatMessages className=\"h-[calc(100%-80px)] overflow-y-auto p-4\" />\n          <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n            <ChatInput.Form className=\"px-3 py-2\">\n              <ChatInput.Field \n                type=\"textarea\" \n                placeholder=\"Type your message...\" \n                className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n                disabled={chatHandler.isLoading || isProcessing}\n                onChange={chatHandler.handleInputChange}\n              />\n              <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n                <ModelSelector\n                  selectedModel={modelId}\n                  onChangeModel={handleModelChange}\n                />\n                <ChatInput.Upload>\n                  <FileUploadButton />\n                </ChatInput.Upload>\n              </div>\n              <ChatInput.Submit\n                disabled={chatHandler.isLoading || isProcessing}\n                className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n              >\n                {chatHandler.isLoading || isProcessing ? (\n                  <div className=\"h-5 w-5 border-2 border-white border-t-transparent rounded-full animate-spin\"></div>\n                ) : (\n                  <svg className=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                    <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                  </svg>\n                )}\n              </ChatInput.Submit>\n            </ChatInput.Form>\n          </ChatInput>\n        </ChatSection>\n      </div>\n      \n      {/* Enhanced Information footer */}\n      <div className=\"px-3 py-1 text-xs text-gray-500 bg-gray-50 border-t border-gray-200\">\n        <div className=\"flex justify-between\">\n          <span>\n            {activeNode ? (\n              <span>\n                {activeNode.metadata?.tier === 1 ? (\n                  <span className=\"font-medium text-blue-600\">Main Question Node</span>\n                ) : activeNode.metadata?.tier === 2 ? (\n                  <span className=\"font-medium text-green-600\">Category Node</span>\n                ) : (\n                  <span className=\"font-medium text-purple-600\">Conversation Node</span>\n                )}\n              </span>\n            ) : (\n              <span>All messages appear as cards on the canvas</span>\n            )}\n          </span>\n          <div className=\"flex space-x-2\">\n            {activeNode && (\n              <span className=\"text-blue-500 cursor-pointer\" onClick={() => {\n                setActiveNode(null);\n                if (setActiveThread) {\n                  setActiveThread(null);\n                }\n                setTimeout(() => {\n                  try {\n                    syncChatWithNodes(notebookId);\n                  } catch (error) {\n                    console.error('Error syncing all nodes:', error);\n                  }\n                }, 100);\n              }}>\n                View all\n              </span>\n            )}\n            \n            {/* Main Question button - only shown when main question exists */}\n            {Object.values(nodes).some(n => n.metadata?.tier === 1) && !activeNode?.metadata?.tier === 1 && (\n              <span className=\"text-blue-500 cursor-pointer\" onClick={async () => {\n                try {\n                  const mainQuestion = await nodeIntegration.findMainQuestionNode(notebookId);\n                  if (mainQuestion) {\n                    setSelectedNode(mainQuestion.id);\n                    setActiveNode(mainQuestion.id);\n                    if (setActiveThread) {\n                      setActiveThread(mainQuestion.id);\n                    }\n                    setTimeout(() => {\n                      try {\n                        syncNodesToChat(mainQuestion.id);\n                      } catch (error) {\n                        console.error('Error syncing with main node:', error);\n                      }\n                    }, 100);\n                  }\n                } catch (error) {\n                  console.error('Error finding main question:', error);\n                }\n              }}>\n                Main question\n              </span>\n            )}\n            \n            {/* Sync button */}\n            <span className=\"text-blue-500 cursor-pointer\" onClick={() => {\n              try {\n                if (activeNode) {\n                  setTimeout(() => {\n                    try {\n                      syncNodesToChat(activeNode.id);\n                    } catch (error) {\n                      console.error('Error in manual sync:', error);\n                    }\n                  }, 100);\n                } else {\n                  setTimeout(() => {\n                    try {\n                      syncChatWithNodes(notebookId);\n                    } catch (error) {\n                      console.error('Error in manual sync:', error);\n                    }\n                  }, 100);\n                }\n              } catch (error) {\n                console.error('Error in sync button:', error);\n              }\n            }}>\n              Sync\n            </span>\n          </div>\n        </div>\n        \n        {/* Debug/Info panel */}\n        <div className=\"mt-1 p-1 bg-blue-50 rounded text-xs\">\n          <div className=\"flex flex-wrap justify-between\">\n            <span>\n              {activeNode ? (\n                <span className=\"whitespace-nowrap\">\n                  Current: {activeNode.id.substring(0, 8)}\n                  {activeNode.metadata?.parentNodeId && (\n                    <span> (Parent: {activeNode.metadata.parentNodeId.substring(0, 8)})</span>\n                  )}\n                </span>\n              ) : (\n                <span>No active node</span>\n              )}\n            </span>\n            <span>Nodes: {nodeCount}</span>\n            <span>Messages: {visibleMessages.length}</span>\n            <span>\n              Tiers: {\" \"}\n              <span className=\"text-blue-600 font-semibold\">\n                {Object.values(nodes).filter(n => n.metadata?.tier === 1).length} main\n              </span>\n              {\" | \"}\n              <span className=\"text-green-600 font-semibold\">\n                {Object.values(nodes).filter(n => n.metadata?.tier === 2).length} categories\n              </span>\n              {\" | \"}\n              <span className=\"text-purple-600 font-semibold\">\n                {Object.values(nodes).filter(n => n.metadata?.tier === 3 || !n.metadata?.tier).length} convos\n              </span>\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Wrap component with error boundary\nconst WrappedLlamaChat = (props: LlamaChatProps) => (\n  <LlamaChatErrorBoundary>\n    <LlamaChat {...props} />\n  </LlamaChatErrorBoundary>\n);\n\nexport default WrappedLlamaChat;\nðŸ“„ --- File: ./src/components/ui/LlamaChat.updated.tsx ---\n/**\n * LlamaChat Component\n * \n * A redesigned chat component using the new chat architecture\n */\nimport React, { useState, useCallback, useEffect, useRef } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\nimport { \n  useNodes, \n  useNodeActions,\n  useActiveNode,\n} from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { useChatNodeSync } from '@/hooks/useChatNodeSync';\nimport { Spinner } from '../shadcn/spinner';\n\n// Model selector component - extracted for cleaner code\nconst ModelSelector = ({ selectedModel, onChangeModel }: { \n  selectedModel: string; \n  onChangeModel: (model: string) => void;\n}) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\ninterface LlamaChatProps {\n  notebookId: string;\n  systemPrompt?: string;\n  fullScreen?: boolean;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string;\n}\n\nconst LlamaChat: React.FC<LlamaChatProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  // Validate notebookId early\n  if (!notebookId) {\n    console.error('LlamaChat received empty notebookId');\n    return <div className=\"p-4 text-red-500\">Error: Missing notebook ID</div>;\n  }\n\n  // State management\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionCreatedRef = useRef(false);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const activeNode = useActiveNode();\n  const { \n    addNode, \n    createNodeRelationship,\n    setActiveNode \n  } = useNodeActions();\n  \n  // Chat-node synchronization\n  const { \n    syncNodeToChat, \n    findNodeByMessageId,\n    syncChatToNodes\n  } = useChatNodeSync({ notebookId });\n  \n  // Initialize chat with Vercel AI SDK\n  const chatHandler = useChat({\n    api: '/api/claude/unified-chat',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: true\n    },\n    onResponse: (response) => {\n      console.log('Chat response started:', response.status);\n    },\n    onFinish: async (message) => {\n      try {\n        // Create a node for the AI response\n        if (message && message.content) {\n          const messageObj = {\n            id: message.id,\n            role: 'assistant',\n            content: message.content,\n            created_at: new Date().toISOString()\n          };\n          \n          // Create node from message\n          const node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId\n          );\n          \n          // Create relationship with previous node if possible\n          if (node) {\n            // Get the last user message (which should be the question this response answers)\n            const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n            if (userMessages.length > 0) {\n              const lastUserMessage = userMessages[userMessages.length - 1];\n              const userNode = findNodeByMessageId(lastUserMessage.id);\n              \n              if (userNode) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  node.id,\n                  'extends',\n                  notebookId\n                );\n              }\n            }\n          }\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle model change\n  const handleModelChange = useCallback((model: string) => {\n    setModelId(model);\n  }, []);\n\n  // Handle message submission\n  const handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user' as const,\n        content: content.trim(),\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node for user message\n      const node = await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n      // If we have an active node, create a relationship\n      if (node && activeNode) {\n        await nodeIntegration.createNodeRelationship(\n          activeNode.id,\n          node.id,\n          'extends',\n          notebookId\n        );\n      }\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Send message to AI\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n      });\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [notebookId, isProcessing, chatHandler, activeNode]);\n\n  // Create a new thread\n  const handleCreateNewThread = useCallback(() => {\n    // Reset active node\n    setActiveNode(null);\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n  }, [setActiveNode, chatHandler]);\n  \n  // Send initial question if provided\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionCreatedRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionCreatedRef.current = true;\n          setIsProcessing(true);\n          \n          // Create message ID\n          const messageId = `initial-question-${Date.now()}`;\n          \n          // Create node for the question\n          const questionNode = await nodeIntegration.createNodeFromMessage(\n            {\n              id: messageId,\n              role: 'user',\n              content: initialQuestion,\n              created_at: new Date().toISOString()\n            },\n            notebookId\n          );\n          \n          // Send to chat\n          chatHandler.append({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          });\n        } catch (error) {\n          console.error('Error sending initial question:', error);\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler, notebookId]);\n  \n  // Sync with active node when it changes\n  useEffect(() => {\n    if (activeNode && !isProcessing) {\n      syncNodeToChat(activeNode.id).catch(error => {\n        console.error('Error syncing with active node:', error);\n      });\n    }\n  }, [activeNode, isProcessing, syncNodeToChat]);\n  \n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (activeNode.type === 'question' ? 'Question' : 'Conversation') : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            onClick={handleCreateNewThread}\n            className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n            title=\"New conversation\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n          {onClose && (\n            <button \n              onClick={onClose}\n              className=\"text-gray-500 hover:text-gray-700\"\n              aria-label=\"Close panel\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n      \n      {/* Chat UI */}\n      <div className=\"flex-1 overflow-hidden\">\n        <ChatSection handler={chatHandler} className=\"h-full\">\n          <ChatMessages className=\"h-[calc(100%-80px)] overflow-y-auto p-4\" />\n          <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n            <ChatInput.Form className=\"px-3 py-2\">\n              <ChatInput.Field \n                type=\"textarea\" \n                placeholder=\"Type your message...\" \n                className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n                disabled={chatHandler.isLoading || isProcessing}\n              />\n              <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n                <ModelSelector\n                  selectedModel={modelId}\n                  onChangeModel={handleModelChange}\n                />\n              </div>\n              <ChatInput.Submit\n                disabled={chatHandler.isLoading || isProcessing}\n                className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n              >\n                {chatHandler.isLoading || isProcessing ? (\n                  <Spinner className=\"h-5 w-5 border-2 border-white border-t-transparent\" />\n                ) : (\n                  <svg className=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                    <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                  </svg>\n                )}\n              </ChatInput.Submit>\n            </ChatInput.Form>\n          </ChatInput>\n        </ChatSection>\n      </div>\n      \n      {/* Information footer */}\n      <div className=\"px-3 py-1 text-xs text-gray-500 bg-gray-50 border-t border-gray-200\">\n        <div className=\"flex justify-between\">\n          <span>All messages appear as cards on the canvas</span>\n          <div className=\"flex space-x-2\">\n            {activeNode && (\n              <span className=\"text-blue-500 cursor-pointer\" onClick={() => {\n                setActiveNode(null);\n              }}>\n                View all threads\n              </span>\n            )}\n            <span \n              className=\"text-blue-500 cursor-pointer\" \n              onClick={() => syncChatToNodes()}\n            >\n              Sync messages\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default LlamaChat;\nðŸ“„ --- File: ./src/components/ui/LlamaIndexChat.tsx ---\n/**\n * LlamaIndexChat - Integration of LlamaIndex Chat UI with Vercel AI\n */\nimport React from 'react';\nimport { ChatSection } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\n\ninterface LlamaIndexChatProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst LlamaIndexChat: React.FC<LlamaIndexChatProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  // Use Vercel AI's useChat hook for API integration\n  const chatHandler = useChat({\n    api: '/api/claude/stream',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: 'claude-3-5-sonnet-20240620',\n    },\n    onError: (error) => {\n      console.error(\"Chat error:\", error);\n    },\n  });\n\n  return (\n    <div className={`h-full ${className}`}>\n      <ChatSection \n        handler={chatHandler}\n        className=\"h-full\"\n      />\n    </div>\n  );\n};\n\nexport default LlamaIndexChat;\nðŸ“„ --- File: ./src/components/ui/QuestionInput.tsx ---\nimport React, { useState } from 'react';\nimport { useRouter } from 'next/router';\nimport { useAuth } from '@/contexts/AuthContext';\n\nconst QuestionInput: React.FC = () => {\n  const [question, setQuestion] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState('');\n  const router = useRouter();\n  const { user, loading } = useAuth();\n\n  const handleQuestionSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!question.trim()) return;\n    \n    setIsLoading(true);\n    setError('');\n    \n    try {\n      // Redirect to login if user is not authenticated\n      if (!user) {\n        router.push(`/login?redirect=/&question=${encodeURIComponent(question)}`);\n        return;\n      }\n      \n      // Create a notebook with the question via API\n      const response = await fetch('/api/notebooks/create-with-question', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ question })\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to create notebook: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      if (data.success && data.notebookId) {\n        // Redirect to the unified view of the notebook\n        router.push(`/notebooks/${data.notebookId}/unified`);\n      } else {\n        throw new Error('Failed to create notebook');\n      }\n    } catch (err) {\n      console.error('Error creating notebook:', err);\n      setError(err instanceof Error ? err.message : 'Failed to create notebook');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"w-full max-w-2xl\">\n      <form onSubmit={handleQuestionSubmit} className=\"relative\">\n        <div className=\"rounded-xl shadow-sm overflow-hidden border-2 border-blue-200 focus-within:border-blue-500 transition\">\n          <textarea\n            value={question}\n            onChange={(e) => setQuestion(e.target.value)}\n            className=\"w-full px-4 py-3 focus:outline-none resize-none min-h-[80px]\"\n            placeholder=\"Ask any question or Start a blank notebook...\"\n            disabled={isLoading || loading}\n          />\n          \n          <div className=\"flex justify-between items-center px-4 py-2 bg-blue-50 border-t border-blue-100\">\n            <div className=\"text-sm text-gray-500\">\n              {error ? (\n                <span className=\"text-red-500\">{error}</span>\n              ) : (\n                \"Your question will be turned into a notebook\"\n              )}\n            </div>\n            \n            <div className=\"flex space-x-2\">\n              <button\n                type=\"button\"\n                className=\"px-4 py-2 bg-white text-blue-600 rounded-md border border-blue-200 hover:bg-blue-50\"\n                onClick={() => router.push('/notebooks/new')}\n                disabled={isLoading || loading}\n              >\n                Blank Notebook\n              </button>\n              \n              <button\n                type=\"submit\"\n                className=\"px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 flex items-center\"\n                disabled={!question.trim() || isLoading || loading}\n              >\n                {isLoading ? (\n                  <>\n                    <svg className=\"animate-spin -ml-1 mr-2 h-4 w-4 text-white\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                      <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n                      <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                    </svg>\n                    Processing...\n                  </>\n                ) : (\n                  'Ask Question'\n                )}\n              </button>\n            </div>\n          </div>\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default QuestionInput;\nðŸ“„ --- File: ./src/components/ui/SimpleChatPanel.tsx ---\n/**\n * SimpleChatPanel Component\n * \n * A clean, simple chat interface using Vercel AI SDK\n */\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useChat, type Message } from 'ai/react';\nimport { Button } from '@/components/shadcn/button';\nimport { Textarea } from '@/components/shadcn/textarea';\nimport { Spinner } from '@/components/shadcn/spinner';\nimport { nodeIntegration } from '@/lib/chat';\nimport { supabase } from '@/lib/supabaseClient';\n\ninterface SimpleChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string;\n}\n\nexport const SimpleChatPanel: React.FC<SimpleChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionSentRef = useRef(false);\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  \n  // Initialize chat with Vercel AI SDK\n  const chatHandler = useChat({\n    api: '/api/claude/chat-simple',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: 'claude-3-5-sonnet-20240620',\n      includeUserContext: true\n    },\n    onResponse: (response) => {\n      console.log('Chat response started:', response.status);\n    },\n    onFinish: async (message) => {\n      try {\n        // Create a node for the AI response\n        if (message?.content) {\n          await handleNodeCreation(message, 'assistant');\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle node creation\n  const handleNodeCreation = async (message: Message, role: 'user' | 'assistant') => {\n    try {\n      console.log(\"Node creation skipped for chat UI simplicity\");\n      // Return a mock node to avoid errors\n      const mockNode = {\n        id: `mock-${Date.now()}`,\n        type: role === 'user' ? 'question' : 'response',\n        content: message.content\n      };\n      return mockNode;\n    } catch (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n  };\n  \n  // Mock find user message node - simplified for this component\n  const findUserMessageNode = async () => {\n    console.log(\"User message node lookup skipped for simplicity\");\n    return null;\n  };\n\n  // We're now using Vercel AI's built-in handlers directly in the form\n  \n  // Send initial question if provided - simplified for direct use\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionSentRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionSentRef.current = true;\n          setIsProcessing(true);\n          \n          console.log(\"Sending initial question:\", initialQuestion);\n          \n          // Send using the handler's method\n          await chatHandler.setInput(initialQuestion);\n          \n          // Create a mock form event\n          const fakeEvent = {\n            preventDefault: () => {}\n          } as React.FormEvent;\n          \n          await chatHandler.handleSubmit(fakeEvent);\n          \n          console.log(\"Initial question sent\");\n        } catch (error) {\n          console.error('Error sending initial question:', error);\n        } finally {\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler]);\n  \n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow-md ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">Chat</h2>\n        {onClose && (\n          <Button \n            onClick={onClose}\n            size=\"sm\"\n            variant=\"ghost\"\n            aria-label=\"Close panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </Button>\n        )}\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        {chatHandler.messages\n          .filter(msg => msg.role !== 'system')\n          .map((message, index) => {\n            // Check if there's valid content to display\n            if (!message.content && message.role !== 'assistant') {\n              return null;\n            }\n            \n            return (\n              <div \n                key={message.id || `message-${index}`} \n                className={`mb-4 ${message.role === 'user' ? 'ml-auto max-w-[80%]' : 'mr-auto max-w-[80%]'}`}\n              >\n                <div \n                  className={`p-3 rounded-lg ${\n                    message.role === 'user' \n                      ? 'bg-blue-500 text-white' \n                      : 'bg-gray-100 text-gray-800'\n                  }`}\n                >\n                  {typeof message.content === 'string' ? message.content : JSON.stringify(message.content)}\n                </div>\n              </div>\n            );\n          })}\n          \n        {/* Show additional messages from the chat state that might not be in messages array */}\n        {chatHandler.data?.map((item, i) => {\n          if (item.role === 'assistant' && \n              !chatHandler.messages.some(m => m.id === item.id)) {\n            return (\n              <div key={`data-${item.id || i}`} className=\"mb-4 mr-auto max-w-[80%]\">\n                <div className=\"p-3 rounded-lg bg-gray-100 text-gray-800\">\n                  {typeof item.content === 'string' ? item.content : JSON.stringify(item.content)}\n                </div>\n                <div className=\"text-xs text-gray-500 mt-1\">Assistant response from data array</div>\n              </div>\n            );\n          }\n          return null;\n        })}\n        \n        {chatHandler.isLoading && (\n          <div className=\"flex justify-center items-center p-4\">\n            <Spinner className=\"w-6 h-6 text-blue-500\" />\n          </div>\n        )}\n        \n        {/* Debug info - show all messages for troubleshooting */}\n        <div className=\"mt-4 p-2 border border-gray-200 rounded bg-gray-50\">\n          <p className=\"text-xs text-gray-500 mb-1\">Debug: Message Count = {chatHandler.messages.length}</p>\n          {chatHandler.messages.map((msg, idx) => (\n            <div key={`debug-${msg.id || idx}`} className=\"text-xs mb-1\">\n              <strong>{msg.role}:</strong> {typeof msg.content === 'string' \n                ? (msg.content.substring(0, 30) + (msg.content.length > 30 ? '...' : ''))\n                : 'complex content'}\n            </div>\n          ))}\n          \n          {chatHandler.data && chatHandler.data.length > 0 && (\n            <>\n              <p className=\"text-xs text-gray-500 mt-2 mb-1\">Data array: {chatHandler.data.length} items</p>\n              {chatHandler.data.map((item, idx) => (\n                <div key={`data-debug-${idx}`} className=\"text-xs mb-1\">\n                  <strong>{item.role}:</strong> {typeof item.content === 'string' \n                    ? (item.content.substring(0, 30) + (item.content.length > 30 ? '...' : ''))\n                    : 'complex content'}\n                </div>\n              ))}\n            </>\n          )}\n        </div>\n      </div>\n      \n      {/* Input - Use Vercel AI's input handling */}\n      <form onSubmit={chatHandler.handleSubmit} className=\"border-t border-gray-200 p-3\">\n        <div className=\"relative\">\n          <Textarea\n            ref={inputRef}\n            value={chatHandler.input}\n            onChange={(e) => chatHandler.setInput(e.target.value)}\n            placeholder=\"Type your message...\"\n            className=\"resize-none min-h-[80px] pr-16\"\n            disabled={isProcessing || chatHandler.isLoading}\n          />\n          <Button \n            type=\"submit\"\n            className=\"absolute bottom-2 right-2\"\n            disabled={isProcessing || chatHandler.isLoading || !chatHandler.input.trim()}\n          >\n            {isProcessing || chatHandler.isLoading ? (\n              <Spinner className=\"w-5 h-5\" />\n            ) : (\n              <svg className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n              </svg>\n            )}\n          </Button>\n        </div>\n        <p className=\"text-xs text-gray-500 mt-1\">\n          Simple chat interface using Vercel AI SDK\n        </p>\n      </form>\n    </div>\n  );\n};\n\nexport default SimpleChatPanel;\nðŸ“„ --- File: ./src/components/ui/StreamingChatPanel.tsx ---\n/**\n * StreamingChatPanel - Chat panel with streaming responses from Claude\n */\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface Message {\n  role: 'user' | 'assistant';\n  content: string;\n  id?: string;\n}\n\ninterface StreamingChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst StreamingChatPanel: React.FC<StreamingChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [streamedText, setStreamedText] = useState<string>(\"\");\n  \n  // Reference to the message container for auto-scrolling\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Auto-scroll to bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages, streamedText]);\n  \n  // Function to stream responses from the API\n  const streamResponse = async (response: Response) => {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n    \n    // Reset streamed text\n    setStreamedText(\"\");\n    \n    // Function to process stream chunks\n    const processText = async (): Promise<void> => {\n      try {\n        const { done, value } = await reader.read();\n        if (done) {\n          // When streaming is complete, add the message to the messages array\n          if (streamedText) {\n            setMessages(prev => [...prev, {\n              role: 'assistant',\n              content: streamedText\n            }]);\n            setStreamedText(\"\");\n          }\n          return;\n        }\n        \n        // Decode the chunk and append to streamed text\n        const text = new TextDecoder().decode(value);\n        try {\n          // Split response into individual events\n          const events = text.trim().split('\\\\n\\\\n').filter(Boolean);\n          \n          // Process each event\n          events.forEach(eventStr => {\n            if (eventStr.startsWith('data:')) {\n              const jsonStr = eventStr.slice(5).trim();\n              try {\n                if (jsonStr === '[DONE]') return;\n                \n                const data = JSON.parse(jsonStr);\n                if (data.choices && data.choices[0]?.delta?.content) {\n                  setStreamedText(prev => prev + data.choices[0].delta.content);\n                } else if (data.content) {\n                  setStreamedText(prev => prev + data.content);\n                }\n              } catch (err) {\n                console.error('Error parsing event JSON:', jsonStr, err);\n              }\n            }\n          });\n        } catch (err) {\n          console.error('Error processing text chunk:', err);\n          // As a fallback, just append the raw text\n          setStreamedText(prev => prev + text);\n        }\n        \n        // Continue reading\n        return processText();\n      } catch (err) {\n        console.error('Error reading stream:', err);\n        reader.cancel();\n        throw err;\n      }\n    };\n    \n    await processText();\n  };\n  \n  // Send a message to the API\n  const sendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!input.trim() || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Add the user message to the list\n      const userMessage: Message = {\n        role: 'user',\n        content: input.trim()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare the messages to send to the API\n      const messagesToSend = [\n        { role: 'system', content: systemPrompt },\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        userMessage\n      ];\n      \n      // Make the API request with stream option\n      const response = await fetch('/api/claude/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: messagesToSend,\n          notebookId,\n          model: 'claude-3-5-sonnet-20240620',\n          stream: true\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n      \n      // Clear the input\n      setInput(\"\");\n      \n      // Process the stream\n      await streamResponse(response);\n      \n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Streaming Chat</h2>\n        <p className=\"text-xs text-gray-500\">With real-time responses</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {/* Streaming response */}\n        {streamedText && (\n          <div className=\"p-3 rounded-lg bg-gray-100 text-gray-800 mr-auto max-w-[80%]\">\n            <div className=\"text-sm font-semibold mb-1\">\n              Assistant <span className=\"text-xs text-gray-500\">(streaming)</span>\n            </div>\n            <div className=\"whitespace-pre-wrap\">{streamedText}</div>\n          </div>\n        )}\n        \n        {/* Loading indicator */}\n        {isLoading && !streamedText && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n        \n        {/* Invisible element for auto-scrolling */}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={sendMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            disabled={isLoading}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Error Display */}\n        {error && (\n          <div className=\"mt-2 p-2 text-sm text-red-600 bg-red-50 rounded\">\n            Error: {error}\n          </div>\n        )}\n      </form>\n    </div>\n  );\n};\n\nexport default StreamingChatPanel;\nðŸ“„ --- File: ./src/pages/notebooks/[id]/ai-chat.tsx ---\n/**\n * AI Chat Page\n * \n * A test page to verify that the AI SDK integration is working properly\n */\nimport { useRouter } from 'next/router';\nimport { useState, useEffect } from 'react';\nimport LlamaIndexChat from '@/components/ui/LlamaIndexChat';\nimport Layout from '@/components/layout/Layout';\n\nexport default function AIChatPage() {\n  const router = useRouter();\n  const { id: notebookId } = router.query;\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    // Set loading to false once we have a notebookId\n    if (notebookId) {\n      setLoading(false);\n    }\n  }, [notebookId]);\n\n  if (loading) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <div className=\"animate-spin h-8 w-8 border-2 border-blue-500 border-t-transparent rounded-full\"></div>\n          <span className=\"ml-2\">Loading...</span>\n        </div>\n      </Layout>\n    );\n  }\n\n  return (\n    <Layout>\n      <div className=\"flex flex-col h-screen\">\n        <div className=\"p-4 bg-white shadow-sm\">\n          <h1 className=\"text-xl font-bold\">AI Chat Test Page</h1>\n          <p className=\"text-sm text-gray-500\">\n            Testing simple chat integration with notebook ID: {notebookId}\n          </p>\n          <p className=\"text-sm text-red-500 mt-1\">\n            Note: Using simplified UI for demonstration only - node saving disabled\n          </p>\n        </div>\n        \n        <div className=\"flex-1 bg-gray-50 p-4\">\n          <div className=\"bg-white shadow-sm rounded-lg h-full border border-gray-200\">\n            <LlamaIndexChat \n              notebookId={notebookId as string} \n              systemPrompt=\"You are a helpful assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\"\n            />\n          </div>\n        </div>\n      </div>\n    </Layout>\n  );\n}\nðŸ“„ --- File: ./src/pages/notebooks/[id]/chat.tsx ---\n// src/pages/notebooks/[id]/chat.tsx\nimport React from 'react';\nimport { useRouter } from 'next/router';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport LlamaChat from '@/components/ui/LlamaChat';\nimport Layout from '@/components/layout/Layout';\nimport LoadingSpinner from '@/components/ui/LoadingSpinner';\n\nconst NotebookChatPage = () => {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Handle the case when router.query isn't loaded yet\n  if (!router.isReady) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n  \n  const notebookId = typeof id === 'string' ? id : '';\n  \n  const { notebook, loading, error } = useNotebook(notebookId);\n\n  // Handle loading state\n  if (loading) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n\n  // Handle error state\n  if (error || !notebook) {\n    return (\n      <Layout>\n        <div className=\"flex flex-col items-center justify-center h-screen\">\n          <h2 className=\"text-xl font-semibold text-red-600 mb-4\">Error Loading Notebook</h2>\n          <p className=\"text-gray-700 mb-6\">{error || 'Notebook not found'}</p>\n          <button\n            onClick={() => router.push('/notebooks')}\n            className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n          >\n            Return to Notebooks\n          </button>\n        </div>\n      </Layout>\n    );\n  }\n\n  return (\n    <Layout>\n      <div className=\"flex flex-col h-screen\">\n        {/* Header */}\n        <div className=\"bg-white border-b border-gray-200 px-4 py-4 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <button\n              onClick={() => router.push(`/notebooks/${notebookId}`)}\n              className=\"mr-4 text-gray-600 hover:text-gray-900\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-5 w-5\"\n                viewBox=\"0 0 20 20\"\n                fill=\"currentColor\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n            </button>\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              {notebook.title || 'Untitled Notebook'} - Chat\n            </h1>\n          </div>\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={() => router.push(`/notebooks/${notebookId}/unified`)}\n              className=\"text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-600 rounded-md hover:bg-blue-50\"\n            >\n              Switch to Canvas\n            </button>\n          </div>\n        </div>\n\n        {/* Main content - Chat UI */}\n        <div className=\"flex-1 overflow-hidden bg-gray-50\">\n          <LlamaChat\n            notebookId={notebookId}\n            systemPrompt={notebook.system_prompt}\n            fullScreen={true}\n            className=\"max-w-4xl mx-auto bg-white shadow-sm h-full\"\n          />\n        </div>\n      </div>\n    </Layout>\n  );\n};\n\nexport default NotebookChatPage;\nðŸ” Files using `useState` with 'input':\n\nðŸ“„ --- File: ./src/components/ui/ConversationSidePanel.tsx (matched useState input) ---\n// src/components/ui/ConversationSidePanel.tsx\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Conversation } from '@/types/supabase';\nimport { useAIChat } from '@/hooks/useAIChat';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface ConversationSidePanelProps {\n  notebookId: string;\n  conversations: Conversation[];\n  onEditTranscription: (id: string, newText: string) => Promise<void>;\n  onSendMessage: (message: string, mode: 'chat' | 'comment') => Promise<void>;\n  onJumpToCard?: (id: string) => void;\n  onClose: () => void;\n  isOpen: boolean;\n  isFullScreen?: boolean;\n  onToggleFullScreen?: () => void;\n  systemPrompt?: string | null;\n}\n\n// Group conversations by thread\nconst groupByThread = (conversations: Conversation[]): Record<string, Conversation[]> => {\n  return conversations.reduce((acc, conv) => {\n    const threadId = conv.thread_id || conv.id;\n    if (!acc[threadId]) {\n      acc[threadId] = [];\n    }\n    acc[threadId].push(conv);\n    return acc;\n  }, {} as Record<string, Conversation[]>);\n};\n\n// Sort conversations within a thread (parents first, then children by created_at)\nconst sortThreadConversations = (conversations: Conversation[]): Conversation[] => {\n  // Build parent-child relationships\n  const convMap = new Map<string, Conversation>();\n  conversations.forEach(conv => {\n    convMap.set(conv.id, { ...conv, thread: [] });\n  });\n  \n  // Group by parents\n  const roots: Conversation[] = [];\n  const children: Conversation[] = [];\n  \n  conversations.forEach(conv => {\n    if (conv.parent_id && convMap.has(conv.parent_id)) {\n      children.push(conv);\n    } else {\n      roots.push(conv);\n    }\n  });\n  \n  // Sort roots by creation date\n  roots.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Sort children by creation date\n  children.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Combine sorted roots and children\n  return [...roots, ...children];\n};\n\nconst ConversationSidePanel: React.FC<ConversationSidePanelProps> = ({\n  notebookId,\n  conversations,\n  onEditTranscription,\n  onSendMessage,\n  onJumpToCard,\n  onClose,\n  isOpen,\n  isFullScreen = false,\n  onToggleFullScreen = () => {},\n  systemPrompt = null\n}) => {\n  // Initialize AI chat hook\n  const {\n    isLoading: isProcessing,\n    status,\n    sendMessage\n  } = useAIChat({\n    notebookId,\n    systemPrompt: systemPrompt || undefined,\n    api: '/api/ai/chat'\n  });\n  \n  // Simulate AI progress for UI consistency with the previous implementation\n  const [aiProgress, setAiProgress] = useState(0);\n  \n  useEffect(() => {\n    if (isProcessing) {\n      const interval = setInterval(() => {\n        setAiProgress(prev => Math.min(prev + 5, 90));\n      }, 300);\n      \n      return () => clearInterval(interval);\n    } else {\n      setAiProgress(0);\n    }\n  }, [isProcessing]);\n  const [inputValue, setInputValue] = useState('');\n  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);\n  const [expandedThreads, setExpandedThreads] = useState<Set<string>>(new Set());\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Scroll to highlighted message when receiving \"jumpToConversation\" event\n  useEffect(() => {\n    const handleJumpToConversation = (event: CustomEvent) => {\n      const { conversationId } = event.detail;\n      \n      // Find the conversation\n      const conversation = conversations.find(c => c.id === conversationId);\n      if (!conversation) return;\n      \n      // Determine thread ID\n      const threadId = conversation.thread_id || conversation.id;\n      \n      // Set active thread and ensure it's expanded\n      setActiveThreadId(threadId);\n      setExpandedThreads(prev => {\n        const newSet = new Set(prev);\n        newSet.add(threadId);\n        return newSet;\n      });\n      \n      // Scroll to the message\n      setTimeout(() => {\n        const messageElement = document.getElementById(`message-${conversationId}`);\n        if (messageElement) {\n          messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n          messageElement.classList.add('highlight-message');\n          setTimeout(() => {\n            messageElement.classList.remove('highlight-message');\n          }, 2000);\n        }\n      }, 100);\n    };\n    \n    // Add event listener\n    window.addEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    };\n  }, [conversations]);\n  \n  // Auto-grow textarea as content grows\n  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const value = e.target.value;\n    setInputValue(value);\n    \n    // Auto-resize textarea\n    e.target.style.height = 'auto';\n    e.target.style.height = `${Math.min(e.target.scrollHeight, 200)}px`;\n  };\n  \n  const handleSend = async () => {\n    if (!inputValue.trim()) return;\n\n    try {\n      // If there's an active thread, add to that thread\n      if (activeThreadId) {\n        const thread = conversations.find(c =>\n          c.id === activeThreadId || c.thread_id === activeThreadId\n        );\n\n        if (thread) {\n          // Get message history for the thread\n          const threadMessages = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .map(c => ({\n              role: 'user' as const,\n              content: c.user_content || '',\n              ...(c.ai_response ? { role: 'assistant' as const, content: c.ai_response } : {})\n            }))\n            .filter(m => m.content); // Filter out empty messages\n\n          // Send message through AI interaction hook\n          // Send the message using the new AI hook\n          const success = await sendMessage(inputValue);\n\n          // Save the message through the regular flow\n          await onSendMessage(inputValue, 'chat');\n\n          // With the new Vercel AI SDK, we don't get direct access to the response\n          // The response is handled through the onFinish callback and automatically\n          // added to the message history, so we can't check for duplicates like before\n          const lastConversationId = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0]?.id;\n\n            // With the new API, we don't need to manually update the transcription\n            // as it's handled by onSendMessage and the conversation system now\n          }\n        } else {\n          // If thread not found, create a new message\n          await onSendMessage(inputValue, 'chat');\n        }\n      } else {\n        // No active thread, create a new conversation\n        // Send message using the new AI hook (we don't get a direct response)\n        await sendMessage(inputValue);\n        \n        // Save through the regular flow\n        await onSendMessage(inputValue, 'chat');\n        \n        // With the new Vercel AI SDK architecture, we don't need to manually update\n        // the transcription as it's handled by the onSendMessage and conversation system\n      }\n    }\n\n      // Clear input regardless of outcome\n      setInputValue('');\n\n      if (inputRef.current) {\n        inputRef.current.style.height = 'auto';\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // Optionally show error to user\n    }\n  };\n  \n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n  \n  // Toggle thread expansion\n  const toggleThreadExpansion = (threadId: string) => {\n    setExpandedThreads(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(threadId)) {\n        newSet.delete(threadId);\n      } else {\n        newSet.add(threadId);\n      }\n      return newSet;\n    });\n  };\n  \n  // Group conversations by thread\n  const threadGroups = groupByThread(conversations);\n  \n  // Sort threads by most recent activity\n  const sortedThreadIds = Object.keys(threadGroups).sort((a, b) => {\n    const aLatest = threadGroups[a].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    const bLatest = threadGroups[b].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    return bLatest - aLatest; // Most recent first\n  });\n  \n  return (\n    <div\n      className={`bg-white border-l border-gray-200 shadow-xl ${\n        isOpen\n          ? (isFullScreen\n              ? 'fixed inset-0 z-50 w-full h-full'\n              : 'fixed right-0 top-0 bottom-0 z-40 w-80 h-full')\n          : 'fixed right-[-320px] top-0 bottom-0 z-40 w-80 h-full'\n      }`}\n      style={{\n        transition: 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out',\n        transform: isOpen ? 'translateX(0)' : 'translateX(100%)',\n        opacity: isOpen ? 1 : 0,\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      {/* Header */}\n      <div className=\"py-3 px-4 border-b border-gray-200 flex items-center justify-between\">\n        <h2 className=\"text-lg font-semibold text-gray-800\">Conversation Threads</h2>\n        <div className=\"flex space-x-2\">\n          {/* Toggle full-screen button */}\n          <button\n            onClick={onToggleFullScreen}\n            className={`p-1.5 rounded-md ${isFullScreen ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100'}`}\n            title={isFullScreen ? \"Exit full screen\" : \"Full screen mode\"}\n          >\n            {isFullScreen ? (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 3v3a2 2 0 01-2 2H3m18 0h-3a2 2 0 01-2-2V3m0 18v-3a2 2 0 012-2h3M3 16h3a2 2 0 012 2v3\" />\n              </svg>\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4\" />\n              </svg>\n            )}\n          </button>\n\n          {/* Close button */}\n          <button\n            onClick={onClose}\n            className=\"p-1.5 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100\"\n            title=\"Close panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      {/* Messages Container - wider padding in full-screen mode */}\n      <div className={`flex-1 overflow-y-auto ${isFullScreen ? 'p-6 md:px-12 lg:px-24' : 'p-4'} space-y-8`}>\n        {sortedThreadIds.map(threadId => {\n          const threadsInGroup = sortThreadConversations(threadGroups[threadId]);\n          const starter = threadsInGroup.find(t => t.is_thread_starter) || threadsInGroup[0];\n          const isExpanded = expandedThreads.has(threadId);\n          const isActive = activeThreadId === threadId;\n          \n          // Determine card type\n          const cardType = starter.card_type || \n            (starter.is_thread_starter ? 'question' : 'note');\n          \n          // Color indicator based on card type\n          const colorMap = {\n            question: 'bg-purple-600',\n            response: 'bg-blue-600',\n            note: 'bg-green-600',\n            follow_up: 'bg-amber-600'\n          };\n          \n          const bgColorMap = {\n            question: 'bg-purple-50',\n            response: 'bg-blue-50',\n            note: 'bg-green-50',\n            follow_up: 'bg-amber-50'\n          };\n          \n          const textColorMap = {\n            question: 'text-purple-700',\n            response: 'text-blue-700',\n            note: 'text-green-700',\n            follow_up: 'text-amber-700'\n          };\n          \n          return (\n            <div \n              key={threadId}\n              className={`border rounded-lg shadow-sm ${isActive ? 'border-blue-300 shadow-md' : 'border-gray-200'}`}\n            >\n              {/* Thread Header */}\n              <div \n                className={`p-3 rounded-t-lg flex items-center justify-between cursor-pointer\n                  ${bgColorMap[cardType as keyof typeof bgColorMap] || 'bg-gray-50'}`}\n                onClick={() => toggleThreadExpansion(threadId)}\n              >\n                <div className=\"flex items-center space-x-2\">\n                  <div className={`w-3 h-3 rounded-full ${colorMap[cardType as keyof typeof colorMap] || 'bg-gray-500'}`}></div>\n                  <h3 className={`font-medium ${textColorMap[cardType as keyof typeof textColorMap] || 'text-gray-700'}`}>\n                    {starter.user_content?.split('\\n')[0].substring(0, 40) || 'Untitled Thread'}\n                  </h3>\n                </div>\n                \n                <div className=\"flex items-center space-x-2\">\n                  <span className=\"text-xs text-gray-500\">\n                    {threadsInGroup.length} message{threadsInGroup.length !== 1 ? 's' : ''}\n                  </span>\n                  <svg \n                    xmlns=\"http://www.w3.org/2000/svg\" \n                    className={`h-5 w-5 text-gray-500 transition-transform ${isExpanded ? 'transform rotate-180' : ''}`} \n                    viewBox=\"0 0 20 20\" \n                    fill=\"currentColor\"\n                  >\n                    <path fillRule=\"evenodd\" d=\"M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n                  </svg>\n                </div>\n              </div>\n              \n              {/* Thread Messages */}\n              {isExpanded && (\n                <div className=\"p-3 space-y-4\">\n                  {threadsInGroup.map((message, _index) => { // Prefixed with underscore to satisfy ESLint unused arg rule\n                    const isStarter = message.id === starter.id;\n                    const depth = message.parent_id ? 1 : 0; // Simple depth calculation\n                    \n                    return (\n                      <div \n                        key={message.id}\n                        id={`message-${message.id}`}\n                        className={`transition-all duration-300 ${\n                          depth > 0 ? 'ml-6 border-l-2 pl-3 border-gray-200' : ''\n                        }`}\n                      >\n                        <div className=\"flex justify-between items-start mb-1\">\n                          <div className=\"flex items-center\">\n                            <div className={`w-2 h-2 rounded-full mr-2 ${\n                              isStarter ? colorMap[cardType as keyof typeof colorMap] : 'bg-gray-400'\n                            }`}></div>\n                            <span className=\"text-xs text-gray-500\">\n                              {new Date(message.created_at).toLocaleString()}\n                            </span>\n                          </div>\n                          \n                          {/* Jump to card button */}\n                          <button\n                            className=\"text-xs text-blue-600 hover:text-blue-800 flex items-center\"\n                            onClick={() => onJumpToCard && onJumpToCard(message.id)}\n                          >\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                              <path fillRule=\"evenodd\" d=\"M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z\" clipRule=\"evenodd\" />\n                            </svg>\n                            Jump\n                          </button>\n                        </div>\n                        \n                        {/* Message content */}\n                        {message.user_content && (\n                          <div className=\"mb-2 bg-white rounded-md p-3 border border-gray-200\">\n                            <p className=\"text-gray-700 whitespace-pre-wrap\">\n                              {message.user_content}\n                            </p>\n                          </div>\n                        )}\n                        \n                        {/* AI response */}\n                        {message.ai_response && (\n                          <div className=\"mb-2 bg-blue-50 rounded-md p-3 border border-blue-100\">\n                            <p className=\"text-blue-800 whitespace-pre-wrap\">\n                              {message.ai_response}\n                            </p>\n                          </div>\n                        )}\n                      </div>\n                    );\n                  })}\n                </div>\n              )}\n            </div>\n          );\n        })}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input Area - centered and with max-width in full-screen mode */}\n      <div className={`border-t border-gray-200 ${isFullScreen ? 'p-6' : 'p-4'}`}>\n        <div className={`relative ${isFullScreen ? 'max-w-3xl mx-auto' : ''}`}>\n          <textarea\n            ref={inputRef}\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Type a message...\"\n            className={`w-full border border-gray-300 rounded-lg py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none\n              ${isFullScreen ? 'text-lg' : ''}`}\n            rows={1}\n            disabled={isProcessing}\n          />\n          <button\n            onClick={handleSend}\n            disabled={!inputValue.trim() || isProcessing}\n            className={`absolute right-2 bottom-2 ${isProcessing ? 'bg-gray-400' : 'bg-blue-600'} text-white ${isFullScreen ? 'p-3' : 'p-2'} rounded-full disabled:opacity-50`}\n          >\n            {isProcessing ? (\n              <Spinner size=\"sm\" />\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className={`${isFullScreen ? 'h-6 w-6' : 'h-5 w-5'}`} viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            )}\n          </button>\n        </div>\n\n        {/* AI Progress indicator */}\n        {aiProgress > 0 && aiProgress < 100 && (\n          <div className={`mt-2 ${isFullScreen ? 'max-w-3xl mx-auto' : ''}`}>\n            <div className=\"h-1 w-full bg-gray-200 rounded-full overflow-hidden\">\n              <div\n                className=\"h-full bg-blue-600 transition-all duration-300 ease-in-out\"\n                style={{ width: `${aiProgress}%` }}\n              ></div>\n            </div>\n            <p className=\"text-xs text-gray-500 mt-1 text-center\">AI is thinking...</p>\n          </div>\n        )}\n      </div>\n      \n      {/* No custom styles needed - using global CSS classes */}\n    </div>\n  );\n};\n\nexport default ConversationSidePanel;\nðŸ“„ --- File: ./src/components/ui/DirectChatPanel.tsx (matched useState input) ---\n/**\n * DirectChatPanel - Simple chat panel using direct fetch instead of the AI SDK\n */\nimport React, { useState, useRef } from 'react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface Message {\n  role: 'user' | 'assistant';\n  content: string;\n}\n\ninterface DirectChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst DirectChatPanel: React.FC<DirectChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Send a message to the API\n  const sendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!input.trim() || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Add the user message to the list\n      const userMessage: Message = {\n        role: 'user',\n        content: input.trim()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare the messages to send to the API\n      const messagesToSend = [\n        { role: 'system', content: systemPrompt },\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        userMessage\n      ];\n      \n      // Make the API request\n      const response = await fetch('/api/claude/chat-simple', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: messagesToSend,\n          notebookId,\n          model: 'claude-3-5-sonnet-20240620',\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      console.log('API response:', result);\n      \n      // Handle the assistant's response\n      if (Array.isArray(result) && result.length > 0) {\n        const assistantMessage = result[0];\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: assistantMessage.content\n        }]);\n      } else if (result.content) {\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: result.content\n        }]);\n      } else {\n        setError('Received unexpected response format from API');\n      }\n      \n      // Clear the input\n      setInput(\"\");\n      \n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Direct Chat</h2>\n        <p className=\"text-xs text-gray-500\">Using Claude 3.5 Sonnet</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {isLoading && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={sendMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            disabled={isLoading}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Error Display */}\n        {error && (\n          <div className=\"mt-2 p-2 text-sm text-red-600 bg-red-50 rounded\">\n            Error: {error}\n          </div>\n        )}\n        \n        {/* Debug Info */}\n        <div className=\"mt-2 text-xs text-gray-500\">\n          Status: {isLoading ? \"Loading\" : \"Ready\"} | Messages: {messages.length}\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default DirectChatPanel;\nðŸ“„ --- File: ./src/components/ui/StreamingChatPanel.tsx (matched useState input) ---\n/**\n * StreamingChatPanel - Chat panel with streaming responses from Claude\n */\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface Message {\n  role: 'user' | 'assistant';\n  content: string;\n  id?: string;\n}\n\ninterface StreamingChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst StreamingChatPanel: React.FC<StreamingChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [streamedText, setStreamedText] = useState<string>(\"\");\n  \n  // Reference to the message container for auto-scrolling\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Auto-scroll to bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages, streamedText]);\n  \n  // Function to stream responses from the API\n  const streamResponse = async (response: Response) => {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n    \n    // Reset streamed text\n    setStreamedText(\"\");\n    \n    // Function to process stream chunks\n    const processText = async (): Promise<void> => {\n      try {\n        const { done, value } = await reader.read();\n        if (done) {\n          // When streaming is complete, add the message to the messages array\n          if (streamedText) {\n            setMessages(prev => [...prev, {\n              role: 'assistant',\n              content: streamedText\n            }]);\n            setStreamedText(\"\");\n          }\n          return;\n        }\n        \n        // Decode the chunk and append to streamed text\n        const text = new TextDecoder().decode(value);\n        try {\n          // Split response into individual events\n          const events = text.trim().split('\\\\n\\\\n').filter(Boolean);\n          \n          // Process each event\n          events.forEach(eventStr => {\n            if (eventStr.startsWith('data:')) {\n              const jsonStr = eventStr.slice(5).trim();\n              try {\n                if (jsonStr === '[DONE]') return;\n                \n                const data = JSON.parse(jsonStr);\n                if (data.choices && data.choices[0]?.delta?.content) {\n                  setStreamedText(prev => prev + data.choices[0].delta.content);\n                } else if (data.content) {\n                  setStreamedText(prev => prev + data.content);\n                }\n              } catch (err) {\n                console.error('Error parsing event JSON:', jsonStr, err);\n              }\n            }\n          });\n        } catch (err) {\n          console.error('Error processing text chunk:', err);\n          // As a fallback, just append the raw text\n          setStreamedText(prev => prev + text);\n        }\n        \n        // Continue reading\n        return processText();\n      } catch (err) {\n        console.error('Error reading stream:', err);\n        reader.cancel();\n        throw err;\n      }\n    };\n    \n    await processText();\n  };\n  \n  // Send a message to the API\n  const sendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!input.trim() || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Add the user message to the list\n      const userMessage: Message = {\n        role: 'user',\n        content: input.trim()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare the messages to send to the API\n      const messagesToSend = [\n        { role: 'system', content: systemPrompt },\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        userMessage\n      ];\n      \n      // Make the API request with stream option\n      const response = await fetch('/api/claude/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: messagesToSend,\n          notebookId,\n          model: 'claude-3-5-sonnet-20240620',\n          stream: true\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n      \n      // Clear the input\n      setInput(\"\");\n      \n      // Process the stream\n      await streamResponse(response);\n      \n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Streaming Chat</h2>\n        <p className=\"text-xs text-gray-500\">With real-time responses</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {/* Streaming response */}\n        {streamedText && (\n          <div className=\"p-3 rounded-lg bg-gray-100 text-gray-800 mr-auto max-w-[80%]\">\n            <div className=\"text-sm font-semibold mb-1\">\n              Assistant <span className=\"text-xs text-gray-500\">(streaming)</span>\n            </div>\n            <div className=\"whitespace-pre-wrap\">{streamedText}</div>\n          </div>\n        )}\n        \n        {/* Loading indicator */}\n        {isLoading && !streamedText && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n        \n        {/* Invisible element for auto-scrolling */}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={sendMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            disabled={isLoading}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Error Display */}\n        {error && (\n          <div className=\"mt-2 p-2 text-sm text-red-600 bg-red-50 rounded\">\n            Error: {error}\n          </div>\n        )}\n      </form>\n    </div>\n  );\n};\n\nexport default StreamingChatPanel;\nðŸ“„ --- File: ./src/components/canvas/CanvasContainer.tsx (matched useState input) ---\n// src/components/canvas/CanvasContainer.tsx\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Stage, Layer } from 'react-konva';\nimport { KonvaEventObject } from 'konva/lib/Node';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Stroke, Conversation } from '@/types/supabase';\nimport { extractPositionFromJson } from '@/types/position';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport { useRouter } from 'next/router';\nimport DrawingLayer from './DrawingLayer';\nimport TextLayer from './TextLayer';\nimport BackgroundLayer from './BackgroundLayer';\nimport CardLayer from './CardLayer';\n// Using updated responsive toolbar\nimport ResponsiveToolbar from './ResponsiveToolbar';\nimport SystemPromptModal from '@/components/modals/SystemPromptModal';\nimport ConversationSidePanel from '@/components/ui/ConversationSidePanel';\nimport { generateUUID } from '@/utils/uuidUtils';\n\n// Tool types definition\nexport type Tool = 'pen' | 'eraser' | 'select' | 'text' | 'pan';\n\n// Component Props\ninterface CanvasContainerProps {\n  notebookId: string;\n}\n\nconst CanvasContainer: React.FC<CanvasContainerProps> = ({ notebookId }) => {\n  const { user } = useAuth();\n  const { notebook, loading: notebookLoading } = useNotebook(notebookId);\n  const router = useRouter();\n  \n  // Refs\n   \n  const stageRef = useRef<any>(null); // Using any for Konva Stage ref\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Canvas dimension state\n  const [stageWidth, setStageWidth] = useState(typeof window !== 'undefined' ? window.innerWidth : 1000);\n  const [stageHeight, setStageHeight] = useState(typeof window !== 'undefined' ? window.innerHeight - 100 : 900);\n  \n  // Canvas view state\n  const [scale, setScale] = useState(1);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  // Tool state\n  const [tool, setTool] = useState<Tool>('pen');\n  const [previousTool, setPreviousTool] = useState<Tool>('pen');\n  const [isPenMode, setIsPenMode] = useState(true);\n  const [penSize, setPenSize] = useState(2);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [penColor, setPenColor] = useState('#000000');\n\n  // Tool transition handling\n  const safeSetTool = useCallback((newTool: Tool) => {\n    console.log(`CanvasContainer: Setting tool from ${tool} to ${newTool}`);\n    setPreviousTool(tool);\n    setTool(newTool);\n  }, [tool]);\n\n  // Error boundary for tool switching\n  useEffect(() => {\n    const handleToolChangeError = (error: ErrorEvent) => {\n      console.error('Error during tool change:', error);\n\n      // If we get a \"getParent\" or similar Konva error, try to recover\n      if (error.message.includes('getParent') ||\n          error.message.includes('parent') ||\n          error.message.includes('undefined')) {\n\n        console.warn('Detected Konva parent error during tool switch, attempting recovery');\n\n        // Force back to previous tool as a recovery mechanism\n        setTimeout(() => {\n          console.log(`Recovering by reverting to previous tool: ${previousTool}`);\n          setTool(previousTool);\n        }, 100);\n      }\n    };\n\n    // Listen for errors that might indicate tool switching problems\n    window.addEventListener('error', handleToolChangeError);\n\n    return () => {\n      window.removeEventListener('error', handleToolChangeError);\n    };\n  }, [previousTool]);\n  \n  // Drawing state\n  const [strokes, setStrokes] = useState<Stroke[]>([]);\n  const [currentStroke, setCurrentStroke] = useState<Stroke | null>(null);\n  const [undoStack, setUndoStack] = useState<Stroke[]>([]);\n  const [isDrawing, setIsDrawing] = useState(false);\n  \n  // Conversation state\n  const [conversationState, setConversationState] = useState<{\n    items: Conversation[];\n    positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>;\n    activeInfoDialog: string | null;\n    activeConversation: string | null;\n  }>({\n    items: [],\n    positions: {},\n    activeInfoDialog: null,\n    activeConversation: null\n  });\n  \n  // Parliament functionality has been removed\n\n  // UI state\n  const [isSidePanelOpen, setIsSidePanelOpen] = useState(false);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isSidePanelFullScreen, setIsSidePanelFullScreen] = useState(false);\n  const [isSystemPromptModalOpen, setIsSystemPromptModalOpen] = useState(false);\n  const [systemPrompt, setSystemPrompt] = useState<string | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  \n  // Resize handler\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleResize = () => {\n      if (containerRef.current) {\n        setStageWidth(containerRef.current.offsetWidth);\n        setStageHeight(containerRef.current.offsetHeight - 100);\n      }\n    };\n    \n    handleResize();\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // Load notebook data\n  useEffect(() => {\n    if (notebookLoading || !notebook) return;\n    \n    // Load system prompt from notebook\n    if (notebook.system_prompt) {\n      setSystemPrompt(notebook.system_prompt);\n    }\n    \n    // Fetch strokes\n    const fetchStrokes = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('strokes')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          setStrokes(data);\n        }\n      } catch (err) {\n        console.error('Error fetching strokes:', err);\n      }\n    };\n    \n    // Fetch conversations\n    const fetchConversations = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('conversations')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          const positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }> = {};\n          \n          // Initialize positions\n          data.forEach(conv => {\n            if (conv.id) {\n              const pos = extractPositionFromJson(conv.position);\n              positions[conv.id] = {\n                x: pos.x,\n                y: pos.y,\n                isCollapsed: false,\n                isDragging: false\n              };\n            }\n          });\n          \n          setConversationState({\n            items: data,\n            positions,\n            activeInfoDialog: null,\n            activeConversation: null\n          });\n        }\n      } catch (err) {\n        console.error('Error fetching conversations:', err);\n      }\n    };\n    \n    fetchStrokes();\n    fetchConversations();\n    \n    // Set up real-time subscription\n    if (user) {\n      const strokesSubscription = supabase\n        .channel(`strokes:${notebookId}`)\n        .on('postgres_changes', {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'strokes',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, (payload) => {\n          const newStroke = payload.new as Stroke;\n          \n          // Only add strokes from other users\n          if (user && newStroke.user_id !== user.id) {\n            setStrokes(prev => [...prev, newStroke]);\n          }\n        })\n        .subscribe();\n        \n      const conversationsSubscription = supabase\n        .channel(`conversations:${notebookId}`)\n        .on('postgres_changes', {\n          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)\n          schema: 'public',\n          table: 'conversations',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, async (payload) => {\n          if (payload.eventType === 'INSERT') {\n            const newConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: [...prev.items, newConversation],\n              positions: {\n                ...prev.positions,\n                [newConversation.id]: {\n                  ...extractPositionFromJson(newConversation.position),\n                  isCollapsed: false,\n                  isDragging: false\n                }\n              }\n            }));\n          } else if (payload.eventType === 'UPDATE') {\n            const updatedConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.map(item => \n                item.id === updatedConversation.id ? updatedConversation : item\n              ),\n              positions: {\n                ...prev.positions,\n                [updatedConversation.id]: {\n                  ...prev.positions[updatedConversation.id],\n                  ...extractPositionFromJson(\n                    updatedConversation.position,\n                    prev.positions[updatedConversation.id]?.x || 100,\n                    prev.positions[updatedConversation.id]?.y || 100\n                  )\n                }\n              }\n            }));\n          } else if (payload.eventType === 'DELETE') {\n            const deletedConversation = payload.old as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.filter(item => item.id !== deletedConversation.id),\n              positions: Object.entries(prev.positions).reduce((acc, [key, value]) => {\n                if (key !== deletedConversation.id) {\n                  acc[key] = value;\n                }\n                return acc;\n              }, {} as Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>)\n            }));\n          }\n        })\n        .subscribe();\n        \n      return () => {\n        supabase.removeChannel(strokesSubscription);\n        supabase.removeChannel(conversationsSubscription);\n      };\n    }\n  }, [notebookId, notebookLoading, notebook, user]);\n  \n  // Jump to card if specified in URL\n  useEffect(() => {\n    if (!router.isReady) return;\n    \n    const { card, x, y, zoom } = router.query;\n    \n    if (card && typeof card === 'string') {\n      // Find the card in conversation state\n      const conversation = conversationState.items.find(c => c.id === card);\n      \n      if (conversation && conversationState.positions[card]) {\n        // Center view on the card\n        const pos = conversationState.positions[card];\n        setPosition({\n          x: -pos.x + stageWidth / 2 - 140, // Center card horizontally\n          y: -pos.y + stageHeight / 2 - 100 // Center card vertically\n        });\n        \n        // Set as active\n        setConversationState(prev => ({\n          ...prev,\n          activeConversation: card\n        }));\n      }\n    } else if (x && y && typeof x === 'string' && typeof y === 'string') {\n      // Jump to specific position\n      setPosition({\n        x: -parseInt(x) + stageWidth / 2,\n        y: -parseInt(y) + stageHeight / 2\n      });\n      \n      // Set zoom if specified\n      if (zoom && typeof zoom === 'string') {\n        const zoomValue = parseFloat(zoom);\n        if (!isNaN(zoomValue) && zoomValue > 0) {\n          setScale(zoomValue);\n        }\n      }\n    }\n  }, [router.isReady, router.query, conversationState.items, conversationState.positions, stageWidth, stageHeight]);\n  \n  // Active conversation reference is used in other parts of the component\n\n  // Debug mode state\n  const [debugMode, setDebugMode] = useState(false);\n\n  // State to track input type\n  const [inputType, setInputType] = useState('mouse'); // 'mouse', 'touch', or 'pen'\n\n  // Detect input type on first interaction\n  useEffect(() => {\n    const handleInputTypeDetection = (e: PointerEvent) => {\n      if (e.pointerType === 'pen' || e.pointerType === 'stylus') {\n        setInputType('pen');\n        console.log('Pen input detected');\n      } else if (e.pointerType === 'touch' || e.type.includes('touch')) {\n        setInputType('touch');\n        console.log('Touch input detected');\n      } else {\n        setInputType('mouse');\n        console.log('Mouse input detected');\n      }\n    };\n\n    // Add pointerdown listener to detect input type\n    document.addEventListener('pointerdown', handleInputTypeDetection);\n\n    // Also check touch capability\n    if (window.matchMedia(\"(pointer: coarse)\").matches) {\n      console.log('Touch-capable device detected');\n      setInputType('touch');\n    }\n\n    return () => {\n      document.removeEventListener('pointerdown', handleInputTypeDetection);\n    };\n  }, []);\n\n  // Optimize selection behavior based on input type\n  useEffect(() => {\n    console.log(`Input type detected: ${inputType}`);\n\n    // Adjust selection threshold based on input type\n    if (inputType === 'touch') {\n      // Touch needs larger selection threshold\n      setSelectionThreshold(30); // px\n    } else if (inputType === 'pen') {\n      // Pen can be more precise\n      setSelectionThreshold(15); // px\n    } else {\n      // Mouse is most precise\n      setSelectionThreshold(10); // px\n    }\n\n    // Adjust cursor style based on input type\n    if (stageRef.current) {\n      const stage = stageRef.current.getStage();\n      if (stage && stage.container) {\n        if (inputType === 'touch') {\n          // On touch, cursors aren't visible anyway\n          stage.container().style.cursor = 'default';\n        } else if (tool === 'select') {\n          stage.container().style.cursor = 'crosshair';\n        } else if (tool === 'pan') {\n          stage.container().style.cursor = 'grab';\n        } else if (tool === 'pen') {\n          stage.container().style.cursor = 'pointer';\n        } else if (tool === 'eraser') {\n          stage.container().style.cursor = 'cell';\n        } else {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [inputType, tool]);\n\n  // Add keyboard shortcut to toggle debug mode (Ctrl+Shift+D)\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'd' && e.ctrlKey && e.shiftKey) {\n        setDebugMode(prev => !prev);\n        console.log(`Debug mode ${!debugMode ? 'enabled' : 'disabled'}`);\n      }\n\n      // Allow forcing a specific input type for testing (Shift+Alt+...)\n      if (e.shiftKey && e.altKey) {\n        if (e.key === 'm') {\n          setInputType('mouse');\n          console.log('Forced input type: mouse');\n        } else if (e.key === 't') {\n          setInputType('touch');\n          console.log('Forced input type: touch');\n        } else if (e.key === 'p') {\n          setInputType('pen');\n          console.log('Forced input type: pen');\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [debugMode]);\n\n  // Debug panel component\n  const DebugPanel = () => {\n    if (!debugMode) return null;\n\n    return (\n      <div style={{\n        position: 'absolute',\n        bottom: 10,\n        left: 10,\n        background: 'rgba(0,0,0,0.7)',\n        color: 'white',\n        padding: 10,\n        borderRadius: 5,\n        fontSize: 12,\n        zIndex: 1000,\n        fontFamily: 'monospace',\n        maxWidth: '300px'\n      }}>\n        <div style={{ borderBottom: '1px solid rgba(255,255,255,0.3)', paddingBottom: '5px', marginBottom: '5px', fontWeight: 'bold' }}>\n          Input Debug Panel\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Tool:</div>\n          <div>{tool}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Input:</div>\n          <div>{inputType}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Selection:</div>\n          <div>{isSelecting ? 'Active' : 'Inactive'}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Precision:</div>\n          <div>{selectionPrecision}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Threshold:</div>\n          <div>{selectionThreshold}px</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Scale:</div>\n          <div>{(scale * 100).toFixed(0)}%</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Position:</div>\n          <div>{Math.round(position.x)},{Math.round(position.y)}</div>\n        </div>\n        {selectionRect.isActive && (\n          <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px' }}>\n            <div>Selection:</div>\n            <div>\n              x:{Math.round(selectionRect.x)}, y:{Math.round(selectionRect.y)},\n              w:{Math.round(selectionRect.width)}, h:{Math.round(selectionRect.height)}\n            </div>\n          </div>\n        )}\n        <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px', fontSize: '10px' }}>\n          Shortcuts:\n          <div>â€¢ Ctrl+Shift+D: Toggle debug panel</div>\n          <div>â€¢ Shift+Alt+M: Force mouse input</div>\n          <div>â€¢ Shift+Alt+T: Force touch input</div>\n          <div>â€¢ Shift+Alt+P: Force pen input</div>\n        </div>\n        <button\n          onClick={() => setDebugMode(false)}\n          style={{\n            marginTop: 5,\n            padding: '2px 5px',\n            background: '#333',\n            border: '1px solid #555',\n            color: 'white',\n            borderRadius: '3px',\n            cursor: 'pointer',\n            fontSize: '11px'\n          }}\n        >\n          Close\n        </button>\n      </div>\n    );\n  };\n\n  // State for selection\n  const [selectionRect, setSelectionRect] = useState({ x: 0, y: 0, width: 0, height: 0, isActive: false });\n  const [isSelecting, setIsSelecting] = useState(false);\n  const [selectionThreshold, setSelectionThreshold] = useState(10); // px\n  const [selectionPrecision, setSelectionPrecision] = useState('normal'); // 'normal' or 'high'\n\n  // Get pressure from pointer events\n  const getPressure = useCallback((e: any) => {\n    // Default pressure if not available\n    let pressure = 1.0;\n\n    // Try to get pressure from various events\n    if (e.pressure !== undefined && e.pressure !== 0) {\n      // Pointer events include pressure\n      pressure = e.pressure;\n    } else if (e.touches && e.touches[0] && e.touches[0].force !== undefined) {\n      // Some touch events include force (iOS)\n      pressure = e.touches[0].force;\n    } else if (e.evt && e.evt.pressure !== undefined && e.evt.pressure !== 0) {\n      // Konva wraps events in evt property\n      pressure = e.evt.pressure;\n    } else if (e.evt && e.evt.touches && e.evt.touches[0] && e.evt.touches[0].force !== undefined) {\n      // Konva wrapped touch events\n      pressure = e.evt.touches[0].force;\n    }\n\n    return pressure;\n  }, []);\n\n  // Universal input handler for all device types\n  const handleInputStart = useCallback((e: any) => {\n    // Get stage from event\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    // Get pointer position\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Log input for debugging\n    console.log(`Input start (${e.type || e.evt?.type || 'unknown'}) at position:`, pos.x, pos.y);\n\n    // Get pressure for pen input\n    const pressure = getPressure(e);\n    console.log(`Input pressure: ${pressure}`);\n\n    // Adjust selection behavior based on pressure\n    if (pressure > 0.5) {\n      // Harder press might indicate more precise selection\n      setSelectionPrecision('high');\n    } else {\n      setSelectionPrecision('normal');\n    }\n\n    // Check if we clicked on a card or other interactive element\n    const target = e.target;\n    const isClickOnCard = target.hasName?.('card-wrapper') ||\n                        target.findAncestor?.('card-wrapper') ||\n                        target.findAncestor?.('thread-card');\n\n    // Handle based on current tool\n    if (tool === 'pan' || (e.evt?.button === 1 || e.evt?.buttons === 4)) {\n      // Middle mouse or pan tool - handle panning\n      if (stage) {\n        stage.container().style.cursor = 'grabbing';\n      }\n      return;\n    }\n\n    if (tool === 'select') {\n      // If clicking on a card while in select mode, ignore\n      if (isClickOnCard) {\n        console.log(\"Clicked on interactive element while in select mode - ignoring\");\n        return;\n      }\n\n      console.log(\"Starting selection at\", pos.x, pos.y);\n\n      // Store initial position, accounting for scroll and zoom\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect({\n        x: adjustedX,\n        y: adjustedY,\n        width: 0,\n        height: 0,\n        isActive: true\n      });\n\n      // Set a flag to indicate we're selecting\n      setIsSelecting(true);\n      return;\n    }\n\n    if (tool === 'text') {\n      // Text insertion logic - we'll implement this later\n      return;\n    }\n\n    if (tool === 'pen' || tool === 'eraser') {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Create new stroke\n      const newStroke: Stroke = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        points: [{ x, y, pressure }],\n        tool: tool,\n        color: tool === 'pen' ? penColor : '#ffffff',\n        width: tool === 'pen' ? penSize : eraserSize,\n        order_index: strokes.length,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        user_id: user?.id\n      };\n\n      setCurrentStroke(newStroke);\n      setIsDrawing(true);\n      setUndoStack([]);\n    }\n  }, [tool, position, scale, notebookId, strokes.length, penColor, penSize, eraserSize, user?.id, getPressure]);\n\n  // Unified move handler for all input types\n  const handleInputMove = useCallback((e: any) => {\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Handle panning\n    if (tool === 'pan' || e.evt?.buttons === 4 || (e.evt?.buttons === 1 && e.evt?.button === 1)) {\n      // Panning logic\n      const dx = e.evt?.movementX || 0;\n      const dy = e.evt?.movementY || 0;\n\n      setPosition(prev => ({\n        x: prev.x + dx,\n        y: prev.y + dy\n      }));\n\n      return;\n    }\n\n    // Handle selection\n    if (tool === 'select' && isSelecting) {\n      // Calculate adjusted position for zoom and pan\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect((prev) => ({\n        ...prev,\n        width: adjustedX - prev.x,\n        height: adjustedY - prev.y\n      }));\n\n      return;\n    }\n\n    // Handle drawing\n    if (isDrawing && currentStroke) {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Get pressure data\n      const pressure = getPressure(e);\n\n      // Add point to current stroke\n      setCurrentStroke(prev => {\n        if (!prev) return null;\n\n        const newPoints = [...prev.points, { x, y, pressure }];\n        return { ...prev, points: newPoints };\n      });\n    }\n  }, [isDrawing, currentStroke, tool, position, scale, isSelecting, getPressure]);\n\n  // Unified end handler for all input types\n  const handleInputEnd = useCallback(async (e: any) => {\n    // Handle selection completion\n    if (tool === 'select' && isSelecting) {\n      console.log(\"Ending selection\");\n      setIsSelecting(false);\n\n      // Check if selection has meaningful size\n      if (Math.abs(selectionRect.width) > selectionThreshold &&\n          Math.abs(selectionRect.height) > selectionThreshold) {\n        const normalizedRect = {\n          x: selectionRect.width > 0 ? selectionRect.x : selectionRect.x + selectionRect.width,\n          y: selectionRect.height > 0 ? selectionRect.y : selectionRect.y + selectionRect.height,\n          width: Math.abs(selectionRect.width),\n          height: Math.abs(selectionRect.height),\n          isActive: false\n        };\n\n        console.log(\"Selection completed:\", normalizedRect);\n        // TODO: Process the selection (e.g., analyze text in this area)\n      } else {\n        // Reset selection if too small\n        setSelectionRect({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0,\n          isActive: false\n        });\n      }\n\n      return;\n    }\n\n    // Handle drawing completion\n    if (isDrawing && currentStroke) {\n      if (currentStroke.points.length < 2) {\n        // If it's just a dot, add another point slightly offset\n        const point = currentStroke.points[0];\n        setCurrentStroke(prev => {\n          if (!prev) return null;\n          return {\n            ...prev,\n            points: [...prev.points, { x: point.x + 0.1, y: point.y + 0.1, pressure: point.pressure }]\n          };\n        });\n      }\n\n      // Save the completed stroke\n      setStrokes(prev => [...prev, currentStroke]);\n\n      // Save to database if authenticated\n      if (user) {\n        try {\n          await supabase.from('strokes').insert(currentStroke);\n\n          // Store stroke ID for undo functionality\n          if (typeof window !== 'undefined') {\n            if (!window.ownStrokeIds) {\n              window.ownStrokeIds = new Set();\n            }\n            window.ownStrokeIds.add(currentStroke.id);\n          }\n        } catch (err) {\n          console.error('Error saving stroke:', err);\n        }\n      }\n\n      setCurrentStroke(null);\n      setIsDrawing(false);\n    }\n  }, [isDrawing, currentStroke, user, tool, isSelecting, selectionRect, selectionThreshold]);\n  \n  // Undo/Redo handlers\n  const handleUndo = useCallback(async () => {\n    if (strokes.length === 0) return;\n\n    const lastStroke = strokes[strokes.length - 1];\n    const newStrokes = strokes.slice(0, -1);\n\n    setStrokes(newStrokes);\n    setUndoStack(prev => [...prev, lastStroke]);\n\n    // Update database if authenticated\n    if (user && lastStroke.id && window.ownStrokeIds?.has(lastStroke.id)) {\n      try {\n        await supabase.from('strokes').delete().eq('id', lastStroke.id);\n      } catch (err) {\n        console.error('Error deleting stroke:', err);\n      }\n    }\n  }, [strokes, user]);\n\n  const handleRedo = useCallback(async () => {\n    if (undoStack.length === 0) return;\n\n    const strokeToRedo = undoStack[undoStack.length - 1];\n    const newUndoStack = undoStack.slice(0, -1);\n\n    setStrokes(prev => [...prev, strokeToRedo]);\n    setUndoStack(newUndoStack);\n\n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').insert(strokeToRedo);\n\n        // Store stroke ID for undo functionality\n        if (typeof window !== 'undefined') {\n          if (!window.ownStrokeIds) {\n            window.ownStrokeIds = new Set();\n          }\n          window.ownStrokeIds.add(strokeToRedo.id);\n        }\n      } catch (err) {\n        console.error('Error redoing stroke:', err);\n      }\n    }\n  }, [undoStack, user]);\n\n  // Tool handlers\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    // Prevent handling if in an input or textarea\n    if (\n      document.activeElement?.tagName === 'INPUT' ||\n      document.activeElement?.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (e.code === 'Space') {\n      // Temporarily switch to pan tool with spacebar\n      setTool('pan');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'grab';\n        }\n      }\n    } else if (e.code === 'KeyP') {\n      setTool('pen');\n    } else if (e.code === 'KeyE') {\n      setTool('eraser');\n    } else if (e.code === 'KeyS') {\n      setTool('select');\n    } else if (e.code === 'KeyT') {\n      setTool('text');\n    } else if (e.ctrlKey && e.code === 'KeyZ') {\n      // Undo\n      handleUndo();\n    } else if (e.ctrlKey && e.shiftKey && e.code === 'KeyZ') {\n      // Redo\n      handleRedo();\n    }\n  }, [handleUndo, handleRedo]);\n\n  const handleKeyUp = useCallback((e: KeyboardEvent) => {\n    if (e.code === 'Space' && tool === 'pan') {\n      // Switch back to previous tool when spacebar is released\n      setTool('pen');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [tool]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n  \n  // Clear canvas\n  const handleClearCanvas = useCallback(async () => {\n    // Store current strokes for potential undo (unused for now)\n    /*\n    const currentStrokes = [...strokes];\n    */\n\n    // Clear canvas\n    setStrokes([]);\n    setUndoStack([]);\n    \n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').delete().eq('notebook_id', notebookId);\n      } catch (err) {\n        console.error('Error clearing canvas:', err);\n      }\n    }\n  }, [strokes, user, notebookId]);\n  \n  // Thread card handlers\n  const handleDragStart = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: true\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n\n  // Card click handler for the new unified card system\n  const handleCardClick = useCallback((cardId: string) => {\n    // This will be integrated with the unified view store\n    if (window.unifiedViewStore) {\n      window.unifiedViewStore.setActiveCard(cardId);\n    }\n  }, []);\n  \n  const handleDragMove = useCallback((id: string, x: number, y: number) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          x,\n          y\n        }\n      }\n    }));\n  }, []);\n  \n  const handleDragEnd = useCallback(async (id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: false\n        }\n      }\n    }));\n    \n    // Save position to database if authenticated\n    if (user) {\n      const conversation = conversationState.items.find(c => c.id === id);\n      const pos = conversationState.positions[id];\n      \n      if (conversation && pos) {\n        try {\n          await supabase\n            .from('conversations')\n            .update({\n              position: { x: pos.x, y: pos.y },\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', id);\n        } catch (err) {\n          console.error('Error updating position:', err);\n        }\n      }\n    }\n  }, [user, conversationState.items, conversationState.positions]);\n  \n  const handleToggleCollapse = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isCollapsed: !prev.positions[id].isCollapsed\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n  \n  const handleToggleInfoDialog = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      activeInfoDialog: prev.activeInfoDialog === id ? null : id\n    }));\n  }, []);\n  \n  const handleEditContent = useCallback(async (id: string, text: string) => {\n    if (!user) return;\n    \n    try {\n      await supabase\n        .from('conversations')\n        .update({\n          user_content: text,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n        \n      setConversationState(prev => ({\n        ...prev,\n        items: prev.items.map(item => \n          item.id === id ? { ...item, user_content: text, updated_at: new Date().toISOString() } : item\n        )\n      }));\n    } catch (err) {\n      console.error('Error updating content:', err);\n    }\n  }, [user]);\n  \n  const handleContinueThread = useCallback((id: string) => {\n    // Conversation continuation logic\n    console.log('Continue thread:', id);\n  }, []);\n  \n  const handleCreateFollowUp = useCallback((id: string) => {\n    // Follow-up creation logic\n    console.log('Create follow-up:', id);\n  }, []);\n  \n  const handleCreateReference = useCallback((id: string, targetId?: string) => {\n    // Reference creation logic\n    console.log('Create reference from', id, 'to', targetId);\n  }, []);\n  \n  // System prompt handlers\n  const handleUpdateSystemPrompt = useCallback(async (prompt: string) => {\n    if (!user || !notebook) return;\n    \n    setSystemPrompt(prompt);\n    setIsSystemPromptModalOpen(false);\n    \n    try {\n      await supabase\n        .from('notebooks')\n        .update({\n          system_prompt: prompt,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', notebookId);\n    } catch (err) {\n      console.error('Error updating system prompt:', err);\n    }\n  }, [user, notebook, notebookId]);\n  \n  // Determine undo/redo availability\n  const undoAvailable = strokes.length > 0;\n  const redoAvailable = undoStack.length > 0;\n  \n  // Loading state\n  if (notebookLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500\"></div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"flex flex-col h-screen w-full\">\n      {/* Toolbar */}\n      <ResponsiveToolbar\n        tool={tool}\n        setTool={safeSetTool}\n        scale={scale}\n        setScale={setScale}\n        setPosition={setPosition}\n        notebookId={notebookId}\n        notebookTitle={notebook?.title || 'Untitled Notebook'}\n        isCollaborative={notebook?.is_collaborative}\n        onClearCanvas={handleClearCanvas}\n        isPenMode={isPenMode}\n        setIsPenMode={setIsPenMode}\n        penSize={penSize}\n        setPenSize={setPenSize}\n        eraserSize={eraserSize}\n        setEraserSize={setEraserSize}\n        undoAvailable={undoAvailable}\n        redoAvailable={redoAvailable}\n        onUndo={handleUndo}\n        onRedo={handleRedo}\n        penColor={penColor}\n        setPenColor={setPenColor}\n        isSidePanelOpen={isSidePanelOpen}\n        toggleSidePanel={() => setIsSidePanelOpen(prev => !prev)}\n        onOpenSystemPromptModal={() => setIsSystemPromptModalOpen(true)}\n      />\n      \n      {/* Canvas Container */}\n      <div\n        ref={containerRef}\n        className=\"flex-1 relative bg-gray-50 overflow-hidden\"\n        style={{ height: 'calc(100vh - 100px)' }}\n      >\n        {/* Debug Panel */}\n        <DebugPanel />\n\n        <Stage\n          width={stageWidth}\n          height={stageHeight}\n          ref={stageRef}\n          draggable={tool === 'pan'}\n          onMouseDown={handleInputStart}\n          onMouseMove={handleInputMove}\n          onMouseUp={handleInputEnd}\n          onMouseLeave={handleInputEnd}\n          onTouchStart={handleInputStart}\n          onTouchMove={handleInputMove}\n          onTouchEnd={handleInputEnd}\n          onPointerDown={handleInputStart}\n          onPointerMove={handleInputMove}\n          onPointerUp={handleInputEnd}\n          position={position}\n          scale={{ x: scale, y: scale }}\n          onContextMenu={e => e.evt.preventDefault()}\n        >\n          {/* Background Layer */}\n          <Layer name=\"background-layer\">\n            <BackgroundLayer\n              width={stageWidth}\n              height={stageHeight}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Drawing Layer */}\n          <Layer name=\"drawing-layer\">\n            <DrawingLayer\n              strokes={strokes}\n              currentStroke={currentStroke}\n              scale={scale}\n              position={position}\n            />\n          </Layer>\n\n          {/* Text Layer */}\n          <Layer name=\"text-layer\">\n            <TextLayer\n              conversationState={conversationState}\n              notebookId={notebookId}\n              onDragStart={handleDragStart}\n              onDragMove={handleDragMove}\n              onDragEnd={handleDragEnd}\n              onToggleCollapse={handleToggleCollapse}\n              onToggleInfoDialog={handleToggleInfoDialog}\n              onEditContent={handleEditContent}\n              onContinueThread={handleContinueThread}\n              onCreateFollowUp={handleCreateFollowUp}\n              onCreateReference={handleCreateReference}\n              tool={tool}\n              isTextSelectionEnabled={tool === 'text'}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Selection Layer */}\n          {selectionRect.isActive && (\n            <Layer name=\"selection-layer\">\n              <Line\n                points={[\n                  selectionRect.x, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y\n                ]}\n                stroke=\"rgba(0, 161, 255, 0.8)\"\n                strokeWidth={2 / scale}\n                dash={[5 / scale, 5 / scale]}\n                closed={true}\n                fill=\"rgba(0, 161, 255, 0.1)\"\n              />\n            </Layer>\n          )}\n        </Stage>\n      </div>\n      \n      {/* System Prompt Modal */}\n      {isSystemPromptModalOpen && (\n        <SystemPromptModal\n          isOpen={isSystemPromptModalOpen}\n          onClose={() => setIsSystemPromptModalOpen(false)}\n          initialPrompt={systemPrompt || ''}\n          onSave={handleUpdateSystemPrompt}\n        />\n      )}\n      \n      {/* Side Panel with ConversationSidePanel */}\n      {isSidePanelOpen && (\n        <ConversationSidePanel\n          notebookId={notebookId}\n          conversations={conversationState.items}\n          onEditTranscription={async (id, text) => {\n            try {\n              await supabase\n                .from('conversations')\n                .update({\n                  ai_response: text,\n                  updated_at: new Date().toISOString()\n                })\n                .eq('id', id);\n\n              // Update local state\n              setConversationState(prev => ({\n                ...prev,\n                items: prev.items.map(item =>\n                  item.id === id ? { ...item, ai_response: text, updated_at: new Date().toISOString() } : item\n                )\n              }));\n            } catch (err) {\n              console.error('Error updating AI response:', err);\n            }\n          }}\n          onSendMessage={async (message, mode) => {\n            try {\n              if (!user) return;\n\n              // Create a new conversation\n              const newConversation: Partial<Conversation> = {\n                id: generateUUID(), // Use our custom UUID generator\n                notebook_id: notebookId,\n                user_id: user.id,\n                user_content: message,\n                position: {\n                  x: -position.x + stageWidth / 2 - 150, // Center horizontally\n                  y: -position.y + stageHeight / 2 - 100 // Center vertically\n                },\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString(),\n                card_type: mode === 'chat' ? 'question' : 'note',\n                thread_id: conversationState.activeConversation || undefined,\n                is_thread_starter: !conversationState.activeConversation\n              };\n\n              // Save to database\n              const { data, error } = await supabase\n                .from('conversations')\n                .insert(newConversation)\n                .select()\n                .single();\n\n              if (error) throw error;\n\n              // Update local state\n              const savedConversation = data as Conversation;\n\n              setConversationState(prev => ({\n                ...prev,\n                items: [...prev.items, savedConversation],\n                positions: {\n                  ...prev.positions,\n                  [savedConversation.id]: {\n                    ...extractPositionFromJson(savedConversation.position),\n                    isCollapsed: false,\n                    isDragging: false\n                  }\n                },\n                activeConversation: savedConversation.id\n              }));\n\n              // Parliament functionality has been removed\n              if (mode === 'chat') {\n                // Process chat message without parliament\n                console.log('Chat message sent:', message);\n              }\n\n              return savedConversation;\n            } catch (err) {\n              console.error('Error sending message:', err);\n              throw err;\n            }\n          }}\n          onJumpToCard={(id) => {\n            // Find the card\n            const conversation = conversationState.items.find(c => c.id === id);\n            const position = conversationState.positions[id];\n\n            if (conversation && position) {\n              // Center on the card\n              setPosition({\n                x: -position.x + stageWidth / 2 - 150,\n                y: -position.y + stageHeight / 2 - 100\n              });\n\n              // Set as active\n              setConversationState(prev => ({\n                ...prev,\n                activeConversation: id\n              }));\n            }\n          }}\n          onClose={() => setIsSidePanelOpen(false)}\n          isOpen={isSidePanelOpen}\n          isFullScreen={false}\n          onToggleFullScreen={() => {\n            // This would toggle full-screen mode if implemented\n            console.log('Toggle full-screen mode');\n          }}\n          systemPrompt={systemPrompt}\n        />\n      )}\n\n      {/* Parliament functionality has been removed */}\n    </div>\n  );\n};\n\nexport default CanvasContainer;\nðŸ” Files with possible incorrect `setInput` usage:\n\nðŸ“„ --- File: ./src/components/ui/ConversationSidePanel.tsx (matched setInput) ---\n// src/components/ui/ConversationSidePanel.tsx\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Conversation } from '@/types/supabase';\nimport { useAIChat } from '@/hooks/useAIChat';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface ConversationSidePanelProps {\n  notebookId: string;\n  conversations: Conversation[];\n  onEditTranscription: (id: string, newText: string) => Promise<void>;\n  onSendMessage: (message: string, mode: 'chat' | 'comment') => Promise<void>;\n  onJumpToCard?: (id: string) => void;\n  onClose: () => void;\n  isOpen: boolean;\n  isFullScreen?: boolean;\n  onToggleFullScreen?: () => void;\n  systemPrompt?: string | null;\n}\n\n// Group conversations by thread\nconst groupByThread = (conversations: Conversation[]): Record<string, Conversation[]> => {\n  return conversations.reduce((acc, conv) => {\n    const threadId = conv.thread_id || conv.id;\n    if (!acc[threadId]) {\n      acc[threadId] = [];\n    }\n    acc[threadId].push(conv);\n    return acc;\n  }, {} as Record<string, Conversation[]>);\n};\n\n// Sort conversations within a thread (parents first, then children by created_at)\nconst sortThreadConversations = (conversations: Conversation[]): Conversation[] => {\n  // Build parent-child relationships\n  const convMap = new Map<string, Conversation>();\n  conversations.forEach(conv => {\n    convMap.set(conv.id, { ...conv, thread: [] });\n  });\n  \n  // Group by parents\n  const roots: Conversation[] = [];\n  const children: Conversation[] = [];\n  \n  conversations.forEach(conv => {\n    if (conv.parent_id && convMap.has(conv.parent_id)) {\n      children.push(conv);\n    } else {\n      roots.push(conv);\n    }\n  });\n  \n  // Sort roots by creation date\n  roots.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Sort children by creation date\n  children.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Combine sorted roots and children\n  return [...roots, ...children];\n};\n\nconst ConversationSidePanel: React.FC<ConversationSidePanelProps> = ({\n  notebookId,\n  conversations,\n  onEditTranscription,\n  onSendMessage,\n  onJumpToCard,\n  onClose,\n  isOpen,\n  isFullScreen = false,\n  onToggleFullScreen = () => {},\n  systemPrompt = null\n}) => {\n  // Initialize AI chat hook\n  const {\n    isLoading: isProcessing,\n    status,\n    sendMessage\n  } = useAIChat({\n    notebookId,\n    systemPrompt: systemPrompt || undefined,\n    api: '/api/ai/chat'\n  });\n  \n  // Simulate AI progress for UI consistency with the previous implementation\n  const [aiProgress, setAiProgress] = useState(0);\n  \n  useEffect(() => {\n    if (isProcessing) {\n      const interval = setInterval(() => {\n        setAiProgress(prev => Math.min(prev + 5, 90));\n      }, 300);\n      \n      return () => clearInterval(interval);\n    } else {\n      setAiProgress(0);\n    }\n  }, [isProcessing]);\n  const [inputValue, setInputValue] = useState('');\n  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);\n  const [expandedThreads, setExpandedThreads] = useState<Set<string>>(new Set());\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Scroll to highlighted message when receiving \"jumpToConversation\" event\n  useEffect(() => {\n    const handleJumpToConversation = (event: CustomEvent) => {\n      const { conversationId } = event.detail;\n      \n      // Find the conversation\n      const conversation = conversations.find(c => c.id === conversationId);\n      if (!conversation) return;\n      \n      // Determine thread ID\n      const threadId = conversation.thread_id || conversation.id;\n      \n      // Set active thread and ensure it's expanded\n      setActiveThreadId(threadId);\n      setExpandedThreads(prev => {\n        const newSet = new Set(prev);\n        newSet.add(threadId);\n        return newSet;\n      });\n      \n      // Scroll to the message\n      setTimeout(() => {\n        const messageElement = document.getElementById(`message-${conversationId}`);\n        if (messageElement) {\n          messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n          messageElement.classList.add('highlight-message');\n          setTimeout(() => {\n            messageElement.classList.remove('highlight-message');\n          }, 2000);\n        }\n      }, 100);\n    };\n    \n    // Add event listener\n    window.addEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    };\n  }, [conversations]);\n  \n  // Auto-grow textarea as content grows\n  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const value = e.target.value;\n    setInputValue(value);\n    \n    // Auto-resize textarea\n    e.target.style.height = 'auto';\n    e.target.style.height = `${Math.min(e.target.scrollHeight, 200)}px`;\n  };\n  \n  const handleSend = async () => {\n    if (!inputValue.trim()) return;\n\n    try {\n      // If there's an active thread, add to that thread\n      if (activeThreadId) {\n        const thread = conversations.find(c =>\n          c.id === activeThreadId || c.thread_id === activeThreadId\n        );\n\n        if (thread) {\n          // Get message history for the thread\n          const threadMessages = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .map(c => ({\n              role: 'user' as const,\n              content: c.user_content || '',\n              ...(c.ai_response ? { role: 'assistant' as const, content: c.ai_response } : {})\n            }))\n            .filter(m => m.content); // Filter out empty messages\n\n          // Send message through AI interaction hook\n          // Send the message using the new AI hook\n          const success = await sendMessage(inputValue);\n\n          // Save the message through the regular flow\n          await onSendMessage(inputValue, 'chat');\n\n          // With the new Vercel AI SDK, we don't get direct access to the response\n          // The response is handled through the onFinish callback and automatically\n          // added to the message history, so we can't check for duplicates like before\n          const lastConversationId = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0]?.id;\n\n            // With the new API, we don't need to manually update the transcription\n            // as it's handled by onSendMessage and the conversation system now\n          }\n        } else {\n          // If thread not found, create a new message\n          await onSendMessage(inputValue, 'chat');\n        }\n      } else {\n        // No active thread, create a new conversation\n        // Send message using the new AI hook (we don't get a direct response)\n        await sendMessage(inputValue);\n        \n        // Save through the regular flow\n        await onSendMessage(inputValue, 'chat');\n        \n        // With the new Vercel AI SDK architecture, we don't need to manually update\n        // the transcription as it's handled by the onSendMessage and conversation system\n      }\n    }\n\n      // Clear input regardless of outcome\n      setInputValue('');\n\n      if (inputRef.current) {\n        inputRef.current.style.height = 'auto';\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // Optionally show error to user\n    }\n  };\n  \n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n  \n  // Toggle thread expansion\n  const toggleThreadExpansion = (threadId: string) => {\n    setExpandedThreads(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(threadId)) {\n        newSet.delete(threadId);\n      } else {\n        newSet.add(threadId);\n      }\n      return newSet;\n    });\n  };\n  \n  // Group conversations by thread\n  const threadGroups = groupByThread(conversations);\n  \n  // Sort threads by most recent activity\n  const sortedThreadIds = Object.keys(threadGroups).sort((a, b) => {\n    const aLatest = threadGroups[a].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    const bLatest = threadGroups[b].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    return bLatest - aLatest; // Most recent first\n  });\n  \n  return (\n    <div\n      className={`bg-white border-l border-gray-200 shadow-xl ${\n        isOpen\n          ? (isFullScreen\n              ? 'fixed inset-0 z-50 w-full h-full'\n              : 'fixed right-0 top-0 bottom-0 z-40 w-80 h-full')\n          : 'fixed right-[-320px] top-0 bottom-0 z-40 w-80 h-full'\n      }`}\n      style={{\n        transition: 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out',\n        transform: isOpen ? 'translateX(0)' : 'translateX(100%)',\n        opacity: isOpen ? 1 : 0,\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      {/* Header */}\n      <div className=\"py-3 px-4 border-b border-gray-200 flex items-center justify-between\">\n        <h2 className=\"text-lg font-semibold text-gray-800\">Conversation Threads</h2>\n        <div className=\"flex space-x-2\">\n          {/* Toggle full-screen button */}\n          <button\n            onClick={onToggleFullScreen}\n            className={`p-1.5 rounded-md ${isFullScreen ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100'}`}\n            title={isFullScreen ? \"Exit full screen\" : \"Full screen mode\"}\n          >\n            {isFullScreen ? (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 3v3a2 2 0 01-2 2H3m18 0h-3a2 2 0 01-2-2V3m0 18v-3a2 2 0 012-2h3M3 16h3a2 2 0 012 2v3\" />\n              </svg>\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4\" />\n              </svg>\n            )}\n          </button>\n\n          {/* Close button */}\n          <button\n            onClick={onClose}\n            className=\"p-1.5 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100\"\n            title=\"Close panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      {/* Messages Container - wider padding in full-screen mode */}\n      <div className={`flex-1 overflow-y-auto ${isFullScreen ? 'p-6 md:px-12 lg:px-24' : 'p-4'} space-y-8`}>\n        {sortedThreadIds.map(threadId => {\n          const threadsInGroup = sortThreadConversations(threadGroups[threadId]);\n          const starter = threadsInGroup.find(t => t.is_thread_starter) || threadsInGroup[0];\n          const isExpanded = expandedThreads.has(threadId);\n          const isActive = activeThreadId === threadId;\n          \n          // Determine card type\n          const cardType = starter.card_type || \n            (starter.is_thread_starter ? 'question' : 'note');\n          \n          // Color indicator based on card type\n          const colorMap = {\n            question: 'bg-purple-600',\n            response: 'bg-blue-600',\n            note: 'bg-green-600',\n            follow_up: 'bg-amber-600'\n          };\n          \n          const bgColorMap = {\n            question: 'bg-purple-50',\n            response: 'bg-blue-50',\n            note: 'bg-green-50',\n            follow_up: 'bg-amber-50'\n          };\n          \n          const textColorMap = {\n            question: 'text-purple-700',\n            response: 'text-blue-700',\n            note: 'text-green-700',\n            follow_up: 'text-amber-700'\n          };\n          \n          return (\n            <div \n              key={threadId}\n              className={`border rounded-lg shadow-sm ${isActive ? 'border-blue-300 shadow-md' : 'border-gray-200'}`}\n            >\n              {/* Thread Header */}\n              <div \n                className={`p-3 rounded-t-lg flex items-center justify-between cursor-pointer\n                  ${bgColorMap[cardType as keyof typeof bgColorMap] || 'bg-gray-50'}`}\n                onClick={() => toggleThreadExpansion(threadId)}\n              >\n                <div className=\"flex items-center space-x-2\">\n                  <div className={`w-3 h-3 rounded-full ${colorMap[cardType as keyof typeof colorMap] || 'bg-gray-500'}`}></div>\n                  <h3 className={`font-medium ${textColorMap[cardType as keyof typeof textColorMap] || 'text-gray-700'}`}>\n                    {starter.user_content?.split('\\n')[0].substring(0, 40) || 'Untitled Thread'}\n                  </h3>\n                </div>\n                \n                <div className=\"flex items-center space-x-2\">\n                  <span className=\"text-xs text-gray-500\">\n                    {threadsInGroup.length} message{threadsInGroup.length !== 1 ? 's' : ''}\n                  </span>\n                  <svg \n                    xmlns=\"http://www.w3.org/2000/svg\" \n                    className={`h-5 w-5 text-gray-500 transition-transform ${isExpanded ? 'transform rotate-180' : ''}`} \n                    viewBox=\"0 0 20 20\" \n                    fill=\"currentColor\"\n                  >\n                    <path fillRule=\"evenodd\" d=\"M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n                  </svg>\n                </div>\n              </div>\n              \n              {/* Thread Messages */}\n              {isExpanded && (\n                <div className=\"p-3 space-y-4\">\n                  {threadsInGroup.map((message, _index) => { // Prefixed with underscore to satisfy ESLint unused arg rule\n                    const isStarter = message.id === starter.id;\n                    const depth = message.parent_id ? 1 : 0; // Simple depth calculation\n                    \n                    return (\n                      <div \n                        key={message.id}\n                        id={`message-${message.id}`}\n                        className={`transition-all duration-300 ${\n                          depth > 0 ? 'ml-6 border-l-2 pl-3 border-gray-200' : ''\n                        }`}\n                      >\n                        <div className=\"flex justify-between items-start mb-1\">\n                          <div className=\"flex items-center\">\n                            <div className={`w-2 h-2 rounded-full mr-2 ${\n                              isStarter ? colorMap[cardType as keyof typeof colorMap] : 'bg-gray-400'\n                            }`}></div>\n                            <span className=\"text-xs text-gray-500\">\n                              {new Date(message.created_at).toLocaleString()}\n                            </span>\n                          </div>\n                          \n                          {/* Jump to card button */}\n                          <button\n                            className=\"text-xs text-blue-600 hover:text-blue-800 flex items-center\"\n                            onClick={() => onJumpToCard && onJumpToCard(message.id)}\n                          >\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                              <path fillRule=\"evenodd\" d=\"M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z\" clipRule=\"evenodd\" />\n                            </svg>\n                            Jump\n                          </button>\n                        </div>\n                        \n                        {/* Message content */}\n                        {message.user_content && (\n                          <div className=\"mb-2 bg-white rounded-md p-3 border border-gray-200\">\n                            <p className=\"text-gray-700 whitespace-pre-wrap\">\n                              {message.user_content}\n                            </p>\n                          </div>\n                        )}\n                        \n                        {/* AI response */}\n                        {message.ai_response && (\n                          <div className=\"mb-2 bg-blue-50 rounded-md p-3 border border-blue-100\">\n                            <p className=\"text-blue-800 whitespace-pre-wrap\">\n                              {message.ai_response}\n                            </p>\n                          </div>\n                        )}\n                      </div>\n                    );\n                  })}\n                </div>\n              )}\n            </div>\n          );\n        })}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input Area - centered and with max-width in full-screen mode */}\n      <div className={`border-t border-gray-200 ${isFullScreen ? 'p-6' : 'p-4'}`}>\n        <div className={`relative ${isFullScreen ? 'max-w-3xl mx-auto' : ''}`}>\n          <textarea\n            ref={inputRef}\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Type a message...\"\n            className={`w-full border border-gray-300 rounded-lg py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none\n              ${isFullScreen ? 'text-lg' : ''}`}\n            rows={1}\n            disabled={isProcessing}\n          />\n          <button\n            onClick={handleSend}\n            disabled={!inputValue.trim() || isProcessing}\n            className={`absolute right-2 bottom-2 ${isProcessing ? 'bg-gray-400' : 'bg-blue-600'} text-white ${isFullScreen ? 'p-3' : 'p-2'} rounded-full disabled:opacity-50`}\n          >\n            {isProcessing ? (\n              <Spinner size=\"sm\" />\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className={`${isFullScreen ? 'h-6 w-6' : 'h-5 w-5'}`} viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            )}\n          </button>\n        </div>\n\n        {/* AI Progress indicator */}\n        {aiProgress > 0 && aiProgress < 100 && (\n          <div className={`mt-2 ${isFullScreen ? 'max-w-3xl mx-auto' : ''}`}>\n            <div className=\"h-1 w-full bg-gray-200 rounded-full overflow-hidden\">\n              <div\n                className=\"h-full bg-blue-600 transition-all duration-300 ease-in-out\"\n                style={{ width: `${aiProgress}%` }}\n              ></div>\n            </div>\n            <p className=\"text-xs text-gray-500 mt-1 text-center\">AI is thinking...</p>\n          </div>\n        )}\n      </div>\n      \n      {/* No custom styles needed - using global CSS classes */}\n    </div>\n  );\n};\n\nexport default ConversationSidePanel;\nðŸ“„ --- File: ./src/components/ui/ConversationSidePanel.tsx (matched setInput) ---\n// src/components/ui/ConversationSidePanel.tsx\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Conversation } from '@/types/supabase';\nimport { useAIChat } from '@/hooks/useAIChat';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface ConversationSidePanelProps {\n  notebookId: string;\n  conversations: Conversation[];\n  onEditTranscription: (id: string, newText: string) => Promise<void>;\n  onSendMessage: (message: string, mode: 'chat' | 'comment') => Promise<void>;\n  onJumpToCard?: (id: string) => void;\n  onClose: () => void;\n  isOpen: boolean;\n  isFullScreen?: boolean;\n  onToggleFullScreen?: () => void;\n  systemPrompt?: string | null;\n}\n\n// Group conversations by thread\nconst groupByThread = (conversations: Conversation[]): Record<string, Conversation[]> => {\n  return conversations.reduce((acc, conv) => {\n    const threadId = conv.thread_id || conv.id;\n    if (!acc[threadId]) {\n      acc[threadId] = [];\n    }\n    acc[threadId].push(conv);\n    return acc;\n  }, {} as Record<string, Conversation[]>);\n};\n\n// Sort conversations within a thread (parents first, then children by created_at)\nconst sortThreadConversations = (conversations: Conversation[]): Conversation[] => {\n  // Build parent-child relationships\n  const convMap = new Map<string, Conversation>();\n  conversations.forEach(conv => {\n    convMap.set(conv.id, { ...conv, thread: [] });\n  });\n  \n  // Group by parents\n  const roots: Conversation[] = [];\n  const children: Conversation[] = [];\n  \n  conversations.forEach(conv => {\n    if (conv.parent_id && convMap.has(conv.parent_id)) {\n      children.push(conv);\n    } else {\n      roots.push(conv);\n    }\n  });\n  \n  // Sort roots by creation date\n  roots.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Sort children by creation date\n  children.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Combine sorted roots and children\n  return [...roots, ...children];\n};\n\nconst ConversationSidePanel: React.FC<ConversationSidePanelProps> = ({\n  notebookId,\n  conversations,\n  onEditTranscription,\n  onSendMessage,\n  onJumpToCard,\n  onClose,\n  isOpen,\n  isFullScreen = false,\n  onToggleFullScreen = () => {},\n  systemPrompt = null\n}) => {\n  // Initialize AI chat hook\n  const {\n    isLoading: isProcessing,\n    status,\n    sendMessage\n  } = useAIChat({\n    notebookId,\n    systemPrompt: systemPrompt || undefined,\n    api: '/api/ai/chat'\n  });\n  \n  // Simulate AI progress for UI consistency with the previous implementation\n  const [aiProgress, setAiProgress] = useState(0);\n  \n  useEffect(() => {\n    if (isProcessing) {\n      const interval = setInterval(() => {\n        setAiProgress(prev => Math.min(prev + 5, 90));\n      }, 300);\n      \n      return () => clearInterval(interval);\n    } else {\n      setAiProgress(0);\n    }\n  }, [isProcessing]);\n  const [inputValue, setInputValue] = useState('');\n  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);\n  const [expandedThreads, setExpandedThreads] = useState<Set<string>>(new Set());\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Scroll to highlighted message when receiving \"jumpToConversation\" event\n  useEffect(() => {\n    const handleJumpToConversation = (event: CustomEvent) => {\n      const { conversationId } = event.detail;\n      \n      // Find the conversation\n      const conversation = conversations.find(c => c.id === conversationId);\n      if (!conversation) return;\n      \n      // Determine thread ID\n      const threadId = conversation.thread_id || conversation.id;\n      \n      // Set active thread and ensure it's expanded\n      setActiveThreadId(threadId);\n      setExpandedThreads(prev => {\n        const newSet = new Set(prev);\n        newSet.add(threadId);\n        return newSet;\n      });\n      \n      // Scroll to the message\n      setTimeout(() => {\n        const messageElement = document.getElementById(`message-${conversationId}`);\n        if (messageElement) {\n          messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n          messageElement.classList.add('highlight-message');\n          setTimeout(() => {\n            messageElement.classList.remove('highlight-message');\n          }, 2000);\n        }\n      }, 100);\n    };\n    \n    // Add event listener\n    window.addEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    };\n  }, [conversations]);\n  \n  // Auto-grow textarea as content grows\n  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const value = e.target.value;\n    setInputValue(value);\n    \n    // Auto-resize textarea\n    e.target.style.height = 'auto';\n    e.target.style.height = `${Math.min(e.target.scrollHeight, 200)}px`;\n  };\n  \n  const handleSend = async () => {\n    if (!inputValue.trim()) return;\n\n    try {\n      // If there's an active thread, add to that thread\n      if (activeThreadId) {\n        const thread = conversations.find(c =>\n          c.id === activeThreadId || c.thread_id === activeThreadId\n        );\n\n        if (thread) {\n          // Get message history for the thread\n          const threadMessages = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .map(c => ({\n              role: 'user' as const,\n              content: c.user_content || '',\n              ...(c.ai_response ? { role: 'assistant' as const, content: c.ai_response } : {})\n            }))\n            .filter(m => m.content); // Filter out empty messages\n\n          // Send message through AI interaction hook\n          // Send the message using the new AI hook\n          const success = await sendMessage(inputValue);\n\n          // Save the message through the regular flow\n          await onSendMessage(inputValue, 'chat');\n\n          // With the new Vercel AI SDK, we don't get direct access to the response\n          // The response is handled through the onFinish callback and automatically\n          // added to the message history, so we can't check for duplicates like before\n          const lastConversationId = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0]?.id;\n\n            // With the new API, we don't need to manually update the transcription\n            // as it's handled by onSendMessage and the conversation system now\n          }\n        } else {\n          // If thread not found, create a new message\n          await onSendMessage(inputValue, 'chat');\n        }\n      } else {\n        // No active thread, create a new conversation\n        // Send message using the new AI hook (we don't get a direct response)\n        await sendMessage(inputValue);\n        \n        // Save through the regular flow\n        await onSendMessage(inputValue, 'chat');\n        \n        // With the new Vercel AI SDK architecture, we don't need to manually update\n        // the transcription as it's handled by the onSendMessage and conversation system\n      }\n    }\n\n      // Clear input regardless of outcome\n      setInputValue('');\n\n      if (inputRef.current) {\n        inputRef.current.style.height = 'auto';\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // Optionally show error to user\n    }\n  };\n  \n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n  \n  // Toggle thread expansion\n  const toggleThreadExpansion = (threadId: string) => {\n    setExpandedThreads(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(threadId)) {\n        newSet.delete(threadId);\n      } else {\n        newSet.add(threadId);\n      }\n      return newSet;\n    });\n  };\n  \n  // Group conversations by thread\n  const threadGroups = groupByThread(conversations);\n  \n  // Sort threads by most recent activity\n  const sortedThreadIds = Object.keys(threadGroups).sort((a, b) => {\n    const aLatest = threadGroups[a].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    const bLatest = threadGroups[b].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    return bLatest - aLatest; // Most recent first\n  });\n  \n  return (\n    <div\n      className={`bg-white border-l border-gray-200 shadow-xl ${\n        isOpen\n          ? (isFullScreen\n              ? 'fixed inset-0 z-50 w-full h-full'\n              : 'fixed right-0 top-0 bottom-0 z-40 w-80 h-full')\n          : 'fixed right-[-320px] top-0 bottom-0 z-40 w-80 h-full'\n      }`}\n      style={{\n        transition: 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out',\n        transform: isOpen ? 'translateX(0)' : 'translateX(100%)',\n        opacity: isOpen ? 1 : 0,\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      {/* Header */}\n      <div className=\"py-3 px-4 border-b border-gray-200 flex items-center justify-between\">\n        <h2 className=\"text-lg font-semibold text-gray-800\">Conversation Threads</h2>\n        <div className=\"flex space-x-2\">\n          {/* Toggle full-screen button */}\n          <button\n            onClick={onToggleFullScreen}\n            className={`p-1.5 rounded-md ${isFullScreen ? 'bg-blue-100 text-blue-600' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-100'}`}\n            title={isFullScreen ? \"Exit full screen\" : \"Full screen mode\"}\n          >\n            {isFullScreen ? (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 3v3a2 2 0 01-2 2H3m18 0h-3a2 2 0 01-2-2V3m0 18v-3a2 2 0 012-2h3M3 16h3a2 2 0 012 2v3\" />\n              </svg>\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4\" />\n              </svg>\n            )}\n          </button>\n\n          {/* Close button */}\n          <button\n            onClick={onClose}\n            className=\"p-1.5 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100\"\n            title=\"Close panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      {/* Messages Container - wider padding in full-screen mode */}\n      <div className={`flex-1 overflow-y-auto ${isFullScreen ? 'p-6 md:px-12 lg:px-24' : 'p-4'} space-y-8`}>\n        {sortedThreadIds.map(threadId => {\n          const threadsInGroup = sortThreadConversations(threadGroups[threadId]);\n          const starter = threadsInGroup.find(t => t.is_thread_starter) || threadsInGroup[0];\n          const isExpanded = expandedThreads.has(threadId);\n          const isActive = activeThreadId === threadId;\n          \n          // Determine card type\n          const cardType = starter.card_type || \n            (starter.is_thread_starter ? 'question' : 'note');\n          \n          // Color indicator based on card type\n          const colorMap = {\n            question: 'bg-purple-600',\n            response: 'bg-blue-600',\n            note: 'bg-green-600',\n            follow_up: 'bg-amber-600'\n          };\n          \n          const bgColorMap = {\n            question: 'bg-purple-50',\n            response: 'bg-blue-50',\n            note: 'bg-green-50',\n            follow_up: 'bg-amber-50'\n          };\n          \n          const textColorMap = {\n            question: 'text-purple-700',\n            response: 'text-blue-700',\n            note: 'text-green-700',\n            follow_up: 'text-amber-700'\n          };\n          \n          return (\n            <div \n              key={threadId}\n              className={`border rounded-lg shadow-sm ${isActive ? 'border-blue-300 shadow-md' : 'border-gray-200'}`}\n            >\n              {/* Thread Header */}\n              <div \n                className={`p-3 rounded-t-lg flex items-center justify-between cursor-pointer\n                  ${bgColorMap[cardType as keyof typeof bgColorMap] || 'bg-gray-50'}`}\n                onClick={() => toggleThreadExpansion(threadId)}\n              >\n                <div className=\"flex items-center space-x-2\">\n                  <div className={`w-3 h-3 rounded-full ${colorMap[cardType as keyof typeof colorMap] || 'bg-gray-500'}`}></div>\n                  <h3 className={`font-medium ${textColorMap[cardType as keyof typeof textColorMap] || 'text-gray-700'}`}>\n                    {starter.user_content?.split('\\n')[0].substring(0, 40) || 'Untitled Thread'}\n                  </h3>\n                </div>\n                \n                <div className=\"flex items-center space-x-2\">\n                  <span className=\"text-xs text-gray-500\">\n                    {threadsInGroup.length} message{threadsInGroup.length !== 1 ? 's' : ''}\n                  </span>\n                  <svg \n                    xmlns=\"http://www.w3.org/2000/svg\" \n                    className={`h-5 w-5 text-gray-500 transition-transform ${isExpanded ? 'transform rotate-180' : ''}`} \n                    viewBox=\"0 0 20 20\" \n                    fill=\"currentColor\"\n                  >\n                    <path fillRule=\"evenodd\" d=\"M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n                  </svg>\n                </div>\n              </div>\n              \n              {/* Thread Messages */}\n              {isExpanded && (\n                <div className=\"p-3 space-y-4\">\n                  {threadsInGroup.map((message, _index) => { // Prefixed with underscore to satisfy ESLint unused arg rule\n                    const isStarter = message.id === starter.id;\n                    const depth = message.parent_id ? 1 : 0; // Simple depth calculation\n                    \n                    return (\n                      <div \n                        key={message.id}\n                        id={`message-${message.id}`}\n                        className={`transition-all duration-300 ${\n                          depth > 0 ? 'ml-6 border-l-2 pl-3 border-gray-200' : ''\n                        }`}\n                      >\n                        <div className=\"flex justify-between items-start mb-1\">\n                          <div className=\"flex items-center\">\n                            <div className={`w-2 h-2 rounded-full mr-2 ${\n                              isStarter ? colorMap[cardType as keyof typeof colorMap] : 'bg-gray-400'\n                            }`}></div>\n                            <span className=\"text-xs text-gray-500\">\n                              {new Date(message.created_at).toLocaleString()}\n                            </span>\n                          </div>\n                          \n                          {/* Jump to card button */}\n                          <button\n                            className=\"text-xs text-blue-600 hover:text-blue-800 flex items-center\"\n                            onClick={() => onJumpToCard && onJumpToCard(message.id)}\n                          >\n                            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                              <path fillRule=\"evenodd\" d=\"M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z\" clipRule=\"evenodd\" />\n                            </svg>\n                            Jump\n                          </button>\n                        </div>\n                        \n                        {/* Message content */}\n                        {message.user_content && (\n                          <div className=\"mb-2 bg-white rounded-md p-3 border border-gray-200\">\n                            <p className=\"text-gray-700 whitespace-pre-wrap\">\n                              {message.user_content}\n                            </p>\n                          </div>\n                        )}\n                        \n                        {/* AI response */}\n                        {message.ai_response && (\n                          <div className=\"mb-2 bg-blue-50 rounded-md p-3 border border-blue-100\">\n                            <p className=\"text-blue-800 whitespace-pre-wrap\">\n                              {message.ai_response}\n                            </p>\n                          </div>\n                        )}\n                      </div>\n                    );\n                  })}\n                </div>\n              )}\n            </div>\n          );\n        })}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input Area - centered and with max-width in full-screen mode */}\n      <div className={`border-t border-gray-200 ${isFullScreen ? 'p-6' : 'p-4'}`}>\n        <div className={`relative ${isFullScreen ? 'max-w-3xl mx-auto' : ''}`}>\n          <textarea\n            ref={inputRef}\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            placeholder=\"Type a message...\"\n            className={`w-full border border-gray-300 rounded-lg py-2 px-4 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent resize-none\n              ${isFullScreen ? 'text-lg' : ''}`}\n            rows={1}\n            disabled={isProcessing}\n          />\n          <button\n            onClick={handleSend}\n            disabled={!inputValue.trim() || isProcessing}\n            className={`absolute right-2 bottom-2 ${isProcessing ? 'bg-gray-400' : 'bg-blue-600'} text-white ${isFullScreen ? 'p-3' : 'p-2'} rounded-full disabled:opacity-50`}\n          >\n            {isProcessing ? (\n              <Spinner size=\"sm\" />\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className={`${isFullScreen ? 'h-6 w-6' : 'h-5 w-5'}`} viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            )}\n          </button>\n        </div>\n\n        {/* AI Progress indicator */}\n        {aiProgress > 0 && aiProgress < 100 && (\n          <div className={`mt-2 ${isFullScreen ? 'max-w-3xl mx-auto' : ''}`}>\n            <div className=\"h-1 w-full bg-gray-200 rounded-full overflow-hidden\">\n              <div\n                className=\"h-full bg-blue-600 transition-all duration-300 ease-in-out\"\n                style={{ width: `${aiProgress}%` }}\n              ></div>\n            </div>\n            <p className=\"text-xs text-gray-500 mt-1 text-center\">AI is thinking...</p>\n          </div>\n        )}\n      </div>\n      \n      {/* No custom styles needed - using global CSS classes */}\n    </div>\n  );\n};\n\nexport default ConversationSidePanel;\nðŸ“„ --- File: ./src/components/ui/ConversationSidePanel.tsx (matched setInput) ---\n// src/components/ui/ConversationSidePanel.tsx\n\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Conversation } from '@/types/supabase';\nimport { useAIChat } from '@/hooks/useAIChat';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface ConversationSidePanelProps {\n  notebookId: string;\n  conversations: Conversation[];\n  onEditTranscription: (id: string, newText: string) => Promise<void>;\n  onSendMessage: (message: string, mode: 'chat' | 'comment') => Promise<void>;\n  onJumpToCard?: (id: string) => void;\n  onClose: () => void;\n  isOpen: boolean;\n  isFullScreen?: boolean;\n  onToggleFullScreen?: () => void;\n  systemPrompt?: string | null;\n}\n\n// Group conversations by thread\nconst groupByThread = (conversations: Conversation[]): Record<string, Conversation[]> => {\n  return conversations.reduce((acc, conv) => {\n    const threadId = conv.thread_id || conv.id;\n    if (!acc[threadId]) {\n      acc[threadId] = [];\n    }\n    acc[threadId].push(conv);\n    return acc;\n  }, {} as Record<string, Conversation[]>);\n};\n\n// Sort conversations within a thread (parents first, then children by created_at)\nconst sortThreadConversations = (conversations: Conversation[]): Conversation[] => {\n  // Build parent-child relationships\n  const convMap = new Map<string, Conversation>();\n  conversations.forEach(conv => {\n    convMap.set(conv.id, { ...conv, thread: [] });\n  });\n  \n  // Group by parents\n  const roots: Conversation[] = [];\n  const children: Conversation[] = [];\n  \n  conversations.forEach(conv => {\n    if (conv.parent_id && convMap.has(conv.parent_id)) {\n      children.push(conv);\n    } else {\n      roots.push(conv);\n    }\n  });\n  \n  // Sort roots by creation date\n  roots.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Sort children by creation date\n  children.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n  \n  // Combine sorted roots and children\n  return [...roots, ...children];\n};\n\nconst ConversationSidePanel: React.FC<ConversationSidePanelProps> = ({\n  notebookId,\n  conversations,\n  onEditTranscription,\n  onSendMessage,\n  onJumpToCard,\n  onClose,\n  isOpen,\n  isFullScreen = false,\n  onToggleFullScreen = () => {},\n  systemPrompt = null\n}) => {\n  // Initialize AI chat hook\n  const {\n    isLoading: isProcessing,\n    status,\n    sendMessage\n  } = useAIChat({\n    notebookId,\n    systemPrompt: systemPrompt || undefined,\n    api: '/api/ai/chat'\n  });\n  \n  // Simulate AI progress for UI consistency with the previous implementation\n  const [aiProgress, setAiProgress] = useState(0);\n  \n  useEffect(() => {\n    if (isProcessing) {\n      const interval = setInterval(() => {\n        setAiProgress(prev => Math.min(prev + 5, 90));\n      }, 300);\n      \n      return () => clearInterval(interval);\n    } else {\n      setAiProgress(0);\n    }\n  }, [isProcessing]);\n  const [inputValue, setInputValue] = useState('');\n  const [activeThreadId, setActiveThreadId] = useState<string | null>(null);\n  const [expandedThreads, setExpandedThreads] = useState<Set<string>>(new Set());\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Scroll to highlighted message when receiving \"jumpToConversation\" event\n  useEffect(() => {\n    const handleJumpToConversation = (event: CustomEvent) => {\n      const { conversationId } = event.detail;\n      \n      // Find the conversation\n      const conversation = conversations.find(c => c.id === conversationId);\n      if (!conversation) return;\n      \n      // Determine thread ID\n      const threadId = conversation.thread_id || conversation.id;\n      \n      // Set active thread and ensure it's expanded\n      setActiveThreadId(threadId);\n      setExpandedThreads(prev => {\n        const newSet = new Set(prev);\n        newSet.add(threadId);\n        return newSet;\n      });\n      \n      // Scroll to the message\n      setTimeout(() => {\n        const messageElement = document.getElementById(`message-${conversationId}`);\n        if (messageElement) {\n          messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n          messageElement.classList.add('highlight-message');\n          setTimeout(() => {\n            messageElement.classList.remove('highlight-message');\n          }, 2000);\n        }\n      }, 100);\n    };\n    \n    // Add event listener\n    window.addEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('jumpToConversation', handleJumpToConversation as EventListener);\n    };\n  }, [conversations]);\n  \n  // Auto-grow textarea as content grows\n  const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const value = e.target.value;\n    setInputValue(value);\n    \n    // Auto-resize textarea\n    e.target.style.height = 'auto';\n    e.target.style.height = `${Math.min(e.target.scrollHeight, 200)}px`;\n  };\n  \n  const handleSend = async () => {\n    if (!inputValue.trim()) return;\n\n    try {\n      // If there's an active thread, add to that thread\n      if (activeThreadId) {\n        const thread = conversations.find(c =>\n          c.id === activeThreadId || c.thread_id === activeThreadId\n        );\n\n        if (thread) {\n          // Get message history for the thread\n          const threadMessages = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .map(c => ({\n              role: 'user' as const,\n              content: c.user_content || '',\n              ...(c.ai_response ? { role: 'assistant' as const, content: c.ai_response } : {})\n            }))\n            .filter(m => m.content); // Filter out empty messages\n\n          // Send message through AI interaction hook\n          // Send the message using the new AI hook\n          const success = await sendMessage(inputValue);\n\n          // Save the message through the regular flow\n          await onSendMessage(inputValue, 'chat');\n\n          // With the new Vercel AI SDK, we don't get direct access to the response\n          // The response is handled through the onFinish callback and automatically\n          // added to the message history, so we can't check for duplicates like before\n          const lastConversationId = conversations\n            .filter(c => c.thread_id === thread.thread_id || c.id === thread.id)\n            .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())[0]?.id;\n\n            // With the new API, we don't need to manually update the transcription\n            // as it's handled by onSendMessage and the conversation system now\n          }\n        } else {\n          // If thread not found, create a new message\n          await onSendMessage(inputValue, 'chat');\n        }\n      } else {\n        // No active thread, create a new conversation\n        // Send message using the new AI hook (we don't get a direct response)\n        await sendMessage(inputValue);\n        \n        // Save through the regular flow\n        await onSendMessage(inputValue, 'chat');\n        \n        // With the new Vercel AI SDK architecture, we don't need to manually update\n        // the transcription as it's handled by the onSendMessage and conversation system\n      }\n    }\n\n      // Clear input regardless of outcome\n      setInputValue('');\n\n      if (inputRef.current) {\n        inputRef.current.style.height = 'auto';\n      }\n    } catch (error) {\n      console.error('Error sending message:', error);\n      // Optionally show error to user\n    }\n  };\n  \n  const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSend();\n    }\n  };\n  \n  // Toggle thread expansion\n  const toggleThreadExpansion = (threadId: string) => {\n    setExpandedThreads(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(threadId)) {\n        newSet.delete(threadId);\n      } else {\n        newSet.add(threadId);\n      }\n      return newSet;\n    });\n  };\n  \n  // Group conversations by thread\n  const threadGroups = groupByThread(conversations);\n  \n  // Sort threads by most recent activity\n  const sortedThreadIds = Object.keys(threadGroups).sort((a, b) => {\n    const aLatest = threadGroups[a].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n      return convDate > latest ? convDate : latest;\n    }, 0);\n    \n    const bLatest = threadGroups[b].reduce((latest, conv) => {\n      const convDate = new Date(conv.created_at).getTime();\n            content: systemPrompt,\n            created_at: new Date().toISOString()\n          });\n        }\n        \n        // Sort messages by creation time\n        allMessages.sort((a, b) => \n          new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n        );\n        \n        // Update chat messages\n        setChatMessages(allMessages);\n        return;\n      }\n      \n      // Step 2: Build a hierarchical view with main question at the root\n      console.log(`Found main question node: ${mainQuestionNode.id}`);\n      \n      // Collect main question messages\n      let hierarchicalMessages = [];\n      \n      // Add main question's messages\n      if (mainQuestionNode.messages && mainQuestionNode.messages.length > 0) {\n        hierarchicalMessages = [\n          ...hierarchicalMessages,\n          ...mainQuestionNode.messages.map(msg => ({\n            ...msg,\n            nodeId: mainQuestionNode.id,\n            tier: 1\n          }))\n        ];\n      } else {\n        // Create synthetic message for main question\n        hierarchicalMessages.push({\n          id: `node_${mainQuestionNode.id}`,\n          role: 'user',\n          content: mainQuestionNode.content,\n          created_at: mainQuestionNode.created_at,\n          nodeId: mainQuestionNode.id,\n          tier: 1\n        });\n      }\n      \n      // Find direct responses to the main question (tier 3 nodes)\n      const directResponses = Object.values(nodes).filter(node => {\n        return node.metadata?.parentNodeId === mainQuestionNode.id &&\n               node.metadata?.tier === 3;\n      }).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n      \n      // Add direct responses to the chat\n      for (const responseNode of directResponses) {\n        if (responseNode.messages && responseNode.messages.length > 0) {\n          hierarchicalMessages = [\n            ...hierarchicalMessages,\n            ...responseNode.messages.map(msg => ({\n              ...msg,\n              nodeId: responseNode.id,\n              tier: 3\n            }))\n          ];\n        } else {\n          hierarchicalMess\n  // Get chat messages and store instance\n  const chatMessages = useChatMessages();\n  \n  // Initialize the unified store with the notebook ID\n  useEffect(() => {\n    if (setNotebookId) {\n      setNotebookId(notebookId);\n    }\n  }, [notebookId, setNotebookId]);\n\n  // Initialize the chat handler with our simplified, more reliable API endpoint\n  console.log(\"ðŸ“Š LlamaChat: Setting up chat handler with:\", { \n    api: '/api/claude/chat-simple',\n    notebookId,\n    modelId,\n    useStream: true \n  });\n  \n  useEffect(() => {\n    // One-time debug check of environment \n    console.log(\"ðŸ“Š LlamaChat: Environment check:\", { \n      window: typeof window !== 'undefined',\n      fetch: typeof fetch !== 'undefined',\n      notebookId,\n      apiUrl: window.location.origin + '/api/claude/chat-simple'\n    });\n    \n    // Make test request to check API health - use chat-simple for testing\n    fetch('/api/claude/chat-simple', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ \n        messages: [{ role: 'user', content: 'Test request' }],\n        notebookId,\n        stream: false,\n        test: true\n      })\n    })\n    .then(res => {\n      console.log('ðŸ“Š LlamaChat: API test response:', { \n        status: res.status, \n        statusText: res.statusText,\n        ok: res.ok\n      });\n    })\n    .catch(err => {\n      console.error('ðŸ”´ LlamaChat: API test error:', err);\n    });\n  }, [notebookId]);\n  \n  // Get system prompt from the config file and use it instead of hardcoding\n  // The system prompt will be sent to the API but not displayed in the UI\n  const chatHandler = useChat({\n    api: '/api/claude/chat-simple', // Use simpler endpoint that doesn't use streaming\n    initialMessages: [], // Do not send system message via initialMessages\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: false, // Disable streaming to avoid parsing issues\n      systemPrompt // Pass system prompt in the body instead\n    },\n    headers: {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n    },\n    onError: (error) => {\n      console.error(\"ðŸ”´ LlamaChat: Chat error:\", error);\n    },\n    onMessage: (message) => {\n      console.log(\"ðŸŸ¡ LlamaChat: Message received:\", {\n        type: typeof message,\n        snippet: typeof message === 'string' ? message.substring(0, 30) : JSON.stringify(message).substring(0, 30)\n      });\n    },\n    onResponse: (response) => {\n      // Called when a response is received\n      console.log('ðŸ”µ LlamaChat: Chat response started:', {\n        status: response.status,\n        statusText: response.statusText,\n        headers: Array.from(response.headers.entries()),\n        notebookId\n      });\n    },\n    onFinish: async (message) => {\n      // Called when a message is completed\n      console.log('ðŸŸ¢ LlamaChat: Message completed:', {\n        id: message.id,\n        role: message.role,\n        contentLength: message.content?.length || 0,\n        contentPreview: message.content?.substring(0, 50) + '...' || 'No content'\n      });\n      \n      try {\n        // Create a node for the AI response message\n        if (message && message.content && message.content !== 'New response') {\n          // Ensure content is a valid string\n          const messageContent = typeof message.content === 'string' ? \n            message.content : \n            (message.content ? JSON.stringify(message.content) : 'Empty response');\n\n          // Create message object\n          const messageObj = {\n            id: message.id,\n            role: 'assistant',\n            content: messageContent,\n            created_at: new Date().toISOString()\n          };\n          \n          // Get the last user message to create proper relationship\n          const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n          if (userMessages.length === 0) {\n            console.error('No user messages found to respond to');\n            setIsProcessing(false);\n            return;\n          }\n          \n          const lastUserMessage = userMessages[userMessages.length - 1];\n          \n          // Find the node for the last user message\n          const userNodes = Object.values(nodes).filter(n => {\n            return n.messages && n.messages.some(m => m.id === lastUserMessage.id);\n          });\n          \n          // Handle based on the user's node tier\n          if (userNodes.length > 0) {\n            const userNode = userNodes[0];\n            const userNodeTier = userNode.metadata?.tier || 3;\n            \n            // Three cases: tier 1 (main question), tier 2 (category), tier 3 (conversation)\n            if (userNodeTier === 1) {\n              // This is a response to the main question\n              console.log('Adding response to main question (tier 1 node)');\n              \n              // Create a tier 3 node with relationship to main question\n              const position = { \n                x: userNode.position?.x || 350, \n                y: (userNode.position?.y || 200) + 120 \n              };\n              \n              // Create node from message with right tier and metadata\n              const responseNode = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                position,\n                {\n                  parentNodeId: userNode.id,\n                  mainQuestionId: userNode.id,\n                  isAnswerToMainQuestion: true,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              // Create relationship from main question to response\n              if (responseNode) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  responseNode.id,\n                  'supports', // AI response supports the question\n                  notebookId,\n                  {\n                    direction: 'resolving',\n                    intention: 'answer',\n                    state: 'active'\n                  }\n                );\n                \n                // Update active node to this response\n                setSelectedNode(responseNode.id);\n                setActiveNode(responseNode.id);\n              }\n              \n              // Add to chat messages store for consistency\n              await addChatMessage(messageObj, false);\n            } else if (userNodeTier === 2) {\n              // This is a response to a category question\n              console.log('Adding response to category node (tier 2 node)');\n              \n              // Position relative to category node\n              const position = { \n                x: userNode.position?.x || 400, \n                y: (userNode.position?.y || 300) + 80 \n              };\n              \n              // Create response node with proper metadata\n              const responseNode = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                position,\n                {\n                  parentNodeId: userNode.id,\n                  categoryNodeId: userNode.id,\n                  mainQuestionId: userNode.metadata?.parentNodeId,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              // Create relationship\n              if (responseNode) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  responseNode.id,\n                  'supports', // AI response supports the category question\n                  notebookId,\n                  {\n                    direction: 'resolving',\n                    intention: 'answer',\n                    state: 'active'\n                  }\n                );\n                \n                // Update active node\n                setSelectedNode(responseNode.id);\n                setActiveNode(responseNode.id);\n              }\n              \n              // Add to chat messages store for consistency\n              await addChatMessage(messageObj, false);\n            } else {\n              // This is a response to a regular conversation message (tier 3)\n              // Check if this is a standalone node or part of a conversation\n              \n              if (userNode.isConversationNode && userNode.messages && userNode.messages.length > 0) {\n                // This is part of an existing conversation - add to the same node\n                console.log('Adding response to existing conversation node');\n                \n                // Add message to the existing node instead of creating a new one\n                const success = await nodeIntegration.addMessageToNode(\n                  userNode.id, \n                  messageObj,\n                  lastUserMessage.id // parent message ID for threading\n                );\n                \n                if (!success) {\n                  console.error('Failed to add message to node, falling back to new node creation');\n                  \n                  // Fallback - create a new node\n                  const position = { \n                    x: userNode.position?.x || 450, \n                    y: (userNode.position?.y || 350) + 60 \n                  };\n                  \n                  const responseNode = await nodeIntegration.createNodeFromMessage(\n                    messageObj,\n                    notebookId,\n                    position,\n                    {\n                      parentNodeId: userNode.metadata?.parentNodeId,\n                      respondingToNodeId: userNode.id,\n                      source: 'chat',\n                      timestamp: new Date().toISOString()\n                    },\n                    'response',\n                    3 // tier 3\n                  );\n                  \n                  // Create relationship\n                  if (responseNode) {\n                    await nodeIntegration.createNodeRelationship(\n                      userNode.id,\n                      responseNode.id,\n                      'supports',\n                      notebookId,\n                      {\n                        direction: 'resolving',\n                        intention: 'answer',\n                        state: 'active'\n                      }\n                    );\n                  }\n                }\n              } else {\n                // This is a response to a standalone message - create a new node\n                console.log('Creating response node for standalone message');\n                \n                const position = { \n                  x: userNode.position?.x || 450, \n                  y: (userNode.position?.y || 350) + 60 \n                };\n                \n                const responseNode = await nodeIntegration.createNodeFromMessage(\n                  messageObj,\n                  notebookId,\n                  position,\n                  {\n                    parentNodeId: userNode.metadata?.parentNodeId,\n                    respondingToNodeId: userNode.id,\n                    source: 'chat',\n                    timestamp: new Date().toISOString()\n                  },\n                  'response',\n                  3 // tier 3\n                );\n                \n                // Create relationship\n                if (responseNode) {\n                  await nodeIntegration.createNodeRelationship(\n                    userNode.id,\n                    responseNode.id,\n                    'supports',\n                    notebookId,\n                    {\n                      direction: 'resolving',\n                      intention: 'answer',\n                      state: 'active'\n                    }\n                  );\n                  \n                  // Update active node\n                  setSelectedNode(responseNode.id);\n                  setActiveNode(responseNode.id);\n                }\n              }\n              \n              // Add to chat messages store for consistency\n              await addChatMessage(messageObj, false);\n            }\n          } else {\n            // No user node found - create a standalone response\n            console.warn('No user node found for message', lastUserMessage.id);\n            \n            // Create node as a fallback\n            const node = await nodeIntegration.createNodeFromMessage(\n              messageObj,\n              notebookId\n            );\n            \n            // Find main question node to at least attach it somewhere\n            const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n            if (node && mainQuestionNode) {\n              await nodeIntegration.createNodeRelationship(\n                mainQuestionNode.id,\n                node.id,\n                'supports',\n                notebookId\n              );\n            }\n            \n            // Add to chat messages\n            await addChatMessage(messageObj, false);\n          }\n          \n          // If we have an active thread, attempt to synchronize\n          if (getActiveThreadNodeId) {\n            try {\n              await syncActiveThreadFn();\n            } catch (syncError) {\n              console.error('Error syncing with active thread:', syncError);\n            }\n          }\n        } else if (message.content === 'New response') {\n          console.log('Skipping placeholder content \"New response\"');\n        } else {\n          console.error('Received empty message from AI', message);\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n  \n  // Sync chat handler messages with unified store (one-way, unified store -> chat handler)\n  useEffect(() => {\n    // When unified store messages change, update chat handler if significantly different\n    const unifiedMessages = chatMessages;\n    const chatHandlerMessages = chatHandler.messages;\n    \n    // Skip if no messages or if processing - prevent loop\n    if (unifiedMessages.length === 0 || isProcessing) return;\n    \n    // Check if significantly different (different number of messages or last message content differs)\n    const isDifferent = \n      unifiedMessages.length !== chatHandlerMessages.length ||\n      (unifiedMessages.length > 0 && chatHandlerMessages.length > 0 &&\n       unifiedMessages[unifiedMessages.length - 1].content !== \n       chatHandlerMessages[chatHandlerMessages.length - 1].content);\n    \n    if (isDifferent) {\n      // Convert from unified store format to chat handler format\n      const newChatMessages = unifiedMessages.map(msg => ({\n        id: msg.id,\n        role: msg.role,\n        content: msg.content\n      }));\n      \n      // Set messages in chat handler\n      chatHandler.setMessages(newChatMessages);\n    }\n  }, [chatMessages, chatHandler, isProcessing]);\n\n  // Handle model change\n  const handleModelChange = useCallback((model: string) => {\n    setModelId(model);\n  }, []);\n\n  // Override the submit handler to create nodes with proper tier hierarchy\n  const handleSubmit = useCallback(async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      console.log('Processing user message...');\n      \n      // Generate a unique ID for this message\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n        created_at: new Date().toISOString()\n      };\n      \n      // Check if this is the first message - if so, mark it as the main question (tier 1)\n      // First, count existing question nodes\n      const existingQuestionNodes = Object.values(nodes).filter(n => \n        n.type === 'question' && n.notebook_id === notebookId\n      );\n      const isFirstMessage = existingQuestionNodes.length === 0;\n      \n      // Find main question node if it exists\n      let mainQuestionNode = null;\n      if (!isFirstMessage) {\n        mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n      }\n      \n      let node = null;\n      \n      if (isFirstMessage) {\n        // This is the first question - create as tier 1 (main question)\n        console.log('Creating main question node (tier 1)');\n        \n        // Position in center\n        const position = { x: 350, y: 200 };\n        \n        // Create with tier 1 metadata\n        node = await nodeIntegration.createNodeFromMessage(\n          messageObj,\n          notebookId,\n          position,\n          {\n            isMainQuestion: true,\n            source: 'chat',\n            timestamp: new Date().toISOString()\n          },\n          'question',\n          1 // tier 1\n        );\n      } else if (activeNode) {\n        // We have an active node to attach to\n        const activeTier = activeNode.metadata?.tier || 3;\n        \n        if (activeTier === 1) {\n          // Adding to the main question - create as tier 3 (conversation)\n          console.log('Creating conversation node under main question (tier 3)');\n          \n          // Position below the active node\n          const position = { \n            x: activeNode.position?.x || 350, \n            y: (activeNode.position?.y || 200) + 100 \n          };\n          \n          // Create as tier 3 (conversation node)\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId,\n            position,\n            {\n              parentNodeId: activeNode.id,\n              source: 'chat',\n              timestamp: new Date().toISOString()\n            },\n            'question',\n            3 // tier 3\n          );\n          \n          // Create relationship to parent\n          if (node) {\n            await nodeIntegration.createNodeRelationship(\n              activeNode.id,\n              node.id,\n              'extends',\n              notebookId,\n              {\n                direction: 'outgoing',\n                intention: 'conversation',\n                state: 'active'\n              }\n            );\n          }\n        } else if (activeTier === 2) {\n          // Adding to a category node - create as tier 3 (conversation)\n          console.log('Creating conversation node under category (tier 3)');\n          \n          // Position below the category node\n          const position = { \n            x: activeNode.position?.x || 400, \n            y: (activeNode.position?.y || 300) + 80 \n          };\n          \n          // Create as tier 3 (conversation node)\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId,\n            position,\n            {\n              parentNodeId: activeNode.id,\n              categoryNodeId: activeNode.id,\n              mainQuestionId: activeNode.metadata?.parentNodeId,\n              source: 'chat',\n              timestamp: new Date().toISOString()\n            },\n            'question',\n            3 // tier 3\n          );\n          \n          // Create relationship to parent category\n          if (node) {\n            await nodeIntegration.createNodeRelationship(\n              activeNode.id,\n              node.id,\n              'extends',\n              notebookId,\n              {\n                direction: 'outgoing',\n                intention: 'conversation',\n                state: 'active'\n              }\n            );\n          }\n        } else {\n          // Adding to a conversation node - create as continuation (tier 3)\n          console.log('Adding to existing conversation (tier 3)');\n          \n          // Instead of creating a new node, add message to existing node\n          if (await nodeIntegration.addMessageToNode(activeNode.id, messageObj)) {\n            // Using existing node\n            node = activeNode;\n          } else {\n            // Fallback - create new node\n            const position = { \n              x: activeNode.position?.x || 450, \n              y: (activeNode.position?.y || 350) + 60 \n            };\n            \n            node = await nodeIntegration.createNodeFromMessage(\n              messageObj,\n              notebookId,\n              position,\n              {\n                parentNodeId: activeNode.metadata?.parentNodeId,\n                source: 'chat',\n                timestamp: new Date().toISOString()\n              },\n              'question',\n              3 // tier 3\n            );\n            \n            // Create relationship\n            if (node) {\n              await nodeIntegration.createNodeRelationship(\n                activeNode.id,\n                node.id,\n                'extends',\n                notebookId\n              );\n            }\n          }\n        }\n      } else if (mainQuestionNode) {\n        // No active node but we have a main question - attach to it\n        console.log('Attaching to main question node (no active node)');\n        \n        // Position relative to main question\n        const position = { \n          x: mainQuestionNode.position?.x || 350, \n          y: (mainQuestionNode.position?.y || 200) + 120 \n        };\n        \n        // Create as tier 3 (conversation node)\n        node = await nodeIntegration.createNodeFromMessage(\n          messageObj,\n          notebookId,\n          position,\n          {\n            parentNodeId: mainQuestionNode.id,\n            source: 'chat',\n            timestamp: new Date().toISOString()\n          },\n          'question',\n          3 // tier 3\n        );\n        \n        // Create relationship to main question\n        if (node) {\n          await nodeIntegration.createNodeRelationship(\n            mainQuestionNode.id,\n            node.id,\n            'extends',\n            notebookId,\n            {\n              direction: 'outgoing',\n              intention: 'conversation',\n              state: 'active'\n            }\n          );\n        }\n      } else {\n        // Fallback - create as a standard question node\n        console.log('Creating standard node (no hierarchy found)');\n        \n        // Create node with default settings\n        node = await nodeIntegration.createNodeFromMessage(\n          messageObj,\n          notebookId\n        );\n      }\n      \n      // Also add to chat messages store for consistency\n      await addChatMessage(messageObj, false); // false = don't create node (already created)\n      \n      // Update the UI state with new active node\n      if (node && node.id !== activeNode?.id) {\n        setSelectedNode(node.id);\n        setActiveNode(node.id);\n      }\n      \n      // Clear the input field immediately for better UX\n      chatHandler.setInput('');\n      \n      // Call the chat handler manually to avoid double-submission\n      // This will update messages array and trigger API call\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n      });\n      \n      console.log('User message processed, node created:', node?.id);\n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [activeNode, addChatMessage, chatHandler, isProcessing, nodes, notebookId, setActiveNode, setSelectedNode]);\n\n  // Create a new thread or conversation\n  const handleCreateNewThread = useCallback(() => {\n    // Clear active node selection\n    setSelectedNode(null);\n    setActiveNode(null);\n    if (setActiveThread) {\n      setActiveThread(null);\n    }\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n    setChatMessages(systemMessages.map(msg => ({\n      ...msg,\n      created_at: new Date().toISOString()\n    })));\n  }, [setSelectedNode, setActiveNode, chatHandler, setChatMessages, setActiveThread]);\n  \n  // Create a tier 2 category node\n  const handleCreateCategoryNode = useCallback(async (\n    type: 'question' | 'response' | 'note' | 'drawing',\n    defaultContent: string\n  ) => {\n    try {\n      // First find the main question node (tier 1)\n      const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n      \n      if (!mainQuestionNode) {\n        console.error('Cannot create category node - no main question found');\n        alert('Please create a main question first before adding category nodes');\n        return;\n      }\n      \n      // Create a dialog to get the content for the node\n      const content = window.prompt(`Enter content for the new ${type} node:`, defaultContent);\n      \n      if (!content) {\n        console.log('Category node creation cancelled');\n        return; // User cancelled\n      }\n      \n      console.log(`Creating tier 2 ${type} node with content: ${content}`);\n      \n      // Create the tier 2 node\n      const categoryNode = await nodeIntegration.createTier2Node(\n        mainQuestionNode.id,\n        type,\n        content,\n        notebookId\n      );\n      \n      if (!categoryNode) {\n        console.error('Failed to create category node');\n        return;\n      }\n      \n      // Set this as the active node\n      setSelectedNode(categoryNode.id);\n      setActiveNode(categoryNode.id);\n      \n      // Update the chat view to reflect this node\n      if (setActiveThread) {\n        setActiveThread(categoryNode.id);\n      }\n      \n      // Reset chat to only system message + new prompt about this category\n      const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n      \n      // Append a message about the category\n      const categoryMessage = {\n        id: `cat_${Date.now()}`,\n        role: 'system' as const,\n        content: `You are now working in the category: ${content} (${type}). This is a tier 2 node organized under the main question.`\n      };\n      \n      chatHandler.setMessages([...systemMessages, categoryMessage]);\n      \n      console.log(`Created and activated tier 2 node: ${categoryNode.id}`);\n    } catch (error) {\n      console.error('Error creating category node:', error);\n    }\n  }, [nodeIntegration, notebookId, setSelectedNode, setActiveNode, setActiveThread, chatHandler]);\n  \n  // Create initial question node if provided\n  useEffect(() => {\n    const createInitialQuestion = async () => {\n      // Skip if already created, no initial question, or processing\n      if (initialQuestionCreatedRef.current || !initialQuestion || isProcessing) {\n        return;\n      }\n\n      // Skip if any messages already exist\n      if (chatMessages.length > 1) { // More than just system message\n        initialQuestionCreatedRef.current = true;\n        return;\n      }\n\n      // Create the initial question\n      try {\n        setIsProcessing(true);\n        initialQuestionCreatedRef.current = true;\n        \n        // Add initial question to chat\n        await addChatMessage({\n          role: 'user',\n          content: initialQuestion\n        }, true);\n        \n        // Update chat handler\n        chatHandler.setInput('');\n        chatHandler.setMessages([\n          ...chatHandler.messages,\n          {\n            id: `initial-question-${Date.now()}`,\n            role: 'user',\n            content: initialQuestion\n          }\n        ]);\n        \n        // Trigger AI response using the simpler API endpoint\n        const response = await fetch('/api/claude/chat-simple', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            messages: [\n              { role: 'system', content: systemPrompt },\n              { role: 'user', content: initialQuestion }\n            ],\n            notebookId,\n            model: modelId,\n            includeUserContext: true,\n            stream: false // Disable streaming for reliability\n          })\n        });\n        \n        if (response.ok) {\n          const responseData = await response.json();\n          \n          // Extract text content from response\n          let aiResponseText = '';\n          if (responseData.content && Array.isArray(responseData.content)) {\n            aiResponseText = responseData.content\n              .filter((block: any) => block.type === 'text')\n              .map((block: any) => block.text)\n              .join('\\n');\n          } else if (typeof responseData.content === 'string') {\n            aiResponseText = responseData.content;\n          }\n          \n          // Add AI response to chat\n          if (aiResponseText) {\n            await addChatMessage({\n              role: 'assistant',\n              content: aiResponseText\n            }, true);\n            \n            // Update chat handler messages\n            chatHandler.setMessages([\n              ...chatHandler.messages,\n              {\n                id: `initial-response-${Date.now()}`,\n                role: 'assistant',\n                content: aiResponseText\n              }\n            ]);\n          }\n        }\n      } catch (error) {\n        console.error('Error creating initial question:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    };\n\n    createInitialQuestion();\n  }, [initialQuestion, notebookId, modelId, systemPrompt, chatMessages, addChatMessage, chatHandler, isProcessing]);\n  \n  // REMOVED sync with active thread - this causes infinite loops\n  // Instead, set active thread once when node changes\n  useEffect(() => {\n    if (activeNode && !isProcessing) {\n      const activeNodeId = activeNode.id;\n      if (setActiveThread) {\n        setActiveThread(activeNodeId);\n      }\n    }\n  }, [activeNode, isProcessing, setActiveThread]);\n  \n  // REMOVED automatic sync on mount - caused infinite loops\n  // User can manually sync with the button when needed\n\n  // Debug information for development\n  const nodeCount = Object.keys(nodes).length;\n  const messageCount = chatHandler.messages.length;\n  const visibleMessages = chatHandler.messages.filter(msg => msg.role !== 'system' && msg.content !== 'New response');\n  \n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">\n          {activeNode ? (\n            <>\n              {activeNode.type === 'question' ? 'Question' : 'Conversation'}\n              {activeNode.metadata?.tier && (\n                <span className=\"ml-2 text-xs bg-blue-100 px-2 py-0.5 rounded-full text-blue-800\">\n                  Tier {activeNode.metadata.tier}\n                </span>\n              )}\n            </>\n          ) : 'Chat'}\n        </h2>\n        <div className=\"flex items-center space-x-2\">\n          {/* Create category node dropdown (only visible when main question exists) */}\n          {Object.values(nodes).some(n => n.metadata?.tier === 1) && (\n            <div className=\"relative group\">\n              <button\n                className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n                title=\"Create category node\"\n              >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path d=\"M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM14 11a1 1 0 011 1v1h1a1 1 0 110 2h-1v1a1 1 0 11-2 0v-1h-1a1 1 0 110-2h1v-1a1 1 0 011-1z\" />\n                </svg>\n              </button>\n              <div className=\"absolute right-0 mt-2 w-48 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none hidden group-hover:block z-10\">\n                <div className=\"py-1\" role=\"menu\" aria-orientation=\"vertical\">\n                  <button\n                    onClick={() => handleCreateCategoryNode('question', 'New Question')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸ¤” New Question\n                  </button>\n                  <button\n                    onClick={() => handleCreateCategoryNode('note', 'Research Notes')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸ“ Research Notes\n                  </button>\n                  <button\n                    onClick={() => handleCreateCategoryNode('drawing', 'Visual Map')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸŽ¨ Visual Map\n                  </button>\n                  <button\n                    onClick={() => handleCreateCategoryNode('response', 'Agent')}\n                    className=\"w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 hover:text-gray-900\"\n                    role=\"menuitem\"\n                  >\n                    ðŸ¤– Agent\n                  </button>\n                </div>\n              </div>\n            </div>\n          )}\n          \n          <button\n                nodeId: node.id\n              }))\n            ];\n          } else {\n            allMessages.push({\n              id: `node_${node.id}`,\n              role: node.type === 'question' ? 'user' : 'assistant',\n              content: node.content,\n              created_at: node.created_at,\n              nodeId: node.id\n            });\n          }\n        }\n        \n        // Add system prompt at the beginning if not present\n        const hasSystemMessage = allMessages.some(msg => msg.role === 'system');\n        if (!hasSystemMessage) {\n          allMessages.unshift({\n            id: `system_${Date.now()}`,\n            role: 'system',\n            content: systemPrompt,\n            created_at: new Date().toISOString()\n          });\n        }\n        \n        // Sort messages by creation time\n        allMessages.sort((a, b) => \n          new Date(a.created_at).getTime() - new Date(b.created_at).getTime()\n        );\n        \n        // Update chat messages\n        setChatMessages(allMessages);\n        return;\n      }\n      \n      // Step 2: Build a hierarchical view with main question at the root\n      console.log(`Found main question node: ${mainQuestionNode.id}`);\n      \n      // Collect main question messages\n      let hierarchicalMessages = [];\n      \n      // Add main question's messages\n      if (mainQuestionNode.messages && mainQuestionNode.messages.length > 0) {\n        hierarchicalMessages = [\n          ...hierarchicalMessages,\n          ...mainQuestionNode.messages.map(msg => ({\n            ...msg,\n            nodeId: mainQuestionNode.id,\n            tier: 1\n          }))\n        ];\n      } else {\n        // Create synthetic message for main question\n        hierarchicalMessages.push({\n          id: `node_${mainQuestionNode.id}`,\n          role: 'user',\n          content: mainQuestionNode.content,\n          created_at: mainQuestionNode.created_at,\n          nodeId: mainQuestionNode.id,\n          tier: 1\n        });\n      }\n      \n      // Find direct responses to the main question (tier 3 nodes)\n      const directResponses = Object.values(nodes).filter(node => {\n        return node.metadata?.parentNodeId === mainQuestionNode.id &&\n               node.metadata?.tier === 3;\n      }).sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());\n      \n      // Add direct responses to the chat\n      for (const responseNode of directResponses) {\n        if (responseNode.messages && responseNode.messages.length > 0) {\n          hierarchicalMessages = [\n            ...hierarchicalMessages,\n            ...responseNode.messages.map(msg => ({\n              ...msg,\n              nodeId: responseNode.id,\n              tier: 3\n            }))\n          ];\n        } else {\n          hierarchicalMessages.push({\n            id: `node_${responseNode.id}`,\n            role: responseNode.type === 'question' ? 'user' : 'assistant',\n            content: responseNode.content,\n            created_at: responseNode.created_at,\n            nodeId: responseNode.id,\n            tier: 3\n          });\n        }\n      }\n      \n            );\n            \n            // Find main question node to at least attach it somewhere\n            const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n            if (node && mainQuestionNode) {\n              await nodeIntegration.createNoe(2);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [penColor, setPenColor] = useState('#000000');\n\n          y\n        }\n      }\n    }));\n  }, []);\n  \n  const handleDragEnd = useCallback(async (id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: false\n        }\n      }\n    }));\n    \n    // Save position to database if authenticated\n    if (user) {\n      const conversation = conversationState.items.find(c => c.id === id);\n      const pos = conversationState.positions[id];\n      \n      if (conversation && pos) {\n        try {\n          await supabase\n            .from('conversations')\n            .update({\n              position: { x: pos.x, y: pos.y },\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', id);\n        } catch (err) {\n          console.error('Error updating position:', err);\n        }\n      }\n    }\n  }, [user, conversationState.items, conversationState.positions]);\n  \n  const handleToggleCollapse = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isCollapsed: !prev.positions[id].isCollapsed\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n  \n  const handleToggleInfoDialog = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      activeInfoDialog: prev.activeInfoDialog === id ? null : id\n    }));\n  }, []);\n  \n  const handleEditContent = useCallback(async (id: string, text: string) => {\n    if (!user) return;\n    \n    try {\n      await supabase\n        .from('conversations')\n        .update({\n          user_content: text,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n        \n      setConversationState(prev => ({\n        ...prev,\n        items: prev.items.map(item => \n          item.id === id ? { ...item, user_content: text, updated_at: new Date().toISOString() } : item\n        )\n      }));\n    } catch (err) {\n      console.error('Error updating content:', err);\n    }\n  }, [user]);\n  \n  const handleContinueThread = useCallback((id: string) => {\n    // Conversation continuation logic\n    console.log('Continue thread:', id);\n  }, []);\n  \n  const handleCreateFollowUp = useCallback((id: string) => {\n    // Follow-up creation logic\n    console.log('Create follow-up:', id);\n  }, []);\n  \n  const handleCreateReference = useCallback((id: string, targetId?: string) => {\n    // Reference creation logic\n    console.log('Create reference from', id, 'to', targetId);\n  }, []);\n  \n  // System prompt handlers\n  const handleUpdateSystemPrompt = useCallback(async (prompt: string) => {\n    if (!user || !notebook) return;\n    \n    setSystemPrompt(prompt);\n    setIsSystemPromptModalOpen(false);\n    \n    try {\n      await supabase\n        .from('notebooks')\n        .update({\n          system_prompt: prompt,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', notebookId);\n    } catch (err) {\n      console.error('Error updating system prompt:', err);\n    }\n  }, [user, notebook, notebookId]);\n  \n  // Determine undo/redo availability\n  const undoAvailable = strokes.length > 0;\n  const redoAvailable = undoStack.length > 0;\n  \n  // Loading state\n  if (notebookLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500\"></div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"flex flex-col h-screen w-full\">\n      {/* Toolbar */}\n      <ResponsiveToolbar\n        tool={tool}\n        setTool={safeSetTool}\n        scale={scale}\n        setScale={setScale}\n        setPosition={setPosition}\n        notebookId={notebookId}\n        notebookTitle={notebook?.title || 'Untitled Notebook'}\n        isCollaborative={notebook?.is_collaborative}\n        onClearCanvas={handleClearCanvas}\n        isPenMode={isPenMode}\n        setIsPenMode={setIsPenMode}\n        penSize={penSize}\n        setPenSize={setPenSize}\n        eraserSize={eraserSize}\n        setEraserSize={setEraserSize}\n        undoAvailable={undoAvailable}\n        redoAvailable={redoAvailable}\n        onUndo={handleUndo}\n        onRedo={handleRedo}\n        penColor={penColor}\n        setPenColor={setPenColor}\n        isSidePanelOpen={isSidePanelOpen}\n        toggleSidePanel={() => setIsSidePanelOpen(prev => !prev)}\n        onOpenSystemPromptModal={() => setIsSystemPromptModalOpen(true)}\n      />\n      \n      {/* Canvas Container */}\n      <div\n        ref={containerRef}\n        className=\"flex-1 relative bg-gray-50 overflow-hidden\"\n        style={{ height: 'calc(100vh - 100px)' }}\n      >\n        {/* Debug Panel */}\n        <DebugPanel />\n\n        <Stage\n          width={stageWidth}\n          height={stageHeight}\n          ref={stageRef}\n          draggable={tool === 'pan'}\n          onMouseDown={handleInputStart}\n          onMouseMove={handleInputMove}\n          onMouseUp={handleInputEnd}\n          onMouseLeave={handleInputEnd}\n          onTouchStart={handleInputStart}\n          onTouchMove={handleInputMove}\n          onTouchEnd={handleInputEnd}\n          onPointerDown={handleInputStart}\n          onPointerMove={handleInputMove}\n          onPointerUp={handleInputEnd}\n          position={position}\n          scale={{ x: scale, y: scale }}\n          onContextMenu={e => e.evt.preventDefault()}\n        >\n          {/* Background Layer */}\n          <Layer name=\"background-layer\">\n            <BackgroundLayer\n              width={stageWidth}\n              height={stageHeight}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Drawing Layer */}\n          <Layer name=\"drawing-layer\">\n            <DrawingLayer\n              strokes={strokes}\n              currentStroke={currentStroke}\n              scale={scale}\n              position={position}\n            />\n          </Layer>\n\n          {/* Text Layer */}\n          <Layer name=\"text-layer\">\n            <TextLayer\n              conversationState={conversationState}\n              notebookId={notebookId}\n              onDragStart={handleDragStart}\n              onDragMove={handleDragMove}\n              onDragEnd={handleDragEnd}\n              onToggleCollapse={handleToggleCollapse}\n              onToggleInfoDialog={handleToggleInfoDialog}\n              onEditContent={handleEditContent}\n              onContinueThread={handleContinueThread}\n              onCreateFollowUp={handleCreateFollowUp}\n              onCreateReference={handleCreateReference}\n              tool={tool}\n              isTextSelectionEnabled={tool === 'text'}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Selection Layer */}\n          {selectionRect.isActive && (\n            <Layer name=\"selection-layer\">\n              <Line\n                points={[\n                  selectionRect.x, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y\n                ]}\n                stroke=\"rgba(0, 161, 255, 0.8)\"\n                strokeWidth={2 / scale}\n                dash={[5 / scale, 5 / scale]}\n                closed={true}\n                fill=\"rgba(0, 161, 255, 0.1)\"\n              />\n            </Layer>\n          )}\n        </Stage>\n      </div>\n      \n      {/* System Prompt Modal */}\n      {isSystemPromptModalOpen && (\n        <SystemPromptModal\n          isOpen={isSystemPromptModalOpen}\n          onClose={() => setIsSystemPromptModalOpen(false)}\n          initialPrompt={systemPrompt || ''}\n          onSave={handleUpdateSystemPrompt}\n        />\n      )}\n      \n      {/* Side Panel with ConversationSidePanel */}\n      {isSidePanelOpen && (\n        <ConversationSidePanel\n          notebookId={notebookId}\n          conversations={conversationState.items}\n          onEditTranscription={async (id, text) => {\n            try {\n              await supabase\n                .from('conversations')\n                .update({\n                  ai_response: text,\n                  updated_at: new Date().toISOString()\n                })\n                .eq('id', id);\n\n              // Update local state\n              setConversationState(prev => ({\n                ...prev,\n                items: prev.items.map(item =>\n                  item.id === id ? { ...item, ai_response: text, updated_at: new Date().toISOString() } : item\n                )\n              }));\n            } catch (err) {\n              console.error('Error updating AI response:', err);\n            }\n          }}\n          onSendMessage={async (message, mode) => {\n            try {\n              if (!user) return;\n\n              // Create a new conversation\n              const newConversation: Partial<Conversation> = {\n                id: generateUUID(), // Use our custom UUID generator\n                notebook_id: notebookId,\n                user_id: user.id,\n                user_content: message,\n                position: {\n                  x: -position.x + stageWidth / 2 - 150, // Center horizontally\n                  y: -position.y + stageHeight / 2 - 100 // Center vertically\n                },\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString(),\n                card_type: mode === 'chat' ? 'question' : 'note',\n                thread_id: conversationState.activeConversation || undefined,\n                is_thread_starter: !conversationState.activeConversation\n              };\n\n              // Save to database\n              const { data, error } = await supabase\n                .from('conversations')\n                .insert(newConversation)\n                .select()\n                .single();\n\n              if (error) throw error;\n\n              // Update local state\n              const savedConversation = data as Conversation;\n\n              setConversationState(prev => ({\n                ...prev,\n                items: [...prev.items, savedConversation],\n                positions: {\n                  ...prev.positions,\n                  [savedConversation.id]: {\n                    ...extractPositionFromJson(savedConversation.position),\n                    isCollapsed: false,\n                    isDragging: false\n                  }\n                },\n                activeConversation: savedConversation.id\n              }));\n\n              // Parliament functionality has been removed\n              if (mode === 'chat') {\n                // Process chat message without parliament\n                console.log('Chat message sent:', message);\n              }\n\n              return savedConversation;\n            } catch (err) {\n              console.error('Error sending message:', err);\n              throw err;\n            }\n          }}\n          onJumpToCard={(id) => {\n            // Find the card\n            const conversation = conversationState.items.find(c => c.id === id);\n            const position = conversationState.positions[id];\n\n            if (conversation && position) {\n              // Center on the card\n              setPosition({\n                x: -position.x + stageWidth / 2 - 150,\n                y: -position.y + stageHeight / 2 - 100\n              });\n\n              // Set as active\n              setConversationState(prev => ({\n                ...prev,\n                activeConversation: id\n              }));\n            }\n          }}\n          onClose={() => setIsSidePanelOpen(false)}\n          isOpen={isSidePanelOpen}\n          isFullScreen={false}\n          onToggleFullScreen={() => {\n            // This would toggle full-screen mode if implemented\n            console.log('Toggle full-screen mode');\n          }}\n          systemPrompt={systemPrompt}\n        />\n      )}\n\n      {/* Parliament functionality has been removed */}\n    </div>\n  );\n};\n\nexport default CanvasContainer;\nðŸ“„ --- File: ./src/components/canvas/CanvasContainer.tsx (matched setInput) ---\n// src/components/canvas/CanvasContainer.tsx\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Stage, Layer } from 'react-konva';\nimport { KonvaEventObject } from 'konva/lib/Node';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Stroke, Conversation } from '@/types/supabase';\nimport { extractPositionFromJson } from '@/types/position';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport { useRouter } from 'next/router';\nimport DrawingLayer from './DrawingLayer';\nimport TextLayer from './TextLayer';\nimport BackgroundLayer from './BackgroundLayer';\nimport CardLayer from './CardLayer';\n// Using updated responsive toolbar\nimport ResponsiveToolbar from './ResponsiveToolbar';\nimport SystemPromptModal from '@/components/modals/SystemPromptModal';\nimport ConversationSidePanel from '@/components/ui/ConversationSidePanel';\nimport { generateUUID } from '@/utils/uuidUtils';\n\n// Tool types definition\nexport type Tool = 'pen' | 'eraser' | 'select' | 'text' | 'pan';\n\n// Component Props\ninterface CanvasContainerProps {\n  notebookId: string;\n}\n\nconst CanvasContainer: React.FC<CanvasContainerProps> = ({ notebookId }) => {\n  const { user } = useAuth();\n  const { notebook, loading: notebookLoading } = useNotebook(notebookId);\n  const router = useRouter();\n  \n  // Refs\n   \n  const stageRef = useRef<any>(null); // Using any for Konva Stage ref\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Canvas dimension state\n  const [stageWidth, setStageWidth] = useState(typeof window !== 'undefined' ? window.innerWidth : 1000);\n  const [stageHeight, setStageHeight] = useState(typeof window !== 'undefined' ? window.innerHeight - 100 : 900);\n  \n  // Canvas view state\n  const [scale, setScale] = useState(1);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  // Tool state\n  const [tool, setTool] = useState<Tool>('pen');\n  const [previousTool, setPreviousTool] = useState<Tool>('pen');\n  const [isPenMode, setIsPenMode] = useState(true);\n  const [penSize, setPenSize] = useState(2);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [penColor, setPenColor] = useState('#000000');\n\n  // Tool transition handling\n  const safeSetTool = useCallback((newTool: Tool) => {\n    console.log(`CanvasContainer: Setting tool from ${tool} to ${newTool}`);\n    setPreviousTool(tool);\n    setTool(newTool);\n  }, [tool]);\n\n  // Error boundary for tool switching\n  useEffect(() => {\n    const handleToolChangeError = (error: ErrorEvent) => {\n      console.error('Error during tool change:', error);\n\n      // If we get a \"getParent\" or similar Konva error, try to recover\n      if (error.message.includes('getParent') ||\n          error.message.includes('parent') ||\n          error.message.includes('undefined')) {\n\n        console.warn('Detected Konva parent error during tool switch, attempting recovery');\n\n        // Force back to previous tool as a recovery mechanism\n        setTimeout(() => {\n          console.log(`Recovering by reverting to previous tool: ${previousTool}`);\n          setTool(previousTool);\n        }, 100);\n      }\n    };\n\n    // Listen for errors that might indicate tool switching problems\n    window.addEventListener('error', handleToolChangeError);\n\n    return () => {\n      window.removeEventListener('error', handleToolChangeError);\n    };\n  }, [previousTool]);\n  \n  // Drawing state\n  const [strokes, setStrokes] = useState<Stroke[]>([]);\n  const [currentStroke, setCurrentStroke] = useState<Stroke | null>(null);\n  const [undoStack, setUndoStack] = useState<Stroke[]>([]);\n  const [isDrawing, setIsDrawing] = useState(false);\n  \n  // Conversation state\n  const [conversationState, setConversationState] = useState<{\n    items: Conversation[];\n    positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>;\n    activeInfoDialog: string | null;\n    activeConversation: string | null;\n  }>({\n    items: [],\n    positions: {},\n    activeInfoDialog: null,\n    activeConversation: null\n  });\n  \n  // Parliament functionality has been removed\n\n  // UI state\n  const [isSidePanelOpen, setIsSidePanelOpen] = useState(false);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isSidePanelFullScreen, setIsSidePanelFullScreen] = useState(false);\n  const [isSystemPromptModalOpen, setIsSystemPromptModalOpen] = useState(false);\n  const [systemPrompt, setSystemPrompt] = useState<string | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  \n  // Resize handler\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleResize = () => {\n      if (containerRef.current) {\n        setStageWidth(containerRef.current.offsetWidth);\n        setStageHeight(containerRef.current.offsetHeight - 100);\n      }\n    };\n    \n    handleResize();\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // Load notebook data\n  useEffect(() => {\n    if (notebookLoading || !notebook) return;\n    \n    // Load system prompt from notebook\n    if (notebook.system_prompt) {\n      setSystemPrompt(notebook.system_prompt);\n    }\n    \n    // Fetch strokes\n    const fetchStrokes = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('strokes')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          setStrokes(data);\n        }\n      } catch (err) {\n        console.error('Error fetching strokes:', err);\n      }\n    };\n    \n    // Fetch conversations\n    const fetchConversations = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('conversations')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          const positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }> = {};\n          \n          // Initialize positions\n          data.forEach(conv => {\n            if (conv.id) {\n              const pos = extractPositionFromJson(conv.position);\n              positions[conv.id] = {\n                x: pos.x,\n                y: pos.y,\n                isCollapsed: false,\n                isDragging: false\n              };\n            }\n          });\n          \n          setConversationState({\n            items: data,\n            positions,\n            activeInfoDialog: null,\n            activeConversation: null\n          });\n        }\n      } catch (err) {\n        console.error('Error fetching conversations:', err);\n      }\n    };\n    \n    fetchStrokes();\n    fetchConversations();\n    \n    // Set up real-time subscription\n    if (user) {\n      const strokesSubscription = supabase\n        .channel(`strokes:${notebookId}`)\n        .on('postgres_changes', {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'strokes',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, (payload) => {\n          const newStroke = payload.new as Stroke;\n          \n          // Only add strokes from other users\n          if (user && newStroke.user_id !== user.id) {\n            setStrokes(prev => [...prev, newStroke]);\n          }\n        })\n        .subscribe();\n        \n      const conversationsSubscription = supabase\n        .channel(`conversations:${notebookId}`)\n        .on('postgres_changes', {\n          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)\n          schema: 'public',\n          table: 'conversations',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, async (payload) => {\n          if (payload.eventType === 'INSERT') {\n            const newConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: [...prev.items, newConversation],\n              positions: {\n                ...prev.positions,\n                [newConversation.id]: {\n                  ...extractPositionFromJson(newConversation.position),\n                  isCollapsed: false,\n                  isDragging: false\n                }\n              }\n            }));\n          } else if (payload.eventType === 'UPDATE') {\n            const updatedConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.map(item => \n                item.id === updatedConversation.id ? updatedConversation : item\n              ),\n              positions: {\n                ...prev.positions,\n                [updatedConversation.id]: {\n                  ...prev.positions[updatedConversation.id],\n                  ...extractPositionFromJson(\n                    updatedConversation.position,\n                    prev.positions[updatedConversation.id]?.x || 100,\n                    prev.positions[updatedConversation.id]?.y || 100\n                  )\n                }\n              }\n            }));\n          } else if (payload.eventType === 'DELETE') {\n            const deletedConversation = payload.old as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.filter(item => item.id !== deletedConversation.id),\n              positions: Object.entries(prev.positions).reduce((acc, [key, value]) => {\n                if (key !== deletedConversation.id) {\n                  acc[key] = value;\n                }\n                return acc;\n              }, {} as Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>)\n            }));\n          }\n        })\n        .subscribe();\n        \n      return () => {\n        supabase.removeChannel(strokesSubscription);\n        supabase.removeChannel(conversationsSubscription);\n      };\n    }\n  }, [notebookId, notebookLoading, notebook, user]);\n  \n  // Jump to card if specified in URL\n  useEffect(() => {\n    if (!router.isReady) return;\n    \n    const { card, x, y, zoom } = router.query;\n    \n    if (card && typeof card === 'string') {\n      // Find the card in conversation state\n      const conversation = conversationState.items.find(c => c.id === card);\n      \n      if (conversation && conversationState.positions[card]) {\n        // Center view on the card\n        const pos = conversationState.positions[card];\n        setPosition({\n          x: -pos.x + stageWidth / 2 - 140, // Center card horizontally\n          y: -pos.y + stageHeight / 2 - 100 // Center card vertically\n        });\n        \n        // Set as active\n        setConversationState(prev => ({\n          ...prev,\n          activeConversation: card\n        }));\n      }\n    } else if (x && y && typeof x === 'string' && typeof y === 'string') {\n      // Jump to specific position\n      setPosition({\n        x: -parseInt(x) + stageWidth / 2,\n        y: -parseInt(y) + stageHeight / 2\n      });\n      \n      // Set zoom if specified\n      if (zoom && typeof zoom === 'string') {\n        const zoomValue = parseFloat(zoom);\n        if (!isNaN(zoomValue) && zoomValue > 0) {\n          setScale(zoomValue);\n        }\n      }\n    }\n  }, [router.isReady, router.query, conversationState.items, conversationState.positions, stageWidth, stageHeight]);\n  \n  // Active conversation reference is used in other parts of the component\n\n  // Debug mode state\n  const [debugMode, setDebugMode] = useState(false);\n\n  // State to track input type\n  const [inputType, setInputType] = useState('mouse'); // 'mouse', 'touch', or 'pen'\n\n  // Detect input type on first interaction\n  useEffect(() => {\n    const handleInputTypeDetection = (e: PointerEvent) => {\n      if (e.pointerType === 'pen' || e.pointerType === 'stylus') {\n        setInputType('pen');\n        console.log('Pen input detected');\n      } else if (e.pointerType === 'touch' || e.type.includes('touch')) {\n        setInputType('touch');\n        console.log('Touch input detected');\n      } else {\n        setInputType('mouse');\n        console.log('Mouse input detected');\n      }\n    };\n\n    // Add pointerdown listener to detect input type\n    document.addEventListener('pointerdown', handleInputTypeDetection);\n\n    // Also check touch capability\n    if (window.matchMedia(\"(pointer: coarse)\").matches) {\n      console.log('Touch-capable device detected');\n      setInputType('touch');\n    }\n\n    return () => {\n      document.removeEventListener('pointerdown', handleInputTypeDetection);\n    };\n  }, []);\n\n  // Optimize selection behavior based on input type\n  useEffect(() => {\n    console.log(`Input type detected: ${inputType}`);\n\n    // Adjust selection threshold based on input type\n    if (inputType === 'touch') {\n      // Touch needs larger selection threshold\n      setSelectionThreshold(30); // px\n    } else if (inputType === 'pen') {\n      // Pen can be more precise\n      setSelectionThreshold(15); // px\n    } else {\n      // Mouse is most precise\n      setSelectionThreshold(10); // px\n    }\n\n    // Adjust cursor style based on input type\n    if (stageRef.current) {\n      const stage = stageRef.current.getStage();\n      if (stage && stage.container) {\n        if (inputType === 'touch') {\n          // On touch, cursors aren't visible anyway\n          stage.container().style.cursor = 'default';\n        } else if (tool === 'select') {\n          stage.container().style.cursor = 'crosshair';\n        } else if (tool === 'pan') {\n          stage.container().style.cursor = 'grab';\n        } else if (tool === 'pen') {\n          stage.container().style.cursor = 'pointer';\n        } else if (tool === 'eraser') {\n          stage.container().style.cursor = 'cell';\n        } else {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [inputType, tool]);\n\n  // Add keyboard shortcut to toggle debug mode (Ctrl+Shift+D)\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'd' && e.ctrlKey && e.shiftKey) {\n        setDebugMode(prev => !prev);\n        console.log(`Debug mode ${!debugMode ? 'enabled' : 'disabled'}`);\n      }\n\n      // Allow forcing a specific input type for testing (Shift+Alt+...)\n      if (e.shiftKey && e.altKey) {\n        if (e.key === 'm') {\n          setInputType('mouse');\n          console.log('Forced input type: mouse');\n        } else if (e.key === 't') {\n          setInputType('touch');\n          console.log('Forced input type: touch');\n        } else if (e.key === 'p') {\n          setInputType('pen');\n          console.log('Forced input type: pen');\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [debugMode]);\n\n  // Debug panel component\n  const DebugPanel = () => {\n    if (!debugMode) return null;\n\n    return (\n      <div style={{\n        position: 'absolute',\n        bottom: 10,\n        left: 10,\n        background: 'rgba(0,0,0,0.7)',\n        color: 'white',\n        padding: 10,\n        borderRadius: 5,\n        fontSize: 12,\n        zIndex: 1000,\n        fontFamily: 'monospace',\n        maxWidth: '300px'\n      }}>\n        <div style={{ borderBottom: '1px solid rgba(255,255,255,0.3)', paddingBottom: '5px', marginBottom: '5px', fontWeight: 'bold' }}>\n          Input Debug Panel\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Tool:</div>\n          <div>{tool}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Input:</div>\n          <div>{inputType}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Selection:</div>\n          <div>{isSelecting ? 'Active' : 'Inactive'}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Precision:</div>\n          <div>{selectionPrecision}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Threshold:</div>\n          <div>{selectionThreshold}px</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Scale:</div>\n          <div>{(scale * 100).toFixed(0)}%</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Position:</div>\n          <div>{Math.round(position.x)},{Math.round(position.y)}</div>\n        </div>\n        {selectionRect.isActive && (\n          <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px' }}>\n            <div>Selection:</div>\n            <div>\n              x:{Math.round(selectionRect.x)}, y:{Math.round(selectionRect.y)},\n              w:{Math.round(selectionRect.width)}, h:{Math.round(selectionRect.height)}\n            </div>\n          </div>\n        )}\n        <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px', fontSize: '10px' }}>\n          Shortcuts:\n          <div>â€¢ Ctrl+Shift+D: Toggle debug panel</div>\n          <div>â€¢ Shift+Alt+M: Force mouse input</div>\n          <div>â€¢ Shift+Alt+T: Force touch input</div>\n          <div>â€¢ Shift+Alt+P: Force pen input</div>\n        </div>\n        <button\n          onClick={() => setDebugMode(false)}\n          style={{\n            marginTop: 5,\n            padding: '2px 5px',\n            background: '#333',\n            border: '1px solid #555',\n            color: 'white',\n            borderRadius: '3px',\n            cursor: 'pointer',\n            fontSize: '11px'\n          }}\n        >\n          Close\n        </button>\n      </div>\n    );\n  };\n\n  // State for selection\n  const [selectionRect, setSelectionRect] = useState({ x: 0, y: 0, width: 0, height: 0, isActive: false });\n  const [isSelecting, setIsSelecting] = useState(false);\n  const [selectionThreshold, setSelectionThreshold] = useState(10); // px\n  const [selectionPrecision, setSelectionPrecision] = useState('normal'); // 'normal' or 'high'\n\n  // Get pressure from pointer events\n  const getPressure = useCallback((e: any) => {\n    // Default pressure if not available\n    let pressure = 1.0;\n\n    // Try to get pressure from various events\n    if (e.pressure !== undefined && e.pressure !== 0) {\n      // Pointer events include pressure\n      pressure = e.pressure;\n    } else if (e.touches && e.touches[0] && e.touches[0].force !== undefined) {\n      // Some touch events include force (iOS)\n      pressure = e.touches[0].force;\n    } else if (e.evt && e.evt.pressure !== undefined && e.evt.pressure !== 0) {\n      // Konva wraps events in evt property\n      pressure = e.evt.pressure;\n    } else if (e.evt && e.evt.touches && e.evt.touches[0] && e.evt.touches[0].force !== undefined) {\n      // Konva wrapped touch events\n      pressure = e.evt.touches[0].force;\n    }\n\n    return pressure;\n  }, []);\n\n  // Universal input handler for all device types\n  const handleInputStart = useCallback((e: any) => {\n    // Get stage from event\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    // Get pointer position\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Log input for debugging\n    console.log(`Input start (${e.type || e.evt?.type || 'unknown'}) at position:`, pos.x, pos.y);\n\n    // Get pressure for pen input\n    const pressure = getPressure(e);\n    console.log(`Input pressure: ${pressure}`);\n\n    // Adjust selection behavior based on pressure\n    if (pressure > 0.5) {\n      // Harder press might indicate more precise selection\n      setSelectionPrecision('high');\n    } else {\n      setSelectionPrecision('normal');\n    }\n\n    // Check if we clicked on a card or other interactive element\n    const target = e.target;\n    const isClickOnCard = target.hasName?.('card-wrapper') ||\n                        target.findAncestor?.('card-wrapper') ||\n                        target.findAncestor?.('thread-card');\n\n    // Handle based on current tool\n    if (tool === 'pan' || (e.evt?.button === 1 || e.evt?.buttons === 4)) {\n      // Middle mouse or pan tool - handle panning\n      if (stage) {\n        stage.container().style.cursor = 'grabbing';\n      }\n      return;\n    }\n\n    if (tool === 'select') {\n      // If clicking on a card while in select mode, ignore\n      if (isClickOnCard) {\n        console.log(\"Clicked on interactive element while in select mode - ignoring\");\n        return;\n      }\n\n      console.log(\"Starting selection at\", pos.x, pos.y);\n\n      // Store initial position, accounting for scroll and zoom\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect({\n        x: adjustedX,\n        y: adjustedY,\n        width: 0,\n        height: 0,\n        isActive: true\n      });\n\n      // Set a flag to indicate we're selecting\n      setIsSelecting(true);\n      return;\n    }\n\n    if (tool === 'text') {\n      // Text insertion logic - we'll implement this later\n      return;\n    }\n\n    if (tool === 'pen' || tool === 'eraser') {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Create new stroke\n      const newStroke: Stroke = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        points: [{ x, y, pressure }],\n        tool: tool,\n        color: tool === 'pen' ? penColor : '#ffffff',\n        width: tool === 'pen' ? penSize : eraserSize,\n        order_index: strokes.length,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        user_id: user?.id\n      };\n\n      setCurrentStroke(newStroke);\n      setIsDrawing(true);\n      setUndoStack([]);\n    }\n  }, [tool, position, scale, notebookId, strokes.length, penColor, penSize, eraserSize, user?.id, getPressure]);\n\n  // Unified move handler for all input types\n  const handleInputMove = useCallback((e: any) => {\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Handle panning\n    if (tool === 'pan' || e.evt?.buttons === 4 || (e.evt?.buttons === 1 && e.evt?.button === 1)) {\n      // Panning logic\n      const dx = e.evt?.movementX || 0;\n      const dy = e.evt?.movementY || 0;\n\n      setPosition(prev => ({\n        x: prev.x + dx,\n        y: prev.y + dy\n      }));\n\n      return;\n    }\n\n    // Handle selection\n    if (tool === 'select' && isSelecting) {\n      // Calculate adjusted position for zoom and pan\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect((prev) => ({\n        ...prev,\n        width: adjustedX - prev.x,\n        height: adjustedY - prev.y\n      }));\n\n      return;\n    }\n\n    // Handle drawing\n    if (isDrawing && currentStroke) {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Get pressure data\n      const pressure = getPressure(e);\n\n      // Add point to current stroke\n      setCurrentStroke(prev => {\n        if (!prev) return null;\n\n        const newPoints = [...prev.points, { x, y, pressure }];\n        return { ...prev, points: newPoints };\n      });\n    }\n  }, [isDrawing, currentStroke, tool, position, scale, isSelecting, getPressure]);\n\n  // Unified end handler for all input types\n  const handleInputEnd = useCallback(async (e: any) => {\n    // Handle selection completion\n    if (tool === 'select' && isSelecting) {\n      console.log(\"Ending selection\");\n      setIsSelecting(false);\n\n      // Check if selection has meaningful size\n      if (Math.abs(selectionRect.width) > selectionThreshold &&\n          Math.abs(selectionRect.height) > selectionThreshold) {\n        const normalizedRect = {\n          x: selectionRect.width > 0 ? selectionRect.x : selectionRect.x + selectionRect.width,\n          y: selectionRect.height > 0 ? selectionRect.y : selectionRect.y + selectionRect.height,\n          width: Math.abs(selectionRect.width),\n          height: Math.abs(selectionRect.height),\n          isActive: false\n        };\n\n        console.log(\"Selection completed:\", normalizedRect);\n        // TODO: Process the selection (e.g., analyze text in this area)\n      } else {\n        // Reset selection if too small\n        setSelectionRect({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0,\n          isActive: false\n        });\n      }\n\n      return;\n    }\n\n    // Handle drawing completion\n    if (isDrawing && currentStroke) {\n      if (currentStroke.points.length < 2) {\n        // If it's just a dot, add another point slightly offset\n        const point = currentStroke.points[0];\n        setCurrentStroke(prev => {\n          if (!prev) return null;\n          return {\n            ...prev,\n            points: [...prev.points, { x: point.x + 0.1, y: point.y + 0.1, pressure: point.pressure }]\n          };\n        });\n      }\n\n      // Save the completed stroke\n      setStrokes(prev => [...prev, currentStroke]);\n\n      // Save to database if authenticated\n      if (user) {\n        try {\n          await supabase.from('strokes').insert(currentStroke);\n\n          // Store stroke ID for undo functionality\n          if (typeof window !== 'undefined') {\n            if (!window.ownStrokeIds) {\n              window.ownStrokeIds = new Set();\n            }\n            window.ownStrokeIds.add(currentStroke.id);\n          }\n        } catch (err) {\n          console.error('Error saving stroke:', err);\n        }\n      }\n\n      setCurrentStroke(null);\n      setIsDrawing(false);\n    }\n  }, [isDrawing, currentStroke, user, tool, isSelecting, selectionRect, selectionThreshold]);\n  \n  // Undo/Redo handlers\n  const handleUndo = useCallback(async () => {\n    if (strokes.length === 0) return;\n\n    const lastStroke = strokes[strokes.length - 1];\n    const newStrokes = strokes.slice(0, -1);\n\n    setStrokes(newStrokes);\n    setUndoStack(prev => [...prev, lastStroke]);\n\n    // Update database if authenticated\n    if (user && lastStroke.id && window.ownStrokeIds?.has(lastStroke.id)) {\n      try {\n        await supabase.from('strokes').delete().eq('id', lastStroke.id);\n      } catch (err) {\n        console.error('Error deleting stroke:', err);\n      }\n    }\n  }, [strokes, user]);\n\n  const handleRedo = useCallback(async () => {\n    if (undoStack.length === 0) return;\n\n    const strokeToRedo = undoStack[undoStack.length - 1];\n    const newUndoStack = undoStack.slice(0, -1);\n\n    setStrokes(prev => [...prev, strokeToRedo]);\n    setUndoStack(newUndoStack);\n\n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').insert(strokeToRedo);\n\n        // Store stroke ID for undo functionality\n        if (typeof window !== 'undefined') {\n          if (!window.ownStrokeIds) {\n            window.ownStrokeIds = new Set();\n          }\n          window.ownStrokeIds.add(strokeToRedo.id);\n        }\n      } catch (err) {\n        console.error('Error redoing stroke:', err);\n      }\n    }\n  }, [undoStack, user]);\n\n  // Tool handlers\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    // Prevent handling if in an input or textarea\n    if (\n      document.activeElement?.tagName === 'INPUT' ||\n      document.activeElement?.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (e.code === 'Space') {\n      // Temporarily switch to pan tool with spacebar\n      setTool('pan');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'grab';\n        }\n      }\n    } else if (e.code === 'KeyP') {\n      setTool('pen');\n    } else if (e.code === 'KeyE') {\n      setTool('eraser');\n    } else if (e.code === 'KeyS') {\n      setTool('select');\n    } else if (e.code === 'KeyT') {\n      setTool('text');\n    } else if (e.ctrlKey && e.code === 'KeyZ') {\n      // Undo\n      handleUndo();\n    } else if (e.ctrlKey && e.shiftKey && e.code === 'KeyZ') {\n      // Redo\n      handleRedo();\n    }\n  }, [handleUndo, handleRedo]);\n\n  const handleKeyUp = useCallback((e: KeyboardEvent) => {\n    if (e.code === 'Space' && tool === 'pan') {\n      // Switch back to previous tool when spacebar is released\n      setTool('pen');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [tool]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n  \n  // Clear canvas\n  const handleClearCanvas = useCallback(async () => {\n    // Store current strokes for potential undo (unused for now)\n    /*\n    const currentStrokes = [...strokes];\n    */\n\n    // Clear canvas\n    setStrokes([]);\n    setUndoStack([]);\n    \n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').delete().eq('notebook_id', notebookId);\n      } catch (err) {\n        console.error('Error clearing canvas:', err);\n      }\n    }\n  }, [strokes, user, notebookId]);\n  \n  // Thread card handlers\n  const handleDragStart = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: true\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n\n  // Card click handler for the new unified card system\n  const handleCardClick = useCallback((cardId: string) => {\n    // This will be integrated with the unified view store\n    if (window.unifiedViewStore) {\n      window.unifiedViewStore.setActiveCard(cardId);\n    }\n  }, []);\n  \n  const handleDragMove = useCallback((id: string, x: number, y: number) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          x,\n          y\n        }\n      }\n    }));\n  }, []);\n  \n  const handleDragEnd = useCallback(async (id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: false\n        }\n      }\n    }));\n    \n    // Save position to database if authenticated\n    if (user) {\n      const conversation = conversationState.items.find(c => c.id === id);\n      const pos = conversationState.positions[id];\n      \n      if (conversation && pos) {\n        try {\n          await supabase\n            .from('conversations')\n            .update({\n              position: { x: pos.x, y: pos.y },\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', id);\n        } catch (err) {\n          console.error('Error updating position:', err);\n        }\n      }\n    }\n  }, [user, conversationState.items, conversationState.positions]);\n  \n  const handleToggleCollapse = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isCollapsed: !prev.positions[id].isCollapsed\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n  \n  const handleToggleInfoDialog = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      activeInfoDialog: prev.activeInfoDialog === id ? null : id\n    }));\n  }, []);\n  \n  const handleEditContent = useCallback(async (id: string, text: string) => {\n    if (!user) return;\n    \n    try {\n      await supabase\n        .from('conversations')\n        .update({\n          user_content: text,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n        \n      setConversationState(prev => ({\n        ...prev,\n        items: prev.items.map(item => \n          item.id === id ? { ...item, user_content: text, updated_at: new Date().toISOString() } : item\n        )\n      }));\n    } catch (err) {\n      console.error('Error updating content:', err);\n    }\n  }, [user]);\n  \n  const handleContinueThread = useCallback((id: string) => {\n    // Conversation continuation logic\n    console.log('Continue thread:', id);\n  }, []);\n  \n  const handleCreateFollowUp = useCallback((id: string) => {\n    // Follow-up creation logic\n    console.log('Create follow-up:', id);\n  }, []);\n  \n  const handleCreateReference = useCallback((id: string, targetId?: string) => {\n    // Reference creation logic\n    console.log('Create reference from', id, 'to', targetId);\n  }, []);\n  \n  // System prompt handlers\n  const handleUpdateSystemPrompt = useCallback(async (prompt: string) => {\n    if (!user || !notebook) return;\n    \n    setSystemPrompt(prompt);\n    setIsSystemPromptModalOpen(false);\n    \n    try {\n      await supabase\n        .from('notebooks')\n        .update({\n          system_prompt: prompt,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', notebookId);\n    } catch (err) {\n      console.error('Error updating system prompt:', err);\n    }\n  }, [user, notebook, notebookId]);\n  \n  // Determine undo/redo availability\n  const undoAvailable = strokes.length > 0;\n  const redoAvailable = undoStack.length > 0;\n  \n  // Loading state\n  if (notebookLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500\"></div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"flex flex-col h-screen w-full\">\n      {/* Toolbar */}\n      <ResponsiveToolbar\n        tool={tool}\n        setTool={safeSetTool}\n        scale={scale}\n        setScale={setScale}\n        setPosition={setPosition}\n        notebookId={notebookId}\n        notebookTitle={notebook?.title || 'Untitled Notebook'}\n        isCollaborative={notebook?.is_collaborative}\n        onClearCanvas={handleClearCanvas}\n        isPenMode={isPenMode}\n        setIsPenMode={setIsPenMode}\n        penSize={penSize}\n        setPenSize={setPenSize}\n        eraserSize={eraserSize}\n        setEraserSize={setEraserSize}\n        undoAvailable={undoAvailable}\n        redoAvailable={redoAvailable}\n        onUndo={handleUndo}\n        onRedo={handleRedo}\n        penColor={penColor}\n        setPenColor={setPenColor}\n        isSidePanelOpen={isSidePanelOpen}\n        toggleSidePanel={() => setIsSidePanelOpen(prev => !prev)}\n        onOpenSystemPromptModal={() => setIsSystemPromptModalOpen(true)}\n      />\n      \n      {/* Canvas Container */}\n      <div\n        ref={containerRef}\n        className=\"flex-1 relative bg-gray-50 overflow-hidden\"\n        style={{ height: 'calc(100vh - 100px)' }}\n      >\n        {/* Debug Panel */}\n        <DebugPanel />\n\n        <Stage\n          width={stageWidth}\n          height={stageHeight}\n          ref={stageRef}\n          draggable={tool === 'pan'}\n          onMouseDown={handleInputStart}\n          onMouseMove={handleInputMove}\n          onMouseUp={handleInputEnd}\n          onMouseLeave={handleInputEnd}\n          onTouchStart={handleInputStart}\n          onTouchMove={handleInputMove}\n          onTouchEnd={handleInputEnd}\n          onPointerDown={handleInputStart}\n          onPointerMove={handleInputMove}\n          onPointerUp={handleInputEnd}\n          position={position}\n          scale={{ x: scale, y: scale }}\n          onContextMenu={e => e.evt.preventDefault()}\n        >\n          {/* Background Layer */}\n          <Layer name=\"background-layer\">\n            <BackgroundLayer\n              width={stageWidth}\n              height={stageHeight}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Drawing Layer */}\n          <Layer name=\"drawing-layer\">\n            <DrawingLayer\n              strokes={strokes}\n              currentStroke={currentStroke}\n              scale={scale}\n              position={position}\n            />\n          </Layer>\n\n          {/* Text Layer */}\n          <Layer name=\"text-layer\">\n            <TextLayer\n              conversationState={conversationState}\n              notebookId={notebookId}\n              onDragStart={handleDragStart}\n              onDragMove={handleDragMove}\n              onDragEnd={handleDragEnd}\n              onToggleCollapse={handleToggleCollapse}\n              onToggleInfoDialog={handleToggleInfoDialog}\n              onEditContent={handleEditContent}\n              onContinueThread={handleContinueThread}\n              onCreateFollowUp={handleCreateFollowUp}\n              onCreateReference={handleCreateReference}\n              tool={tool}\n              isTextSelectionEnabled={tool === 'text'}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Selection Layer */}\n          {selectionRect.isActive && (\n            <Layer name=\"selection-layer\">\n              <Line\n                points={[\n                  selectionRect.x, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y\n                ]}\n                stroke=\"rgba(0, 161, 255, 0.8)\"\n                strokeWidth={2 / scale}\n                dash={[5 / scale, 5 / scale]}\n                closed={true}\n                fill=\"rgba(0, 161, 255, 0.1)\"\n              />\n            </Layer>\n          )}\n        </Stage>\n      </div>\n      \n      {/* System Prompt Modal */}\n      {isSystemPromptModalOpen && (\n        <SystemPromptModal\n          isOpen={isSystemPromptModalOpen}\n          onClose={() => setIsSystemPromptModalOpen(false)}\n          initialPrompt={systemPrompt || ''}\n          onSave={handleUpdateSystemPrompt}\n        />\n      )}\n      \n      {/* Side Panel with ConversationSidePanel */}\n      {isSidePanelOpen && (\n        <ConversationSidePanel\n          notebookId={notebookId}\n          conversations={conversationState.items}\n          onEditTranscription={async (id, text) => {\n            try {\n              await supabase\n                .from('conversations')\n                .update({\n                  ai_response: text,\n                  updated_at: new Date().toISOString()\n                })\n                .eq('id', id);\n\n              // Update local state\n              setConversationState(prev => ({\n                ...prev,\n                items: prev.items.map(item =>\n                  item.id === id ? { ...item, ai_response: text, updated_at: new Date().toISOString() } : item\n                )\n              }));\n            } catch (err) {\n              console.error('Error updating AI response:', err);\n            }\n          }}\n          onSendMessage={async (message, mode) => {\n            try {\n              if (!user) return;\n\n              // Create a new conversation\n              const newConversation: Partial<Conversation> = {\n                id: generateUUID(), // Use our custom UUID generator\n                notebook_id: notebookId,\n                user_id: user.id,\n                user_content: message,\n                position: {\n                  x: -position.x + stageWidth / 2 - 150, // Center horizontally\n                  y: -position.y + stageHeight / 2 - 100 // Center vertically\n                },\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString(),\n                card_type: mode === 'chat' ? 'question' : 'note',\n                thread_id: conversationState.activeConversation || undefined,\n                is_thread_starter: !conversationState.activeConversation\n              };\n\n              // Save to database\n              const { data, error } = await supabase\n                .from('conversations')\n                .insert(newConversation)\n                .select()\n                .single();\n\n              if (error) throw error;\n\n              // Update local state\n              const savedConversation = data as Conversation;\n\n              setConversationState(prev => ({\n                ...prev,\n                items: [...prev.items, savedConversation],\n                positions: {\n                  ...prev.positions,\n                  [savedConversation.id]: {\n                    ...extractPositionFromJson(savedConversation.position),\n                    isCollapsed: false,\n                    isDragging: false\n                  }\n                },\n                activeConversation: savedConversation.id\n              }));\n\n              // Parliament functionality has been removed\n              if (mode === 'chat') {\n                // Process chat message without parliament\n                console.log('Chat message sent:', message);\n              }\n\n              return savedConversation;\n            } catch (err) {\n              console.error('Error sending message:', err);\n              throw err;\n            }\n          }}\n          onJumpToCard={(id) => {\n            // Find the card\n            const conversation = conversationState.items.find(c => c.id === id);\n            const position = conversationState.positions[id];\n\n            if (conversation && position) {\n              // Center on the card\n              setPosition({\n                x: -position.x + stageWidth / 2 - 150,\n                y: -position.y + stageHeight / 2 - 100\n              });\n\n              // Set as active\n              setConversationState(prev => ({\n                ...prev,\n                activeConversation: id\n              }));\n            }\n          }}\n          onClose={() => setIsSidePanelOpen(false)}\n          isOpen={isSidePanelOpen}\n          isFullScreen={false}\n          onToggleFullScreen={() => {\n            // This would toggle full-screen mode if implemented\n            console.log('Toggle full-screen mode');\n          }}\n          systemPrompt={systemPrompt}\n        />\n      )}\n\n      {/* Parliament functionality has been removed */}\n    </div>\n  );\n};\n\nexport default CanvasContainer;\nðŸ“„ --- File: ./src/components/canvas/CanvasContainer.tsx (matched setInput) ---\n// src/components/canvas/CanvasContainer.tsx\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Stage, Layer } from 'react-konva';\nimport { KonvaEventObject } from 'konva/lib/Node';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Stroke, Conversation } from '@/types/supabase';\nimport { extractPositionFromJson } from '@/types/position';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport { useRouter } from 'next/router';\nimport DrawingLayer from './DrawingLayer';\nimport TextLayer from './TextLayer';\nimport BackgroundLayer from './BackgroundLayer';\nimport CardLayer from './CardLayer';\n// Using updated responsive toolbar\nimport ResponsiveToolbar from './ResponsiveToolbar';\nimport SystemPromptModal from '@/components/modals/SystemPromptModal';\nimport ConversationSidePanel from '@/components/ui/ConversationSidePanel';\nimport { generateUUID } from '@/utils/uuidUtils';\n\n// Tool types definition\nexport type Tool = 'pen' | 'eraser' | 'select' | 'text' | 'pan';\n\n// Component Props\ninterface CanvasContainerProps {\n  notebookId: string;\n}\n\nconst CanvasContainer: React.FC<CanvasContainerProps> = ({ notebookId }) => {\n  const { user } = useAuth();\n  const { notebook, loading: notebookLoading } = useNotebook(notebookId);\n  const router = useRouter();\n  \n  // Refs\n   \n  const stageRef = useRef<any>(null); // Using any for Konva Stage ref\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Canvas dimension state\n  const [stageWidth, setStageWidth] = useState(typeof window !== 'undefined' ? window.innerWidth : 1000);\n  const [stageHeight, setStageHeight] = useState(typeof window !== 'undefined' ? window.innerHeight - 100 : 900);\n  \n  // Canvas view state\n  const [scale, setScale] = useState(1);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  // Tool state\n  const [tool, setTool] = useState<Tool>('pen');\n  const [previousTool, setPreviousTool] = useState<Tool>('pen');\n  const [isPenMode, setIsPenMode] = useState(true);\n  const [penSize, setPenSize] = useState(2);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [penColor, setPenColor] = useState('#000000');\n\n  // Tool transition handling\n  const safeSetTool = useCallback((newTool: Tool) => {\n    console.log(`CanvasContainer: Setting tool from ${tool} to ${newTool}`);\n    setPreviousTool(tool);\n    setTool(newTool);\n  }, [tool]);\n\n  // Error boundary for tool switching\n  useEffect(() => {\n    const handleToolChangeError = (error: ErrorEvent) => {\n      console.error('Error during tool change:', error);\n\n      // If we get a \"getParent\" or similar Konva error, try to recover\n      if (error.message.includes('getParent') ||\n          error.message.includes('parent') ||\n          error.message.includes('undefined')) {\n\n        console.warn('Detected Konva parent error during tool switch, attempting recovery');\n\n        // Force back to previous tool as a recovery mechanism\n        setTimeout(() => {\n          console.log(`Recovering by reverting to previous tool: ${previousTool}`);\n          setTool(previousTool);\n        }, 100);\n      }\n    };\n\n    // Listen for errors that might indicate tool switching problems\n    window.addEventListener('error', handleToolChangeError);\n\n    return () => {\n      window.removeEventListener('error', handleToolChangeError);\n    };\n  }, [previousTool]);\n  \n  // Drawing state\n  const [strokes, setStrokes] = useState<Stroke[]>([]);\n  const [currentStroke, setCurrentStroke] = useState<Stroke | null>(null);\n  const [undoStack, setUndoStack] = useState<Stroke[]>([]);\n  const [isDrawing, setIsDrawing] = useState(false);\n  \n  // Conversation state\n  const [conversationState, setConversationState] = useState<{\n    items: Conversation[];\n    positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>;\n    activeInfoDialog: string | null;\n    activeConversation: string | null;\n  }>({\n    items: [],\n    positions: {},\n    activeInfoDialog: null,\n    activeConversation: null\n  });\n  \n  // Parliament functionality has been removed\n\n  // UI state\n  const [isSidePanelOpen, setIsSidePanelOpen] = useState(false);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isSidePanelFullScreen, setIsSidePanelFullScreen] = useState(false);\n  const [isSystemPromptModalOpen, setIsSystemPromptModalOpen] = useState(false);\n  const [systemPrompt, setSystemPrompt] = useState<string | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  \n  // Resize handler\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleResize = () => {\n      if (containerRef.current) {\n        setStageWidth(containerRef.current.offsetWidth);\n        setStageHeight(containerRef.current.offsetHeight - 100);\n      }\n    };\n    \n    handleResize();\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // Load notebook data\n  useEffect(() => {\n    if (notebookLoading || !notebook) return;\n    \n    // Load system prompt from notebook\n    if (notebook.system_prompt) {\n      setSystemPrompt(notebook.system_prompt);\n    }\n    \n    // Fetch strokes\n    const fetchStrokes = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('strokes')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          setStrokes(data);\n        }\n      } catch (err) {\n        console.error('Error fetching strokes:', err);\n      }\n    };\n    \n    // Fetch conversations\n    const fetchConversations = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('conversations')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          const positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }> = {};\n          \n          // Initialize positions\n          data.forEach(conv => {\n            if (conv.id) {\n              const pos = extractPositionFromJson(conv.position);\n              positions[conv.id] = {\n                x: pos.x,\n                y: pos.y,\n                isCollapsed: false,\n                isDragging: false\n              };\n            }\n          });\n          \n          setConversationState({\n            items: data,\n            positions,\n            activeInfoDialog: null,\n            activeConversation: null\n          });\n        }\n      } catch (err) {\n        console.error('Error fetching conversations:', err);\n      }\n    };\n    \n    fetchStrokes();\n    fetchConversations();\n    \n    // Set up real-time subscription\n    if (user) {\n      const strokesSubscription = supabase\n        .channel(`strokes:${notebookId}`)\n        .on('postgres_changes', {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'strokes',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, (payload) => {\n          const newStroke = payload.new as Stroke;\n          \n          // Only add strokes from other users\n          if (user && newStroke.user_id !== user.id) {\n            setStrokes(prev => [...prev, newStroke]);\n          }\n        })\n        .subscribe();\n        \n      const conversationsSubscription = supabase\n        .channel(`conversations:${notebookId}`)\n        .on('postgres_changes', {\n          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)\n          schema: 'public',\n          table: 'conversations',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, async (payload) => {\n          if (payload.eventType === 'INSERT') {\n            const newConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: [...prev.items, newConversation],\n              positions: {\n                ...prev.positions,\n                [newConversation.id]: {\n                  ...extractPositionFromJson(newConversation.position),\n                  isCollapsed: false,\n                  isDragging: false\n                }\n              }\n            }));\n          } else if (payload.eventType === 'UPDATE') {\n            const updatedConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.map(item => \n                item.id === updatedConversation.id ? updatedConversation : item\n              ),\n              positions: {\n                ...prev.positions,\n                [updatedConversation.id]: {\n                  ...prev.positions[updatedConversation.id],\n                  ...extractPositionFromJson(\n                    updatedConversation.position,\n                    prev.positions[updatedConversation.id]?.x || 100,\n                    prev.positions[updatedConversation.id]?.y || 100\n                  )\n                }\n              }\n            }));\n          } else if (payload.eventType === 'DELETE') {\n            const deletedConversation = payload.old as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.filter(item => item.id !== deletedConversation.id),\n              positions: Object.entries(prev.positions).reduce((acc, [key, value]) => {\n                if (key !== deletedConversation.id) {\n                  acc[key] = value;\n                }\n                return acc;\n              }, {} as Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>)\n            }));\n          }\n        })\n        .subscribe();\n        \n      return () => {\n        supabase.removeChannel(strokesSubscription);\n        supabase.removeChannel(conversationsSubscription);\n      };\n    }\n  }, [notebookId, notebookLoading, notebook, user]);\n  \n  // Jump to card if specified in URL\n  useEffect(() => {\n    if (!router.isReady) return;\n    \n    const { card, x, y, zoom } = router.query;\n    \n    if (card && typeof card === 'string') {\n      // Find the card in conversation state\n      const conversation = conversationState.items.find(c => c.id === card);\n      \n      if (conversation && conversationState.positions[card]) {\n        // Center view on the card\n        const pos = conversationState.positions[card];\n        setPosition({\n          x: -pos.x + stageWidth / 2 - 140, // Center card horizontally\n          y: -pos.y + stageHeight / 2 - 100 // Center card vertically\n        });\n        \n        // Set as active\n        setConversationState(prev => ({\n          ...prev,\n          activeConversation: card\n        }));\n      }\n    } else if (x && y && typeof x === 'string' && typeof y === 'string') {\n      // Jump to specific position\n      setPosition({\n        x: -parseInt(x) + stageWidth / 2,\n        y: -parseInt(y) + stageHeight / 2\n      });\n      \n      // Set zoom if specified\n      if (zoom && typeof zoom === 'string') {\n        const zoomValue = parseFloat(zoom);\n        if (!isNaN(zoomValue) && zoomValue > 0) {\n          setScale(zoomValue);\n        }\n      }\n    }\n  }, [router.isReady, router.query, conversationState.items, conversationState.positions, stageWidth, stageHeight]);\n  \n  // Active conversation reference is used in other parts of the component\n\n  // Debug mode state\n  const [debugMode, setDebugMode] = useState(false);\n\n  // State to track input type\n  const [inputType, setInputType] = useState('mouse'); // 'mouse', 'touch', or 'pen'\n\n  // Detect input type on first interaction\n  useEffect(() => {\n    const handleInputTypeDetection = (e: PointerEvent) => {\n      if (e.pointerType === 'pen' || e.pointerType === 'stylus') {\n        setInputType('pen');\n        console.log('Pen input detected');\n      } else if (e.pointerType === 'touch' || e.type.includes('touch')) {\n        setInputType('touch');\n        console.log('Touch input detected');\n      } else {\n        setInputType('mouse');\n        console.log('Mouse input detected');\n      }\n    };\n\n    // Add pointerdown listener to detect input type\n    document.addEventListener('pointerdown', handleInputTypeDetection);\n\n    // Also check touch capability\n    if (window.matchMedia(\"(pointer: coarse)\").matches) {\n      console.log('Touch-capable device detected');\n      setInputType('touch');\n    }\n\n    return () => {\n      document.removeEventListener('pointerdown', handleInputTypeDetection);\n    };\n  }, []);\n\n  // Optimize selection behavior based on input type\n  useEffect(() => {\n    console.log(`Input type detected: ${inputType}`);\n\n    // Adjust selection threshold based on input type\n    if (inputType === 'touch') {\n      // Touch needs larger selection threshold\n      setSelectionThreshold(30); // px\n    } else if (inputType === 'pen') {\n      // Pen can be more precise\n      setSelectionThreshold(15); // px\n    } else {\n      // Mouse is most precise\n      setSelectionThreshold(10); // px\n    }\n\n    // Adjust cursor style based on input type\n    if (stageRef.current) {\n      const stage = stageRef.current.getStage();\n      if (stage && stage.container) {\n        if (inputType === 'touch') {\n          // On touch, cursors aren't visible anyway\n          stage.container().style.cursor = 'default';\n        } else if (tool === 'select') {\n          stage.container().style.cursor = 'crosshair';\n        } else if (tool === 'pan') {\n          stage.container().style.cursor = 'grab';\n        } else if (tool === 'pen') {\n          stage.container().style.cursor = 'pointer';\n        } else if (tool === 'eraser') {\n          stage.container().style.cursor = 'cell';\n        } else {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [inputType, tool]);\n\n  // Add keyboard shortcut to toggle debug mode (Ctrl+Shift+D)\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'd' && e.ctrlKey && e.shiftKey) {\n        setDebugMode(prev => !prev);\n        console.log(`Debug mode ${!debugMode ? 'enabled' : 'disabled'}`);\n      }\n\n      // Allow forcing a specific input type for testing (Shift+Alt+...)\n      if (e.shiftKey && e.altKey) {\n        if (e.key === 'm') {\n          setInputType('mouse');\n          console.log('Forced input type: mouse');\n        } else if (e.key === 't') {\n          setInputType('touch');\n          console.log('Forced input type: touch');\n        } else if (e.key === 'p') {\n          setInputType('pen');\n          console.log('Forced input type: pen');\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [debugMode]);\n\n  // Debug panel component\n  const DebugPanel = () => {\n    if (!debugMode) return null;\n\n    return (\n      <div style={{\n        position: 'absolute',\n        bottom: 10,\n        left: 10,\n        background: 'rgba(0,0,0,0.7)',\n        color: 'white',\n        padding: 10,\n        borderRadius: 5,\n        fontSize: 12,\n        zIndex: 1000,\n        fontFamily: 'monospace',\n        maxWidth: '300px'\n      }}>\n        <div style={{ borderBottom: '1px solid rgba(255,255,255,0.3)', paddingBottom: '5px', marginBottom: '5px', fontWeight: 'bold' }}>\n          Input Debug Panel\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Tool:</div>\n          <div>{tool}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Input:</div>\n          <div>{inputType}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Selection:</div>\n          <div>{isSelecting ? 'Active' : 'Inactive'}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Precision:</div>\n          <div>{selectionPrecision}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Threshold:</div>\n          <div>{selectionThreshold}px</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Scale:</div>\n          <div>{(scale * 100).toFixed(0)}%</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Position:</div>\n          <div>{Math.round(position.x)},{Math.round(position.y)}</div>\n        </div>\n        {selectionRect.isActive && (\n          <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px' }}>\n            <div>Selection:</div>\n            <div>\n              x:{Math.round(selectionRect.x)}, y:{Math.round(selectionRect.y)},\n              w:{Math.round(selectionRect.width)}, h:{Math.round(selectionRect.height)}\n            </div>\n          </div>\n        )}\n        <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px', fontSize: '10px' }}>\n          Shortcuts:\n          <div>â€¢ Ctrl+Shift+D: Toggle debug panel</div>\n          <div>â€¢ Shift+Alt+M: Force mouse input</div>\n          <div>â€¢ Shift+Alt+T: Force touch input</div>\n          <div>â€¢ Shift+Alt+P: Force pen input</div>\n        </div>\n        <button\n          onClick={() => setDebugMode(false)}\n          style={{\n            marginTop: 5,\n            padding: '2px 5px',\n            background: '#333',\n            border: '1px solid #555',\n            color: 'white',\n            borderRadius: '3px',\n            cursor: 'pointer',\n            fontSize: '11px'\n          }}\n        >\n          Close\n        </button>\n      </div>\n    );\n  };\n\n  // State for selection\n  const [selectionRect, setSelectionRect] = useState({ x: 0, y: 0, width: 0, height: 0, isActive: false });\n  const [isSelecting, setIsSelecting] = useState(false);\n  const [selectionThreshold, setSelectionThreshold] = useState(10); // px\n  const [selectionPrecision, setSelectionPrecision] = useState('normal'); // 'normal' or 'high'\n\n  // Get pressure from pointer events\n  const getPressure = useCallback((e: any) => {\n    // Default pressure if not available\n    let pressure = 1.0;\n\n    // Try to get pressure from various events\n    if (e.pressure !== undefined && e.pressure !== 0) {\n      // Pointer events include pressure\n      pressure = e.pressure;\n    } else if (e.touches && e.touches[0] && e.touches[0].force !== undefined) {\n      // Some touch events include force (iOS)\n      pressure = e.touches[0].force;\n    } else if (e.evt && e.evt.pressure !== undefined && e.evt.pressure !== 0) {\n      // Konva wraps events in evt property\n      pressure = e.evt.pressure;\n    } else if (e.evt && e.evt.touches && e.evt.touches[0] && e.evt.touches[0].force !== undefined) {\n      // Konva wrapped touch events\n      pressure = e.evt.touches[0].force;\n    }\n\n    return pressure;\n  }, []);\n\n  // Universal input handler for all device types\n  const handleInputStart = useCallback((e: any) => {\n    // Get stage from event\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    // Get pointer position\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Log input for debugging\n    console.log(`Input start (${e.type || e.evt?.type || 'unknown'}) at position:`, pos.x, pos.y);\n\n    // Get pressure for pen input\n    const pressure = getPressure(e);\n    console.log(`Input pressure: ${pressure}`);\n\n    // Adjust selection behavior based on pressure\n    if (pressure > 0.5) {\n      // Harder press might indicate more precise selection\n      setSelectionPrecision('high');\n    } else {\n      setSelectionPrecision('normal');\n    }\n\n    // Check if we clicked on a card or other interactive element\n    const target = e.target;\n    const isClickOnCard = target.hasName?.('card-wrapper') ||\n                        target.findAncestor?.('card-wrapper') ||\n                        target.findAncestor?.('thread-card');\n\n    // Handle based on current tool\n    if (tool === 'pan' || (e.evt?.button === 1 || e.evt?.buttons === 4)) {\n      // Middle mouse or pan tool - handle panning\n      if (stage) {\n        stage.container().style.cursor = 'grabbing';\n      }\n      return;\n    }\n\n    if (tool === 'select') {\n      // If clicking on a card while in select mode, ignore\n      if (isClickOnCard) {\n        console.log(\"Clicked on interactive element while in select mode - ignoring\");\n        return;\n      }\n\n      console.log(\"Starting selection at\", pos.x, pos.y);\n\n      // Store initial position, accounting for scroll and zoom\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect({\n        x: adjustedX,\n        y: adjustedY,\n        width: 0,\n        height: 0,\n        isActive: true\n      });\n\n      // Set a flag to indicate we're selecting\n      setIsSelecting(true);\n      return;\n    }\n\n    if (tool === 'text') {\n      // Text insertion logic - we'll implement this later\n      return;\n    }\n\n    if (tool === 'pen' || tool === 'eraser') {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Create new stroke\n      const newStroke: Stroke = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        points: [{ x, y, pressure }],\n        tool: tool,\n        color: tool === 'pen' ? penColor : '#ffffff',\n        width: tool === 'pen' ? penSize : eraserSize,\n        order_index: strokes.length,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        user_id: user?.id\n      };\n\n      setCurrentStroke(newStroke);\n      setIsDrawing(true);\n      setUndoStack([]);\n    }\n  }, [tool, position, scale, notebookId, strokes.length, penColor, penSize, eraserSize, user?.id, getPressure]);\n\n  // Unified move handler for all input types\n  const handleInputMove = useCallback((e: any) => {\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Handle panning\n    if (tool === 'pan' || e.evt?.buttons === 4 || (e.evt?.buttons === 1 && e.evt?.button === 1)) {\n      // Panning logic\n      const dx = e.evt?.movementX || 0;\n      const dy = e.evt?.movementY || 0;\n\n      setPosition(prev => ({\n        x: prev.x + dx,\n        y: prev.y + dy\n      }));\n\n      return;\n    }\n\n    // Handle selection\n    if (tool === 'select' && isSelecting) {\n      // Calculate adjusted position for zoom and pan\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect((prev) => ({\n        ...prev,\n        width: adjustedX - prev.x,\n        height: adjustedY - prev.y\n      }));\n\n      return;\n    }\n\n    // Handle drawing\n    if (isDrawing && currentStroke) {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Get pressure data\n      const pressure = getPressure(e);\n\n      // Add point to current stroke\n      setCurrentStroke(prev => {\n        if (!prev) return null;\n\n        const newPoints = [...prev.points, { x, y, pressure }];\n        return { ...prev, points: newPoints };\n      });\n    }\n  }, [isDrawing, currentStroke, tool, position, scale, isSelecting, getPressure]);\n\n  // Unified end handler for all input types\n  const handleInputEnd = useCallback(async (e: any) => {\n    // Handle selection completion\n    if (tool === 'select' && isSelecting) {\n      console.log(\"Ending selection\");\n      setIsSelecting(false);\n\n      // Check if selection has meaningful size\n      if (Math.abs(selectionRect.width) > selectionThreshold &&\n          Math.abs(selectionRect.height) > selectionThreshold) {\n        const normalizedRect = {\n          x: selectionRect.width > 0 ? selectionRect.x : selectionRect.x + selectionRect.width,\n          y: selectionRect.height > 0 ? selectionRect.y : selectionRect.y + selectionRect.height,\n          width: Math.abs(selectionRect.width),\n          height: Math.abs(selectionRect.height),\n          isActive: false\n        };\n\n        console.log(\"Selection completed:\", normalizedRect);\n        // TODO: Process the selection (e.g., analyze text in this area)\n      } else {\n        // Reset selection if too small\n        setSelectionRect({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0,\n          isActive: false\n        });\n      }\n\n      return;\n    }\n\n    // Handle drawing completion\n    if (isDrawing && currentStroke) {\n      if (currentStroke.points.length < 2) {\n        // If it's just a dot, add another point slightly offset\n        const point = currentStroke.points[0];\n        setCurrentStroke(prev => {\n          if (!prev) return null;\n          return {\n            ...prev,\n            points: [...prev.points, { x: point.x + 0.1, y: point.y + 0.1, pressure: point.pressure }]\n          };\n        });\n      }\n\n      // Save the completed stroke\n      setStrokes(prev => [...prev, currentStroke]);\n\n      // Save to database if authenticated\n      if (user) {\n        try {\n          await supabase.from('strokes').insert(currentStroke);\n\n          // Store stroke ID for undo functionality\n          if (typeof window !== 'undefined') {\n            if (!window.ownStrokeIds) {\n              window.ownStrokeIds = new Set();\n            }\n            window.ownStrokeIds.add(currentStroke.id);\n          }\n        } catch (err) {\n          console.error('Error saving stroke:', err);\n        }\n      }\n\n      setCurrentStroke(null);\n      setIsDrawing(false);\n    }\n  }, [isDrawing, currentStroke, user, tool, isSelecting, selectionRect, selectionThreshold]);\n  \n  // Undo/Redo handlers\n  const handleUndo = useCallback(async () => {\n    if (strokes.length === 0) return;\n\n    const lastStroke = strokes[strokes.length - 1];\n    const newStrokes = strokes.slice(0, -1);\n\n    setStrokes(newStrokes);\n    setUndoStack(prev => [...prev, lastStroke]);\n\n    // Update database if authenticated\n    if (user && lastStroke.id && window.ownStrokeIds?.has(lastStroke.id)) {\n      try {\n        await supabase.from('strokes').delete().eq('id', lastStroke.id);\n      } catch (err) {\n        console.error('Error deleting stroke:', err);\n      }\n    }\n  }, [strokes, user]);\n\n  const handleRedo = useCallback(async () => {\n    if (undoStack.length === 0) return;\n\n    const strokeToRedo = undoStack[undoStack.length - 1];\n    const newUndoStack = undoStack.slice(0, -1);\n\n    setStrokes(prev => [...prev, strokeToRedo]);\n    setUndoStack(newUndoStack);\n\n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').insert(strokeToRedo);\n\n        // Store stroke ID for undo functionality\n        if (typeof window !== 'undefined') {\n          if (!window.ownStrokeIds) {\n            window.ownStrokeIds = new Set();\n          }\n          window.ownStrokeIds.add(strokeToRedo.id);\n        }\n      } catch (err) {\n        console.error('Error redoing stroke:', err);\n      }\n    }\n  }, [undoStack, user]);\n\n  // Tool handlers\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    // Prevent handling if in an input or textarea\n    if (\n      document.activeElement?.tagName === 'INPUT' ||\n      document.activeElement?.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (e.code === 'Space') {\n      // Temporarily switch to pan tool with spacebar\n      setTool('pan');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'grab';\n        }\n      }\n    } else if (e.code === 'KeyP') {\n      setTool('pen');\n    } else if (e.code === 'KeyE') {\n      setTool('eraser');\n    } else if (e.code === 'KeyS') {\n      setTool('select');\n    } else if (e.code === 'KeyT') {\n      setTool('text');\n    } else if (e.ctrlKey && e.code === 'KeyZ') {\n      // Undo\n      handleUndo();\n    } else if (e.ctrlKey && e.shiftKey && e.code === 'KeyZ') {\n      // Redo\n      handleRedo();\n    }\n  }, [handleUndo, handleRedo]);\n\n  const handleKeyUp = useCallback((e: KeyboardEvent) => {\n    if (e.code === 'Space' && tool === 'pan') {\n      // Switch back to previous tool when spacebar is released\n      setTool('pen');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [tool]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n  \n  // Clear canvas\n  const handleClearCanvas = useCallback(async () => {\n    // Store current strokes for potential undo (unused for now)\n    /*\n    const currentStrokes = [...strokes];\n    */\n\n    // Clear canvas\n    setStrokes([]);\n    setUndoStack([]);\n    \n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').delete().eq('notebook_id', notebookId);\n      } catch (err) {\n        console.error('Error clearing canvas:', err);\n      }\n    }\n  }, [strokes, user, notebookId]);\n  \n  // Thread card handlers\n  const handleDragStart = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: true\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n\n  // Card click handler for the new unified card system\n  const handleCardClick = useCallback((cardId: string) => {\n    // This will be integrated with the unified view store\n    if (window.unifiedViewStore) {\n      window.unifiedViewStore.setActiveCard(cardId);\n    }\n  }, []);\n  \n  const handleDragMove = useCallback((id: string, x: number, y: number) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          x,\n          y\n        }\n      }\n    }));\n  }, []);\n  \n  const handleDragEnd = useCallback(async (id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: false\n        }\n      }\n    }));\n    \n    // Save position to database if authenticated\n    if (user) {\n      const conversation = conversationState.items.find(c => c.id === id);\n      const pos = conversationState.positions[id];\n      \n      if (conversation && pos) {\n        try {\n          await supabase\n            .from('conversations')\n            .update({\n              position: { x: pos.x, y: pos.y },\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', id);\n        } catch (err) {\n          console.error('Error updating position:', err);\n        }\n      }\n    }\n  }, [user, conversationState.items, conversationState.positions]);\n  \n  const handleToggleCollapse = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isCollapsed: !prev.positions[id].isCollapsed\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n  \n  const handleToggleInfoDialog = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      activeInfoDialog: prev.activeInfoDialog === id ? null : id\n    }));\n  }, []);\n  \n  const handleEditContent = useCallback(async (id: string, text: string) => {\n    if (!user) return;\n    \n    try {\n      await supabase\n        .from('conversations')\n        .update({\n          user_content: text,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n        \n      setConversationState(prev => ({\n        ...prev,\n        items: prev.items.map(item => \n          item.id === id ? { ...item, user_content: text, updated_at: new Date().toISOString() } : item\n        )\n      }));\n    } catch (err) {\n      console.error('Error updating content:', err);\n    }\n  }, [user]);\n  \n  const handleContinueThread = useCallback((id: string) => {\n    // Conversation continuation logic\n    console.log('Continue thread:', id);\n  }, []);\n  \n  const handleCreateFollowUp = useCallback((id: string) => {\n    // Follow-up creation logic\n    console.log('Create follow-up:', id);\n  }, []);\n  \n  const handleCreateReference = useCallback((id: string, targetId?: string) => {\n    // Reference creation logic\n    console.log('Create reference from', id, 'to', targetId);\n  }, []);\n  \n  // System prompt handlers\n  const handleUpdateSystemPrompt = useCallback(async (prompt: string) => {\n    if (!user || !notebook) return;\n    \n    setSystemPrompt(prompt);\n    setIsSystemPromptModalOpen(false);\n    \n    try {\n      await supabase\n        .from('notebooks')\n        .update({\n          system_prompt: prompt,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', notebookId);\n    } catch (err) {\n      console.error('Error updating system prompt:', err);\n    }\n  }, [user, notebook, notebookId]);\n  \n  // Determine undo/redo availability\n  const undoAvailable = strokes.length > 0;\n  const redoAvailable = undoStack.length > 0;\n  \n  // Loading state\n  if (notebookLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500\"></div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"flex flex-col h-screen w-full\">\n      {/* Toolbar */}\n      <ResponsiveToolbar\n        tool={tool}\n        setTool={safeSetTool}\n        scale={scale}\n        setScale={setScale}\n        setPosition={setPosition}\n        notebookId={notebookId}\n        notebookTitle={notebook?.title || 'Untitled Notebook'}\n        isCollaborative={notebook?.is_collaborative}\n        onClearCanvas={handleClearCanvas}\n        isPenMode={isPenMode}\n        setIsPenMode={setIsPenMode}\n        penSize={penSize}\n        setPenSize={setPenSize}\n        eraserSize={eraserSize}\n        setEraserSize={setEraserSize}\n        undoAvailable={undoAvailable}\n        redoAvailable={redoAvailable}\n        onUndo={handleUndo}\n        onRedo={handleRedo}\n        penColor={penColor}\n        setPenColor={setPenColor}\n        isSidePanelOpen={isSidePanelOpen}\n        toggleSidePanel={() => setIsSidePanelOpen(prev => !prev)}\n        onOpenSystemPromptModal={() => setIsSystemPromptModalOpen(true)}\n      />\n      \n      {/* Canvas Container */}\n      <div\n        ref={containerRef}\n        className=\"flex-1 relative bg-gray-50 overflow-hidden\"\n        style={{ height: 'calc(100vh - 100px)' }}\n      >\n        {/* Debug Panel */}\n        <DebugPanel />\n\n        <Stage\n          width={stageWidth}\n          height={stageHeight}\n          ref={stageRef}\n          draggable={tool === 'pan'}\n          onMouseDown={handleInputStart}\n          onMouseMove={handleInputMove}\n          onMouseUp={handleInputEnd}\n          onMouseLeave={handleInputEnd}\n          onTouchStart={handleInputStart}\n          onTouchMove={handleInputMove}\n          onTouchEnd={handleInputEnd}\n          onPointerDown={handleInputStart}\n          onPointerMove={handleInputMove}\n          onPointerUp={handleInputEnd}\n          position={position}\n          scale={{ x: scale, y: scale }}\n          onContextMenu={e => e.evt.preventDefault()}\n        >\n          {/* Background Layer */}\n          <Layer name=\"background-layer\">\n            <BackgroundLayer\n              width={stageWidth}\n              height={stageHeight}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Drawing Layer */}\n          <Layer name=\"drawing-layer\">\n            <DrawingLayer\n              strokes={strokes}\n              currentStroke={currentStroke}\n              scale={scale}\n              position={position}\n            />\n          </Layer>\n\n          {/* Text Layer */}\n          <Layer name=\"text-layer\">\n            <TextLayer\n              conversationState={conversationState}\n              notebookId={notebookId}\n              onDragStart={handleDragStart}\n              onDragMove={handleDragMove}\n              onDragEnd={handleDragEnd}\n              onToggleCollapse={handleToggleCollapse}\n              onToggleInfoDialog={handleToggleInfoDialog}\n              onEditContent={handleEditContent}\n              onContinueThread={handleContinueThread}\n              onCreateFollowUp={handleCreateFollowUp}\n              onCreateReference={handleCreateReference}\n              tool={tool}\n              isTextSelectionEnabled={tool === 'text'}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Selection Layer */}\n          {selectionRect.isActive && (\n            <Layer name=\"selection-layer\">\n              <Line\n                points={[\n                  selectionRect.x, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y\n                ]}\n                stroke=\"rgba(0, 161, 255, 0.8)\"\n                strokeWidth={2 / scale}\n                dash={[5 / scale, 5 / scale]}\n                closed={true}\n                fill=\"rgba(0, 161, 255, 0.1)\"\n              />\n            </Layer>\n          )}\n        </Stage>\n      </div>\n      \n      {/* System Prompt Modal */}\n      {isSystemPromptModalOpen && (\n        <SystemPromptModal\n          isOpen={isSystemPromptModalOpen}\n          onClose={() => setIsSystemPromptModalOpen(false)}\n          initialPrompt={systemPrompt || ''}\n          onSave={handleUpdateSystemPrompt}\n        />\n      )}\n      \n      {/* Side Panel with ConversationSidePanel */}\n      {isSidePanelOpen && (\n        <ConversationSidePanel\n          notebookId={notebookId}\n          conversations={conversationState.items}\n          onEditTranscription={async (id, text) => {\n            try {\n              await supabase\n                .from('conversations')\n                .update({\n                  ai_response: text,\n                  updated_at: new Date().toISOString()\n                })\n                .eq('id', id);\n\n              // Update local state\n              setConversationState(prev => ({\n                ...prev,\n                items: prev.items.map(item =>\n                  item.id === id ? { ...item, ai_response: text, updated_at: new Date().toISOString() } : item\n                )\n              }));\n            } catch (err) {\n              console.error('Error updating AI response:', err);\n            }\n          }}\n          onSendMessage={async (message, mode) => {\n            try {\n              if (!user) return;\n\n              // Create a new conversation\n              const newConversation: Partial<Conversation> = {\n                id: generateUUID(), // Use our custom UUID generator\n                notebook_id: notebookId,\n                user_id: user.id,\n                user_content: message,\n                position: {\n                  x: -position.x + stageWidth / 2 - 150, // Center horizontally\n                  y: -position.y + stageHeight / 2 - 100 // Center vertically\n                },\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString(),\n                card_type: mode === 'chat' ? 'question' : 'note',\n                thread_id: conversationState.activeConversation || undefined,\n                is_thread_starter: !conversationState.activeConversation\n              };\n\n              // Save to database\n              const { data, error } = await supabase\n                .from('conversations')\n                .insert(newConversation)\n                .select()\n                .single();\n\n              if (error) throw error;\n\n              // Update local state\n              const savedConversation = data as Conversation;\n\n              setConversationState(prev => ({\n                ...prev,\n                items: [...prev.items, savedConversation],\n                positions: {\n                  ...prev.positions,\n                  [savedConversation.id]: {\n                    ...extractPositionFromJson(savedConversation.position),\n                    isCollapsed: false,\n                    isDragging: false\n                  }\n                },\n                activeConversation: savedConversation.id\n              }));\n\n              // Parliament functionality has been removed\n              if (mode === 'chat') {\n                // Process chat message without parliament\n                console.log('Chat message sent:', message);\n              }\n\n              return savedConversation;\n            } catch (err) {\n              console.error('Error sending message:', err);\n              throw err;\n            }\n          }}\n          onJumpToCard={(id) => {\n            // Find the card\n            const conversation = conversationState.items.find(c => c.id === id);\n            const position = conversationState.positions[id];\n\n            if (conversation && position) {\n              // Center on the card\n              setPosition({\n                x: -position.x + stageWidth / 2 - 150,\n                y: -position.y + stageHeight / 2 - 100\n              });\n\n              // Set as active\n              setConversationState(prev => ({\n                ...prev,\n                activeConversation: id\n              }));\n            }\n          }}\n          onClose={() => setIsSidePanelOpen(false)}\n          isOpen={isSidePanelOpen}\n          isFullScreen={false}\n          onToggleFullScreen={() => {\n            // This would toggle full-screen mode if implemented\n            console.log('Toggle full-screen mode');\n          }}\n          systemPrompt={systemPrompt}\n        />\n      )}\n\n      {/* Parliament functionality has been removed */}\n    </div>\n  );\n};\n\nexport default CanvasContainer;\nðŸ“„ --- File: ./src/components/canvas/CanvasContainer.tsx (matched setInput) ---\n// src/components/canvas/CanvasContainer.tsx\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Stage, Layer } from 'react-konva';\nimport { KonvaEventObject } from 'konva/lib/Node';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Stroke, Conversation } from '@/types/supabase';\nimport { extractPositionFromJson } from '@/types/position';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport { useRouter } from 'next/router';\nimport DrawingLayer from './DrawingLayer';\nimport TextLayer from './TextLayer';\nimport BackgroundLayer from './BackgroundLayer';\nimport CardLayer from './CardLayer';\n// Using updated responsive toolbar\nimport ResponsiveToolbar from './ResponsiveToolbar';\nimport SystemPromptModal from '@/components/modals/SystemPromptModal';\nimport ConversationSidePanel from '@/components/ui/ConversationSidePanel';\nimport { generateUUID } from '@/utils/uuidUtils';\n\n// Tool types definition\nexport type Tool = 'pen' | 'eraser' | 'select' | 'text' | 'pan';\n\n// Component Props\ninterface CanvasContainerProps {\n  notebookId: string;\n}\n\nconst CanvasContainer: React.FC<CanvasContainerProps> = ({ notebookId }) => {\n  const { user } = useAuth();\n  const { notebook, loading: notebookLoading } = useNotebook(notebookId);\n  const router = useRouter();\n  \n  // Refs\n   \n  const stageRef = useRef<any>(null); // Using any for Konva Stage ref\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Canvas dimension state\n  const [stageWidth, setStageWidth] = useState(typeof window !== 'undefined' ? window.innerWidth : 1000);\n  const [stageHeight, setStageHeight] = useState(typeof window !== 'undefined' ? window.innerHeight - 100 : 900);\n  \n  // Canvas view state\n  const [scale, setScale] = useState(1);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  \n  // Tool state\n  const [tool, setTool] = useState<Tool>('pen');\n  const [previousTool, setPreviousTool] = useState<Tool>('pen');\n  const [isPenMode, setIsPenMode] = useState(true);\n  const [penSize, setPenSize] = useState(2);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [penColor, setPenColor] = useState('#000000');\n\n  // Tool transition handling\n  const safeSetTool = useCallback((newTool: Tool) => {\n    console.log(`CanvasContainer: Setting tool from ${tool} to ${newTool}`);\n    setPreviousTool(tool);\n    setTool(newTool);\n  }, [tool]);\n\n  // Error boundary for tool switching\n  useEffect(() => {\n    const handleToolChangeError = (error: ErrorEvent) => {\n      console.error('Error during tool change:', error);\n\n      // If we get a \"getParent\" or similar Konva error, try to recover\n      if (error.message.includes('getParent') ||\n          error.message.includes('parent') ||\n          error.message.includes('undefined')) {\n\n        console.warn('Detected Konva parent error during tool switch, attempting recovery');\n\n        // Force back to previous tool as a recovery mechanism\n        setTimeout(() => {\n          console.log(`Recovering by reverting to previous tool: ${previousTool}`);\n          setTool(previousTool);\n        }, 100);\n      }\n    };\n\n    // Listen for errors that might indicate tool switching problems\n    window.addEventListener('error', handleToolChangeError);\n\n    return () => {\n      window.removeEventListener('error', handleToolChangeError);\n    };\n  }, [previousTool]);\n  \n  // Drawing state\n  const [strokes, setStrokes] = useState<Stroke[]>([]);\n  const [currentStroke, setCurrentStroke] = useState<Stroke | null>(null);\n  const [undoStack, setUndoStack] = useState<Stroke[]>([]);\n  const [isDrawing, setIsDrawing] = useState(false);\n  \n  // Conversation state\n  const [conversationState, setConversationState] = useState<{\n    items: Conversation[];\n    positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>;\n    activeInfoDialog: string | null;\n    activeConversation: string | null;\n  }>({\n    items: [],\n    positions: {},\n    activeInfoDialog: null,\n    activeConversation: null\n  });\n  \n  // Parliament functionality has been removed\n\n  // UI state\n  const [isSidePanelOpen, setIsSidePanelOpen] = useState(false);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isSidePanelFullScreen, setIsSidePanelFullScreen] = useState(false);\n  const [isSystemPromptModalOpen, setIsSystemPromptModalOpen] = useState(false);\n  const [systemPrompt, setSystemPrompt] = useState<string | null>(null);\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  \n  // Resize handler\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleResize = () => {\n      if (containerRef.current) {\n        setStageWidth(containerRef.current.offsetWidth);\n        setStageHeight(containerRef.current.offsetHeight - 100);\n      }\n    };\n    \n    handleResize();\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n  \n  // Load notebook data\n  useEffect(() => {\n    if (notebookLoading || !notebook) return;\n    \n    // Load system prompt from notebook\n    if (notebook.system_prompt) {\n      setSystemPrompt(notebook.system_prompt);\n    }\n    \n    // Fetch strokes\n    const fetchStrokes = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('strokes')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          setStrokes(data);\n        }\n      } catch (err) {\n        console.error('Error fetching strokes:', err);\n      }\n    };\n    \n    // Fetch conversations\n    const fetchConversations = async () => {\n      try {\n        const { data, error } = await supabase\n          .from('conversations')\n          .select('*')\n          .eq('notebook_id', notebookId)\n          .order('created_at', { ascending: true });\n          \n        if (error) throw error;\n        \n        if (data) {\n          const positions: Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }> = {};\n          \n          // Initialize positions\n          data.forEach(conv => {\n            if (conv.id) {\n              const pos = extractPositionFromJson(conv.position);\n              positions[conv.id] = {\n                x: pos.x,\n                y: pos.y,\n                isCollapsed: false,\n                isDragging: false\n              };\n            }\n          });\n          \n          setConversationState({\n            items: data,\n            positions,\n            activeInfoDialog: null,\n            activeConversation: null\n          });\n        }\n      } catch (err) {\n        console.error('Error fetching conversations:', err);\n      }\n    };\n    \n    fetchStrokes();\n    fetchConversations();\n    \n    // Set up real-time subscription\n    if (user) {\n      const strokesSubscription = supabase\n        .channel(`strokes:${notebookId}`)\n        .on('postgres_changes', {\n          event: 'INSERT',\n          schema: 'public',\n          table: 'strokes',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, (payload) => {\n          const newStroke = payload.new as Stroke;\n          \n          // Only add strokes from other users\n          if (user && newStroke.user_id !== user.id) {\n            setStrokes(prev => [...prev, newStroke]);\n          }\n        })\n        .subscribe();\n        \n      const conversationsSubscription = supabase\n        .channel(`conversations:${notebookId}`)\n        .on('postgres_changes', {\n          event: '*', // Listen to all events (INSERT, UPDATE, DELETE)\n          schema: 'public',\n          table: 'conversations',\n          filter: `notebook_id=eq.${notebookId}`,\n        }, async (payload) => {\n          if (payload.eventType === 'INSERT') {\n            const newConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: [...prev.items, newConversation],\n              positions: {\n                ...prev.positions,\n                [newConversation.id]: {\n                  ...extractPositionFromJson(newConversation.position),\n                  isCollapsed: false,\n                  isDragging: false\n                }\n              }\n            }));\n          } else if (payload.eventType === 'UPDATE') {\n            const updatedConversation = payload.new as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.map(item => \n                item.id === updatedConversation.id ? updatedConversation : item\n              ),\n              positions: {\n                ...prev.positions,\n                [updatedConversation.id]: {\n                  ...prev.positions[updatedConversation.id],\n                  ...extractPositionFromJson(\n                    updatedConversation.position,\n                    prev.positions[updatedConversation.id]?.x || 100,\n                    prev.positions[updatedConversation.id]?.y || 100\n                  )\n                }\n              }\n            }));\n          } else if (payload.eventType === 'DELETE') {\n            const deletedConversation = payload.old as Conversation;\n            \n            setConversationState(prev => ({\n              ...prev,\n              items: prev.items.filter(item => item.id !== deletedConversation.id),\n              positions: Object.entries(prev.positions).reduce((acc, [key, value]) => {\n                if (key !== deletedConversation.id) {\n                  acc[key] = value;\n                }\n                return acc;\n              }, {} as Record<string, { x: number; y: number; isCollapsed: boolean; isDragging: boolean }>)\n            }));\n          }\n        })\n        .subscribe();\n        \n      return () => {\n        supabase.removeChannel(strokesSubscription);\n        supabase.removeChannel(conversationsSubscription);\n      };\n    }\n  }, [notebookId, notebookLoading, notebook, user]);\n  \n  // Jump to card if specified in URL\n  useEffect(() => {\n    if (!router.isReady) return;\n    \n    const { card, x, y, zoom } = router.query;\n    \n    if (card && typeof card === 'string') {\n      // Find the card in conversation state\n      const conversation = conversationState.items.find(c => c.id === card);\n      \n      if (conversation && conversationState.positions[card]) {\n        // Center view on the card\n        const pos = conversationState.positions[card];\n        setPosition({\n          x: -pos.x + stageWidth / 2 - 140, // Center card horizontally\n          y: -pos.y + stageHeight / 2 - 100 // Center card vertically\n        });\n        \n        // Set as active\n        setConversationState(prev => ({\n          ...prev,\n          activeConversation: card\n        }));\n      }\n    } else if (x && y && typeof x === 'string' && typeof y === 'string') {\n      // Jump to specific position\n      setPosition({\n        x: -parseInt(x) + stageWidth / 2,\n        y: -parseInt(y) + stageHeight / 2\n      });\n      \n      // Set zoom if specified\n      if (zoom && typeof zoom === 'string') {\n        const zoomValue = parseFloat(zoom);\n        if (!isNaN(zoomValue) && zoomValue > 0) {\n          setScale(zoomValue);\n        }\n      }\n    }\n  }, [router.isReady, router.query, conversationState.items, conversationState.positions, stageWidth, stageHeight]);\n  \n  // Active conversation reference is used in other parts of the component\n\n  // Debug mode state\n  const [debugMode, setDebugMode] = useState(false);\n\n  // State to track input type\n  const [inputType, setInputType] = useState('mouse'); // 'mouse', 'touch', or 'pen'\n\n  // Detect input type on first interaction\n  useEffect(() => {\n    const handleInputTypeDetection = (e: PointerEvent) => {\n      if (e.pointerType === 'pen' || e.pointerType === 'stylus') {\n        setInputType('pen');\n        console.log('Pen input detected');\n      } else if (e.pointerType === 'touch' || e.type.includes('touch')) {\n        setInputType('touch');\n        console.log('Touch input detected');\n      } else {\n        setInputType('mouse');\n        console.log('Mouse input detected');\n      }\n    };\n\n    // Add pointerdown listener to detect input type\n    document.addEventListener('pointerdown', handleInputTypeDetection);\n\n    // Also check touch capability\n    if (window.matchMedia(\"(pointer: coarse)\").matches) {\n      console.log('Touch-capable device detected');\n      setInputType('touch');\n    }\n\n    return () => {\n      document.removeEventListener('pointerdown', handleInputTypeDetection);\n    };\n  }, []);\n\n  // Optimize selection behavior based on input type\n  useEffect(() => {\n    console.log(`Input type detected: ${inputType}`);\n\n    // Adjust selection threshold based on input type\n    if (inputType === 'touch') {\n      // Touch needs larger selection threshold\n      setSelectionThreshold(30); // px\n    } else if (inputType === 'pen') {\n      // Pen can be more precise\n      setSelectionThreshold(15); // px\n    } else {\n      // Mouse is most precise\n      setSelectionThreshold(10); // px\n    }\n\n    // Adjust cursor style based on input type\n    if (stageRef.current) {\n      const stage = stageRef.current.getStage();\n      if (stage && stage.container) {\n        if (inputType === 'touch') {\n          // On touch, cursors aren't visible anyway\n          stage.container().style.cursor = 'default';\n        } else if (tool === 'select') {\n          stage.container().style.cursor = 'crosshair';\n        } else if (tool === 'pan') {\n          stage.container().style.cursor = 'grab';\n        } else if (tool === 'pen') {\n          stage.container().style.cursor = 'pointer';\n        } else if (tool === 'eraser') {\n          stage.container().style.cursor = 'cell';\n        } else {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [inputType, tool]);\n\n  // Add keyboard shortcut to toggle debug mode (Ctrl+Shift+D)\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'd' && e.ctrlKey && e.shiftKey) {\n        setDebugMode(prev => !prev);\n        console.log(`Debug mode ${!debugMode ? 'enabled' : 'disabled'}`);\n      }\n\n      // Allow forcing a specific input type for testing (Shift+Alt+...)\n      if (e.shiftKey && e.altKey) {\n        if (e.key === 'm') {\n          setInputType('mouse');\n          console.log('Forced input type: mouse');\n        } else if (e.key === 't') {\n          setInputType('touch');\n          console.log('Forced input type: touch');\n        } else if (e.key === 'p') {\n          setInputType('pen');\n          console.log('Forced input type: pen');\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [debugMode]);\n\n  // Debug panel component\n  const DebugPanel = () => {\n    if (!debugMode) return null;\n\n    return (\n      <div style={{\n        position: 'absolute',\n        bottom: 10,\n        left: 10,\n        background: 'rgba(0,0,0,0.7)',\n        color: 'white',\n        padding: 10,\n        borderRadius: 5,\n        fontSize: 12,\n        zIndex: 1000,\n        fontFamily: 'monospace',\n        maxWidth: '300px'\n      }}>\n        <div style={{ borderBottom: '1px solid rgba(255,255,255,0.3)', paddingBottom: '5px', marginBottom: '5px', fontWeight: 'bold' }}>\n          Input Debug Panel\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Tool:</div>\n          <div>{tool}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Input:</div>\n          <div>{inputType}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Selection:</div>\n          <div>{isSelecting ? 'Active' : 'Inactive'}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Precision:</div>\n          <div>{selectionPrecision}</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Threshold:</div>\n          <div>{selectionThreshold}px</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Scale:</div>\n          <div>{(scale * 100).toFixed(0)}%</div>\n        </div>\n        <div style={{ display: 'flex', justifyContent: 'space-between' }}>\n          <div>Position:</div>\n          <div>{Math.round(position.x)},{Math.round(position.y)}</div>\n        </div>\n        {selectionRect.isActive && (\n          <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px' }}>\n            <div>Selection:</div>\n            <div>\n              x:{Math.round(selectionRect.x)}, y:{Math.round(selectionRect.y)},\n              w:{Math.round(selectionRect.width)}, h:{Math.round(selectionRect.height)}\n            </div>\n          </div>\n        )}\n        <div style={{ borderTop: '1px solid rgba(255,255,255,0.3)', paddingTop: '5px', marginTop: '5px', fontSize: '10px' }}>\n          Shortcuts:\n          <div>â€¢ Ctrl+Shift+D: Toggle debug panel</div>\n          <div>â€¢ Shift+Alt+M: Force mouse input</div>\n          <div>â€¢ Shift+Alt+T: Force touch input</div>\n          <div>â€¢ Shift+Alt+P: Force pen input</div>\n        </div>\n        <button\n          onClick={() => setDebugMode(false)}\n          style={{\n            marginTop: 5,\n            padding: '2px 5px',\n            background: '#333',\n            border: '1px solid #555',\n            color: 'white',\n            borderRadius: '3px',\n            cursor: 'pointer',\n            fontSize: '11px'\n          }}\n        >\n          Close\n        </button>\n      </div>\n    );\n  };\n\n  // State for selection\n  const [selectionRect, setSelectionRect] = useState({ x: 0, y: 0, width: 0, height: 0, isActive: false });\n  const [isSelecting, setIsSelecting] = useState(false);\n  const [selectionThreshold, setSelectionThreshold] = useState(10); // px\n  const [selectionPrecision, setSelectionPrecision] = useState('normal'); // 'normal' or 'high'\n\n  // Get pressure from pointer events\n  const getPressure = useCallback((e: any) => {\n    // Default pressure if not available\n    let pressure = 1.0;\n\n    // Try to get pressure from various events\n    if (e.pressure !== undefined && e.pressure !== 0) {\n      // Pointer events include pressure\n      pressure = e.pressure;\n    } else if (e.touches && e.touches[0] && e.touches[0].force !== undefined) {\n      // Some touch events include force (iOS)\n      pressure = e.touches[0].force;\n    } else if (e.evt && e.evt.pressure !== undefined && e.evt.pressure !== 0) {\n      // Konva wraps events in evt property\n      pressure = e.evt.pressure;\n    } else if (e.evt && e.evt.touches && e.evt.touches[0] && e.evt.touches[0].force !== undefined) {\n      // Konva wrapped touch events\n      pressure = e.evt.touches[0].force;\n    }\n\n    return pressure;\n  }, []);\n\n  // Universal input handler for all device types\n  const handleInputStart = useCallback((e: any) => {\n    // Get stage from event\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    // Get pointer position\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Log input for debugging\n    console.log(`Input start (${e.type || e.evt?.type || 'unknown'}) at position:`, pos.x, pos.y);\n\n    // Get pressure for pen input\n    const pressure = getPressure(e);\n    console.log(`Input pressure: ${pressure}`);\n\n    // Adjust selection behavior based on pressure\n    if (pressure > 0.5) {\n      // Harder press might indicate more precise selection\n      setSelectionPrecision('high');\n    } else {\n      setSelectionPrecision('normal');\n    }\n\n    // Check if we clicked on a card or other interactive element\n    const target = e.target;\n    const isClickOnCard = target.hasName?.('card-wrapper') ||\n                        target.findAncestor?.('card-wrapper') ||\n                        target.findAncestor?.('thread-card');\n\n    // Handle based on current tool\n    if (tool === 'pan' || (e.evt?.button === 1 || e.evt?.buttons === 4)) {\n      // Middle mouse or pan tool - handle panning\n      if (stage) {\n        stage.container().style.cursor = 'grabbing';\n      }\n      return;\n    }\n\n    if (tool === 'select') {\n      // If clicking on a card while in select mode, ignore\n      if (isClickOnCard) {\n        console.log(\"Clicked on interactive element while in select mode - ignoring\");\n        return;\n      }\n\n      console.log(\"Starting selection at\", pos.x, pos.y);\n\n      // Store initial position, accounting for scroll and zoom\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect({\n        x: adjustedX,\n        y: adjustedY,\n        width: 0,\n        height: 0,\n        isActive: true\n      });\n\n      // Set a flag to indicate we're selecting\n      setIsSelecting(true);\n      return;\n    }\n\n    if (tool === 'text') {\n      // Text insertion logic - we'll implement this later\n      return;\n    }\n\n    if (tool === 'pen' || tool === 'eraser') {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Create new stroke\n      const newStroke: Stroke = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        points: [{ x, y, pressure }],\n        tool: tool,\n        color: tool === 'pen' ? penColor : '#ffffff',\n        width: tool === 'pen' ? penSize : eraserSize,\n        order_index: strokes.length,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        user_id: user?.id\n      };\n\n      setCurrentStroke(newStroke);\n      setIsDrawing(true);\n      setUndoStack([]);\n    }\n  }, [tool, position, scale, notebookId, strokes.length, penColor, penSize, eraserSize, user?.id, getPressure]);\n\n  // Unified move handler for all input types\n  const handleInputMove = useCallback((e: any) => {\n    const stage = e.target.getStage();\n    if (!stage) return;\n\n    const pos = stage.getPointerPosition();\n    if (!pos) return;\n\n    // Handle panning\n    if (tool === 'pan' || e.evt?.buttons === 4 || (e.evt?.buttons === 1 && e.evt?.button === 1)) {\n      // Panning logic\n      const dx = e.evt?.movementX || 0;\n      const dy = e.evt?.movementY || 0;\n\n      setPosition(prev => ({\n        x: prev.x + dx,\n        y: prev.y + dy\n      }));\n\n      return;\n    }\n\n    // Handle selection\n    if (tool === 'select' && isSelecting) {\n      // Calculate adjusted position for zoom and pan\n      const adjustedX = (pos.x - position.x) / scale;\n      const adjustedY = (pos.y - position.y) / scale;\n\n      setSelectionRect((prev) => ({\n        ...prev,\n        width: adjustedX - prev.x,\n        height: adjustedY - prev.y\n      }));\n\n      return;\n    }\n\n    // Handle drawing\n    if (isDrawing && currentStroke) {\n      // Calculate position in virtual canvas space\n      const x = (pos.x - position.x) / scale;\n      const y = (pos.y - position.y) / scale;\n\n      // Get pressure data\n      const pressure = getPressure(e);\n\n      // Add point to current stroke\n      setCurrentStroke(prev => {\n        if (!prev) return null;\n\n        const newPoints = [...prev.points, { x, y, pressure }];\n        return { ...prev, points: newPoints };\n      });\n    }\n  }, [isDrawing, currentStroke, tool, position, scale, isSelecting, getPressure]);\n\n  // Unified end handler for all input types\n  const handleInputEnd = useCallback(async (e: any) => {\n    // Handle selection completion\n    if (tool === 'select' && isSelecting) {\n      console.log(\"Ending selection\");\n      setIsSelecting(false);\n\n      // Check if selection has meaningful size\n      if (Math.abs(selectionRect.width) > selectionThreshold &&\n          Math.abs(selectionRect.height) > selectionThreshold) {\n        const normalizedRect = {\n          x: selectionRect.width > 0 ? selectionRect.x : selectionRect.x + selectionRect.width,\n          y: selectionRect.height > 0 ? selectionRect.y : selectionRect.y + selectionRect.height,\n          width: Math.abs(selectionRect.width),\n          height: Math.abs(selectionRect.height),\n          isActive: false\n        };\n\n        console.log(\"Selection completed:\", normalizedRect);\n        // TODO: Process the selection (e.g., analyze text in this area)\n      } else {\n        // Reset selection if too small\n        setSelectionRect({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0,\n          isActive: false\n        });\n      }\n\n      return;\n    }\n\n    // Handle drawing completion\n    if (isDrawing && currentStroke) {\n      if (currentStroke.points.length < 2) {\n        // If it's just a dot, add another point slightly offset\n        const point = currentStroke.points[0];\n        setCurrentStroke(prev => {\n          if (!prev) return null;\n          return {\n            ...prev,\n            points: [...prev.points, { x: point.x + 0.1, y: point.y + 0.1, pressure: point.pressure }]\n          };\n        });\n      }\n\n      // Save the completed stroke\n      setStrokes(prev => [...prev, currentStroke]);\n\n      // Save to database if authenticated\n      if (user) {\n        try {\n          await supabase.from('strokes').insert(currentStroke);\n\n          // Store stroke ID for undo functionality\n          if (typeof window !== 'undefined') {\n            if (!window.ownStrokeIds) {\n              window.ownStrokeIds = new Set();\n            }\n            window.ownStrokeIds.add(currentStroke.id);\n          }\n        } catch (err) {\n          console.error('Error saving stroke:', err);\n        }\n      }\n\n      setCurrentStroke(null);\n      setIsDrawing(false);\n    }\n  }, [isDrawing, currentStroke, user, tool, isSelecting, selectionRect, selectionThreshold]);\n  \n  // Undo/Redo handlers\n  const handleUndo = useCallback(async () => {\n    if (strokes.length === 0) return;\n\n    const lastStroke = strokes[strokes.length - 1];\n    const newStrokes = strokes.slice(0, -1);\n\n    setStrokes(newStrokes);\n    setUndoStack(prev => [...prev, lastStroke]);\n\n    // Update database if authenticated\n    if (user && lastStroke.id && window.ownStrokeIds?.has(lastStroke.id)) {\n      try {\n        await supabase.from('strokes').delete().eq('id', lastStroke.id);\n      } catch (err) {\n        console.error('Error deleting stroke:', err);\n      }\n    }\n  }, [strokes, user]);\n\n  const handleRedo = useCallback(async () => {\n    if (undoStack.length === 0) return;\n\n    const strokeToRedo = undoStack[undoStack.length - 1];\n    const newUndoStack = undoStack.slice(0, -1);\n\n    setStrokes(prev => [...prev, strokeToRedo]);\n    setUndoStack(newUndoStack);\n\n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').insert(strokeToRedo);\n\n        // Store stroke ID for undo functionality\n        if (typeof window !== 'undefined') {\n          if (!window.ownStrokeIds) {\n            window.ownStrokeIds = new Set();\n          }\n          window.ownStrokeIds.add(strokeToRedo.id);\n        }\n      } catch (err) {\n        console.error('Error redoing stroke:', err);\n      }\n    }\n  }, [undoStack, user]);\n\n  // Tool handlers\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    // Prevent handling if in an input or textarea\n    if (\n      document.activeElement?.tagName === 'INPUT' ||\n      document.activeElement?.tagName === 'TEXTAREA'\n    ) {\n      return;\n    }\n\n    if (e.code === 'Space') {\n      // Temporarily switch to pan tool with spacebar\n      setTool('pan');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'grab';\n        }\n      }\n    } else if (e.code === 'KeyP') {\n      setTool('pen');\n    } else if (e.code === 'KeyE') {\n      setTool('eraser');\n    } else if (e.code === 'KeyS') {\n      setTool('select');\n    } else if (e.code === 'KeyT') {\n      setTool('text');\n    } else if (e.ctrlKey && e.code === 'KeyZ') {\n      // Undo\n      handleUndo();\n    } else if (e.ctrlKey && e.shiftKey && e.code === 'KeyZ') {\n      // Redo\n      handleRedo();\n    }\n  }, [handleUndo, handleRedo]);\n\n  const handleKeyUp = useCallback((e: KeyboardEvent) => {\n    if (e.code === 'Space' && tool === 'pan') {\n      // Switch back to previous tool when spacebar is released\n      setTool('pen');\n      if (stageRef.current) {\n        const stage = stageRef.current.getStage();\n        if (stage && stage.container) {\n          stage.container().style.cursor = 'default';\n        }\n      }\n    }\n  }, [tool]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [handleKeyDown, handleKeyUp]);\n  \n  // Clear canvas\n  const handleClearCanvas = useCallback(async () => {\n    // Store current strokes for potential undo (unused for now)\n    /*\n    const currentStrokes = [...strokes];\n    */\n\n    // Clear canvas\n    setStrokes([]);\n    setUndoStack([]);\n    \n    // Update database if authenticated\n    if (user) {\n      try {\n        await supabase.from('strokes').delete().eq('notebook_id', notebookId);\n      } catch (err) {\n        console.error('Error clearing canvas:', err);\n      }\n    }\n  }, [strokes, user, notebookId]);\n  \n  // Thread card handlers\n  const handleDragStart = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: true\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n\n  // Card click handler for the new unified card system\n  const handleCardClick = useCallback((cardId: string) => {\n    // This will be integrated with the unified view store\n    if (window.unifiedViewStore) {\n      window.unifiedViewStore.setActiveCard(cardId);\n    }\n  }, []);\n  \n  const handleDragMove = useCallback((id: string, x: number, y: number) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          x,\n          y\n        }\n      }\n    }));\n  }, []);\n  \n  const handleDragEnd = useCallback(async (id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isDragging: false\n        }\n      }\n    }));\n    \n    // Save position to database if authenticated\n    if (user) {\n      const conversation = conversationState.items.find(c => c.id === id);\n      const pos = conversationState.positions[id];\n      \n      if (conversation && pos) {\n        try {\n          await supabase\n            .from('conversations')\n            .update({\n              position: { x: pos.x, y: pos.y },\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', id);\n        } catch (err) {\n          console.error('Error updating position:', err);\n        }\n      }\n    }\n  }, [user, conversationState.items, conversationState.positions]);\n  \n  const handleToggleCollapse = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      positions: {\n        ...prev.positions,\n        [id]: {\n          ...prev.positions[id],\n          isCollapsed: !prev.positions[id].isCollapsed\n        }\n      },\n      activeConversation: id\n    }));\n  }, []);\n  \n  const handleToggleInfoDialog = useCallback((id: string) => {\n    setConversationState(prev => ({\n      ...prev,\n      activeInfoDialog: prev.activeInfoDialog === id ? null : id\n    }));\n  }, []);\n  \n  const handleEditContent = useCallback(async (id: string, text: string) => {\n    if (!user) return;\n    \n    try {\n      await supabase\n        .from('conversations')\n        .update({\n          user_content: text,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', id);\n        \n      setConversationState(prev => ({\n        ...prev,\n        items: prev.items.map(item => \n          item.id === id ? { ...item, user_content: text, updated_at: new Date().toISOString() } : item\n        )\n      }));\n    } catch (err) {\n      console.error('Error updating content:', err);\n    }\n  }, [user]);\n  \n  const handleContinueThread = useCallback((id: string) => {\n    // Conversation continuation logic\n    console.log('Continue thread:', id);\n  }, []);\n  \n  const handleCreateFollowUp = useCallback((id: string) => {\n    // Follow-up creation logic\n    console.log('Create follow-up:', id);\n  }, []);\n  \n  const handleCreateReference = useCallback((id: string, targetId?: string) => {\n    // Reference creation logic\n    console.log('Create reference from', id, 'to', targetId);\n  }, []);\n  \n  // System prompt handlers\n  const handleUpdateSystemPrompt = useCallback(async (prompt: string) => {\n    if (!user || !notebook) return;\n    \n    setSystemPrompt(prompt);\n    setIsSystemPromptModalOpen(false);\n    \n    try {\n      await supabase\n        .from('notebooks')\n        .update({\n          system_prompt: prompt,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', notebookId);\n    } catch (err) {\n      console.error('Error updating system prompt:', err);\n    }\n  }, [user, notebook, notebookId]);\n  \n  // Determine undo/redo availability\n  const undoAvailable = strokes.length > 0;\n  const redoAvailable = undoStack.length > 0;\n  \n  // Loading state\n  if (notebookLoading) {\n    return (\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-blue-500\"></div>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"flex flex-col h-screen w-full\">\n      {/* Toolbar */}\n      <ResponsiveToolbar\n        tool={tool}\n        setTool={safeSetTool}\n        scale={scale}\n        setScale={setScale}\n        setPosition={setPosition}\n        notebookId={notebookId}\n        notebookTitle={notebook?.title || 'Untitled Notebook'}\n        isCollaborative={notebook?.is_collaborative}\n        onClearCanvas={handleClearCanvas}\n        isPenMode={isPenMode}\n        setIsPenMode={setIsPenMode}\n        penSize={penSize}\n        setPenSize={setPenSize}\n        eraserSize={eraserSize}\n        setEraserSize={setEraserSize}\n        undoAvailable={undoAvailable}\n        redoAvailable={redoAvailable}\n        onUndo={handleUndo}\n        onRedo={handleRedo}\n        penColor={penColor}\n        setPenColor={setPenColor}\n        isSidePanelOpen={isSidePanelOpen}\n        toggleSidePanel={() => setIsSidePanelOpen(prev => !prev)}\n        onOpenSystemPromptModal={() => setIsSystemPromptModalOpen(true)}\n      />\n      \n      {/* Canvas Container */}\n      <div\n        ref={containerRef}\n        className=\"flex-1 relative bg-gray-50 overflow-hidden\"\n        style={{ height: 'calc(100vh - 100px)' }}\n      >\n        {/* Debug Panel */}\n        <DebugPanel />\n\n        <Stage\n          width={stageWidth}\n          height={stageHeight}\n          ref={stageRef}\n          draggable={tool === 'pan'}\n          onMouseDown={handleInputStart}\n          onMouseMove={handleInputMove}\n          onMouseUp={handleInputEnd}\n          onMouseLeave={handleInputEnd}\n          onTouchStart={handleInputStart}\n          onTouchMove={handleInputMove}\n          onTouchEnd={handleInputEnd}\n          onPointerDown={handleInputStart}\n          onPointerMove={handleInputMove}\n          onPointerUp={handleInputEnd}\n          position={position}\n          scale={{ x: scale, y: scale }}\n          onContextMenu={e => e.evt.preventDefault()}\n        >\n          {/* Background Layer */}\n          <Layer name=\"background-layer\">\n            <BackgroundLayer\n              width={stageWidth}\n              height={stageHeight}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Drawing Layer */}\n          <Layer name=\"drawing-layer\">\n            <DrawingLayer\n              strokes={strokes}\n              currentStroke={currentStroke}\n              scale={scale}\n              position={position}\n            />\n          </Layer>\n\n          {/* Text Layer */}\n          <Layer name=\"text-layer\">\n            <TextLayer\n              conversationState={conversationState}\n              notebookId={notebookId}\n              onDragStart={handleDragStart}\n              onDragMove={handleDragMove}\n              onDragEnd={handleDragEnd}\n              onToggleCollapse={handleToggleCollapse}\n              onToggleInfoDialog={handleToggleInfoDialog}\n              onEditContent={handleEditContent}\n              onContinueThread={handleContinueThread}\n              onCreateFollowUp={handleCreateFollowUp}\n              onCreateReference={handleCreateReference}\n              tool={tool}\n              isTextSelectionEnabled={tool === 'text'}\n              scale={scale}\n            />\n          </Layer>\n\n          {/* Selection Layer */}\n          {selectionRect.isActive && (\n            <Layer name=\"selection-layer\">\n              <Line\n                points={[\n                  selectionRect.x, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y,\n                  selectionRect.x + selectionRect.width, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y + selectionRect.height,\n                  selectionRect.x, selectionRect.y\n                ]}\n                stroke=\"rgba(0, 161, 255, 0.8)\"\n                strokeWidth={2 / scale}\n                dash={[5 / scale, 5 / scale]}\n                closed={true}\n                fill=\"rgba(0, 161, 255, 0.1)\"\n              />\n            </Layer>\n          )}\n        </Stage>\n      </div>\n      \n      {/* System Prompt Modal */}\n      {isSystemPromptModalOpen && (\n        <SystemPromptModal\n          isOpen={isSystemPromptModalOpen}\n          onClose={() => setIsSystemPromptModalOpen(false)}\n          initialPrompt={systemPrompt || ''}\n          onSave={handleUpdateSystemPrompt}\n        />\n      )}\n      \n      {/* Side Panel with ConversationSidePanel */}\n      {isSidePanelOpen && (\n        <ConversationSidePanel\n          notebookId={notebookId}\n          conversations={conversationState.items}\n          onEditTranscription={async (id, text) => {\n            try {\n              await supabase\n                .from('conversations')\n                .update({\n                  ai_response: text,\n                  updated_at: new Date().toISOString()\n                })\n                .eq('id', id);\n\n              // Update local state\n              setConversationState(prev => ({\n                ...prev,\n                items: prev.items.map(item =>\n                  item.id === id ? { ...item, ai_response: text, updated_at: new Date().toISOString() } : item\n                )\n              }));\n            } catch (err) {\n              console.error('Error updating AI response:', err);\n            }\n          }}\n          onSendMessage={async (message, mode) => {\n            try {\n              if (!user) return;\n\n              // Create a new conversation\n              const newConversation: Partial<Conversation> = {\n                id: generateUUID(), // Use our custom UUID generator\n                notebook_id: notebookId,\n                user_id: user.id,\n                user_content: message,\n                position: {\n                  x: -position.x + stageWidth / 2 - 150, // Center horizontally\n                  y: -position.y + stageHeight / 2 - 100 // Center vertically\n                },\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString(),\n                card_type: mode === 'chat' ? 'question' : 'note',\n                thread_id: conversationState.activeConversation || undefined,\n                is_thread_starter: !conversationState.activeConversation\n              };\n\n              // Save to database\n              const { data, error } = await supabase\n                .from('conversations')\n                .insert(newConversation)\n                .select()\n                .single();\n\n              if (error) throw error;\n\n              // Update local state\n              const savedConversation = data as Conversation;\n\n              setConversationState(prev => ({\n                ...prev,\n                items: [...prev.items, savedConversation],\n                positions: {\n                  ...prev.positions,\n                  [savedConversation.id]: {\n                    ...extractPositionFromJson(savedConversation.position),\n                    isCollapsed: false,\n                    isDragging: false\n                  }\n                },\n                activeConversation: savedConversation.id\n              }));\n\n              // Parliament functionality has been removed\n              if (mode === 'chat') {\n                // Process chat message without parliament\n                console.log('Chat message sent:', message);\n              }\n\n              return savedConversation;\n            } catch (err) {\n              console.error('Error sending message:', err);\n              throw err;\n            }\n          }}\n          onJumpToCard={(id) => {\n            // Find the card\n            const conversation = conversationState.items.find(c => c.id === id);\n            const position = conversationState.positions[id];\n\n            if (conversation && position) {\n              // Center on the card\n              setPosition({\n                x: -position.x + stageWidth / 2 - 150,\n                y: -position.y + stageHeight / 2 - 100\n              });\n\n              // Set as active\n              setConversationState(prev => ({\n                ...prev,\n                activeConversation: id\n              }));\n            }\n          }}\n          onClose={() => setIsSidePanelOpen(false)}\n          isOpen={isSidePanelOpen}\n          isFullScreen={false}\n          onToggleFullScreen={() => {\n            // This would toggle full-screen mode if implemented\n            console.log('Toggle full-screen mode');\n          }}\n          systemPrompt={systemPrompt}\n        />\n      )}\n\n      {/* Parliament functionality has been removed */}\n    </div>\n  );\n};\n\nexport default CanvasContainer;\nðŸ” Looking for ChatPanel or ChatInterface components...\n\nðŸ“„ --- File: ./src/components/conversation/ChatPanel.tsx ---\n// src/components/conversation/ChatPanel.tsx\nimport React, { useState, useEffect, useRef } from 'react';\nimport { useNodeStore } from '@/stores/nodeStore';\nimport ChatInput from './ChatInput';\nimport ChatMessage from './ChatMessage';\nimport { Node } from '@/types/thread';\nimport { supabase } from '@/lib/supabaseClient';\n\ninterface ChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string | null;\n  activeNodeId: string | null;\n  onClose: () => void;\n}\n\ninterface Message {\n  id: string;\n  role: 'user' | 'assistant' | 'system';\n  content: string;\n  nodeId?: string;\n  timestamp: string;\n}\n\nconst ChatPanel: React.FC<ChatPanelProps> = ({\n  notebookId,\n  systemPrompt,\n  activeNodeId,\n  onClose\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [contextMode, setContextMode] = useState<'all' | 'thread'>('thread');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  const { nodes, relationships, getNodeRelationships, updateNode } = useNodeStore();\n  \n  // Initialize with system prompt if available\n  useEffect(() => {\n    if (systemPrompt) {\n      setMessages([{\n        id: 'system-prompt',\n        role: 'system',\n        content: systemPrompt,\n        timestamp: new Date().toISOString()\n      }]);\n    } else {\n      setMessages([]);\n    }\n  }, [systemPrompt]);\n  \n  // Update messages when active node changes\n  useEffect(() => {\n    if (activeNodeId) {\n      loadThreadMessages(activeNodeId);\n    } else {\n      // Reset to just system prompt if no active node\n      if (systemPrompt) {\n        setMessages([{\n          id: 'system-prompt',\n          role: 'system',\n          content: systemPrompt,\n          timestamp: new Date().toISOString()\n        }]);\n      } else {\n        setMessages([]);\n      }\n    }\n  }, [activeNodeId, systemPrompt]);\n  \n  // Scroll to bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n  \n  // Load messages for a thread\n  const loadThreadMessages = async (nodeId: string) => {\n    try {\n      // Start with system prompt if available\n      const initialMessages: Message[] = systemPrompt \n        ? [{\n            id: 'system-prompt',\n            role: 'system',\n            content: systemPrompt,\n            timestamp: new Date().toISOString()\n          }] \n        : [];\n      \n      if (contextMode === 'thread') {\n        // Get thread history by traversing relationships\n        const threadMessages = await getThreadMessages(nodeId);\n        setMessages([...initialMessages, ...threadMessages]);\n      } else {\n        // Get all nodes for broader context\n        const allNodeMessages = getAllNodeMessages();\n        setMessages([...initialMessages, ...allNodeMessages]);\n      }\n    } catch (error) {\n      console.error('Error loading thread messages:', error);\n    }\n  };\n  \n  // Get message history for a specific thread\n  const getThreadMessages = async (nodeId: string): Promise<Message[]> => {\n    const result: Message[] = [];\n    const visited = new Set<string>();\n    \n    // Recursive function to traverse thread\n    const traverse = (id: string, depth: number = 0) => {\n      if (visited.has(id)) return;\n      visited.add(id);\n      \n      const node = nodes[id];\n      if (!node) return;\n      \n      // Add this node as a message\n      result.push({\n        id: node.id,\n        role: node.type === 'question' || node.type === 'note' ? 'user' : 'assistant',\n        content: node.content,\n        nodeId: node.id,\n        timestamp: node.created_at\n      });\n      \n      // Get parent relationships (nodes that this node extends from)\n      const parentRels = relationships.filter(r => \n        r.to_node_id === id && r.type === 'extends'\n      );\n      \n      // Traverse parents\n      parentRels.forEach(rel => {\n        traverse(rel.from_node_id, depth + 1);\n      });\n      \n      // Get child relationships (nodes that extend from this node)\n      const childRels = relationships.filter(r => \n        r.from_node_id === id && r.type === 'extends'\n      );\n      \n      // Traverse children\n      childRels.forEach(rel => {\n        traverse(rel.to_node_id, depth + 1);\n      });\n    };\n    \n    // Start traversal from the given node\n    traverse(nodeId);\n    \n    // Sort by timestamp\n    return result.sort((a, b) => \n      new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n    );\n  };\n  \n  // Get all nodes as messages\n  const getAllNodeMessages = (): Message[] => {\n    return Object.values(nodes)\n      .filter(node => node.content.trim() !== '')\n      .map(node => ({\n        id: node.id,\n        role: node.type === 'question' || node.type === 'note' ? 'user' : 'assistant',\n        content: node.content,\n        nodeId: node.id,\n        timestamp: node.created_at\n      }))\n      .sort((a, b) => \n        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n      );\n  };\n  \n  // Handle sending a message\n  const handleSendMessage = async (content: string) => {\n    try {\n      setIsLoading(true);\n      \n      // Add user message to chat\n      const userMessage: Message = {\n        id: `user-${Date.now()}`,\n        role: 'user',\n        content,\n        nodeId: activeNodeId || undefined,\n        timestamp: new Date().toISOString()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare context for AI\n      const contextMessages = messages\n        .filter(msg => msg.role !== 'system') // Filter out system messages\n        .concat(userMessage) // Add the new user message\n        .map(msg => ({\n          role: msg.role,\n          content: msg.content\n        }));\n      \n      // Add system message at the beginning if available\n      if (systemPrompt) {\n        contextMessages.unshift({\n          role: 'system',\n          content: systemPrompt\n        });\n      }\n      \n      // Call API to get AI response\n      const response = await fetch('/api/claude/chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          messages: contextMessages,\n          notebookId\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Failed to get AI response');\n      }\n      \n      const { answer } = await response.json();\n      \n      // Add AI response to chat\n      const aiMessage: Message = {\n        id: `assistant-${Date.now()}`,\n        role: 'assistant',\n        content: answer,\n        timestamp: new Date().toISOString()\n      };\n      \n      setMessages(prev => [...prev, aiMessage]);\n      \n      // Update the node content if we're editing an existing node\n      if (activeNodeId) {\n        await updateNode(activeNodeId, {\n          content: answer\n        });\n      }\n      \n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"flex flex-col h-full\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-200 px-4 py-3\">\n        <div className=\"flex items-center\">\n          <h3 className=\"font-medium text-gray-800\">\n            {activeNodeId \n              ? `Chat with ${nodes[activeNodeId]?.type || 'Node'}`\n              : 'Notebook Chat'\n            }\n          </h3>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className={`text-xs px-2 py-1 rounded ${\n              contextMode === 'thread'\n                ? 'bg-blue-100 text-blue-800'\n                : 'bg-gray-100 text-gray-600'\n            }`}\n            onClick={() => setContextMode('thread')}\n            title=\"Only include messages in the current thread\"\n          >\n            Thread\n          </button>\n          <button\n            className={`text-xs px-2 py-1 rounded ${\n              contextMode === 'all'\n                ? 'bg-blue-100 text-blue-800'\n                : 'bg-gray-100 text-gray-600'\n            }`}\n            onClick={() => setContextMode('all')}\n            title=\"Include all messages in the notebook\"\n          >\n            All\n          </button>\n          <button\n            className=\"ml-2 text-gray-500 hover:text-gray-700\"\n            onClick={onClose}\n            aria-label=\"Close chat panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </button>\n        </div>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {/* System message indicator */}\n        {systemPrompt && (\n          <div className=\"flex justify-center mb-4\">\n            <span className=\"text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded-full\">\n              Using custom system prompt\n            </span>\n          </div>\n        )}\n        \n        {/* Message list */}\n        {messages\n          .filter(msg => msg.role !== 'system') // Don't show system messages\n          .map((message) => (\n            <ChatMessage\n              key={message.id}\n              message={message}\n              isHighlighted={message.nodeId === activeNodeId}\n            />\n          ))}\n        \n        {/* Loading indicator */}\n        {isLoading && (\n          <div className=\"flex justify-center\">\n            <div className=\"animate-pulse flex space-x-2\">\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n              <div className=\"h-2 w-2 bg-gray-400 rounded-full\"></div>\n            </div>\n          </div>\n        )}\n        \n        {/* Element to scroll to */}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input */}\n      <ChatInput\n        notebookId={notebookId}\n        onSendMessage={handleSendMessage}\n        activeNodeId={activeNodeId}\n        disabled={isLoading}\n      />\n    </div>\n  );\n};\n\nexport default ChatPanel;\nðŸ“„ --- File: ./src/components/ui/BasicChatPanel.tsx ---\n/**\n * BasicChatPanel Component\n * \n * A very simple chat interface using Vercel AI SDK with direct rendering\n */\nimport React, { useState, useRef } from 'react';\nimport { useChat } from 'ai/react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface BasicChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst BasicChatPanel: React.FC<BasicChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<{ role: string; content: string }[]>([]);\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Use Vercel AI's useChat hook to handle API interactions\n  const { input, handleInputChange, handleSubmit, isLoading, error } = useChat({\n    api: '/api/claude/chat-simple',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: 'claude-3-5-sonnet-20240620',\n      includeUserContext: true\n    },\n    onResponse(response) {\n      // This is called when the API response starts\n      console.log(\"API Response started:\", response.status);\n    },\n    onFinish(message) {\n      // This is called when the API response is complete\n      console.log(\"Message received:\", message);\n      \n      // Update our messages array with both the user question and AI response\n      setMessages(prevMessages => [\n        ...prevMessages, \n        {\n          role: 'assistant',\n          content: message.content\n        }\n      ]);\n      \n      setIsSubmitting(false);\n    },\n    onError(error) {\n      console.error(\"Chat API error:\", error);\n      setIsSubmitting(false);\n    }\n  });\n\n  // Custom submit handler to manually track messages\n  const submitMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!input.trim() || isLoading || isSubmitting) return;\n    \n    try {\n      setIsSubmitting(true);\n      \n      // Add user message to our local messages array\n      setMessages(prevMessages => [\n        ...prevMessages, \n        {\n          role: 'user',\n          content: input\n        }\n      ]);\n      \n      console.log(\"Submitting message:\", input.substring(0, 30));\n      \n      // Set safety timeout to clear loading state if something goes wrong\n      const safetyTimeout = setTimeout(() => {\n        console.log(\"Safety timeout triggered - clearing loading state\");\n        setIsSubmitting(false);\n      }, 10000); // 10 second timeout\n      \n      try {\n        // Submit using Vercel AI SDK\n        await handleSubmit(e);\n        clearTimeout(safetyTimeout);\n      } catch (submitError) {\n        console.error(\"Error in handleSubmit:\", submitError);\n        clearTimeout(safetyTimeout);\n        setIsSubmitting(false);\n      }\n      \n    } catch (error) {\n      console.error(\"Error in submitMessage:\", error);\n      setIsSubmitting(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Basic Chat</h2>\n        <p className=\"text-xs text-gray-500\">Using Claude 3.5 Sonnet</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {(isLoading || isSubmitting) && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={submitMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={handleInputChange}\n            ref={inputRef}\n            disabled={isLoading || isSubmitting}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || isSubmitting || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading || isSubmitting ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Debug Info */}\n        <div className=\"mt-2 text-xs\">\n          <div className=\"text-gray-500\">\n            Status: {isLoading ? \"Loading\" : isSubmitting ? \"Submitting\" : \"Ready\"}\n          </div>\n          \n          {/* Error display */}\n          {error && (\n            <div className=\"mt-1 p-2 text-sm text-red-600 bg-red-50 rounded\">\n              Error: {error.message || \"Unknown error\"}\n            </div>\n          )}\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default BasicChatPanel;\nðŸ“„ --- File: ./src/components/ui/ChatPanel.tsx ---\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Thread } from '@/types/thread';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface ChatPanelProps {\n  notebookId: string;\n  activeThreadId: string | null;\n  onClose: () => void;\n  onNewThreadCreated: (thread: Thread) => void;\n}\n\n/**\n * ChatPanel component for notebook side panel\n * Displays conversation threads and allows for new messages\n */\nconst ChatPanel: React.FC<ChatPanelProps> = ({\n  notebookId,\n  activeThreadId,\n  onClose,\n  onNewThreadCreated\n}) => {\n  const { user } = useAuth();\n  const [message, setMessage] = useState('');\n  const [isLoading, setIsLoading] = useState(false);\n  const [threads, setThreads] = useState<Thread[]>([]);\n  const messageEndRef = useRef<HTMLDivElement>(null);\n  \n  // Load threads when panel opens\n  useEffect(() => {\n    const loadThreads = async () => {\n      setIsLoading(true);\n      console.log('ChatPanel: Loading threads for notebook:', notebookId);\n\n      try {\n        // This would be replaced with actual thread loading logic\n        // For now, we'll just show a placeholder message\n        setThreads([]);\n\n        // Later you can implement API call to load threads\n        // Example:\n        // const { data, error } = await supabase\n        //   .from('threads')\n        //   .select('*')\n        //   .eq('notebook_id', notebookId)\n        //   .order('created_at', { ascending: false });\n        //\n        // if (error) throw error;\n        // setThreads(data || []);\n\n      } catch (error) {\n        console.error('Error loading threads:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadThreads();\n    console.log('ChatPanel mounted for notebook:', notebookId);\n\n    return () => {\n      console.log('ChatPanel unmounted');\n    };\n  }, [notebookId]);\n  \n  // Scroll to bottom when new messages arrive\n  useEffect(() => {\n    messageEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [threads]);\n  \n  // Create a new thread or add message to existing thread\n  const handleSendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!message.trim() || !user) return;\n    \n    setIsLoading(true);\n    \n    try {\n      // Implement thread creation or message adding logic here\n      console.log('Sending message:', message);\n      \n      // Create a placeholder thread for demo purposes\n      const newThread: Thread = {\n        id: `thread-${Date.now()}`,\n        notebookId,\n        title: 'New Thread',\n        position: { x: 100, y: 100 },\n        messages: [\n          {\n            id: `msg-${Date.now()}`,\n            threadId: `thread-${Date.now()}`,\n            content: message,\n            role: 'user',\n            createdAt: new Date().toISOString()\n          }\n        ],\n        parentId: undefined,\n        referencedThreads: [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        cardType: 'note',\n        handwritingStyle: 'neat',\n        isMinimized: false,\n        zIndex: 1\n      };\n      \n      // Add the new thread to our local state\n      setThreads(prev => [...prev, newThread]);\n      \n      // Notify parent component\n      onNewThreadCreated(newThread);\n      \n      // Clear the input\n      setMessage('');\n    } catch (error) {\n      console.error('Error sending message:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  return (\n    <div className=\"w-80 h-full bg-white border-l border-gray-200 flex flex-col\">\n      {/* Header */}\n      <div className=\"p-4 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-lg\">Notebook Chat</h2>\n        <button\n          onClick={onClose}\n          className=\"rounded-full p-1 hover:bg-gray-100\"\n          aria-label=\"Close panel\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 text-gray-500\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n            <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n          </svg>\n        </button>\n      </div>\n      \n      {/* Chat messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {isLoading && threads.length === 0 ? (\n          <div className=\"flex justify-center py-10\">\n            <Spinner size=\"md\" color=\"primary\" label=\"Loading conversations...\" />\n          </div>\n        ) : threads.length === 0 ? (\n          <div className=\"text-center py-10 text-gray-500\">\n            <p>No conversations yet. Start by sending a message.</p>\n          </div>\n        ) : (\n          threads.map(thread => (\n            <div \n              key={thread.id} \n              className={`p-3 rounded-lg ${thread.id === activeThreadId ? 'bg-blue-50 border border-blue-100' : 'bg-gray-50'}`}\n            >\n              <div className=\"font-medium text-sm text-gray-700 mb-1\">{thread.title}</div>\n              <div className=\"space-y-2\">\n                {thread.messages.map(msg => (\n                  <div key={msg.id} className={`flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>\n                    <div className={`max-w-[80%] px-3 py-2 rounded-lg ${\n                      msg.role === 'user' \n                        ? 'bg-blue-600 text-white' \n                        : 'bg-gray-200 text-gray-800'\n                    }`}>\n                      {msg.content}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          ))\n        )}\n        <div ref={messageEndRef} />\n      </div>\n      \n      {/* Input area */}\n      <div className=\"p-4 border-t border-gray-200\">\n        <form onSubmit={handleSendMessage} className=\"flex\">\n          <input\n            type=\"text\"\n            placeholder=\"Type a message...\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-l-md focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500\"\n            value={message}\n            onChange={(e) => setMessage(e.target.value)}\n            disabled={isLoading}\n          />\n          <button\n            type=\"submit\"\n            className=\"px-4 py-2 bg-blue-600 text-white rounded-r-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 disabled:opacity-50\"\n            disabled={!message.trim() || isLoading}\n          >\n            {isLoading ? (\n              <Spinner size=\"sm\" color=\"white\" />\n            ) : (\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10.293 3.293a1 1 0 011.414 0l6 6a1 1 0 010 1.414l-6 6a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-4.293-4.293a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n              </svg>\n            )}\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default ChatPanel;\nðŸ“„ --- File: ./src/components/ui/DirectChatPanel.tsx ---\n/**\n * DirectChatPanel - Simple chat panel using direct fetch instead of the AI SDK\n */\nimport React, { useState, useRef } from 'react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface Message {\n  role: 'user' | 'assistant';\n  content: string;\n}\n\ninterface DirectChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst DirectChatPanel: React.FC<DirectChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  // Send a message to the API\n  const sendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!input.trim() || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Add the user message to the list\n      const userMessage: Message = {\n        role: 'user',\n        content: input.trim()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare the messages to send to the API\n      const messagesToSend = [\n        { role: 'system', content: systemPrompt },\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        userMessage\n      ];\n      \n      // Make the API request\n      const response = await fetch('/api/claude/chat-simple', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: messagesToSend,\n          notebookId,\n          model: 'claude-3-5-sonnet-20240620',\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      console.log('API response:', result);\n      \n      // Handle the assistant's response\n      if (Array.isArray(result) && result.length > 0) {\n        const assistantMessage = result[0];\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: assistantMessage.content\n        }]);\n      } else if (result.content) {\n        setMessages(prev => [...prev, {\n          role: 'assistant',\n          content: result.content\n        }]);\n      } else {\n        setError('Received unexpected response format from API');\n      }\n      \n      // Clear the input\n      setInput(\"\");\n      \n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Direct Chat</h2>\n        <p className=\"text-xs text-gray-500\">Using Claude 3.5 Sonnet</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {isLoading && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={sendMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            disabled={isLoading}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Error Display */}\n        {error && (\n          <div className=\"mt-2 p-2 text-sm text-red-600 bg-red-50 rounded\">\n            Error: {error}\n          </div>\n        )}\n        \n        {/* Debug Info */}\n        <div className=\"mt-2 text-xs text-gray-500\">\n          Status: {isLoading ? \"Loading\" : \"Ready\"} | Messages: {messages.length}\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default DirectChatPanel;\nðŸ“„ --- File: ./src/components/ui/SimpleChatPanel.tsx ---\n/**\n * SimpleChatPanel Component\n * \n * A clean, simple chat interface using Vercel AI SDK\n */\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { useChat, type Message } from 'ai/react';\nimport { Button } from '@/components/shadcn/button';\nimport { Textarea } from '@/components/shadcn/textarea';\nimport { Spinner } from '@/components/shadcn/spinner';\nimport { nodeIntegration } from '@/lib/chat';\nimport { supabase } from '@/lib/supabaseClient';\n\ninterface SimpleChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  onClose?: () => void;\n  className?: string;\n  initialQuestion?: string;\n}\n\nexport const SimpleChatPanel: React.FC<SimpleChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  onClose,\n  className = \"\",\n  initialQuestion,\n}) => {\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionSentRef = useRef(false);\n  const inputRef = useRef<HTMLTextAreaElement>(null);\n  \n  // Initialize chat with Vercel AI SDK\n  const chatHandler = useChat({\n    api: '/api/claude/chat-simple',\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: 'claude-3-5-sonnet-20240620',\n      includeUserContext: true\n    },\n    onResponse: (response) => {\n      console.log('Chat response started:', response.status);\n    },\n    onFinish: async (message) => {\n      try {\n        // Create a node for the AI response\n        if (message?.content) {\n          await handleNodeCreation(message, 'assistant');\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle node creation\n  const handleNodeCreation = async (message: Message, role: 'user' | 'assistant') => {\n    try {\n      console.log(\"Node creation skipped for chat UI simplicity\");\n      // Return a mock node to avoid errors\n      const mockNode = {\n        id: `mock-${Date.now()}`,\n        type: role === 'user' ? 'question' : 'response',\n        content: message.content\n      };\n      return mockNode;\n    } catch (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n  };\n  \n  // Mock find user message node - simplified for this component\n  const findUserMessageNode = async () => {\n    console.log(\"User message node lookup skipped for simplicity\");\n    return null;\n  };\n\n  // We're now using Vercel AI's built-in handlers directly in the form\n  \n  // Send initial question if provided - simplified for direct use\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionSentRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionSentRef.current = true;\n          setIsProcessing(true);\n          \n          console.log(\"Sending initial question:\", initialQuestion);\n          \n          // Send using the handler's method\n          await chatHandler.setInput(initialQuestion);\n          \n          // Create a mock form event\n          const fakeEvent = {\n            preventDefault: () => {}\n          } as React.FormEvent;\n          \n          await chatHandler.handleSubmit(fakeEvent);\n          \n          console.log(\"Initial question sent\");\n        } catch (error) {\n          console.error('Error sending initial question:', error);\n        } finally {\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler]);\n  \n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow-md ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n        <h2 className=\"font-semibold text-gray-700\">Chat</h2>\n        {onClose && (\n          <Button \n            onClick={onClose}\n            size=\"sm\"\n            variant=\"ghost\"\n            aria-label=\"Close panel\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n            </svg>\n          </Button>\n        )}\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        {chatHandler.messages\n          .filter(msg => msg.role !== 'system')\n          .map((message, index) => {\n            // Check if there's valid content to display\n            if (!message.content && message.role !== 'assistant') {\n              return null;\n            }\n            \n            return (\n              <div \n                key={message.id || `message-${index}`} \n                className={`mb-4 ${message.role === 'user' ? 'ml-auto max-w-[80%]' : 'mr-auto max-w-[80%]'}`}\n              >\n                <div \n                  className={`p-3 rounded-lg ${\n                    message.role === 'user' \n                      ? 'bg-blue-500 text-white' \n                      : 'bg-gray-100 text-gray-800'\n                  }`}\n                >\n                  {typeof message.content === 'string' ? message.content : JSON.stringify(message.content)}\n                </div>\n              </div>\n            );\n          })}\n          \n        {/* Show additional messages from the chat state that might not be in messages array */}\n        {chatHandler.data?.map((item, i) => {\n          if (item.role === 'assistant' && \n              !chatHandler.messages.some(m => m.id === item.id)) {\n            return (\n              <div key={`data-${item.id || i}`} className=\"mb-4 mr-auto max-w-[80%]\">\n                <div className=\"p-3 rounded-lg bg-gray-100 text-gray-800\">\n                  {typeof item.content === 'string' ? item.content : JSON.stringify(item.content)}\n                </div>\n                <div className=\"text-xs text-gray-500 mt-1\">Assistant response from data array</div>\n              </div>\n            );\n          }\n          return null;\n        })}\n        \n        {chatHandler.isLoading && (\n          <div className=\"flex justify-center items-center p-4\">\n            <Spinner className=\"w-6 h-6 text-blue-500\" />\n          </div>\n        )}\n        \n        {/* Debug info - show all messages for troubleshooting */}\n        <div className=\"mt-4 p-2 border border-gray-200 rounded bg-gray-50\">\n          <p className=\"text-xs text-gray-500 mb-1\">Debug: Message Count = {chatHandler.messages.length}</p>\n          {chatHandler.messages.map((msg, idx) => (\n            <div key={`debug-${msg.id || idx}`} className=\"text-xs mb-1\">\n              <strong>{msg.role}:</strong> {typeof msg.content === 'string' \n                ? (msg.content.substring(0, 30) + (msg.content.length > 30 ? '...' : ''))\n                : 'complex content'}\n            </div>\n          ))}\n          \n          {chatHandler.data && chatHandler.data.length > 0 && (\n            <>\n              <p className=\"text-xs text-gray-500 mt-2 mb-1\">Data array: {chatHandler.data.length} items</p>\n              {chatHandler.data.map((item, idx) => (\n                <div key={`data-debug-${idx}`} className=\"text-xs mb-1\">\n                  <strong>{item.role}:</strong> {typeof item.content === 'string' \n                    ? (item.content.substring(0, 30) + (item.content.length > 30 ? '...' : ''))\n                    : 'complex content'}\n                </div>\n              ))}\n            </>\n          )}\n        </div>\n      </div>\n      \n      {/* Input - Use Vercel AI's input handling */}\n      <form onSubmit={chatHandler.handleSubmit} className=\"border-t border-gray-200 p-3\">\n        <div className=\"relative\">\n          <Textarea\n            ref={inputRef}\n            value={chatHandler.input}\n            onChange={(e) => chatHandler.setInput(e.target.value)}\n            placeholder=\"Type your message...\"\n            className=\"resize-none min-h-[80px] pr-16\"\n            disabled={isProcessing || chatHandler.isLoading}\n          />\n          <Button \n            type=\"submit\"\n            className=\"absolute bottom-2 right-2\"\n            disabled={isProcessing || chatHandler.isLoading || !chatHandler.input.trim()}\n          >\n            {isProcessing || chatHandler.isLoading ? (\n              <Spinner className=\"w-5 h-5\" />\n            ) : (\n              <svg className=\"h-5 w-5\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\" />\n              </svg>\n            )}\n          </Button>\n        </div>\n        <p className=\"text-xs text-gray-500 mt-1\">\n          Simple chat interface using Vercel AI SDK\n        </p>\n      </form>\n    </div>\n  );\n};\n\nexport default SimpleChatPanel;\nðŸ“„ --- File: ./src/components/ui/StreamingChatPanel.tsx ---\n/**\n * StreamingChatPanel - Chat panel with streaming responses from Claude\n */\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\ninterface Message {\n  role: 'user' | 'assistant';\n  content: string;\n  id?: string;\n}\n\ninterface StreamingChatPanelProps {\n  notebookId: string;\n  systemPrompt?: string;\n  className?: string;\n}\n\nconst StreamingChatPanel: React.FC<StreamingChatPanelProps> = ({\n  notebookId,\n  systemPrompt = \"You are a helpful assistant embedded in a notebook application.\",\n  className = \"\",\n}) => {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [streamedText, setStreamedText] = useState<string>(\"\");\n  \n  // Reference to the message container for auto-scrolling\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  // Auto-scroll to bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages, streamedText]);\n  \n  // Function to stream responses from the API\n  const streamResponse = async (response: Response) => {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('Response body is not readable');\n    }\n    \n    // Reset streamed text\n    setStreamedText(\"\");\n    \n    // Function to process stream chunks\n    const processText = async (): Promise<void> => {\n      try {\n        const { done, value } = await reader.read();\n        if (done) {\n          // When streaming is complete, add the message to the messages array\n          if (streamedText) {\n            setMessages(prev => [...prev, {\n              role: 'assistant',\n              content: streamedText\n            }]);\n            setStreamedText(\"\");\n          }\n          return;\n        }\n        \n        // Decode the chunk and append to streamed text\n        const text = new TextDecoder().decode(value);\n        try {\n          // Split response into individual events\n          const events = text.trim().split('\\\\n\\\\n').filter(Boolean);\n          \n          // Process each event\n          events.forEach(eventStr => {\n            if (eventStr.startsWith('data:')) {\n              const jsonStr = eventStr.slice(5).trim();\n              try {\n                if (jsonStr === '[DONE]') return;\n                \n                const data = JSON.parse(jsonStr);\n                if (data.choices && data.choices[0]?.delta?.content) {\n                  setStreamedText(prev => prev + data.choices[0].delta.content);\n                } else if (data.content) {\n                  setStreamedText(prev => prev + data.content);\n                }\n              } catch (err) {\n                console.error('Error parsing event JSON:', jsonStr, err);\n              }\n            }\n          });\n        } catch (err) {\n          console.error('Error processing text chunk:', err);\n          // As a fallback, just append the raw text\n          setStreamedText(prev => prev + text);\n        }\n        \n        // Continue reading\n        return processText();\n      } catch (err) {\n        console.error('Error reading stream:', err);\n        reader.cancel();\n        throw err;\n      }\n    };\n    \n    await processText();\n  };\n  \n  // Send a message to the API\n  const sendMessage = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!input.trim() || isLoading) return;\n    \n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Add the user message to the list\n      const userMessage: Message = {\n        role: 'user',\n        content: input.trim()\n      };\n      \n      setMessages(prev => [...prev, userMessage]);\n      \n      // Prepare the messages to send to the API\n      const messagesToSend = [\n        { role: 'system', content: systemPrompt },\n        ...messages.map(msg => ({ role: msg.role, content: msg.content })),\n        userMessage\n      ];\n      \n      // Make the API request with stream option\n      const response = await fetch('/api/claude/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: messagesToSend,\n          notebookId,\n          model: 'claude-3-5-sonnet-20240620',\n          stream: true\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${response.statusText}`);\n      }\n      \n      // Clear the input\n      setInput(\"\");\n      \n      // Process the stream\n      await streamResponse(response);\n      \n    } catch (err) {\n      console.error('Error sending message:', err);\n      setError(err instanceof Error ? err.message : 'Unknown error occurred');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return (\n    <div className={`flex flex-col h-full bg-white rounded-lg shadow ${className}`}>\n      {/* Header */}\n      <div className=\"bg-gray-100 p-3 border-b border-gray-200\">\n        <h2 className=\"font-semibold text-gray-700\">Streaming Chat</h2>\n        <p className=\"text-xs text-gray-500\">With real-time responses</p>\n      </div>\n      \n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message, index) => (\n          <div \n            key={index} \n            className={`p-3 rounded-lg ${\n              message.role === 'user' \n                ? 'bg-blue-500 text-white ml-auto max-w-[80%]' \n                : 'bg-gray-100 text-gray-800 mr-auto max-w-[80%]'\n            }`}\n          >\n            <div className=\"text-sm font-semibold mb-1\">\n              {message.role === 'user' ? 'You' : 'Assistant'}\n            </div>\n            <div className=\"whitespace-pre-wrap\">{message.content}</div>\n          </div>\n        ))}\n        \n        {/* Streaming response */}\n        {streamedText && (\n          <div className=\"p-3 rounded-lg bg-gray-100 text-gray-800 mr-auto max-w-[80%]\">\n            <div className=\"text-sm font-semibold mb-1\">\n              Assistant <span className=\"text-xs text-gray-500\">(streaming)</span>\n            </div>\n            <div className=\"whitespace-pre-wrap\">{streamedText}</div>\n          </div>\n        )}\n        \n        {/* Loading indicator */}\n        {isLoading && !streamedText && (\n          <div className=\"flex items-center space-x-2 bg-gray-100 p-3 rounded-lg mr-auto max-w-[80%]\">\n            <Spinner size=\"sm\" />\n            <span>Thinking...</span>\n          </div>\n        )}\n        \n        {/* Invisible element for auto-scrolling */}\n        <div ref={messagesEndRef} />\n      </div>\n      \n      {/* Input Form */}\n      <form onSubmit={sendMessage} className=\"border-t border-gray-200 p-4\">\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n            placeholder=\"Type your message...\"\n            value={input}\n            onChange={(e) => setInput(e.target.value)}\n            disabled={isLoading}\n          />\n          <Button \n            type=\"submit\" \n            disabled={isLoading || !input.trim()}\n            className=\"bg-blue-600 hover:bg-blue-700 text-white\"\n          >\n            {isLoading ? <Spinner size=\"sm\" color=\"white\" /> : 'Send'}\n          </Button>\n        </div>\n        \n        {/* Error Display */}\n        {error && (\n          <div className=\"mt-2 p-2 text-sm text-red-600 bg-red-50 rounded\">\n            Error: {error}\n          </div>\n        )}\n      </form>\n    </div>\n  );\n};\n\nexport default StreamingChatPanel;%                                  ]]]we have many duplicate files and i'd like your help making it work with Quick Start\nYou can quickly add a chatbot to your project by using Shadcn CLI command:\n\nnpx shadcn@latest add https://ui.llamaindex.ai/r/chat.json\nManual Installation\nTo install the package, run the following command in your project directory:\n\nnpm install @llamaindex/chat-ui\nFeatures\nPre-built chat components (e.g., message bubbles, input fields)\nMinimal styling, fully customizable with Tailwind CSS\nCustom widgets to extend components (e.g., for rendering generated or retrieved documents)\nTypeScript support for type safety\nEasy integration with LLM backends like Vercel Ai\nCode and Latex styling with highlight.js and katex\nUsage\nInstall the package\nnpm install @llamaindex/chat-ui\nConfigure Tailwind CSS to include the chat-ui components\nFor Tailwind CSS version 4.x, update globals.css to include the chat-ui components (update the relative path to node_modules if necessary):\n\n@source '../node_modules/@llamaindex/chat-ui/**/*.{ts,tsx}';\nFor Tailwind CSS version 3.x, you need to add the following to your tailwind.config.ts file:\n\nmodule.exports = {\n  content: [\n    'app/**/*.{ts,tsx}',\n    'node_modules/@llamaindex/chat-ui/**/*.{ts,tsx}',\n  ],\n  // ...\n}\nImport the components and use them\nThe easiest way to get started is to connect the whole ChatSection component with useChat hook from vercel/ai:\n\nimport { ChatSection } from '@llamaindex/chat-ui'\nimport { useChat } from 'ai/react'\n\nconst ChatExample = () => {\n  const handler = useChat()\n  return <ChatSection handler={handler} />\n}\nThis simple example looks like this:\n\noutput\n\nComponent Composition\nComponents are designed to be composable. You can use them as is:\n\nimport { ChatSection } from '@llamaindex/chat-ui'\nimport { useChat } from 'ai/react'\n\nconst ChatExample = () => {\n  const handler = useChat()\n  return <ChatSection handler={handler} />\n}\nOr you can extend them with your own children components:\n\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui'\nimport LlamaCloudSelector from './components/LlamaCloudSelector' // your custom component\nimport { useChat } from 'ai/react'\n\nconst ChatExample = () => {\n  const handler = useChat()\n  return (\n    <ChatSection handler={handler}>\n      <ChatMessages />\n      <ChatInput>\n        <ChatInput.Form className=\"bg-lime-500\">\n          <ChatInput.Field type=\"textarea\" />\n          <ChatInput.Upload />\n          <LlamaCloudSelector /> {/* custom component */}\n          <ChatInput.Submit />\n        </ChatInput.Form>\n      </ChatInput>\n    </ChatSection>\n  )\n}\nYour custom component can use the useChatUI hook to send additional data to the chat API endpoint:\n\nimport { useChatInput } from '@llamaindex/chat-ui'\n\nconst LlamaCloudSelector = () => {\n  const { requestData, setRequestData } = useChatUI()\n  return (\n    <div>\n      <select\n        value={requestData?.model}\n        onChange={e => setRequestData({ model: e.target.value })}\n      >\n        <option value=\"llama-3.1-70b-instruct\">Pipeline 1</option>\n        <option value=\"llama-3.1-8b-instruct\">Pipeline 2</option>\n      </select>\n    </div>\n  )\n}and shadcn and our node based chat response - i just want one place for truth for chat and i want you to give me a command that can help me delete all extra files from the terminal command "
          }
        ],
        "files": [
          {
            "file_name": "paste.txt"
          }
        ]
      }
    },
    {
      "id": "5f122db5-8103-4481-9023-0b81b8b9d2fc",
      "role": "assistant",
      "content": "The user has shared a large amount of code related to a chat interface for a notebook/canvas application. It seems they have multiple implementations of chat panels and are asking for help to streamline things, with a clear \"source of truth\" for chat functionality.\n\nThe main issue appears to be that they have many duplicate or similar chat components:\n- ChatPanel\n- AISdkChat\n- LlamaChat\n- LlamaIndexChat\n- DirectChatPanel\n- StreamingChatPanel\n- SimpleChatPanel\n- BasicChatPanel\nand more\n\nThey're also asking about leveraging Shadcn UI components and LlamaIndex chat, which they mentioned could be installed via:\n```\nnpx shadcn@latest add https://ui.llamaindex.ai/r/chat.json\n```\n\nThey specifically want me to:\n1. Help streamline their chat implementation\n2. Provide a terminal command to delete unnecessary files\n\nLet me analyze the components to identify which ones might be necessary to keep versus which ones could be consolidated or removed:\n\n1. First, it looks like they are trying to use Vercel's AI SDK with `useChat` hook in several components\n2. They're exploring streaming vs non-streaming implementations\n3. Some components are using direct API calls while others use SDK abstractions\n4. There's a mix of UI approaches - some using Shadcn components, others using custom styling\n\nFrom the code patterns and imports, it seems like `LlamaChat` or `LlamaIndexChat` might be their intended direction, as those components leverage the `@llamaindex/chat-ui` components that they mentioned in the footer description.\n\nTo consolidate, I'll suggest a clear approach with:\n1. Which components to keep\n2. Which components to remove\n3. A terminal command to easily delete the unnecessary files# Streamlining Your Chat Implementation\n\nLooking at your code, you have multiple chat implementations that largely overlap in functionality. This leads to redundancy and maintenance challenges. Let's fix the streaming text issue while streamlining your chat components.\n\n## Recommended Approach\n\nBased on the code shared, I'd recommend standardizing on the LlamaIndex Chat UI components since:\n1. It's a structured library with ready-made components\n2. It integrates well with Vercel AI SDK (which you're already using)\n3. It provides proper streaming support out of the box\n4. It's compatible with Shadcn UI which you're using elsewhere\n\n### Fix for Streaming Text Issue\n\nThe main issue in your current implementation is that you have multiple components handling streaming differently. The LlamaIndex Chat UI components handle streaming properly when used with Vercel's AI SDK.\n\n## Cleanup Plan\n\nHere's a command to delete all the duplicate chat components while keeping only what you need:\n\n```bash\n# Keep the core LlamaChat.tsx component and delete the rest\nrm ./src/components/ui/AISdkChat.tsx \\\n   ./src/components/ui/BasicChatPanel.tsx \\\n   ./src/components/ui/ChatPanel.tsx \\\n   ./src/components/ui/DirectChatPanel.tsx \\\n   ./src/components/ui/LlamaChat.updated.tsx \\\n   ./src/components/ui/LlamaIndexChat.tsx \\\n   ./src/components/ui/SimpleChatPanel.tsx \\\n   ./src/components/ui/StreamingChatPanel.tsx \\\n   ./src/components/conversation/ChatPanel.tsx\n```\n\nThen, let's make sure you have the LlamaIndex Chat UI package properly installed:\n\n```bash\nnpm install @llamaindex/chat-ui\n```\n\n## Updating Your Configuration\n\nAdd this to your tailwind.config.js to ensure the chat UI components are styled correctly:\n\n```js\nmodule.exports = {\n  content: [\n    // Your existing content paths\n    './src/**/*.{js,ts,jsx,tsx}',\n    // Add LlamaIndex Chat UI components\n    'node_modules/@llamaindex/chat-ui/**/*.{js,ts,jsx,tsx}',\n  ],\n  // rest of your config\n}\n```\n\n## Improved Chat Implementation\n\nI recommend standardizing on a single implementation based on `LlamaChat.tsx`, but with these improvements:\n\n1. Consistent use of the streaming API\n2. Proper connection between chat messages and your node data structure\n3. Clear separation of UI from data fetching logic\n\nWould you like me to create an improved version of your LlamaChat component that addresses the streaming text issue specifically?",
      "created_at": "2025-05-15T20:43:40.876624Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-15T20:43:26.787206Z",
            "stop_timestamp": "2025-05-15T20:43:32.527102Z",
            "flags": null,
            "type": "thinking",
            "thinking": "The user has shared a large amount of code related to a chat interface for a notebook/canvas application. It seems they have multiple implementations of chat panels and are asking for help to streamline things, with a clear \"source of truth\" for chat functionality.\n\nThe main issue appears to be that they have many duplicate or similar chat components:\n- ChatPanel\n- AISdkChat\n- LlamaChat\n- LlamaIndexChat\n- DirectChatPanel\n- StreamingChatPanel\n- SimpleChatPanel\n- BasicChatPanel\nand more\n\nThey're also asking about leveraging Shadcn UI components and LlamaIndex chat, which they mentioned could be installed via:\n```\nnpx shadcn@latest add https://ui.llamaindex.ai/r/chat.json\n```\n\nThey specifically want me to:\n1. Help streamline their chat implementation\n2. Provide a terminal command to delete unnecessary files\n\nLet me analyze the components to identify which ones might be necessary to keep versus which ones could be consolidated or removed:\n\n1. First, it looks like they are trying to use Vercel's AI SDK with `useChat` hook in several components\n2. They're exploring streaming vs non-streaming implementations\n3. Some components are using direct API calls while others use SDK abstractions\n4. There's a mix of UI approaches - some using Shadcn components, others using custom styling\n\nFrom the code patterns and imports, it seems like `LlamaChat` or `LlamaIndexChat` might be their intended direction, as those components leverage the `@llamaindex/chat-ui` components that they mentioned in the footer description.\n\nTo consolidate, I'll suggest a clear approach with:\n1. Which components to keep\n2. Which components to remove\n3. A terminal command to easily delete the unnecessary files",
            "summaries": [
              {
                "summary": "Streamlining chat interface implementations for notebook application"
              },
              {
                "summary": "Dissected chat components and strategized consolidation approach."
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-05-15T20:43:32.722894Z",
            "stop_timestamp": "2025-05-15T20:43:40.768047Z",
            "flags": null,
            "type": "text",
            "text": "# Streamlining Your Chat Implementation\n\nLooking at your code, you have multiple chat implementations that largely overlap in functionality. This leads to redundancy and maintenance challenges. Let's fix the streaming text issue while streamlining your chat components.\n\n## Recommended Approach\n\nBased on the code shared, I'd recommend standardizing on the LlamaIndex Chat UI components since:\n1. It's a structured library with ready-made components\n2. It integrates well with Vercel AI SDK (which you're already using)\n3. It provides proper streaming support out of the box\n4. It's compatible with Shadcn UI which you're using elsewhere\n\n### Fix for Streaming Text Issue\n\nThe main issue in your current implementation is that you have multiple components handling streaming differently. The LlamaIndex Chat UI components handle streaming properly when used with Vercel's AI SDK.\n\n## Cleanup Plan\n\nHere's a command to delete all the duplicate chat components while keeping only what you need:\n\n```bash\n# Keep the core LlamaChat.tsx component and delete the rest\nrm ./src/components/ui/AISdkChat.tsx \\\n   ./src/components/ui/BasicChatPanel.tsx \\\n   ./src/components/ui/ChatPanel.tsx \\\n   ./src/components/ui/DirectChatPanel.tsx \\\n   ./src/components/ui/LlamaChat.updated.tsx \\\n   ./src/components/ui/LlamaIndexChat.tsx \\\n   ./src/components/ui/SimpleChatPanel.tsx \\\n   ./src/components/ui/StreamingChatPanel.tsx \\\n   ./src/components/conversation/ChatPanel.tsx\n```\n\nThen, let's make sure you have the LlamaIndex Chat UI package properly installed:\n\n```bash\nnpm install @llamaindex/chat-ui\n```\n\n## Updating Your Configuration\n\nAdd this to your tailwind.config.js to ensure the chat UI components are styled correctly:\n\n```js\nmodule.exports = {\n  content: [\n    // Your existing content paths\n    './src/**/*.{js,ts,jsx,tsx}',\n    // Add LlamaIndex Chat UI components\n    'node_modules/@llamaindex/chat-ui/**/*.{js,ts,jsx,tsx}',\n  ],\n  // rest of your config\n}\n```\n\n## Improved Chat Implementation\n\nI recommend standardizing on a single implementation based on `LlamaChat.tsx`, but with these improvements:\n\n1. Consistent use of the streaming API\n2. Proper connection between chat messages and your node data structure\n3. Clear separation of UI from data fetching logic\n\nWould you like me to create an improved version of your LlamaChat component that addresses the streaming text issue specifically?",
            "citations": []
          }
        ],
        "updated_at": "2025-05-15T20:43:40.876624Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "95103cda-7f3c-470a-b483-b4979b9b7393",
      "role": "human",
      "content": "yeah can you get it to work with a single source of truth and my node structure in the visual canvas space, in the slider  and in the chat full screen view and return all files that need to be updated in full",
      "created_at": "2025-05-15T20:56:29.366555Z",
      "sequence_order": 2,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-15T20:56:29.180927Z",
            "stop_timestamp": "2025-05-15T20:56:29.180927Z",
            "flags": null,
            "type": "text",
            "text": "yeah can you get it to work with a single source of truth and my node structure in the visual canvas space, in the slider  and in the chat full screen view and return all files that need to be updated in full",
            "citations": []
          }
        ],
        "updated_at": "2025-05-15T20:56:29.366555Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "1bccbfdd-1861-48ac-ba92-f6205d2eb5f4",
      "role": "assistant",
      "content": "Let's analyze what needs to be done to create a unified chat implementation that works across different views while maintaining a single source of truth.\n\nFrom the shared code, I can see:\n\n1. There's a node-based structure in the visual canvas\n2. There's a sidebar/panel chat view\n3. There's a full-screen chat view\n4. There are multiple implementations of chat with slight variations\n\nThe goals are:\n1. To fix streaming text issues\n2. To have a single source of truth for chat messages\n3. To ensure the chat works in all contexts (canvas, slider, full screen)\n4. To properly connect with the node structure\n\nFirst, I'll outline the files that need to be updated:\n\n1. The primary LlamaChat.tsx component needs significant enhancements to handle streaming properly\n2. We'll need to update any hook that manages chat state\n3. We'll potentially need to adjust the API endpoint to ensure streaming works correctly\n\nNow, let's look at each component:\n\n**LlamaChat.tsx**:\nThis appears to be the main component used for chat. It's using @llamaindex/chat-ui components with Vercel AI SDK.\n\n**For the canvas integration**:\nThe canvas component creates nodes from chat messages. We'll need to ensure this integration remains intact.\n\n**For the streaming text issue**:\nThe issue likely occurs because of how the streaming is handled. We need to ensure that:\n1. The backend properly streams responses\n2. The frontend correctly processes the stream\n3. The UI updates in real-time as new tokens arrive\n\nLet me create a comprehensive solution that addresses all these requirements.# Unified Chat Implementation\n\nI'll create a complete solution that ensures your chat functionality works consistently across all views while maintaining a single source of truth integrated with your node structure.\n\n## 1. Enhanced LlamaChat Component \n\nFirst, here's the improved base chat component that will handle streaming properly:\n\n```tsx\n// src/components/chat/LlamaChat.tsx\n\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\nimport { \n  useNodes, \n  useNodeActions, \n  useSelectedNode, \n  useActiveNode,\n  useUnifiedStore,\n  useUnifiedActions,\n} from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\n// Model selector component\nconst ModelSelector = ({ selectedModel, onChangeModel }) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\n// Custom file upload button\nconst FileUploadButton = () => {\n  return (\n    <div className=\"flex items-center\">\n      <button\n        type=\"button\"\n        className=\"inline-flex items-center p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100\"\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-5 w-5\"\n          viewBox=\"0 0 20 20\"\n          fill=\"currentColor\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      </button>\n    </div>\n  );\n};\n\n// Error boundary component\nclass ChatErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(\"Chat Error:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-4 text-red-500 bg-red-50 rounded border border-red-200\">\n          <h3 className=\"font-bold\">Chat Component Error</h3>\n          <p className=\"text-sm mb-2\">There was an error loading the chat component.</p>\n          <details className=\"text-xs\">\n            <summary>Error details</summary>\n            <pre className=\"mt-2 p-2 bg-gray-100 rounded overflow-x-auto\">\n              {this.state.error?.toString()}\n            </pre>\n          </details>\n          <button \n            onClick={() => this.setState({ hasError: false, error: null })}\n            className=\"mt-2 px-3 py-1 bg-red-100 text-red-600 rounded text-sm hover:bg-red-200\"\n          >\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport const LlamaChat = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n  mode = \"default\" // \"default\", \"panel\", \"fullscreen\"\n}) => {\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionSentRef = useRef(false);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const activeNode = useActiveNode();\n  const selectedNode = useSelectedNode();\n  const { \n    addNode, \n    createNodeRelationship,\n    setActiveNode,\n    setSelectedNode\n  } = useNodeActions();\n  \n  // Get unified store actions\n  const setNotebookId = useUnifiedStore(state => state.setNotebookId);\n  const setActiveThread = useUnifiedStore(state => state.setActiveThread);\n  const { syncActiveThread } = useUnifiedActions();\n  \n  // Initialize unified store\n  useEffect(() => {\n    if (setNotebookId) {\n      setNotebookId(notebookId);\n    }\n  }, [notebookId, setNotebookId]);\n\n  // Initialize the chat handler with streaming API\n  const chatHandler = useChat({\n    api: '/api/claude/chat-stream', // Ensure you have this endpoint set up for streaming\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: true // Important for streaming\n    },\n    onError: (error) => {\n      console.error(\"Chat error:\", error);\n      setIsProcessing(false);\n    },\n    onFinish: async (message) => {\n      try {\n        // Process the completed message\n        if (message && message.content) {\n          console.log('Message completed:', message.id);\n          \n          // Create a node for the AI response\n          await createNodeFromMessage(message, 'assistant');\n          \n          // Sync with active thread if available\n          if (syncActiveThread) {\n            syncActiveThread();\n          }\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle model change\n  const handleModelChange = useCallback((model) => {\n    setModelId(model);\n  }, []);\n\n  // Create node from message\n  const createNodeFromMessage = async (message, role) => {\n    if (!notebookId) return null;\n    \n    try {\n      const messageObj = {\n        id: message.id,\n        role,\n        content: message.content,\n        created_at: new Date().toISOString()\n      };\n      \n      // Check if this is a response to a particular node\n      let parentNodeId = null;\n      let tier = 3; // Default to conversation tier\n      \n      if (role === 'assistant') {\n        // Find the last user message to link to\n        const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n        if (userMessages.length > 0) {\n          const lastUserMessage = userMessages[userMessages.length - 1];\n          \n          // Find node for the last user message\n          const userNode = Object.values(nodes).find(n => \n            n.messages?.some(m => m.id === lastUserMessage.id)\n          );\n          \n          if (userNode) {\n            parentNodeId = userNode.id;\n            \n            // If parent is a main question (tier 1)\n            if (userNode.metadata?.tier === 1) {\n              // Create as response to main question\n              const node = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                { x: userNode.position?.x || 350, y: (userNode.position?.y || 200) + 120 },\n                {\n                  parentNodeId: userNode.id,\n                  mainQuestionId: userNode.id,\n                  isAnswerToMainQuestion: true,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              if (node) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  node.id,\n                  'supports',\n                  notebookId\n                );\n                \n                setSelectedNode(node.id);\n                setActiveNode(node.id);\n              }\n              \n              return node;\n            } \n            \n            // If parent is a tier 3 conversation node\n            else {\n              // Check if node has conversation messages\n              if (userNode.isConversationNode && userNode.messages?.length > 0) {\n                // Add to existing conversation node\n                const success = await nodeIntegration.addMessageToNode(\n                  userNode.id, \n                  messageObj,\n                  lastUserMessage.id // parent message ID\n                );\n                \n                if (success) {\n                  return userNode;\n                }\n              }\n              \n              // Create new response node\n              const node = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                { \n                  x: userNode.position?.x || 450, \n                  y: (userNode.position?.y || 350) + 60 \n                },\n                {\n                  parentNodeId: userNode.metadata?.parentNodeId,\n                  respondingToNodeId: userNode.id,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              if (node) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  node.id,\n                  'supports',\n                  notebookId\n                );\n                \n                setSelectedNode(node.id);\n                setActiveNode(node.id);\n              }\n              \n              return node;\n            }\n          }\n        }\n      } else if (role === 'user') {\n        // Handle user message nodes\n        let node;\n        \n        // Check if this is the first message\n        const isFirstMessage = Object.values(nodes).filter(n => \n          n.type === 'question' && n.notebook_id === notebookId\n        ).length === 0;\n        \n        if (isFirstMessage) {\n          // Create as main question (tier 1)\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId,\n            { x: 350, y: 200 },\n            {\n              isMainQuestion: true,\n              source: 'chat',\n              timestamp: new Date().toISOString()\n            },\n            'question',\n            1 // tier 1\n          );\n        } else if (activeNode) {\n          // Create in relation to active node\n          const activeTier = activeNode.metadata?.tier || 3;\n          \n          if (activeTier === 1) {\n            // Add as conversation under main question\n            node = await nodeIntegration.createNodeFromMessage(\n              messageObj,\n              notebookId,\n              { \n                x: activeNode.position?.x || 350, \n                y: (activeNode.position?.y || 200) + 100 \n              },\n              {\n                parentNodeId: activeNode.id,\n                source: 'chat',\n                timestamp: new Date().toISOString()\n              },\n              'question',\n              3 // tier 3\n            );\n            \n            if (node) {\n              await nodeIntegration.createNodeRelationship(\n                activeNode.id,\n                node.id,\n                'extends',\n                notebookId\n              );\n            }\n          } else {\n            // Add to conversation node\n            if (await nodeIntegration.addMessageToNode(activeNode.id, messageObj)) {\n              node = activeNode;\n            } else {\n              // Create new node\n              node = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                { \n                  x: activeNode.position?.x || 450, \n                  y: (activeNode.position?.y || 350) + 60 \n                },\n                {\n                  parentNodeId: activeNode.metadata?.parentNodeId,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'question',\n                3 // tier 3\n              );\n              \n              if (node) {\n                await nodeIntegration.createNodeRelationship(\n                  activeNode.id,\n                  node.id,\n                  'extends',\n                  notebookId\n                );\n              }\n            }\n          }\n        } else {\n          // Create standalone node\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId\n          );\n          \n          // Try to find main question\n          const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n          if (node && mainQuestionNode) {\n            await nodeIntegration.createNodeRelationship(\n              mainQuestionNode.id,\n              node.id,\n              'extends',\n              notebookId\n            );\n          }\n        }\n        \n        if (node && node.id !== activeNode?.id) {\n          setSelectedNode(node.id);\n          setActiveNode(node.id);\n        }\n        \n        return node;\n      }\n      \n      // Fallback: create a standalone node\n      return await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n    } catch (error) {\n      console.error('Error creating node from message:', error);\n      return null;\n    }\n  };\n\n  // Submit handler\n  const handleSubmit = useCallback(async (e) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate message ID\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node for message\n      await createNodeFromMessage({\n        id: messageId,\n        role: 'user',\n        content: content.trim()\n      }, 'user');\n      \n      // Clear input field\n      chatHandler.setInput('');\n      \n      // Send message to API\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n      });\n      \n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [isProcessing, notebookId, activeNode, createNodeFromMessage, chatHandler, setActiveNode, setSelectedNode]);\n\n  // Create a new thread\n  const handleCreateNewThread = useCallback(() => {\n    // Reset active node selection\n    setSelectedNode(null);\n    setActiveNode(null);\n    if (setActiveThread) {\n      setActiveThread(null);\n    }\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n  }, [setSelectedNode, setActiveNode, chatHandler, setActiveThread]);\n  \n  // Send initial question if provided\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionSentRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionSentRef.current = true;\n          setIsProcessing(true);\n          \n          // Generate a unique ID\n          const messageId = `initial-question-${Date.now()}`;\n          \n          // Create node for the question\n          await createNodeFromMessage({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          }, 'user');\n          \n          // Send to API\n          chatHandler.append({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          });\n          \n        } catch (error) {\n          console.error('Error sending initial question:', error);\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler, notebookId, createNodeFromMessage]);\n  \n  // Sync with active node when it changes\n  useEffect(() => {\n    if (activeNode && !isProcessing && syncActiveThread) {\n      syncActiveThread();\n    }\n  }, [activeNode, isProcessing, syncActiveThread]);\n  \n  // Render based on mode\n  const renderChatUI = () => {\n    // Common chat UI\n    return (\n      <ChatSection handler={chatHandler} className=\"h-full\">\n        <ChatMessages className={`${fullScreen ? 'h-[calc(100%-100px)]' : 'h-[calc(100%-80px)]'} overflow-y-auto p-4`} />\n        <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n          <ChatInput.Form className=\"px-3 py-2\">\n            <ChatInput.Field \n              type=\"textarea\" \n              placeholder=\"Type your message...\" \n              className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n              disabled={chatHandler.isLoading || isProcessing}\n            />\n            <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n              <ModelSelector\n                selectedModel={modelId}\n                onChangeModel={handleModelChange}\n              />\n              <ChatInput.Upload>\n                <FileUploadButton />\n              </ChatInput.Upload>\n            </div>\n            <ChatInput.Submit\n              disabled={chatHandler.isLoading || isProcessing}\n              className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n            >\n              {chatHandler.isLoading || isProcessing ? (\n                <Spinner className=\"h-5 w-5 border-2 border-white border-t-transparent\" />\n              ) : (\n                <svg className=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                </svg>\n              )}\n            </ChatInput.Submit>\n          </ChatInput.Form>\n        </ChatInput>\n      </ChatSection>\n    );\n  };\n  \n  // Panel mode has a header with close button\n  if (mode === \"panel\") {\n    return (\n      <div className={`flex flex-col h-full ${className}`}>\n        <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n          <h2 className=\"font-semibold text-gray-700\">\n            {activeNode ? (activeNode.type === 'question' ? 'Question' : 'Conversation') : 'Chat'}\n          </h2>\n          <div className=\"flex items-center space-x-2\">\n            <button\n              onClick={handleCreateNewThread}\n              className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n              title=\"New conversation\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n            {onClose && (\n              <button \n                onClick={onClose}\n                className=\"text-gray-500 hover:text-gray-700\"\n                aria-label=\"Close panel\"\n              >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n                </svg>\n              </button>\n            )}\n          </div>\n        </div>\n        <div className=\"flex-1 overflow-hidden\">\n          {renderChatUI()}\n        </div>\n      </div>\n    );\n  }\n  \n  // Fullscreen mode has a header with navigation\n  if (mode === \"fullscreen\") {\n    return (\n      <div className={`flex flex-col h-screen ${className}`}>\n        <div className=\"bg-white border-b border-gray-200 px-4 py-4 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <button\n              onClick={() => window.history.back()}\n              className=\"mr-4 text-gray-600 hover:text-gray-900\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-5 w-5\"\n                viewBox=\"0 0 20 20\"\n                fill=\"currentColor\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n            </button>\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              Chat\n            </h1>\n          </div>\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={handleCreateNewThread}\n              className=\"text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-600 rounded-md hover:bg-blue-50\"\n            >\n              New Chat\n            </button>\n          </div>\n        </div>\n        <div className=\"flex-1 overflow-hidden bg-gray-50\">\n          <div className=\"max-w-4xl mx-auto bg-white shadow-sm h-full\">\n            {renderChatUI()}\n          </div>\n        </div>\n      </div>\n    );\n  }\n  \n  // Default mode - just the chat UI without header\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {renderChatUI()}\n    </div>\n  );\n};\n\n// Wrap with error boundary\nconst WrappedLlamaChat = (props) => (\n  <ChatErrorBoundary>\n    <LlamaChat {...props} />\n  </ChatErrorBoundary>\n);\n\nexport default WrappedLlamaChat;\n```\n\n## 2. Create a Chat API Endpoint with Streaming Support\n\n```javascript\n// src/pages/api/claude/chat-stream.js\n\nimport { Configuration, OpenAI } from 'openai';\nimport { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase client\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\n// Initialize Claude/OpenAI client\nconst apiKey = process.env.ANTHROPIC_API_KEY || process.env.OPENAI_API_KEY;\nconst client = new OpenAI({\n  apiKey,\n  baseURL: process.env.ANTHROPIC_API_URL || 'https://api.anthropic.com/v1'\n});\n\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  const { messages, notebookId, model = 'claude-3-5-sonnet-20240620', stream = true } = req.body;\n  \n  if (!messages || !Array.isArray(messages) || messages.length === 0) {\n    return res.status(400).json({ error: 'Invalid messages format' });\n  }\n\n  try {\n    // Set proper headers for streaming\n    if (stream) {\n      res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache, no-transform',\n        'Connection': 'keep-alive',\n      });\n    }\n\n    // Create completion with streaming\n    const completion = await client.chat.completions.create({\n      model,\n      messages,\n      stream,\n      temperature: 0.7,\n      max_tokens: 4000,\n    });\n\n    if (stream) {\n      // Handle streaming response\n      for await (const chunk of completion) {\n        // Send each chunk as an SSE event\n        const content = chunk.choices[0]?.delta?.content || '';\n        if (content) {\n          res.write(`data: ${JSON.stringify({ content })}\\n\\n`);\n        }\n      }\n      \n      // End the stream\n      res.write('data: [DONE]\\n\\n');\n      res.end();\n    } else {\n      // Handle non-streaming response\n      const content = completion.choices[0]?.message?.content;\n      \n      // Save to database if needed\n      if (notebookId) {\n        // Implement database saving logic here\n      }\n      \n      return res.status(200).json({ content });\n    }\n  } catch (error) {\n    console.error('Error processing chat request:', error);\n    \n    if (stream) {\n      // Send error in streaming format\n      res.write(`data: ${JSON.stringify({ error: error.message })}\\n\\n`);\n      res.end();\n    } else {\n      return res.status(500).json({ error: error.message });\n    }\n  }\n}\n```\n\n## 3. Chat Node Integration Module\n\n```typescript\n// src/lib/chat/nodeIntegration.ts\n\nimport { supabase } from '@/lib/supabaseClient';\nimport { generateUUID } from '@/utils/uuidUtils';\n\n/**\n * Node integration functionality for chat\n */\nexport const nodeIntegration = {\n  /**\n   * Create a node from a chat message\n   */\n  async createNodeFromMessage(\n    message: any,\n    notebookId: string,\n    position: { x: number, y: number } = { x: 200, y: 200 },\n    metadata: any = {},\n    type: 'question' | 'response' | 'note' | 'drawing' = 'question',\n    tier: number = 3\n  ) {\n    try {\n      // Determine content and type\n      const content = message.content || '';\n      \n      // Create the node data\n      const nodeData = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        content,\n        type,\n        position,\n        metadata: {\n          ...metadata,\n          tier,\n          source: 'chat',\n          chatMessageId: message.id,\n          timestamp: message.created_at || new Date().toISOString()\n        },\n        messages: [{\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          created_at: message.created_at || new Date().toISOString()\n        }],\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        isConversationNode: true\n      };\n      \n      // Save to database\n      const { data, error } = await supabase\n        .from('nodes')\n        .insert(nodeData)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error creating node from message:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Add a message to an existing node\n   */\n  async addMessageToNode(nodeId: string, message: any, parentMessageId?: string) {\n    try {\n      // Get the node\n      const { data: node, error: nodeError } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('id', nodeId)\n        .single();\n        \n      if (nodeError) throw nodeError;\n      \n      // Add message to the messages array\n      const messages = node.messages || [];\n      messages.push({\n        id: message.id,\n        role: message.role,\n        content: message.content,\n        parentMessageId,\n        created_at: message.created_at || new Date().toISOString()\n      });\n      \n      // Update the node\n      const { error: updateError } = await supabase\n        .from('nodes')\n        .update({\n          messages,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', nodeId);\n        \n      if (updateError) throw updateError;\n      \n      return true;\n    } catch (error) {\n      console.error('Error adding message to node:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Create a relationship between nodes\n   */\n  async createNodeRelationship(\n    fromNodeId: string,\n    toNodeId: string,\n    type: string = 'extends',\n    notebookId: string,\n    metadata: any = {}\n  ) {\n    try {\n      const relationshipData = {\n        id: generateUUID(),\n        from_node_id: fromNodeId,\n        to_node_id: toNodeId,\n        type,\n        notebook_id: notebookId,\n        metadata,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      const { data, error } = await supabase\n        .from('relationships')\n        .insert(relationshipData)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error creating node relationship:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Find the main question node for a notebook\n   */\n  async findMainQuestionNode(notebookId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .eq('type', 'question')\n        .filter('metadata->tier', 'eq', 1)\n        .order('created_at', { ascending: true })\n        .limit(1);\n        \n      if (error) throw error;\n      \n      return data && data.length > 0 ? data[0] : null;\n    } catch (error) {\n      console.error('Error finding main question node:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Create a tier 2 category node\n   */\n  async createTier2Node(\n    parentNodeId: string,\n    type: 'question' | 'response' | 'note' | 'drawing',\n    content: string,\n    notebookId: string\n  ) {\n    try {\n      // Get parent node to determine position\n      const { data: parentNode, error: parentError } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('id', parentNodeId)\n        .single();\n        \n      if (parentError) throw parentError;\n      \n      // Calculate position relative to parent\n      const position = {\n        x: (parentNode.position?.x || 350) + 150,\n        y: (parentNode.position?.y || 200) + 100\n      };\n      \n      // Create the node data\n      const nodeData = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        content,\n        type,\n        position,\n        metadata: {\n          tier: 2,\n          parentNodeId,\n          source: 'chat',\n          timestamp: new Date().toISOString()\n        },\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      // Save to database\n      const { data, error } = await supabase\n        .from('nodes')\n        .insert(nodeData)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      // Create relationship to parent\n      await this.createNodeRelationship(\n        parentNodeId,\n        data.id,\n        'contains',\n        notebookId,\n        {\n          direction: 'outgoing',\n          intention: 'categorization',\n          state: 'active'\n        }\n      );\n      \n      return data;\n    } catch (error) {\n      console.error('Error creating tier 2 node:', error);\n      return null;\n    }\n  }\n};\n\nexport default nodeIntegration;\n```\n\n## 4. Unified Store Hook for Chat Sync\n\n```typescript\n// src/hooks/useChatNodeSync.ts\n\nimport { useState, useCallback } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\nimport { useNodes, useNodeActions, useRelationships } from '@/stores';\n\n/**\n * Hook for synchronizing chat messages with nodes\n */\nexport const useChatNodeSync = ({ notebookId }) => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const relationships = useRelationships();\n  const { setActiveNode } = useNodeActions();\n  \n  /**\n   * Sync node to chat - load messages from a specific node\n   */\n  const syncNodeToChat = useCallback(async (nodeId) => {\n    try {\n      setIsLoading(true);\n      \n      // Get the node\n      const node = nodes[nodeId];\n      if (!node) {\n        throw new Error(`Node ${nodeId} not found`);\n      }\n      \n      // Get node messages\n      const messages = node.messages || [];\n      \n      // If this is a conversation node, return its messages\n      if (node.isConversationNode && messages.length > 0) {\n        return messages;\n      }\n      \n      // Otherwise, create a message from the node content\n      return [{\n        id: `node_${node.id}`,\n        role: node.type === 'question' ? 'user' : 'assistant',\n        content: node.content,\n        created_at: node.created_at,\n        nodeId: node.id\n      }];\n    } catch (err) {\n      setError(err.message);\n      console.error('Error syncing node to chat:', err);\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [nodes]);\n  \n  /**\n   * Find node by message ID\n   */\n  const findNodeByMessageId = useCallback((messageId) => {\n    return Object.values(nodes).find(node => \n      node.messages?.some(msg => msg.id === messageId)\n    );\n  }, [nodes]);\n  \n  /**\n   * Sync chat messages to nodes\n   */\n  const syncChatToNodes = useCallback(async (messages = []) => {\n    try {\n      setIsLoading(true);\n      \n      // Create a map of messages to nodes\n      const messageToNodeMap = new Map();\n      \n      // Process each message\n      for (const message of messages) {\n        // Skip system messages\n        if (message.role === 'system') continue;\n        \n        // Check if message already has a node\n        const existingNode = findNodeByMessageId(message.id);\n        if (existingNode) {\n          messageToNodeMap.set(message.id, existingNode.id);\n          continue;\n        }\n        \n        // Create a new node for this message\n        const nodeData = {\n          id: generateUUID(),\n          notebook_id: notebookId,\n          content: message.content,\n          type: message.role === 'user' ? 'question' : 'response',\n          position: { x: 200, y: 200 }, // Default position\n          metadata: {\n            tier: 3,\n            source: 'chat',\n            chatMessageId: message.id,\n            timestamp: message.created_at || new Date().toISOString()\n          },\n          messages: [message],\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n          isConversationNode: true\n        };\n        \n        // Save to database\n        const { data, error } = await supabase\n          .from('nodes')\n          .insert(nodeData)\n          .select()\n          .single();\n          \n        if (error) throw error;\n        \n        messageToNodeMap.set(message.id, data.id);\n      }\n      \n      // Create relationships between message nodes\n      for (let i = 1; i < messages.length; i++) {\n        const prevMessage = messages[i - 1];\n        const currMessage = messages[i];\n        \n        // Skip system messages\n        if (prevMessage.role === 'system' || currMessage.role === 'system') continue;\n        \n        const prevNodeId = messageToNodeMap.get(prevMessage.id);\n        const currNodeId = messageToNodeMap.get(currMessage.id);\n        \n        if (prevNodeId && currNodeId) {\n          await supabase\n            .from('relationships')\n            .insert({\n              id: generateUUID(),\n              from_node_id: prevNodeId,\n              to_node_id: currNodeId,\n              type: currMessage.role === 'assistant' ? 'responds' : 'follows',\n              notebook_id: notebookId,\n              created_at: new Date().toISOString(),\n              updated_at: new Date().toISOString()\n            });\n        }\n      }\n      \n      // Set active node to last message node\n      const lastMessage = messages[messages.length - 1];\n      if (lastMessage && lastMessage.role !== 'system') {\n        const nodeId = messageToNodeMap.get(lastMessage.id);\n        if (nodeId) {\n          setActiveNode(nodeId);\n        }\n      }\n      \n      return true;\n    } catch (err) {\n      setError(err.message);\n      console.error('Error syncing chat to nodes:', err);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [notebookId, findNodeByMessageId, setActiveNode]);\n  \n  return {\n    syncNodeToChat,\n    syncChatToNodes,\n    findNodeByMessageId,\n    isLoading,\n    error\n  };\n};\n\nexport default useChatNodeSync;\n```\n\n## 5. Files to Update\n\n1. Replace `src/components/ui/LlamaChat.tsx` with our new implementation\n2. Add the new `src/pages/api/claude/chat-stream.js` endpoint\n3. Create or update `src/lib/chat/nodeIntegration.ts` with our integration logic\n4. Create or update `src/hooks/useChatNodeSync.ts` with our sync hook\n5. Remove all other chat implementations:\n\n```bash\nrm ./src/components/ui/AISdkChat.tsx \\\n   ./src/components/ui/BasicChatPanel.tsx \\\n   ./src/components/ui/ChatPanel.tsx \\\n   ./src/components/ui/DirectChatPanel.tsx \\\n   ./src/components/ui/LlamaChat.updated.tsx \\\n   ./src/components/ui/LlamaIndexChat.tsx \\\n   ./src/components/ui/SimpleChatPanel.tsx \\\n   ./src/components/ui/StreamingChatPanel.tsx \\\n   ./src/components/conversation/ChatPanel.tsx\n```\n\n## 6. Update the Panel View for Chat Integration\n\n```tsx\n// src/components/ChatSidePanel.tsx\n\nimport React from 'react';\nimport WrappedLlamaChat from '@/components/chat/LlamaChat';\n\nexport const ChatSidePanel = ({\n  notebookId,\n  systemPrompt,\n  onClose,\n  isOpen,\n  isFullScreen,\n  onToggleFullScreen\n}) => {\n  return (\n    <div\n      className={`bg-white border-l border-gray-200 shadow-xl ${\n        isOpen\n          ? (isFullScreen\n              ? 'fixed inset-0 z-50 w-full h-full'\n              : 'fixed right-0 top-0 bottom-0 z-40 w-80 h-full')\n          : 'fixed right-[-320px] top-0 bottom-0 z-40 w-80 h-full'\n      }`}\n      style={{\n        transition: 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out',\n        transform: isOpen ? 'translateX(0)' : 'translateX(100%)',\n        opacity: isOpen ? 1 : 0,\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      <WrappedLlamaChat\n        notebookId={notebookId}\n        systemPrompt={systemPrompt}\n        onClose={onClose}\n        mode=\"panel\"\n        className=\"h-full\"\n      />\n    </div>\n  );\n};\n\nexport default ChatSidePanel;\n```\n\n## 7. Update Full-Screen Chat Page\n\n```tsx\n// src/pages/notebooks/[id]/chat.tsx\n\nimport React from 'react';\nimport { useRouter } from 'next/router';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport WrappedLlamaChat from '@/components/chat/LlamaChat';\nimport Layout from '@/components/layout/Layout';\nimport LoadingSpinner from '@/components/ui/LoadingSpinner';\n\nconst NotebookChatPage = () => {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Handle the case when router.query isn't loaded yet\n  if (!router.isReady) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n  \n  const notebookId = typeof id === 'string' ? id : '';\n  \n  const { notebook, loading, error } = useNotebook(notebookId);\n\n  // Handle loading state\n  if (loading) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n\n  // Handle error state\n  if (error || !notebook) {\n    return (\n      <Layout>\n        <div className=\"flex flex-col items-center justify-center h-screen\">\n          <h2 className=\"text-xl font-semibold text-red-600 mb-4\">Error Loading Notebook</h2>\n          <p className=\"text-gray-700 mb-6\">{error || 'Notebook not found'}</p>\n          <button\n            onClick={() => router.push('/notebooks')}\n            className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n          >\n            Return to Notebooks\n          </button>\n        </div>\n      </Layout>\n    );\n  }\n\n  return (\n    <Layout>\n      <WrappedLlamaChat\n        notebookId={notebookId}\n        systemPrompt={notebook.system_prompt}\n        mode=\"fullscreen\"\n        className=\"h-screen\"\n      />\n    </Layout>\n  );\n};\n\nexport default NotebookChatPage;\n```\n\n## 8. Update Canvas Integration\n\nIn your Canvas component, replace the chat integration with this simplified integration:\n\n```tsx\n// Add this to your CanvasContainer.tsx where you handle the side panel\nimport WrappedLlamaChat from '@/components/chat/LlamaChat';\n\n// Then in your JSX where you render the side panel:\n{isSidePanelOpen && (\n  <ChatSidePanel\n    notebookId={notebookId}\n    systemPrompt={systemPrompt}\n    onClose={() => setIsSidePanelOpen(false)}\n    isOpen={isSidePanelOpen}\n    isFullScreen={isSidePanelFullScreen}\n    onToggleFullScreen={() => setIsSidePanelFullScreen(prev => !prev)}\n  />\n)}\n```\n\n## 9. Install Required Dependencies\n\nFinally, make sure you have all the required dependencies:\n\n```bash\nnpm install @llamaindex/chat-ui ai openai anthropic\n```\n\n## Implementation Details\n\nThis solution provides:\n\n1. **One source of truth** - All chat interactions are synchronized with your node structure\n2. **Streaming text** - Both API and UI are configured for proper streaming\n3. **Multiple view support** - The same component works in panel, full-screen, and embedded modes\n4. **Correct node relationships** - Messages properly create and update nodes based on their context\n5. **Error handling** - Robust error boundaries prevent crashes when issues occur\n\nAll these components work together to create a unified, consistent chat experience across your application. The LlamaChat component is now your main entry point for chat functionality in any context, and it keeps everything synchronized with your visual node structure.",
      "created_at": "2025-05-15T21:00:57.173097Z",
      "sequence_order": 3,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-15T20:56:35.494583Z",
            "stop_timestamp": "2025-05-15T20:56:43.609642Z",
            "flags": null,
            "type": "thinking",
            "thinking": "Let's analyze what needs to be done to create a unified chat implementation that works across different views while maintaining a single source of truth.\n\nFrom the shared code, I can see:\n\n1. There's a node-based structure in the visual canvas\n2. There's a sidebar/panel chat view\n3. There's a full-screen chat view\n4. There are multiple implementations of chat with slight variations\n\nThe goals are:\n1. To fix streaming text issues\n2. To have a single source of truth for chat messages\n3. To ensure the chat works in all contexts (canvas, slider, full screen)\n4. To properly connect with the node structure\n\nFirst, I'll outline the files that need to be updated:\n\n1. The primary LlamaChat.tsx component needs significant enhancements to handle streaming properly\n2. We'll need to update any hook that manages chat state\n3. We'll potentially need to adjust the API endpoint to ensure streaming works correctly\n\nNow, let's look at each component:\n\n**LlamaChat.tsx**:\nThis appears to be the main component used for chat. It's using @llamaindex/chat-ui components with Vercel AI SDK.\n\n**For the canvas integration**:\nThe canvas component creates nodes from chat messages. We'll need to ensure this integration remains intact.\n\n**For the streaming text issue**:\nThe issue likely occurs because of how the streaming is handled. We need to ensure that:\n1. The backend properly streams responses\n2. The frontend correctly processes the stream\n3. The UI updates in real-time as new tokens arrive\n\nLet me create a comprehensive solution that addresses all these requirements.",
            "summaries": [
              {
                "summary": "Analyzing node-based structure for unified chat implementation"
              },
              {
                "summary": "Engineered unified chat solution across multiple view contexts"
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-05-15T20:56:43.795690Z",
            "stop_timestamp": "2025-05-15T20:59:28.346236Z",
            "flags": null,
            "type": "text",
            "text": "# Unified Chat Implementation\n\nI'll create a complete solution that ensures your chat functionality works consistently across all views while maintaining a single source of truth integrated with your node structure.\n\n## 1. Enhanced LlamaChat Component \n\nFirst, here's the improved base chat component that will handle streaming properly:\n\n```tsx\n// src/components/chat/LlamaChat.tsx\n\nimport React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { ChatSection, ChatMessages, ChatInput } from '@llamaindex/chat-ui';\nimport { useChat } from 'ai/react';\nimport { \n  useNodes, \n  useNodeActions, \n  useSelectedNode, \n  useActiveNode,\n  useUnifiedStore,\n  useUnifiedActions,\n} from '@/stores';\nimport { nodeIntegration } from '@/lib/chat';\nimport { Button } from '@/components/shadcn/button';\nimport { Spinner } from '@/components/shadcn/spinner';\n\n// Model selector component\nconst ModelSelector = ({ selectedModel, onChangeModel }) => {\n  return (\n    <div className=\"flex items-center mr-2\">\n      <select\n        className=\"bg-white text-sm rounded-md border border-gray-300 py-1 px-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\n        value={selectedModel}\n        onChange={(e) => onChangeModel(e.target.value)}\n      >\n        <option value=\"claude-3-5-sonnet-20240620\">Claude 3.5 Sonnet</option>\n        <option value=\"claude-3-opus-20240229\">Claude 3 Opus</option>\n        <option value=\"claude-3-sonnet-20240229\">Claude 3 Sonnet</option>\n        <option value=\"claude-3-haiku-20240307\">Claude 3 Haiku</option>\n      </select>\n    </div>\n  );\n};\n\n// Custom file upload button\nconst FileUploadButton = () => {\n  return (\n    <div className=\"flex items-center\">\n      <button\n        type=\"button\"\n        className=\"inline-flex items-center p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100\"\n      >\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          className=\"h-5 w-5\"\n          viewBox=\"0 0 20 20\"\n          fill=\"currentColor\"\n        >\n          <path\n            fillRule=\"evenodd\"\n            d=\"M8 4a3 3 0 00-3 3v4a5 5 0 0010 0V7a1 1 0 112 0v4a7 7 0 11-14 0V7a5 5 0 0110 0v4a3 3 0 11-6 0V7a1 1 0 012 0v4a1 1 0 102 0V7a3 3 0 00-3-3z\"\n            clipRule=\"evenodd\"\n          />\n        </svg>\n      </button>\n    </div>\n  );\n};\n\n// Error boundary component\nclass ChatErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error, info) {\n    console.error(\"Chat Error:\", error, info);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"p-4 text-red-500 bg-red-50 rounded border border-red-200\">\n          <h3 className=\"font-bold\">Chat Component Error</h3>\n          <p className=\"text-sm mb-2\">There was an error loading the chat component.</p>\n          <details className=\"text-xs\">\n            <summary>Error details</summary>\n            <pre className=\"mt-2 p-2 bg-gray-100 rounded overflow-x-auto\">\n              {this.state.error?.toString()}\n            </pre>\n          </details>\n          <button \n            onClick={() => this.setState({ hasError: false, error: null })}\n            className=\"mt-2 px-3 py-1 bg-red-100 text-red-600 rounded text-sm hover:bg-red-200\"\n          >\n            Try Again\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport const LlamaChat = ({\n  notebookId,\n  systemPrompt = \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\",\n  fullScreen = false,\n  onClose,\n  className = \"\",\n  initialQuestion,\n  mode = \"default\" // \"default\", \"panel\", \"fullscreen\"\n}) => {\n  const [modelId, setModelId] = useState('claude-3-5-sonnet-20240620');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const initialQuestionSentRef = useRef(false);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const activeNode = useActiveNode();\n  const selectedNode = useSelectedNode();\n  const { \n    addNode, \n    createNodeRelationship,\n    setActiveNode,\n    setSelectedNode\n  } = useNodeActions();\n  \n  // Get unified store actions\n  const setNotebookId = useUnifiedStore(state => state.setNotebookId);\n  const setActiveThread = useUnifiedStore(state => state.setActiveThread);\n  const { syncActiveThread } = useUnifiedActions();\n  \n  // Initialize unified store\n  useEffect(() => {\n    if (setNotebookId) {\n      setNotebookId(notebookId);\n    }\n  }, [notebookId, setNotebookId]);\n\n  // Initialize the chat handler with streaming API\n  const chatHandler = useChat({\n    api: '/api/claude/chat-stream', // Ensure you have this endpoint set up for streaming\n    initialMessages: [\n      { id: 'system-1', role: 'system', content: systemPrompt }\n    ],\n    body: {\n      notebookId,\n      model: modelId,\n      includeUserContext: true,\n      stream: true // Important for streaming\n    },\n    onError: (error) => {\n      console.error(\"Chat error:\", error);\n      setIsProcessing(false);\n    },\n    onFinish: async (message) => {\n      try {\n        // Process the completed message\n        if (message && message.content) {\n          console.log('Message completed:', message.id);\n          \n          // Create a node for the AI response\n          await createNodeFromMessage(message, 'assistant');\n          \n          // Sync with active thread if available\n          if (syncActiveThread) {\n            syncActiveThread();\n          }\n        }\n      } catch (error) {\n        console.error('Error processing AI response:', error);\n      } finally {\n        setIsProcessing(false);\n      }\n    }\n  });\n\n  // Handle model change\n  const handleModelChange = useCallback((model) => {\n    setModelId(model);\n  }, []);\n\n  // Create node from message\n  const createNodeFromMessage = async (message, role) => {\n    if (!notebookId) return null;\n    \n    try {\n      const messageObj = {\n        id: message.id,\n        role,\n        content: message.content,\n        created_at: new Date().toISOString()\n      };\n      \n      // Check if this is a response to a particular node\n      let parentNodeId = null;\n      let tier = 3; // Default to conversation tier\n      \n      if (role === 'assistant') {\n        // Find the last user message to link to\n        const userMessages = chatHandler.messages.filter(msg => msg.role === 'user');\n        if (userMessages.length > 0) {\n          const lastUserMessage = userMessages[userMessages.length - 1];\n          \n          // Find node for the last user message\n          const userNode = Object.values(nodes).find(n => \n            n.messages?.some(m => m.id === lastUserMessage.id)\n          );\n          \n          if (userNode) {\n            parentNodeId = userNode.id;\n            \n            // If parent is a main question (tier 1)\n            if (userNode.metadata?.tier === 1) {\n              // Create as response to main question\n              const node = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                { x: userNode.position?.x || 350, y: (userNode.position?.y || 200) + 120 },\n                {\n                  parentNodeId: userNode.id,\n                  mainQuestionId: userNode.id,\n                  isAnswerToMainQuestion: true,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              if (node) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  node.id,\n                  'supports',\n                  notebookId\n                );\n                \n                setSelectedNode(node.id);\n                setActiveNode(node.id);\n              }\n              \n              return node;\n            } \n            \n            // If parent is a tier 3 conversation node\n            else {\n              // Check if node has conversation messages\n              if (userNode.isConversationNode && userNode.messages?.length > 0) {\n                // Add to existing conversation node\n                const success = await nodeIntegration.addMessageToNode(\n                  userNode.id, \n                  messageObj,\n                  lastUserMessage.id // parent message ID\n                );\n                \n                if (success) {\n                  return userNode;\n                }\n              }\n              \n              // Create new response node\n              const node = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                { \n                  x: userNode.position?.x || 450, \n                  y: (userNode.position?.y || 350) + 60 \n                },\n                {\n                  parentNodeId: userNode.metadata?.parentNodeId,\n                  respondingToNodeId: userNode.id,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'response',\n                3 // tier 3\n              );\n              \n              if (node) {\n                await nodeIntegration.createNodeRelationship(\n                  userNode.id,\n                  node.id,\n                  'supports',\n                  notebookId\n                );\n                \n                setSelectedNode(node.id);\n                setActiveNode(node.id);\n              }\n              \n              return node;\n            }\n          }\n        }\n      } else if (role === 'user') {\n        // Handle user message nodes\n        let node;\n        \n        // Check if this is the first message\n        const isFirstMessage = Object.values(nodes).filter(n => \n          n.type === 'question' && n.notebook_id === notebookId\n        ).length === 0;\n        \n        if (isFirstMessage) {\n          // Create as main question (tier 1)\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId,\n            { x: 350, y: 200 },\n            {\n              isMainQuestion: true,\n              source: 'chat',\n              timestamp: new Date().toISOString()\n            },\n            'question',\n            1 // tier 1\n          );\n        } else if (activeNode) {\n          // Create in relation to active node\n          const activeTier = activeNode.metadata?.tier || 3;\n          \n          if (activeTier === 1) {\n            // Add as conversation under main question\n            node = await nodeIntegration.createNodeFromMessage(\n              messageObj,\n              notebookId,\n              { \n                x: activeNode.position?.x || 350, \n                y: (activeNode.position?.y || 200) + 100 \n              },\n              {\n                parentNodeId: activeNode.id,\n                source: 'chat',\n                timestamp: new Date().toISOString()\n              },\n              'question',\n              3 // tier 3\n            );\n            \n            if (node) {\n              await nodeIntegration.createNodeRelationship(\n                activeNode.id,\n                node.id,\n                'extends',\n                notebookId\n              );\n            }\n          } else {\n            // Add to conversation node\n            if (await nodeIntegration.addMessageToNode(activeNode.id, messageObj)) {\n              node = activeNode;\n            } else {\n              // Create new node\n              node = await nodeIntegration.createNodeFromMessage(\n                messageObj,\n                notebookId,\n                { \n                  x: activeNode.position?.x || 450, \n                  y: (activeNode.position?.y || 350) + 60 \n                },\n                {\n                  parentNodeId: activeNode.metadata?.parentNodeId,\n                  source: 'chat',\n                  timestamp: new Date().toISOString()\n                },\n                'question',\n                3 // tier 3\n              );\n              \n              if (node) {\n                await nodeIntegration.createNodeRelationship(\n                  activeNode.id,\n                  node.id,\n                  'extends',\n                  notebookId\n                );\n              }\n            }\n          }\n        } else {\n          // Create standalone node\n          node = await nodeIntegration.createNodeFromMessage(\n            messageObj,\n            notebookId\n          );\n          \n          // Try to find main question\n          const mainQuestionNode = await nodeIntegration.findMainQuestionNode(notebookId);\n          if (node && mainQuestionNode) {\n            await nodeIntegration.createNodeRelationship(\n              mainQuestionNode.id,\n              node.id,\n              'extends',\n              notebookId\n            );\n          }\n        }\n        \n        if (node && node.id !== activeNode?.id) {\n          setSelectedNode(node.id);\n          setActiveNode(node.id);\n        }\n        \n        return node;\n      }\n      \n      // Fallback: create a standalone node\n      return await nodeIntegration.createNodeFromMessage(\n        messageObj,\n        notebookId\n      );\n      \n    } catch (error) {\n      console.error('Error creating node from message:', error);\n      return null;\n    }\n  };\n\n  // Submit handler\n  const handleSubmit = useCallback(async (e) => {\n    e.preventDefault();\n    \n    // Get the message from the form\n    const formData = new FormData(e.currentTarget);\n    const content = formData.get('input')?.toString() || '';\n    \n    if (!content.trim() || isProcessing) return;\n    \n    try {\n      setIsProcessing(true);\n      \n      // Generate message ID\n      const messageId = `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n      \n      // Create message object\n      const messageObj = {\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n        created_at: new Date().toISOString()\n      };\n      \n      // Create node for message\n      await createNodeFromMessage({\n        id: messageId,\n        role: 'user',\n        content: content.trim()\n      }, 'user');\n      \n      // Clear input field\n      chatHandler.setInput('');\n      \n      // Send message to API\n      chatHandler.append({\n        id: messageId,\n        role: 'user',\n        content: content.trim(),\n      });\n      \n    } catch (error) {\n      console.error('Error processing user message:', error);\n      setIsProcessing(false);\n    }\n  }, [isProcessing, notebookId, activeNode, createNodeFromMessage, chatHandler, setActiveNode, setSelectedNode]);\n\n  // Create a new thread\n  const handleCreateNewThread = useCallback(() => {\n    // Reset active node selection\n    setSelectedNode(null);\n    setActiveNode(null);\n    if (setActiveThread) {\n      setActiveThread(null);\n    }\n    \n    // Reset chat history but keep system message\n    const systemMessages = chatHandler.messages.filter(msg => msg.role === 'system');\n    chatHandler.setMessages(systemMessages);\n  }, [setSelectedNode, setActiveNode, chatHandler, setActiveThread]);\n  \n  // Send initial question if provided\n  useEffect(() => {\n    if (initialQuestion && !initialQuestionSentRef.current && !isProcessing && chatHandler.messages.length <= 1) {\n      const sendInitialQuestion = async () => {\n        try {\n          initialQuestionSentRef.current = true;\n          setIsProcessing(true);\n          \n          // Generate a unique ID\n          const messageId = `initial-question-${Date.now()}`;\n          \n          // Create node for the question\n          await createNodeFromMessage({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          }, 'user');\n          \n          // Send to API\n          chatHandler.append({\n            id: messageId,\n            role: 'user',\n            content: initialQuestion\n          });\n          \n        } catch (error) {\n          console.error('Error sending initial question:', error);\n          setIsProcessing(false);\n        }\n      };\n      \n      sendInitialQuestion();\n    }\n  }, [initialQuestion, isProcessing, chatHandler, notebookId, createNodeFromMessage]);\n  \n  // Sync with active node when it changes\n  useEffect(() => {\n    if (activeNode && !isProcessing && syncActiveThread) {\n      syncActiveThread();\n    }\n  }, [activeNode, isProcessing, syncActiveThread]);\n  \n  // Render based on mode\n  const renderChatUI = () => {\n    // Common chat UI\n    return (\n      <ChatSection handler={chatHandler} className=\"h-full\">\n        <ChatMessages className={`${fullScreen ? 'h-[calc(100%-100px)]' : 'h-[calc(100%-80px)]'} overflow-y-auto p-4`} />\n        <ChatInput className=\"border-t border-gray-200 bg-white\" onSubmit={handleSubmit}>\n          <ChatInput.Form className=\"px-3 py-2\">\n            <ChatInput.Field \n              type=\"textarea\" \n              placeholder=\"Type your message...\" \n              className=\"min-h-[44px] max-h-[200px] resize-none py-2.5 pl-4 pr-12 rounded-md border-gray-300\"\n              disabled={chatHandler.isLoading || isProcessing}\n            />\n            <div className=\"absolute right-12 bottom-[18px] flex items-center\">\n              <ModelSelector\n                selectedModel={modelId}\n                onChangeModel={handleModelChange}\n              />\n              <ChatInput.Upload>\n                <FileUploadButton />\n              </ChatInput.Upload>\n            </div>\n            <ChatInput.Submit\n              disabled={chatHandler.isLoading || isProcessing}\n              className=\"absolute right-3 bottom-[18px] p-1 rounded-md bg-blue-600 hover:bg-blue-700 text-white\"\n            >\n              {chatHandler.isLoading || isProcessing ? (\n                <Spinner className=\"h-5 w-5 border-2 border-white border-t-transparent\" />\n              ) : (\n                <svg className=\"h-5 w-5\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path d=\"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z\" />\n                </svg>\n              )}\n            </ChatInput.Submit>\n          </ChatInput.Form>\n        </ChatInput>\n      </ChatSection>\n    );\n  };\n  \n  // Panel mode has a header with close button\n  if (mode === \"panel\") {\n    return (\n      <div className={`flex flex-col h-full ${className}`}>\n        <div className=\"bg-gray-100 p-3 border-b border-gray-200 flex justify-between items-center\">\n          <h2 className=\"font-semibold text-gray-700\">\n            {activeNode ? (activeNode.type === 'question' ? 'Question' : 'Conversation') : 'Chat'}\n          </h2>\n          <div className=\"flex items-center space-x-2\">\n            <button\n              onClick={handleCreateNewThread}\n              className=\"text-gray-600 hover:text-gray-800 p-1 rounded-md hover:bg-gray-200\"\n              title=\"New conversation\"\n            >\n              <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                <path fillRule=\"evenodd\" d=\"M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z\" clipRule=\"evenodd\" />\n              </svg>\n            </button>\n            {onClose && (\n              <button \n                onClick={onClose}\n                className=\"text-gray-500 hover:text-gray-700\"\n                aria-label=\"Close panel\"\n              >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n                  <path fillRule=\"evenodd\" d=\"M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z\" clipRule=\"evenodd\" />\n                </svg>\n              </button>\n            )}\n          </div>\n        </div>\n        <div className=\"flex-1 overflow-hidden\">\n          {renderChatUI()}\n        </div>\n      </div>\n    );\n  }\n  \n  // Fullscreen mode has a header with navigation\n  if (mode === \"fullscreen\") {\n    return (\n      <div className={`flex flex-col h-screen ${className}`}>\n        <div className=\"bg-white border-b border-gray-200 px-4 py-4 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <button\n              onClick={() => window.history.back()}\n              className=\"mr-4 text-gray-600 hover:text-gray-900\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-5 w-5\"\n                viewBox=\"0 0 20 20\"\n                fill=\"currentColor\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n            </button>\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              Chat\n            </h1>\n          </div>\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={handleCreateNewThread}\n              className=\"text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-600 rounded-md hover:bg-blue-50\"\n            >\n              New Chat\n            </button>\n          </div>\n        </div>\n        <div className=\"flex-1 overflow-hidden bg-gray-50\">\n          <div className=\"max-w-4xl mx-auto bg-white shadow-sm h-full\">\n            {renderChatUI()}\n          </div>\n        </div>\n      </div>\n    );\n  }\n  \n  // Default mode - just the chat UI without header\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {renderChatUI()}\n    </div>\n  );\n};\n\n// Wrap with error boundary\nconst WrappedLlamaChat = (props) => (\n  <ChatErrorBoundary>\n    <LlamaChat {...props} />\n  </ChatErrorBoundary>\n);\n\nexport default WrappedLlamaChat;\n```\n\n## 2. Create a Chat API Endpoint with Streaming Support\n\n```javascript\n// src/pages/api/claude/chat-stream.js\n\nimport { Configuration, OpenAI } from 'openai';\nimport { createClient } from '@supabase/supabase-js';\n\n// Initialize Supabase client\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;\nconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;\nconst supabase = createClient(supabaseUrl, supabaseServiceKey);\n\n// Initialize Claude/OpenAI client\nconst apiKey = process.env.ANTHROPIC_API_KEY || process.env.OPENAI_API_KEY;\nconst client = new OpenAI({\n  apiKey,\n  baseURL: process.env.ANTHROPIC_API_URL || 'https://api.anthropic.com/v1'\n});\n\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  const { messages, notebookId, model = 'claude-3-5-sonnet-20240620', stream = true } = req.body;\n  \n  if (!messages || !Array.isArray(messages) || messages.length === 0) {\n    return res.status(400).json({ error: 'Invalid messages format' });\n  }\n\n  try {\n    // Set proper headers for streaming\n    if (stream) {\n      res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache, no-transform',\n        'Connection': 'keep-alive',\n      });\n    }\n\n    // Create completion with streaming\n    const completion = await client.chat.completions.create({\n      model,\n      messages,\n      stream,\n      temperature: 0.7,\n      max_tokens: 4000,\n    });\n\n    if (stream) {\n      // Handle streaming response\n      for await (const chunk of completion) {\n        // Send each chunk as an SSE event\n        const content = chunk.choices[0]?.delta?.content || '';\n        if (content) {\n          res.write(`data: ${JSON.stringify({ content })}\\n\\n`);\n        }\n      }\n      \n      // End the stream\n      res.write('data: [DONE]\\n\\n');\n      res.end();\n    } else {\n      // Handle non-streaming response\n      const content = completion.choices[0]?.message?.content;\n      \n      // Save to database if needed\n      if (notebookId) {\n        // Implement database saving logic here\n      }\n      \n      return res.status(200).json({ content });\n    }\n  } catch (error) {\n    console.error('Error processing chat request:', error);\n    \n    if (stream) {\n      // Send error in streaming format\n      res.write(`data: ${JSON.stringify({ error: error.message })}\\n\\n`);\n      res.end();\n    } else {\n      return res.status(500).json({ error: error.message });\n    }\n  }\n}\n```\n\n## 3. Chat Node Integration Module\n\n```typescript\n// src/lib/chat/nodeIntegration.ts\n\nimport { supabase } from '@/lib/supabaseClient';\nimport { generateUUID } from '@/utils/uuidUtils';\n\n/**\n * Node integration functionality for chat\n */\nexport const nodeIntegration = {\n  /**\n   * Create a node from a chat message\n   */\n  async createNodeFromMessage(\n    message: any,\n    notebookId: string,\n    position: { x: number, y: number } = { x: 200, y: 200 },\n    metadata: any = {},\n    type: 'question' | 'response' | 'note' | 'drawing' = 'question',\n    tier: number = 3\n  ) {\n    try {\n      // Determine content and type\n      const content = message.content || '';\n      \n      // Create the node data\n      const nodeData = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        content,\n        type,\n        position,\n        metadata: {\n          ...metadata,\n          tier,\n          source: 'chat',\n          chatMessageId: message.id,\n          timestamp: message.created_at || new Date().toISOString()\n        },\n        messages: [{\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          created_at: message.created_at || new Date().toISOString()\n        }],\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n        isConversationNode: true\n      };\n      \n      // Save to database\n      const { data, error } = await supabase\n        .from('nodes')\n        .insert(nodeData)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error creating node from message:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Add a message to an existing node\n   */\n  async addMessageToNode(nodeId: string, message: any, parentMessageId?: string) {\n    try {\n      // Get the node\n      const { data: node, error: nodeError } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('id', nodeId)\n        .single();\n        \n      if (nodeError) throw nodeError;\n      \n      // Add message to the messages array\n      const messages = node.messages || [];\n      messages.push({\n        id: message.id,\n        role: message.role,\n        content: message.content,\n        parentMessageId,\n        created_at: message.created_at || new Date().toISOString()\n      });\n      \n      // Update the node\n      const { error: updateError } = await supabase\n        .from('nodes')\n        .update({\n          messages,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', nodeId);\n        \n      if (updateError) throw updateError;\n      \n      return true;\n    } catch (error) {\n      console.error('Error adding message to node:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Create a relationship between nodes\n   */\n  async createNodeRelationship(\n    fromNodeId: string,\n    toNodeId: string,\n    type: string = 'extends',\n    notebookId: string,\n    metadata: any = {}\n  ) {\n    try {\n      const relationshipData = {\n        id: generateUUID(),\n        from_node_id: fromNodeId,\n        to_node_id: toNodeId,\n        type,\n        notebook_id: notebookId,\n        metadata,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      const { data, error } = await supabase\n        .from('relationships')\n        .insert(relationshipData)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      return data;\n    } catch (error) {\n      console.error('Error creating node relationship:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Find the main question node for a notebook\n   */\n  async findMainQuestionNode(notebookId: string) {\n    try {\n      const { data, error } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .eq('type', 'question')\n        .filter('metadata->tier', 'eq', 1)\n        .order('created_at', { ascending: true })\n        .limit(1);\n        \n      if (error) throw error;\n      \n      return data && data.length > 0 ? data[0] : null;\n    } catch (error) {\n      console.error('Error finding main question node:', error);\n      return null;\n    }\n  },\n  \n  /**\n   * Create a tier 2 category node\n   */\n  async createTier2Node(\n    parentNodeId: string,\n    type: 'question' | 'response' | 'note' | 'drawing',\n    content: string,\n    notebookId: string\n  ) {\n    try {\n      // Get parent node to determine position\n      const { data: parentNode, error: parentError } = await supabase\n        .from('nodes')\n        .select('*')\n        .eq('id', parentNodeId)\n        .single();\n        \n      if (parentError) throw parentError;\n      \n      // Calculate position relative to parent\n      const position = {\n        x: (parentNode.position?.x || 350) + 150,\n        y: (parentNode.position?.y || 200) + 100\n      };\n      \n      // Create the node data\n      const nodeData = {\n        id: generateUUID(),\n        notebook_id: notebookId,\n        content,\n        type,\n        position,\n        metadata: {\n          tier: 2,\n          parentNodeId,\n          source: 'chat',\n          timestamp: new Date().toISOString()\n        },\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      \n      // Save to database\n      const { data, error } = await supabase\n        .from('nodes')\n        .insert(nodeData)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      \n      // Create relationship to parent\n      await this.createNodeRelationship(\n        parentNodeId,\n        data.id,\n        'contains',\n        notebookId,\n        {\n          direction: 'outgoing',\n          intention: 'categorization',\n          state: 'active'\n        }\n      );\n      \n      return data;\n    } catch (error) {\n      console.error('Error creating tier 2 node:', error);\n      return null;\n    }\n  }\n};\n\nexport default nodeIntegration;\n```\n\n## 4. Unified Store Hook for Chat Sync\n\n```typescript\n// src/hooks/useChatNodeSync.ts\n\nimport { useState, useCallback } from 'react';\nimport { supabase } from '@/lib/supabaseClient';\nimport { useNodes, useNodeActions, useRelationships } from '@/stores';\n\n/**\n * Hook for synchronizing chat messages with nodes\n */\nexport const useChatNodeSync = ({ notebookId }) => {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  // Get node store data\n  const nodes = useNodes();\n  const relationships = useRelationships();\n  const { setActiveNode } = useNodeActions();\n  \n  /**\n   * Sync node to chat - load messages from a specific node\n   */\n  const syncNodeToChat = useCallback(async (nodeId) => {\n    try {\n      setIsLoading(true);\n      \n      // Get the node\n      const node = nodes[nodeId];\n      if (!node) {\n        throw new Error(`Node ${nodeId} not found`);\n      }\n      \n      // Get node messages\n      const messages = node.messages || [];\n      \n      // If this is a conversation node, return its messages\n      if (node.isConversationNode && messages.length > 0) {\n        return messages;\n      }\n      \n      // Otherwise, create a message from the node content\n      return [{\n        id: `node_${node.id}`,\n        role: node.type === 'question' ? 'user' : 'assistant',\n        content: node.content,\n        created_at: node.created_at,\n        nodeId: node.id\n      }];\n    } catch (err) {\n      setError(err.message);\n      console.error('Error syncing node to chat:', err);\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [nodes]);\n  \n  /**\n   * Find node by message ID\n   */\n  const findNodeByMessageId = useCallback((messageId) => {\n    return Object.values(nodes).find(node => \n      node.messages?.some(msg => msg.id === messageId)\n    );\n  }, [nodes]);\n  \n  /**\n   * Sync chat messages to nodes\n   */\n  const syncChatToNodes = useCallback(async (messages = []) => {\n    try {\n      setIsLoading(true);\n      \n      // Create a map of messages to nodes\n      const messageToNodeMap = new Map();\n      \n      // Process each message\n      for (const message of messages) {\n        // Skip system messages\n        if (message.role === 'system') continue;\n        \n        // Check if message already has a node\n        const existingNode = findNodeByMessageId(message.id);\n        if (existingNode) {\n          messageToNodeMap.set(message.id, existingNode.id);\n          continue;\n        }\n        \n        // Create a new node for this message\n        const nodeData = {\n          id: generateUUID(),\n          notebook_id: notebookId,\n          content: message.content,\n          type: message.role === 'user' ? 'question' : 'response',\n          position: { x: 200, y: 200 }, // Default position\n          metadata: {\n            tier: 3,\n            source: 'chat',\n            chatMessageId: message.id,\n            timestamp: message.created_at || new Date().toISOString()\n          },\n          messages: [message],\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString(),\n          isConversationNode: true\n        };\n        \n        // Save to database\n        const { data, error } = await supabase\n          .from('nodes')\n          .insert(nodeData)\n          .select()\n          .single();\n          \n        if (error) throw error;\n        \n        messageToNodeMap.set(message.id, data.id);\n      }\n      \n      // Create relationships between message nodes\n      for (let i = 1; i < messages.length; i++) {\n        const prevMessage = messages[i - 1];\n        const currMessage = messages[i];\n        \n        // Skip system messages\n        if (prevMessage.role === 'system' || currMessage.role === 'system') continue;\n        \n        const prevNodeId = messageToNodeMap.get(prevMessage.id);\n        const currNodeId = messageToNodeMap.get(currMessage.id);\n        \n        if (prevNodeId && currNodeId) {\n          await supabase\n            .from('relationships')\n            .insert({\n              id: generateUUID(),\n              from_node_id: prevNodeId,\n              to_node_id: currNodeId,\n              type: currMessage.role === 'assistant' ? 'responds' : 'follows',\n              notebook_id: notebookId,\n              created_at: new Date().toISOString(),\n              updated_at: new Date().toISOString()\n            });\n        }\n      }\n      \n      // Set active node to last message node\n      const lastMessage = messages[messages.length - 1];\n      if (lastMessage && lastMessage.role !== 'system') {\n        const nodeId = messageToNodeMap.get(lastMessage.id);\n        if (nodeId) {\n          setActiveNode(nodeId);\n        }\n      }\n      \n      return true;\n    } catch (err) {\n      setError(err.message);\n      console.error('Error syncing chat to nodes:', err);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [notebookId, findNodeByMessageId, setActiveNode]);\n  \n  return {\n    syncNodeToChat,\n    syncChatToNodes,\n    findNodeByMessageId,\n    isLoading,\n    error\n  };\n};\n\nexport default useChatNodeSync;\n```\n\n## 5. Files to Update\n\n1. Replace `src/components/ui/LlamaChat.tsx` with our new implementation\n2. Add the new `src/pages/api/claude/chat-stream.js` endpoint\n3. Create or update `src/lib/chat/nodeIntegration.ts` with our integration logic\n4. Create or update `src/hooks/useChatNodeSync.ts` with our sync hook\n5. Remove all other chat implementations:\n\n```bash\nrm ./src/components/ui/AISdkChat.tsx \\\n   ./src/components/ui/BasicChatPanel.tsx \\\n   ./src/components/ui/ChatPanel.tsx \\\n   ./src/components/ui/DirectChatPanel.tsx \\\n   ./src/components/ui/LlamaChat.updated.tsx \\\n   ./src/components/ui/LlamaIndexChat.tsx \\\n   ./src/components/ui/SimpleChatPanel.tsx \\\n   ./src/components/ui/StreamingChatPanel.tsx \\\n   ./src/components/conversation/ChatPanel.tsx\n```\n\n## 6. Update the Panel View for Chat Integration\n\n```tsx\n// src/components/ChatSidePanel.tsx\n\nimport React from 'react';\nimport WrappedLlamaChat from '@/components/chat/LlamaChat';\n\nexport const ChatSidePanel = ({\n  notebookId,\n  systemPrompt,\n  onClose,\n  isOpen,\n  isFullScreen,\n  onToggleFullScreen\n}) => {\n  return (\n    <div\n      className={`bg-white border-l border-gray-200 shadow-xl ${\n        isOpen\n          ? (isFullScreen\n              ? 'fixed inset-0 z-50 w-full h-full'\n              : 'fixed right-0 top-0 bottom-0 z-40 w-80 h-full')\n          : 'fixed right-[-320px] top-0 bottom-0 z-40 w-80 h-full'\n      }`}\n      style={{\n        transition: 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out',\n        transform: isOpen ? 'translateX(0)' : 'translateX(100%)',\n        opacity: isOpen ? 1 : 0,\n        display: 'flex',\n        flexDirection: 'column'\n      }}\n    >\n      <WrappedLlamaChat\n        notebookId={notebookId}\n        systemPrompt={systemPrompt}\n        onClose={onClose}\n        mode=\"panel\"\n        className=\"h-full\"\n      />\n    </div>\n  );\n};\n\nexport default ChatSidePanel;\n```\n\n## 7. Update Full-Screen Chat Page\n\n```tsx\n// src/pages/notebooks/[id]/chat.tsx\n\nimport React from 'react';\nimport { useRouter } from 'next/router';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport WrappedLlamaChat from '@/components/chat/LlamaChat';\nimport Layout from '@/components/layout/Layout';\nimport LoadingSpinner from '@/components/ui/LoadingSpinner';\n\nconst NotebookChatPage = () => {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Handle the case when router.query isn't loaded yet\n  if (!router.isReady) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n  \n  const notebookId = typeof id === 'string' ? id : '';\n  \n  const { notebook, loading, error } = useNotebook(notebookId);\n\n  // Handle loading state\n  if (loading) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n\n  // Handle error state\n  if (error || !notebook) {\n    return (\n      <Layout>\n        <div className=\"flex flex-col items-center justify-center h-screen\">\n          <h2 className=\"text-xl font-semibold text-red-600 mb-4\">Error Loading Notebook</h2>\n          <p className=\"text-gray-700 mb-6\">{error || 'Notebook not found'}</p>\n          <button\n            onClick={() => router.push('/notebooks')}\n            className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n          >\n            Return to Notebooks\n          </button>\n        </div>\n      </Layout>\n    );\n  }\n\n  return (\n    <Layout>\n      <WrappedLlamaChat\n        notebookId={notebookId}\n        systemPrompt={notebook.system_prompt}\n        mode=\"fullscreen\"\n        className=\"h-screen\"\n      />\n    </Layout>\n  );\n};\n\nexport default NotebookChatPage;\n```\n\n## 8. Update Canvas Integration\n\nIn your Canvas component, replace the chat integration with this simplified integration:\n\n```tsx\n// Add this to your CanvasContainer.tsx where you handle the side panel\nimport WrappedLlamaChat from '@/components/chat/LlamaChat';\n\n// Then in your JSX where you render the side panel:\n{isSidePanelOpen && (\n  <ChatSidePanel\n    notebookId={notebookId}\n    systemPrompt={systemPrompt}\n    onClose={() => setIsSidePanelOpen(false)}\n    isOpen={isSidePanelOpen}\n    isFullScreen={isSidePanelFullScreen}\n    onToggleFullScreen={() => setIsSidePanelFullScreen(prev => !prev)}\n  />\n)}\n```\n\n## 9. Install Required Dependencies\n\nFinally, make sure you have all the required dependencies:\n\n```bash\nnpm install @llamaindex/chat-ui ai openai anthropic\n```\n\n## Implementation Details\n\nThis solution provides:\n\n1. **One source of truth** - All chat interactions are synchronized with your node structure\n2. **Streaming text** - Both API and UI are configured for proper streaming\n3. **Multiple view support** - The same component works in panel, full-screen, and embedded modes\n4. **Correct node relationships** - Messages properly create and update nodes based on their context\n5. **Error handling** - Robust error boundaries prevent crashes when issues occur\n\nAll these components work together to create a unified, consistent chat experience across your application. The LlamaChat component is now your main entry point for chat functionality in any context, and it keeps everything synchronized with your visual node structure.",
            "citations": []
          }
        ],
        "updated_at": "2025-05-15T21:00:57.173097Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}