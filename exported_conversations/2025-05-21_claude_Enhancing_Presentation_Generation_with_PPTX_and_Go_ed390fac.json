{
  "id": "ed390fac-8daa-4aff-8137-7b6115da3903",
  "source": "claude",
  "title": "Enhancing Presentation Generation with PPTX and Google Slides",
  "created_at": "2025-05-21T13:34:52.579060Z",
  "updated_at": "2025-05-21T13:39:37.013360Z",
  "summary": "",
  "message_count": 2,
  "messages": [
    {
      "id": "baf9f498-5c15-408d-8e6a-df7665b1864e",
      "role": "human",
      "content": "let's remove the md2gslides since we're going to focus on generating the content directly - for now as a PPTX and then direclty with the API on google slides, or maybe there's a way to use the API to upload a PPTX to google slides i like the factory idea  I think it's also possible to use vision for the content we create - perhaps it's possible to generate a visual of the slide from the PPTX and to ask the LLM to critique that once it's all done? is there a place to set a template (font/style/colors/sizes/etc?)i don't see in the code where you can position a text block/left/right etc.   I am wondering how we can align with templates on google slides after we make our content because i want to be able to use the themes function to change the theme, sometimes the image will be left othertimes with a different theme it might make it covering spanning the bottom of the screen, what do we need to do to make it like that?  REview my project code in the projects context window and comments and return with full files moving us into the enxt step",
      "created_at": "2025-05-21T13:34:54.451138Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-21T13:34:54.446882Z",
            "stop_timestamp": "2025-05-21T13:34:54.446882Z",
            "flags": null,
            "type": "text",
            "text": "let's remove the md2gslides since we're going to focus on generating the content directly - for now as a PPTX and then direclty with the API on google slides, or maybe there's a way to use the API to upload a PPTX to google slides i like the factory idea  I think it's also possible to use vision for the content we create - perhaps it's possible to generate a visual of the slide from the PPTX and to ask the LLM to critique that once it's all done? is there a place to set a template (font/style/colors/sizes/etc?)i don't see in the code where you can position a text block/left/right etc.   I am wondering how we can align with templates on google slides after we make our content because i want to be able to use the themes function to change the theme, sometimes the image will be left othertimes with a different theme it might make it covering spanning the bottom of the screen, what do we need to do to make it like that?  REview my project code in the projects context window and comments and return with full files moving us into the enxt step",
            "citations": []
          }
        ],
        "updated_at": "2025-05-21T13:34:54.451138Z",
        "attachments": [
          {
            "file_name": "paste.txt",
            "file_size": 63552,
            "file_type": "txt",
            "extracted_content": "2. Modular Component Architecture (Medium-term)\nThis approach refactors the codebase into proper Python modules with clear interfaces:\n\nCreate a proper package structure with setup.py\nDefine clear interfaces between components with appropriate typing\nImplement rich error objects that carry context between operations\nAdd comprehensive test coverage for each component\nCreate pluggable backends for different services (image hosting, diagram rendering)\n\npython# makeslides/\n# ├── __init__.py\n# ├── cli.py\n# ├── core/\n# │   ├── __init__.py\n# │   ├── config.py\n# │   ├── workflow.py\n# │   └── errors.py\n# ├── parsers/\n# │   ├── __init__.py\n# │   └── guide_parser.py\n# ├── diagrams/\n# │   ├── __init__.py\n# │   └── renderer.py\n# ├── images/\n# │   ├── __init__.py\n# │   ├── manager.py\n# │   └── uploaders/\n# │       ├── __init__.py\n# │       ├── litterbox.py\n# │       ├── imgur.py\n# │       └── base64.py\n# └── slides/\n#     ├── __init__.py\n#     ├── markdown.py\n#     └── google.py\n3. Service-Based Architecture (Long-term)\nThe most ambitious approach creates a reusable service that can scale:\n\nImplement a client-server architecture with a simple REST API\nProvide a web interface for slide creation in addition to CLI\nUse proper database storage for assets and caching\nAdd user authentication and persistent configuration\nImplement job queues for asynchronous processing of long-running tasks\n\nStep-by-Step Implementation Plan\nI recommend implementing Approach 2 (Modular Component Architecture) as it provides the best balance of improved architecture without excessive complexity. Here's a plan:\nPhase 1: Core Refactoring (1-2 weeks)\n\nCreate package structure:\nbashmkdir -p makeslides/{core,parsers,diagrams,images,slides}\ntouch makeslides/{core,parsers,diagrams,images,slides}/__init__.py\n\nEstablish core interfaces:\npython# makeslides/core/workflow.py\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\n\n@dataclass\nclass WorkflowResult:\n    success: bool\n    data: Dict[str, Any]\n    error: Optional[str] = None\n\nclass Workflow:\n    \"\"\"Base class for all workflows\"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.state = {}\n        \n    def execute(self) -> WorkflowResult:\n        \"\"\"Execute the workflow and return the result\"\"\"\n        raise NotImplementedError\n\nDefine core error types:\npython# makeslides/core/errors.py\nclass MakeSlidesError(Exception):\n    \"\"\"Base class for all MakeSlides errors\"\"\"\n    pass\n    \nclass ConfigError(MakeSlidesError):\n    \"\"\"Configuration error\"\"\"\n    pass\n    \nclass ParsingError(MakeSlidesError):\n    \"\"\"Error parsing facilitator guide\"\"\"\n    pass\n    \nclass DiagramError(MakeSlidesError):\n    \"\"\"Error rendering diagram\"\"\"\n    pass\n    \nclass ImageError(MakeSlidesError):\n    \"\"\"Error processing image\"\"\"\n    pass\n    \nclass SlideError(MakeSlidesError):\n    \"\"\"Error creating slides\"\"\"\n    pass\n\nCreate configuration module:\npython# makeslides/core/config.py\nimport os\nimport yaml\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\n\nDEFAULT_CONFIG = {\n    \"prompt_template\": \"{{content}}\",\n    \"layout_mappings\": {},\n    \"slide_defaults\": {},\n    \"image_upload\": {\n        \"service\": \"litterbox\",\n        \"expiry\": \"24h\",\n        \"max_retries\": 3\n    },\n    \"diagrams\": {\n        \"mermaid_cmd\": \"mmdc\",\n        \"max_retries\": 3\n    }\n}\n\ndef load_config(config_path: Optional[Path] = None) -> Dict[str, Any]:\n    \"\"\"Load configuration from file with fallbacks to defaults\"\"\"\n    config = DEFAULT_CONFIG.copy()\n    \n    if config_path and config_path.exists():\n        try:\n            with open(config_path, 'r') as f:\n                user_config = yaml.safe_load(f)\n                if user_config:\n                    # Deep merge config\n                    _deep_update(config, user_config)\n        except Exception as e:\n            raise ConfigError(f\"Error loading config from {config_path}: {e}\")\n    \n    # Override with environment variables\n    for key, env_var in ENV_MAPPINGS.items():\n        if env_var in os.environ:\n            _set_config_value(config, key, os.environ[env_var])\n            \n    return config\n\n\nPhase 2: Component Implementation (2-3 weeks)\n\nImplement guide parser:\npython# makeslides/parsers/guide_parser.py\nfrom typing import Dict, Any, List\nimport anthropic\nfrom pathlib import Path\n\nclass GuideParser:\n    \"\"\"Parse facilitator guide into structured slides data\"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.client = self._init_client()\n        \n    def _init_client(self) -> anthropic.Anthropic:\n        api_key = self.config.get(\"anthropic_api_key\") or os.environ.get(\"ANTHROPIC_API_KEY\")\n        if not api_key:\n            raise ConfigError(\"Anthropic API key not set. Set ANTHROPIC_API_KEY environment variable.\")\n        return anthropic.Anthropic(api_key=api_key)\n        \n    def parse(self, guide_path: Path) -> List[Dict[str, Any]]:\n        \"\"\"Parse facilitator guide and return slides data\"\"\"\n        # Implementation\n\nImplement diagram renderer:\npython# makeslides/diagrams/renderer.py\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\nimport subprocess\n\nclass MermaidRenderer:\n    \"\"\"Render Mermaid diagrams to image files\"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.cmd = config.get(\"diagrams\", {}).get(\"mermaid_cmd\", \"mmdc\")\n        \n    def render(self, content: str, output_path: Path, diagram_type: str = \"flowchart\") -> Optional[Path]:\n        \"\"\"Render a diagram to an image file\"\"\"\n        # Implementation\n\nImplement image manager:\npython# makeslides/images/manager.py\nfrom typing import Dict, Any, List, Optional\nfrom pathlib import Path\n\nclass ImageManager:\n    \"\"\"Manage images for slides\"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.uploader = self._init_uploader()\n        \n    def _init_uploader(self):\n        service = self.config.get(\"image_upload\", {}).get(\"service\", \"litterbox\")\n        if service == \"litterbox\":\n            from .uploaders.litterbox import LitterboxUploader\n            return LitterboxUploader(self.config)\n        elif service == \"imgur\":\n            from .uploaders.imgur import ImgurUploader\n            return ImgurUploader(self.config)\n        elif service == \"base64\":\n            from .uploaders.base64 import Base64Uploader\n            return Base64Uploader(self.config)\n        else:\n            raise ConfigError(f\"Unknown image upload service: {service}\")\n            \n    def process_images(self, markdown_path: Path, strategy: str = \"auto\") -> Dict[str, Any]:\n        \"\"\"Process all images in a markdown file\"\"\"\n        # Implementation\n\nImplement slides generator:\npython# makeslides/slides/google.py\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\n\nclass GoogleSlidesGenerator:\n    \"\"\"Generate Google Slides from markdown\"\"\"\n    \n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        \n    def create_slides(self, markdown_path: Path) -> Optional[str]:\n        \"\"\"Create Google Slides presentation and return URL\"\"\"\n        # Implementation\n\n\nPhase 3: CLI and Integration (1-2 weeks)\n\nCreate high-level workflow:\npython# makeslides/core/workflows.py\nfrom typing import Dict, Any, Optional\nfrom pathlib import Path\nfrom .workflow import Workflow, WorkflowResult\n\nclass SlidesWorkflow(Workflow):\n    \"\"\"Complete workflow to generate slides from a facilitator guide\"\"\"\n    \n    def __init__(self, config: Dict[str, Any], guide_path: Path, output_dir: Optional[Path] = None):\n        super().__init__(config)\n        self.guide_path = guide_path\n        self.output_dir = output_dir or guide_path.parent\n        \n    def execute(self) -> WorkflowResult:\n        try:\n            # Step 1: Parse guide\n            from ..parsers.guide_parser import GuideParser\n            parser = GuideParser(self.config)\n            slides_data = parser.parse(self.guide_path)\n            \n            # Additional steps...\n            \n            return WorkflowResult(success=True, data={\n                \"slides_data\": slides_data,\n                \"markdown_path\": markdown_path,\n                \"presentation_url\": presentation_url\n            })\n        except Exception as e:\n            return WorkflowResult(success=False, data={}, error=str(e))\n\nImplement CLI:\npython# makeslides/cli.py\nimport argparse\nimport sys\nfrom pathlib import Path\nfrom .core.config import load_config\nfrom .core.workflows import SlidesWorkflow\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Create slides from facilitator guides\")\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Command to execute\")\n    \n    # Define subcommands...\n    \n    args = parser.parse_args()\n    \n    # Execute commands...\n    \nif __name__ == \"__main__\":\n    main()\n\nCreate setup.py:\npython# setup.py\nfrom setuptools import setup, find_packages\n\nsetup(\n    name=\"makeslides\",\n    version=\"0.1.0\",\n    packages=find_packages(),\n    install_requires=[\n        \"anthropic>=0.3.0,<0.4.0\",\n        \"pyyaml>=6.0,<7.0\",\n        \"requests>=2.25.0,<3.0.0\",\n    ],\n    entry_points={\n        'console_scripts': [\n            'makeslides=makeslides.cli:main',\n        ],\n    },\n    python_requires=\">=3.8\",\n)\n\n\nPhase 4: Testing and Documentation (1-2 weeks)\n\nWrite tests:\npython# tests/test_guide_parser.py\nimport pytest\nfrom pathlib import Path\nfrom makeslides.parsers.guide_parser import GuideParser\n\n@pytest.fixture\ndef mock_config():\n    return {\n        \"prompt_template\": \"{{content}}\",\n        \"anthropic_api_key\": \"test_key\"\n    }\n    \ndef test_parser_initialization(mock_config):\n    parser = GuideParser(mock_config)\n    assert parser.config == mock_config\n    \n# More tests...\n\nCreate user documentation:\n\nInstallation guide\nUsage examples\nConfiguration reference\nTroubleshooting guide\n\n\nCreate developer documentation:\n\nArchitecture overview\nComponent interfaces\nExtension points\nTesting guide\n\n\n\nImmediate Improvements\nWhile working on the larger refactoring, here are some immediate improvements to make:\n\nFix the image upload bug:\n\nIn diagrams_to_images.py, after setting the image_url in the slide, save the JSON file right away\nIn json_to_markdown.py, check for image_url in multiple formats (relative and absolute paths)\n\n\nAdd better error reporting:\n\nCreate a status file that records the progress and errors of each step\nAdd colored console output to highlight errors and warnings\n\n\nImprove image reliability:\n\nImplement fallback uploaders (try litterbox, then imgur, then base64)\nAdd data validation before and after uploads to ensure image consistency\n\n\nEnhance markdown formatting:\n\nAdd image size and alignment options in the markdown\nImprove column layout rendering with consistent spacing\n\n\n\nBy implementing these changes, you'll significantly improve the reliability and maintainability of the MakeSlides tool while addressing the immediate issues with image uploads.\nWould you like me to provide more detailed code for any specific part of this plan?Retrylet's work on pptx layouts because i think i want the flow to be interactive with an LLM to ask it to review the content and to go into a few chunks - we should take our old prompt and perhaps split it into a few stages, we will use best practices from working with claude extended thinking (broader pastedBGhere's where we are, how would you answer: I want the pydantic schema and an explanation of what it is - i want a planner.py with some great prompting - i want the prompts to be in an easy to use YAML and follows good prompt practices. I think perhaps since the extended thinking is on we might be able to do a b and c at the same time rather than separate prompts, let's try - and return valid json which is possible with the tool following this practice: And be sure to update the pptx.py renderer in full and make sure it supports image blocks and allows for bold and \\n and bulleted lists with line breaks between them, - how do we build this so that if/when we use the google API to do almost the same exact thing it's easy to extend? and the rcat works, except i don't know how to copy and apaste that to bring into here, also /core has nothing so i did it to here and it opened a vim i think rcat makeslides | less Think about my goals and what i'm building and make a few versions of the strategy given what you know about me and my interests and explroations and give me a PRD before doing the rest of the work also, guide me step by step in how to do the testing, and give me all files in full so i can copy and paste - i've never done testing before so explain it as you goEditArchitected comprehensive slide generation tool with strategic planning11sThe rest of the thought process is not available for this response.Building an Intelligent Slide Deck Generator with LLM Integration\nBased on your requirements and the existing codebase, I'll provide a comprehensive implementation plan for enhancing MakeSlides with intelligent layout selection, LLM-powered content organization, and flexible rendering options. This will transform your current tool into a powerful presentation builder that leverages Claude's extended thinking capabilities.\nProduct Requirements Document (PRD)\nVision\nCreate an intelligent slide deck generator that analyzes documents, creates well-structured presentations with appropriate layouts, and leverages LLM capabilities to refine content organization and visual elements.\nCore Features\n\nSmart Layout Selection: Automatically choose the best slide layout based on content type\nVisual Element Integration: Insert diagrams, charts, and images where appropriate\nContent Organization: Structure material logically with proper flow and transitions\nLLM Review & Enhancement: Allow Claude to critique and improve presentations\nMultiple Output Formats: Support for PowerPoint (PPTX) and Google Slides\n\nUser Flow\n\nUser submits document (Markdown, text, etc.)\nSystem analyzes content, creates outline, and generates initial slides\nLLM reviews and suggests improvements\nUser reviews final presentation and makes any manual adjustments\nSystem generates the output in desired format\n\nImplementation Plan\nI'll provide all the key components you requested:\n\nPydantic schema for slide specifications\nPlanner module with YAML-based prompts\nPowerPoint renderer with rich formatting support\nTesting infrastructure\n\nLet's start with the core components:\n1. Pydantic Schema (models.py)\npython# makeslides/core/models.py\nfrom enum import Enum\nfrom typing import List, Optional, Dict, Any, Union\nfrom pydantic import BaseModel, Field\n\nclass ContentType(str, Enum):\n    \"\"\"Type of content for slide elements\"\"\"\n    TEXT = \"text\"\n    BULLETS = \"bullets\"\n    IMAGE = \"image\"\n    DIAGRAM = \"diagram\"\n    CHART = \"chart\"\n    TABLE = \"table\"\n    QUOTE = \"quote\"\n\nclass SlideLayout(str, Enum):\n    \"\"\"Available slide layouts\"\"\"\n    TITLE_ONLY = \"TITLE_ONLY\"\n    TITLE_AND_CONTENT = \"TITLE_AND_CONTENT\"\n    SECTION_HEADER = \"SECTION_HEADER\"\n    TWO_COLUMNS = \"TWO_COLUMNS\"\n    COMPARISON = \"COMPARISON\"\n    BIG_NUMBER = \"BIG_NUMBER\"\n    QUOTE = \"QUOTE\"\n    IMAGE_ONLY = \"IMAGE_ONLY\"\n    IMAGE_WITH_CAPTION = \"IMAGE_WITH_CAPTION\"\n    BLANK = \"BLANK\"\n\nclass ImagePosition(str, Enum):\n    \"\"\"Position options for images\"\"\"\n    CENTER = \"center\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    BACKGROUND = \"background\"\n    FULL = \"full\"\n\nclass TextFormat(BaseModel):\n    \"\"\"Text formatting options\"\"\"\n    bold: bool = False\n    italic: bool = False\n    underline: bool = False\n    color: Optional[str] = None\n    size: Optional[int] = None\n\nclass TextBlock(BaseModel):\n    \"\"\"Text content block\"\"\"\n    type: str = ContentType.TEXT\n    content: str\n    format: Optional[TextFormat] = None\n\nclass BulletItem(BaseModel):\n    \"\"\"Individual bullet item\"\"\"\n    content: str\n    format: Optional[TextFormat] = None\n    sub_bullets: List[\"BulletItem\"] = Field(default_factory=list)\n\nclass BulletBlock(BaseModel):\n    \"\"\"Bulleted list block\"\"\"\n    type: str = ContentType.BULLETS\n    items: List[BulletItem] = Field(default_factory=list)\n\nclass ImageBlock(BaseModel):\n    \"\"\"Image content block\"\"\"\n    type: str = ContentType.IMAGE\n    source: str  # URL or file path\n    alt_text: Optional[str] = None\n    position: ImagePosition = ImagePosition.CENTER\n    width: Optional[int] = None\n    height: Optional[int] = None\n\nclass DiagramBlock(BaseModel):\n    \"\"\"Diagram content block\"\"\"\n    type: str = ContentType.DIAGRAM\n    diagram_type: str  # flowchart, mindmap, etc.\n    content: str  # Mermaid syntax\n    alt_text: Optional[str] = None\n    width: Optional[int] = None\n    height: Optional[int] = None\n\nclass ChartBlock(BaseModel):\n    \"\"\"Chart content block\"\"\"\n    type: str = ContentType.CHART\n    chart_type: str  # bar, line, pie, etc.\n    data: Dict[str, Any]  # Chart data\n    title: Optional[str] = None\n    width: Optional[int] = None\n    height: Optional[int] = None\n\nclass TableBlock(BaseModel):\n    \"\"\"Table content block\"\"\"\n    type: str = ContentType.TABLE\n    headers: List[str]\n    rows: List[List[str]]\n    width: Optional[int] = None\n\nclass QuoteBlock(BaseModel):\n    \"\"\"Quote content block\"\"\"\n    type: str = ContentType.QUOTE\n    quote: str\n    attribution: Optional[str] = None\n    format: Optional[TextFormat] = None\n\nContentBlock = Union[TextBlock, BulletBlock, ImageBlock, DiagramBlock, ChartBlock, TableBlock, QuoteBlock]\n\nclass Slide(BaseModel):\n    \"\"\"Single slide specification\"\"\"\n    title: str\n    subtitle: Optional[str] = None\n    layout: SlideLayout\n    blocks: List[ContentBlock] = Field(default_factory=list)\n    notes: Optional[str] = None\n    slide_number: Optional[int] = None\n    background: Optional[str] = None  # Background image or color\n\nclass Presentation(BaseModel):\n    \"\"\"Complete presentation specification\"\"\"\n    title: str\n    author: Optional[str] = None\n    description: Optional[str] = None\n    theme: Optional[str] = None\n    slides: List[Slide] = Field(default_factory=list)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n2. Planner with YAML Prompts (planner.py)\npython# makeslides/core/planner.py\nimport yaml\nimport os\nimport json\nimport anthropic\nfrom typing import Dict, List, Any, Optional\nfrom pathlib import Path\nfrom .models import Slide, Presentation, SlideLayout, ContentType\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass SlidePlanner:\n    \"\"\"Plans and organizes slide content based on document analysis\"\"\"\n    \n    def __init__(self, config_path: Optional[str] = None):\n        \"\"\"Initialize the slide planner\n        \n        Args:\n            config_path: Path to the YAML config file with prompts\n        \"\"\"\n        self.config_path = config_path or os.path.join(\n            os.path.dirname(__file__), \"..\", \"config\", \"prompts.yaml\"\n        )\n        self.prompts = self._load_prompts()\n        self.client = self._init_client()\n        \n    def _load_prompts(self) -> Dict[str, Any]:\n        \"\"\"Load prompts from YAML file\"\"\"\n        try:\n            with open(self.config_path, \"r\") as f:\n                return yaml.safe_load(f)\n        except Exception as e:\n            logger.error(f\"Error loading prompts from {self.config_path}: {e}\")\n            return {}\n            \n    def _init_client(self) -> anthropic.Anthropic:\n        \"\"\"Initialize the Anthropic client\"\"\"\n        api_key = os.environ.get(\"ANTHROPIC_API_KEY\")\n        if not api_key:\n            raise ValueError(\"ANTHROPIC_API_KEY environment variable not set\")\n        return anthropic.Anthropic(api_key=api_key)\n    \n    def analyze_document(self, content: str) -> Dict[str, Any]:\n        \"\"\"Analyze document content and create structured outline\n        \n        Args:\n            content: Document content to analyze\n            \n        Returns:\n            Dict with outline structure\n        \"\"\"\n        prompt = self.prompts.get(\"document_analysis\", {}).get(\"prompt\", \"\")\n        if not prompt:\n            raise ValueError(\"Document analysis prompt not found in config\")\n            \n        # Format the prompt with the document content\n        formatted_prompt = prompt.format(document=content)\n        \n        # Call Claude with extended thinking\n        try:\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=4000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=self.prompts.get(\"document_analysis\", {}).get(\"system\", \"\"),\n                messages=[{\"role\": \"user\", \"content\": formatted_prompt}]\n            )\n            \n            # Extract and parse the JSON from Claude's response\n            json_text = self._extract_json(response.content[1].text)\n            if not json_text:\n                logger.error(\"No JSON found in Claude's response\")\n                return {}\n                \n            return json.loads(json_text)\n        except Exception as e:\n            logger.error(f\"Error analyzing document: {e}\")\n            return {}\n    \n    def generate_slides(self, outline: Dict[str, Any]) -> Presentation:\n        \"\"\"Generate slides from the outline\n        \n        Args:\n            outline: Document outline\n            \n        Returns:\n            Presentation object with slides\n        \"\"\"\n        prompt = self.prompts.get(\"slide_generation\", {}).get(\"prompt\", \"\")\n        if not prompt:\n            raise ValueError(\"Slide generation prompt not found in config\")\n            \n        # Format the prompt with the outline\n        formatted_prompt = prompt.format(outline=json.dumps(outline, indent=2))\n        \n        # Call Claude with extended thinking\n        try:\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=10000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=self.prompts.get(\"slide_generation\", {}).get(\"system\", \"\"),\n                messages=[{\"role\": \"user\", \"content\": formatted_prompt}]\n            )\n            \n            # Extract and parse the JSON from Claude's response\n            json_text = self._extract_json(response.content[1].text)\n            if not json_text:\n                logger.error(\"No JSON found in Claude's response\")\n                return Presentation(title=\"Error\")\n                \n            slide_data = json.loads(json_text)\n            \n            # Convert to Presentation object\n            return Presentation.parse_obj(slide_data)\n        except Exception as e:\n            logger.error(f\"Error generating slides: {e}\")\n            return Presentation(title=\"Error\")\n    \n    def refine_slides(self, presentation: Presentation) -> Presentation:\n        \"\"\"Review and refine the presentation\n        \n        Args:\n            presentation: Initial presentation\n            \n        Returns:\n            Refined presentation\n        \"\"\"\n        prompt = self.prompts.get(\"slide_refinement\", {}).get(\"prompt\", \"\")\n        if not prompt:\n            raise ValueError(\"Slide refinement prompt not found in config\")\n            \n        # Format the prompt with the presentation\n        formatted_prompt = prompt.format(\n            presentation=presentation.json(indent=2)\n        )\n        \n        # Call Claude with extended thinking\n        try:\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=10000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=self.prompts.get(\"slide_refinement\", {}).get(\"system\", \"\"),\n                messages=[{\"role\": \"user\", \"content\": formatted_prompt}]\n            )\n            \n            # Extract and parse the JSON from Claude's response\n            json_text = self._extract_json(response.content[1].text)\n            if not json_text:\n                logger.error(\"No JSON found in Claude's response\")\n                return presentation\n                \n            refined_data = json.loads(json_text)\n            \n            # Convert to Presentation object\n            return Presentation.parse_obj(refined_data)\n        except Exception as e:\n            logger.error(f\"Error refining slides: {e}\")\n            return presentation\n    \n    def _extract_json(self, text: str) -> str:\n        \"\"\"Extract JSON from text\n        \n        Args:\n            text: Text containing JSON\n            \n        Returns:\n            Extracted JSON string\n        \"\"\"\n        # Try to find JSON between triple backticks\n        json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n        import re\n        matches = re.findall(json_pattern, text)\n        \n        if matches:\n            return matches[0]\n        \n        # If not found, just return the text as is (assuming it's already JSON)\n        return text\n3. YAML Prompts Configuration (prompts.yaml)\nyaml# makeslides/config/prompts.yaml\ndocument_analysis:\n  system: \"You are an expert presentation designer skilled at analyzing documents and creating well-structured presentation outlines.\"\n  prompt: |\n    I need you to analyze the following document and create a structured outline for a presentation.\n    \n    For each key point or section, identify:\n    1. A clear slide title (max 60 chars)\n    2. The main content or message\n    3. The most appropriate slide layout\n    4. Any visual elements that would enhance the slide (charts, diagrams, images)\n    \n    Document to analyze:\n    \n    {document}\n    \n    Please think deeply about the document structure, audience needs, and effective presentation principles.\n    \n    Your analysis should identify approximately 10-15 slides (unless the content dictates otherwise).\n    \n    Return your analysis as a valid JSON object with this structure:\n    {{\n      \"title\": \"Overall presentation title\",\n      \"sections\": [\n        {{\n          \"title\": \"Section title\",\n          \"slides\": [\n            {{\n              \"title\": \"Slide title\",\n              \"content\": \"Main slide content/message\",\n              \"layout\": \"TITLE_AND_CONTENT / TWO_COLUMNS / etc.\",\n              \"visuals\": [\n                {{ \"type\": \"image / diagram / chart\", \"description\": \"Description of visual\" }}\n              ]\n            }}\n          ]\n        }}\n      ]\n    }}\n\nslide_generation:\n  system: \"You are an expert presentation designer who creates well-structured, visually appealing slides based on content outlines.\"\n  prompt: |\n    I want you to generate a complete slide deck based on the following outline.\n    \n    For each slide:\n    1. Choose the most appropriate layout\n    2. Structure the content effectively\n    3. Include appropriate visuals (images, diagrams, charts)\n    \n    Outline:\n    \n    {outline}\n    \n    When creating the slides, consider these layout options:\n    - TITLE_ONLY: Just a title (for opening slides)\n    - TITLE_AND_CONTENT: Title with text/bullets below\n    - SECTION_HEADER: Large title for section transitions\n    - TWO_COLUMNS: Title with two columns of content\n    - COMPARISON: Title with comparison elements\n    - BIG_NUMBER: Title with large statistic or number\n    - QUOTE: For testimonials or important statements\n    - IMAGE_ONLY: Full slide image with optional caption\n    - IMAGE_WITH_CAPTION: Image with prominent caption\n    \n    For images, you can use:\n    - Unsplash queries (e.g., \"unsplash:solar panels\")\n    - Stock image descriptions (e.g., \"stock:business meeting\")\n    \n    For diagrams, use Mermaid syntax for:\n    - flowchart\n    - mindmap\n    - timeline\n    - sequence diagrams\n    \n    Return a complete JSON object representing the presentation with this structure:\n    {{\n      \"title\": \"Presentation title\",\n      \"slides\": [\n        {{\n          \"title\": \"Slide title\",\n          \"layout\": \"LAYOUT_TYPE\",\n          \"blocks\": [\n            {{ \"type\": \"text/bullets/image/diagram/chart\", ... additional properties }}\n          ]\n        }}\n      ]\n    }}\n\nslide_refinement:\n  system: \"You are an expert presentation designer who reviews and improves slide decks to ensure they are clear, engaging, and visually effective.\"\n  prompt: |\n    Please review and refine the following presentation. Look for ways to improve:\n    \n    1. Overall flow and narrative structure\n    2. Visual consistency and appeal\n    3. Content clarity and impact\n    4. Appropriate use of layouts\n    \n    The current presentation:\n    \n    {presentation}\n    \n    Provide your improved version as a complete JSON object with the same structure.\n    Include detailed comments about what you changed and why.\n4. PowerPoint Renderer (pptx.py)\npython# makeslides/renderers/pptx.py\nfrom typing import Dict, Any, Optional, List\nimport os\nfrom pathlib import Path\nimport requests\nimport tempfile\nfrom io import BytesIO\nfrom pptx import Presentation\nfrom pptx.util import Inches, Pt\nfrom pptx.enum.shapes import MSO_SHAPE\nfrom pptx.enum.text import PP_ALIGN, MSO_VERTICAL_ANCHOR\nfrom pptx.dml.color import RGBColor\nimport logging\nfrom ..core.models import (\n    Presentation as PresentationModel,\n    Slide as SlideModel,\n    SlideLayout,\n    ContentType,\n    ImagePosition,\n    TextBlock,\n    BulletBlock,\n    ImageBlock,\n    DiagramBlock,\n    ChartBlock,\n    TableBlock,\n    QuoteBlock\n)\n\nlogger = logging.getLogger(__name__)\n\nclass PptxRenderer:\n    \"\"\"Renders slide specifications to PPTX files\"\"\"\n    \n    def __init__(self, template_path: Optional[str] = None):\n        \"\"\"Initialize the PPTX renderer\n        \n        Args:\n            template_path: Path to PPTX template file (optional)\n        \"\"\"\n        self.template_path = template_path\n        \n    def render(self, presentation: PresentationModel, output_path: str) -> bool:\n        \"\"\"Render presentation to PPTX file\n        \n        Args:\n            presentation: Presentation model\n            output_path: Path to save PPTX file\n            \n        Returns:\n            Success status\n        \"\"\"\n        try:\n            # Create presentation from template or blank\n            if self.template_path and os.path.exists(self.template_path):\n                pptx = Presentation(self.template_path)\n            else:\n                pptx = Presentation()\n            \n            # Set presentation properties\n            pptx.core_properties.title = presentation.title\n            if presentation.author:\n                pptx.core_properties.author = presentation.author\n            \n            # Render each slide\n            for slide_model in presentation.slides:\n                self._render_slide(pptx, slide_model)\n            \n            # Save the presentation\n            pptx.save(output_path)\n            logger.info(f\"Presentation saved to {output_path}\")\n            return True\n        \n        except Exception as e:\n            logger.error(f\"Error rendering presentation: {e}\")\n            return False\n    \n    def _render_slide(self, pptx: Presentation, slide_model: SlideModel) -> None:\n        \"\"\"Render a single slide\n        \n        Args:\n            pptx: PowerPoint presentation\n            slide_model: Slide model\n        \"\"\"\n        # Select appropriate slide layout\n        layout = self._get_slide_layout(pptx, slide_model.layout)\n        \n        # Create slide\n        slide = pptx.slides.add_slide(layout)\n        \n        # Set title\n        if hasattr(slide, 'shapes') and hasattr(slide.shapes, 'title') and slide.shapes.title:\n            title_shape = slide.shapes.title\n            title_shape.text = slide_model.title\n        \n        # Set subtitle if available\n        if slide_model.subtitle and hasattr(slide, 'placeholders'):\n            for shape in slide.placeholders:\n                if shape.placeholder_format.type == 2:  # Subtitle\n                    shape.text = slide_model.subtitle\n        \n        # Process content blocks\n        content_placeholder = self._get_content_placeholder(slide)\n        \n        if not content_placeholder and slide_model.blocks:\n            # If no content placeholder exists but we have blocks, create shapes manually\n            self._create_content_shapes(slide, slide_model.blocks)\n        elif content_placeholder:\n            # Process blocks into the content placeholder\n            self._process_blocks_in_placeholder(content_placeholder, slide_model.blocks)\n        \n        # Set slide notes\n        if slide_model.notes:\n            notes_slide = slide.notes_slide\n            notes_slide.notes_text_frame.text = slide_model.notes\n    \n    def _get_slide_layout(self, pptx: Presentation, layout_type: SlideLayout) -> Any:\n        \"\"\"Get the appropriate slide layout from the presentation\n        \n        Args:\n            pptx: PowerPoint presentation\n            layout_type: Slide layout type\n            \n        Returns:\n            Slide layout\n        \"\"\"\n        # Map our layout types to PowerPoint layout indices\n        # These indices can vary between templates, so this is a simplified mapping\n        layout_map = {\n            SlideLayout.TITLE_ONLY: 0,\n            SlideLayout.TITLE_AND_CONTENT: 1,\n            SlideLayout.SECTION_HEADER: 2,\n            SlideLayout.TWO_COLUMNS: 3,\n            SlideLayout.COMPARISON: 4,\n            SlideLayout.BIG_NUMBER: 5,\n            SlideLayout.QUOTE: 6,\n            SlideLayout.IMAGE_ONLY: 7,\n            SlideLayout.IMAGE_WITH_CAPTION: 8,\n            SlideLayout.BLANK: 9\n        }\n        \n        # Default to title and content if layout not found\n        layout_idx = layout_map.get(layout_type, 1)\n        \n        # Check if the layout exists in this presentation\n        if layout_idx < len(pptx.slide_layouts):\n            return pptx.slide_layouts[layout_idx]\n        else:\n            # Fall back to the first layout that's available\n            return pptx.slide_layouts[0]\n    \n    def _get_content_placeholder(self, slide: Any) -> Optional[Any]:\n        \"\"\"Get the main content placeholder from a slide\n        \n        Args:\n            slide: PowerPoint slide\n            \n        Returns:\n            Content placeholder or None\n        \"\"\"\n        # Look for common content placeholder types\n        for shape in slide.placeholders:\n            # Check for body placeholder (type 1)\n            if shape.placeholder_format.type == 1:\n                return shape\n        \n        # If no body placeholder found, look for any placeholder that's not the title\n        for shape in slide.placeholders:\n            if shape.placeholder_format.type != 0:  # Not title\n                return shape\n        \n        return None\n    \n    def _process_blocks_in_placeholder(self, placeholder: Any, blocks: List[Any]) -> None:\n        \"\"\"Process content blocks into a placeholder\n        \n        Args:\n            placeholder: PowerPoint shape placeholder\n            blocks: Content blocks\n        \"\"\"\n        # Get the text frame from the placeholder\n        text_frame = placeholder.text_frame\n        text_frame.clear()  # Clear any existing text\n        \n        # Process each block\n        for i, block in enumerate(blocks):\n            if i > 0:\n                # Add paragraph break between blocks\n                p = text_frame.add_paragraph()\n                p.text = \"\"\n            \n            if block.type == ContentType.TEXT:\n                self._add_text_block(text_frame, block)\n            elif block.type == ContentType.BULLETS:\n                self._add_bullet_block(text_frame, block)\n            elif block.type == ContentType.IMAGE:\n                # Images can't go in text placeholders, so we'll have to create a separate shape\n                pass\n            elif block.type == ContentType.DIAGRAM:\n                # Diagrams can't go in text placeholders, so we'll have to create a separate shape\n                pass\n            elif block.type == ContentType.CHART:\n                # Charts can't go in text placeholders, so we'll have to create a separate shape\n                pass\n            elif block.type == ContentType.TABLE:\n                # Tables can't go in text placeholders, so we'll have to create a separate shape\n                pass\n            elif block.type == ContentType.QUOTE:\n                self._add_quote_block(text_frame, block)\n    \n    def _create_content_shapes(self, slide: Any, blocks: List[Any]) -> None:\n        \"\"\"Create shapes for content blocks manually\n        \n        Args:\n            slide: PowerPoint slide\n            blocks: Content blocks\n        \"\"\"\n        # Get slide dimensions to calculate positions\n        slide_width = Inches(10)  # Standard slide width\n        slide_height = Inches(7.5)  # Standard slide height\n        \n        # Adjust for title space\n        top_margin = Inches(1.5)  # Space for title\n        left_margin = Inches(0.5)\n        right_margin = Inches(0.5)\n        bottom_margin = Inches(0.5)\n        \n        available_width = slide_width - left_margin - right_margin\n        available_height = slide_height - top_margin - bottom_margin\n        \n        # Calculate positions based on number and types of blocks\n        y_pos = top_margin\n        \n        for block in blocks:\n            if block.type == ContentType.TEXT:\n                # Add text block\n                shape = slide.shapes.add_textbox(\n                    left_margin, y_pos, available_width, Inches(1)\n                )\n                self._add_text_block(shape.text_frame, block)\n                y_pos += Inches(1)\n                \n            elif block.type == ContentType.BULLETS:\n                # Add bullet block\n                shape = slide.shapes.add_textbox(\n                    left_margin, y_pos, available_width, Inches(2)\n                )\n                self._add_bullet_block(shape.text_frame, block)\n                y_pos += Inches(2)\n                \n            elif block.type == ContentType.IMAGE:\n                # Add image\n                self._add_image_shape(slide, block, left_margin, y_pos, available_width)\n                y_pos += Inches(3)  # Estimated height\n                \n            elif block.type == ContentType.DIAGRAM:\n                # Render and add diagram\n                self._add_diagram_shape(slide, block, left_margin, y_pos, available_width)\n                y_pos += Inches(3)  # Estimated height\n                \n            elif block.type == ContentType.CHART:\n                # Add chart\n                self._add_chart_shape(slide, block, left_margin, y_pos, available_width)\n                y_pos += Inches(3)  # Estimated height\n                \n            elif block.type == ContentType.TABLE:\n                # Add table\n                self._add_table_shape(slide, block, left_margin, y_pos, available_width)\n                y_pos += Inches(2)  # Estimated height\n                \n            elif block.type == ContentType.QUOTE:\n                # Add quote\n                shape = slide.shapes.add_textbox(\n                    left_margin, y_pos, available_width, Inches(1.5)\n                )\n                self._add_quote_block(shape.text_frame, block)\n                y_pos += Inches(1.5)\n    \n    def _add_text_block(self, text_frame: Any, block: TextBlock) -> None:\n        \"\"\"Add text block to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            block: Text block\n        \"\"\"\n        p = text_frame.add_paragraph()\n        p.text = block.content\n        \n        # Apply text formatting if specified\n        if block.format:\n            for run in p.runs:\n                if block.format.bold:\n                    run.font.bold = True\n                if block.format.italic:\n                    run.font.italic = True\n                if block.format.underline:\n                    run.font.underline = True\n                if block.format.color:\n                    color = self._parse_color(block.format.color)\n                    if color:\n                        run.font.color.rgb = color\n                if block.format.size:\n                    run.font.size = Pt(block.format.size)\n    \n    def _add_bullet_block(self, text_frame: Any, block: BulletBlock) -> None:\n        \"\"\"Add bullet block to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            block: Bullet block\n        \"\"\"\n        # Process each bullet item\n        for item in block.items:\n            p = text_frame.add_paragraph()\n            p.text = item.content\n            p.level = 0  # Top level bullet\n            \n            # Apply bullet formatting\n            p.bullet = True\n            \n            # Apply text formatting if specified\n            if item.format:\n                for run in p.runs:\n                    if item.format.bold:\n                        run.font.bold = True\n                    if item.format.italic:\n                        run.font.italic = True\n                    if item.format.underline:\n                        run.font.underline = True\n                    if item.format.color:\n                        color = self._parse_color(item.format.color)\n                        if color:\n                            run.font.color.rgb = color\n                    if item.format.size:\n                        run.font.size = Pt(item.format.size)\n            \n            # Add sub-bullets\n            for sub_item in item.sub_bullets:\n                p = text_frame.add_paragraph()\n                p.text = sub_item.content\n                p.level = 1  # Second level bullet\n                \n                # Apply bullet formatting\n                p.bullet = True\n                \n                # Apply text formatting if specified\n                if sub_item.format:\n                    for run in p.runs:\n                        if sub_item.format.bold:\n                            run.font.bold = True\n                        if sub_item.format.italic:\n                            run.font.italic = True\n                        if sub_item.format.underline:\n                            run.font.underline = True\n                        if sub_item.format.color:\n                            color = self._parse_color(sub_item.format.color)\n                            if color:\n                                run.font.color.rgb = color\n                        if sub_item.format.size:\n                            run.font.size = Pt(sub_item.format.size)\n    \n    def _add_image_shape(self, slide: Any, block: ImageBlock, left: Any, top: Any, width: Any) -> None:\n        \"\"\"Add image shape to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Image block\n            left: Left position\n            top: Top position\n            width: Available width\n        \"\"\"\n        # Determine image source\n        image_path = block.source\n        \n        # Handle different image source types\n        if image_path.startswith(\"http://\") or image_path.startswith(\"https://\"):\n            # Download from URL\n            try:\n                response = requests.get(image_path)\n                response.raise_for_status()\n                image_data = BytesIO(response.content)\n            except Exception as e:\n                logger.error(f\"Error downloading image from {image_path}: {e}\")\n                return\n        elif image_path.startswith(\"unsplash:\"):\n            # Handle Unsplash images\n            query = image_path.replace(\"unsplash:\", \"\")\n            # This would require an Unsplash API client or similar\n            # For now, just log an error\n            logger.error(f\"Unsplash images not yet implemented: {query}\")\n            return\n        elif os.path.exists(image_path):\n            # Local file\n            image_data = image_path\n        else:\n            logger.error(f\"Image not found: {image_path}\")\n            return\n        \n        # Calculate image size\n        if block.width and block.height:\n            # Use specified dimensions\n            img_width = Inches(block.width / 96)  # Convert pixels to inches\n            img_height = Inches(block.height / 96)\n        else:\n            # Use default dimensions\n            img_width = Inches(5)\n            img_height = Inches(3)\n        \n        # Adjust position based on alignment\n        if block.position == ImagePosition.CENTER:\n            left = left + (width - img_width) / 2\n        elif block.position == ImagePosition.RIGHT:\n            left = left + width - img_width\n        \n        # Add image to slide\n        try:\n            slide.shapes.add_picture(image_data, left, top, img_width, img_height)\n        except Exception as e:\n            logger.error(f\"Error adding image to slide: {e}\")\n    \n    def _add_diagram_shape(self, slide: Any, block: DiagramBlock, left: Any, top: Any, width: Any) -> None:\n        \"\"\"Add diagram shape to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Diagram block\n            left: Left position\n            top: Top position\n            width: Available width\n        \"\"\"\n        # This would require integration with a diagram renderer like Mermaid\n        # For now, just log an error\n        logger.error(f\"Diagram rendering not yet implemented: {block.diagram_type}\")\n        \n        # Add a placeholder textbox instead\n        shape = slide.shapes.add_textbox(left, top, width, Inches(2))\n        p = shape.text_frame.add_paragraph()\n        p.text = f\"[Diagram: {block.diagram_type}]\\n{block.content[:100]}...\"\n    \n    def _add_chart_shape(self, slide: Any, block: ChartBlock, left: Any, top: Any, width: Any) -> None:\n        \"\"\"Add chart shape to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Chart block\n            left: Left position\n            top: Top position\n            width: Available width\n        \"\"\"\n        # This would require integration with a chart renderer\n        # For now, just log an error\n        logger.error(f\"Chart rendering not yet implemented: {block.chart_type}\")\n        \n        # Add a placeholder textbox instead\n        shape = slide.shapes.add_textbox(left, top, width, Inches(2))\n        p = shape.text_frame.add_paragraph()\n        p.text = f\"[Chart: {block.chart_type}]\"\n    \n    def _add_table_shape(self, slide: Any, block: TableBlock, left: Any, top: Any, width: Any) -> None:\n        \"\"\"Add table shape to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Table block\n            left: Left position\n            top: Top position\n            width: Available width\n        \"\"\"\n        # Calculate table dimensions\n        rows = len(block.rows) + 1  # +1 for header\n        cols = len(block.headers)\n        \n        # Add table to slide\n        table = slide.shapes.add_table(rows, cols, left, top, width, Inches(rows * 0.4)).table\n        \n        # Set headers\n        for i, header in enumerate(block.headers):\n            cell = table.cell(0, i)\n            cell.text = header\n            # Apply header formatting\n            for paragraph in cell.text_frame.paragraphs:\n                for run in paragraph.runs:\n                    run.font.bold = True\n        \n        # Set row data\n        for row_idx, row_data in enumerate(block.rows):\n            for col_idx, cell_data in enumerate(row_data):\n                if col_idx < cols:  # Ensure we don't exceed table width\n                    cell = table.cell(row_idx + 1, col_idx)  # +1 to skip header\n                    cell.text = cell_data\n    \n    def _add_quote_block(self, text_frame: Any, block: QuoteBlock) -> None:\n        \"\"\"Add quote block to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            block: Quote block\n        \"\"\"\n        # Add quote text\n        p = text_frame.add_paragraph()\n        p.text = f'\"{block.quote}\"'\n        \n        # Apply quote formatting\n        for run in p.runs:\n            run.font.italic = True\n            if block.format and block.format.size:\n                run.font.size = Pt(block.format.size)\n            else:\n                run.font.size = Pt(14)\n        \n        # Add attribution if provided\n        if block.attribution:\n            p = text_frame.add_paragraph()\n            p.text = f\"— {block.attribution}\"\n            \n            # Apply attribution formatting\n            for run in p.runs:\n                if block.format and block.format.size:\n                    run.font.size = Pt(block.format.size - 2)\n                else:\n                    run.font.size = Pt(12)\n    \n    def _parse_color(self, color_str: str) -> Optional[RGBColor]:\n        \"\"\"Parse color string to RGBColor\n        \n        Args:\n            color_str: Color string (e.g., \"#FF0000\" or \"red\")\n            \n        Returns:\n            RGBColor object or None\n        \"\"\"\n        try:\n            if color_str.startswith(\"#\"):\n                # Hex color\n                r = int(color_str[1:3], 16)\n                g = int(color_str[3:5], 16)\n                b = int(color_str[5:7], 16)\n                return RGBColor(r, g, b)\n            else:\n                # Named color (simplified mapping)\n                color_map = {\n                    \"red\": RGBColor(255, 0, 0),\n                    \"green\": RGBColor(0, 128, 0),\n                    \"blue\": RGBColor(0, 0, 255),\n                    \"black\": RGBColor(0, 0, 0),\n                    \"white\": RGBColor(255, 255, 255),\n                    \"gray\": RGBColor(128, 128, 128),\n                    \"yellow\": RGBColor(255, 255, 0),\n                    \"orange\": RGBColor(255, 165, 0),\n                    \"purple\": RGBColor(128, 0, 128)\n                }\n                return color_map.get(color_str.lower())\n        except Exception:\n            return None\n5. Google Slides Renderer Interface (slides_api.py)\npython# makeslides/renderers/slides_api.py\nfrom typing import Dict, Any, Optional, List\nimport os\nimport json\nimport tempfile\nimport logging\nfrom ..core.models import Presentation as PresentationModel\n\nlogger = logging.getLogger(__name__)\n\nclass GoogleSlidesRenderer:\n    \"\"\"Renders slide specifications to Google Slides\"\"\"\n    \n    def __init__(self, credentials_path: Optional[str] = None):\n        \"\"\"Initialize the Google Slides renderer\n        \n        Args:\n            credentials_path: Path to Google API credentials JSON file\n        \"\"\"\n        self.credentials_path = credentials_path or os.path.join(\n            os.path.expanduser(\"~\"), \".md2googleslides\", \"client_id.json\"\n        )\n        \n    def render(self, presentation: PresentationModel, output_path: Optional[str] = None) -> Optional[str]:\n        \"\"\"Render presentation to Google Slides\n        \n        Args:\n            presentation: Presentation model\n            output_path: Path to save presentation ID (optional)\n            \n        Returns:\n            Google Slides URL or None on error\n        \"\"\"\n        # This is a placeholder implementation that would use the Google Slides API\n        # Currently, we'll convert to markdown for md2gslides\n        \n        try:\n            # Convert presentation to markdown format\n            markdown = self._convert_to_markdown(presentation)\n            \n            # Save markdown to temporary file\n            with tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".md\", delete=False) as f:\n                f.write(markdown)\n                temp_path = f.name\n            \n            # Run md2gslides\n            import subprocess\n            cmd = [\"md2gslides\", \"--title\", presentation.title, \"--use-fileio\", temp_path]\n            \n            logger.info(f\"Running md2gslides: {' '.join(cmd)}\")\n            result = subprocess.run(cmd, capture_output=True, text=True)\n            \n            # Extract presentation URL\n            import re\n            url_match = re.search(r'Opening your presentation \\((https://docs\\.google\\.com/[^)]+)\\)', result.stdout)\n            \n            if url_match:\n                presentation_url = url_match.group(1)\n                \n                # Save URL to output file if specified\n                if output_path:\n                    with open(output_path, \"w\") as f:\n                        f.write(presentation_url)\n                \n                # Clean up temporary file\n                os.unlink(temp_path)\n                \n                logger.info(f\"Presentation created: {presentation_url}\")\n                return presentation_url\n            else:\n                logger.error(\"Failed to create Google Slides presentation\")\n                logger.error(f\"Command output: {result.stdout}\")\n                logger.error(f\"Command error: {result.stderr}\")\n                return None\n                \n        except Exception as e:\n            logger.error(f\"Error rendering Google Slides presentation: {e}\")\n            return None\n    \n    def _convert_to_markdown(self, presentation: PresentationModel) -> str:\n        \"\"\"Convert presentation model to markdown format for md2gslides\n        \n        Args:\n            presentation: Presentation model\n            \n        Returns:\n            Markdown string\n        \"\"\"\n        markdown = f\"# {presentation.title}\\n\\n\"\n        \n        for slide in presentation.slides:\n            # Add slide separator\n            markdown += \"---\\n\\n\"\n            \n            # Add slide title\n            markdown += f\"# {slide.title}\\n\\n\"\n            \n            # Add slide content based on layout\n            if slide.layout == \"TITLE_ONLY\":\n                # Nothing to add for title only\n                pass\n                \n            elif slide.layout == \"SECTION_HEADER\":\n                # Add section header formatting\n                markdown += f\"# {slide.title} {{.section}}\\n\\n\"\n                \n            elif slide.layout == \"TWO_COLUMNS\":\n                # Process blocks into two columns\n                left_content = \"\"\n                right_content = \"\"\n                \n                for i, block in enumerate(slide.blocks):\n                    if i % 2 == 0:\n                        # Left column\n                        left_content += self._block_to_markdown(block) + \"\\n\\n\"\n                    else:\n                        # Right column\n                        right_content += self._block_to_markdown(block) + \"\\n\\n\"\n                \n                markdown += f\"{left_content}\\n\\n\"\n                markdown += \"{{.column}}\\n\\n\"\n                markdown += f\"{right_content}\\n\\n\"\n                \n            elif slide.layout == \"BIG_NUMBER\":\n                # Add big number formatting\n                markdown += f\"# {slide.title} {{.big}}\\n\\n\"\n                \n                for block in slide.blocks:\n                    markdown += self._block_to_markdown(block) + \"\\n\\n\"\n                    \n            elif slide.layout == \"QUOTE\":\n                # Add quote formatting\n                for block in slide.blocks:\n                    if block.type == \"QUOTE\":\n                        markdown += f\"> {block.quote}\\n>\\n\"\n                        if block.attribution:\n                            markdown += f\"> — {block.attribution}\\n\\n\"\n            \n            else:\n                # Default handling for other layouts\n                for block in slide.blocks:\n                    markdown += self._block_to_markdown(block) + \"\\n\\n\"\n            \n            # Add notes if present\n            if slide.notes:\n                markdown += f\"\\n\\n<!--\\n{slide.notes}\\n-->\\n\"\n        \n        return markdown\n    \n    def _block_to_markdown(self, block: Dict[str, Any]) -> str:\n        \"\"\"Convert a content block to markdown\n        \n        Args:\n            block: Content block\n            \n        Returns:\n            Markdown string\n        \"\"\"\n        block_type = block.get(\"type\", \"\")\n        \n        if block_type == \"TEXT\":\n            return block.get(\"content\", \"\")\n            \n        elif block_type == \"BULLETS\":\n            bullets = \"\"\n            for item in block.get(\"items\", []):\n                bullets += f\"* {item.get('content', '')}\\n\"\n                \n                # Handle sub-bullets\n                for sub_item in item.get(\"sub_bullets\", []):\n                    bullets += f\"  * {sub_item.get('content', '')}\\n\"\n            \n            return bullets\n            \n        elif block_type == \"IMAGE\":\n            alt_text = block.get(\"alt_text\", \"Image\")\n            return f\"![{alt_text}]({block.get('source', '')})\"\n            \n        elif block_type == \"DIAGRAM\":\n            # Mermaid diagrams aren't directly supported in md2gslides\n            # We would need to render it first and use the image\n            return f\"[Diagram: {block.get('diagram_type', '')}]\"\n            \n        elif block_type == \"CHART\":\n            # Charts aren't directly supported in md2gslides\n            return f\"[Chart: {block.get('chart_type', '')}]\"\n            \n        elif block_type == \"TABLE\":\n            # Build markdown table\n            table = \"| \" + \" | \".join(block.get(\"headers\", [])) + \" |\\n\"\n            table += \"| \" + \" | \".join([\"---\"] * len(block.get(\"headers\", []))) + \" |\\n\"\n            \n            for row in block.get(\"rows\", []):\n                table += \"| \" + \" | \".join(row) + \" |\\n\"\n            \n            return table\n            \n        elif block_type == \"QUOTE\":\n            quote = block.get(\"quote\", \"\")\n            attribution = block.get(\"attribution\", \"\")\n            \n            if attribution:\n                return f\"> {quote}\\n>\\n> — {attribution}\"\n            else:\n                return f\"> {quote}\"\n        \n        return \"\"\n6. Testing Setup (test_models.py)\npython# tests/test_models.py\nimport pytest\nfrom makeslides.core.models import (\n    Presentation,\n    Slide,\n    SlideLayout,\n    TextBlock,\n    BulletBlock,\n    BulletItem,\n    ImageBlock\n)\n\ndef test_presentation_creation():\n    \"\"\"Test creating a basic presentation model\"\"\"\n    presentation = Presentation(\n        title=\"Test Presentation\",\n        author=\"Test Author\",\n        slides=[]\n    )\n    \n    assert presentation.title == \"Test Presentation\"\n    assert presentation.author == \"Test Author\"\n    assert presentation.slides == []\n\ndef test_slide_creation():\n    \"\"\"Test creating a slide model\"\"\"\n    slide = Slide(\n        title=\"Test Slide\",\n        layout=SlideLayout.TITLE_AND_CONTENT,\n        blocks=[]\n    )\n    \n    assert slide.title == \"Test Slide\"\n    assert slide.layout == SlideLayout.TITLE_AND_CONTENT\n    assert slide.blocks == []\n\ndef test_text_block():\n    \"\"\"Test creating a text block\"\"\"\n    text_block = TextBlock(\n        content=\"This is a test text block\"\n    )\n    \n    assert text_block.type == \"text\"\n    assert text_block.content == \"This is a test text block\"\n    assert text_block.format is None\n\ndef test_bullet_block():\n    \"\"\"Test creating a bullet block with items\"\"\"\n    bullet_block = BulletBlock(\n        items=[\n            BulletItem(content=\"First bullet\"),\n            BulletItem(\n                content=\"Second bullet\",\n                sub_bullets=[\n                    BulletItem(content=\"Sub-bullet 1\"),\n                    BulletItem(content=\"Sub-bullet 2\")\n                ]\n            )\n        ]\n    )\n    \n    assert bullet_block.type == \"bullets\"\n    assert len(bullet_block.items) == 2\n    assert bullet_block.items[0].content == \"First bullet\"\n    assert len(bullet_block.items[1].sub_bullets) == 2\n    assert bullet_block.items[1].sub_bullets[0].content == \"Sub-bullet 1\"\n\ndef test_image_block():\n    \"\"\"Test creating an image block\"\"\"\n    image_block = ImageBlock(\n        source=\"https://example.com/image.jpg\",\n        alt_text=\"Test image\"\n    )\n    \n    assert image_block.type == \"image\"\n    assert image_block.source == \"https://example.com/image.jpg\"\n    assert image_block.alt_text == \"Test image\"\n\ndef test_full_presentation():\n    \"\"\"Test creating a complete presentation with slides and content\"\"\"\n    presentation = Presentation(\n        title=\"Complete Test Presentation\",\n        author=\"Test Author\",\n        slides=[\n            Slide(\n                title=\"Title Slide\",\n                layout=SlideLayout.TITLE_ONLY,\n                slide_number=1\n            ),\n            Slide(\n                title=\"Content Slide\",\n                layout=SlideLayout.TITLE_AND_CONTENT,\n                slide_number=2,\n                blocks=[\n                    TextBlock(content=\"This is some text content\"),\n                    BulletBlock(\n                        items=[\n                            BulletItem(content=\"Bullet 1\"),\n                            BulletItem(content=\"Bullet 2\")\n                        ]\n                    )\n                ]\n            ),\n            Slide(\n                title=\"Image Slide\",\n                layout=SlideLayout.IMAGE_WITH_CAPTION,\n                slide_number=3,\n                blocks=[\n                    ImageBlock(\n                        source=\"https://example.com/image.jpg\",\n                        alt_text=\"Example image\"\n                    )\n                ]\n            )\n        ]\n    )\n    \n    assert len(presentation.slides) == 3\n    assert presentation.slides[0].layout == SlideLayout.TITLE_ONLY\n    assert presentation.slides[1].blocks[0].content == \"This is some text content\"\n    assert presentation.slides[1].blocks[1].items[0].content == \"Bullet 1\"\n    assert presentation.slides[2].blocks[0].source == \"https://example.com/image.jpg\"\n7. Step-by-Step Testing Guide\nTo set up and run tests for this project:\n\nSet up the testing environment:\nbash# Install pytest\npip install pytest\n\n# Create tests directory\nmkdir -p tests\n\nCreate tests:\n\nCreate unit tests for each component (like the test_models.py example above)\nAdd test_planner.py, test_pptx_renderer.py, etc.\n\n\nRun tests:\nbash# Run all tests\npytest\n\n# Run tests with verbose output\npytest -v\n\n# Run specific test file\npytest tests/test_models.py\n\nTest Structure:\n\nUnit Tests: Test individual components in isolation\nIntegration Tests: Test interaction between components\nEnd-to-End Tests: Test the full workflow\n\n\nBest Practices:\n\nUse fixtures to set up common test data\nMock external dependencies (API calls, file I/O)\nTest both success and failure cases\nKeep tests independent and idempotent\n\n\n\n8. Integration Strategy for Google Slides\nThe architecture is designed to make it easy to switch between PowerPoint and Google Slides:\n\nCommon Data Model: The Pydantic models define a presentation structure that's independent of the output format.\nRenderer Interface: Both the PPTX and Google Slides renderers follow the same interface:\npythondef render(self, presentation: PresentationModel, output_path: str) -> bool:\n\nFactory Pattern: You can add a simple factory to create the appropriate renderer:\npythondef create_renderer(output_format=\"pptx\", **kwargs):\n    if output_format == \"pptx\":\n        return PptxRenderer(**kwargs)\n    elif output_format == \"google_slides\":\n        return GoogleSlidesRenderer(**kwargs)\n    else:\n        raise ValueError(f\"Unsupported output format: {output_format}\")\n\n\nThis implementation should provide a solid foundation for your intelligent slide deck generator. You can now:\n\nParse and analyze documents with the LLM\nGenerate structured slide outlines\nCreate rich presentations with appropriate layouts\nOutput to PowerPoint or Google Slides\n\nIs there any specific part of this implementation you'd like me to explain further or expand upon?"
          }
        ],
        "files": [
          {
            "file_name": "paste.txt"
          }
        ]
      }
    },
    {
      "id": "405a0bac-54b6-4c71-9311-097ee6c54af8",
      "role": "assistant",
      "content": "Let me review the project code and your latest requirements. You want to:\n\n1. Remove md2gslides dependency since we'll focus on generating content directly\n2. Generate content primarily as PPTX and possibly use Google Slides API directly\n3. Explore possibility of uploading a PPTX to Google Slides via API\n4. Potentially use vision capabilities to have the LLM critique generated slides\n5. Support templates (fonts, styles, colors, sizes)\n6. Add positioning capabilities for text blocks (left/right alignment)\n7. Support Google Slides themes to allow for different layouts/styles\n\nLooking at the provided code in the context window:\n\nThe project appears to be \"MakeSlides\", a CLI tool for converting training facilitator guides into slide presentations. It currently uses Claude to process facilitator guides into structured JSON, which is then converted to markdown format compatible with md2gslides, and finally used to generate Google Slides presentations.\n\nKey files include:\n- CLAUDE.md - Overview of the project\n- config.yaml - Configuration for the Claude prompt\n- asset_manager.py - Manages image and diagram assets\n- renderer.py - Renders Mermaid diagrams to local image files\n- parser.py - Converts facilitator guides to JSON using Claude\n- embed_images.py - Embeds images in the markdown\n- generator.py - Converts JSON to markdown\n- builder.py - Creates Google Slides from markdown using md2gslides\n- pptx_builder.py - Basic PowerPoint builder\n\nThere's also a \"paste.txt\" document that outlines a proposed modular component architecture and implementation plan, which seems relevant to your desired improvements.\n\nBased on this, I'll propose a set of modifications and additions to move the project forward:\n\n1. Enhance the pptx_builder.py to support more features (positioning, templates, etc.)\n2. Add direct Google Slides API integration\n3. Create a factory pattern for renderers\n4. Add visual review capabilities\n5. Improve template support\n\nLet me draft the key files needed for these improvements.# Moving MakeSlides Forward: Direct PPT and Google Slides Integration\n\nBased on your requests and the existing codebase, I'll focus on enhancing the presentation generation capabilities with direct PPTX creation and Google Slides API integration, while removing the md2gslides dependency. Let's implement the necessary changes:\n\n## 1. Enhanced PPTX Renderer with Template Support\n\nFirst, let's improve the PowerPoint renderer to support templates, positioning, and themes:\n\n```python\n# makeslides/renderers/pptx_renderer.py\nfrom pptx import Presentation\nfrom pptx.util import Inches, Pt\nfrom pptx.enum.text import PP_ALIGN, MSO_VERTICAL_ANCHOR\nfrom pptx.dml.color import RGBColor\nfrom pathlib import Path\nimport logging\nimport os\nfrom typing import Dict, Any, Optional, List, Tuple, Union\n\nlogger = logging.getLogger(__name__)\n\nclass Position:\n    \"\"\"Helper class for positioning elements on slides\"\"\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    CENTER = \"center\"\n    TOP = \"top\"\n    MIDDLE = \"middle\"\n    BOTTOM = \"bottom\"\n    FULL = \"full\"\n\nclass PptxRenderer:\n    \"\"\"Renders presentations to PowerPoint files with enhanced positioning and template support\"\"\"\n    \n    def __init__(self, template_path: Optional[str] = None, theme: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize the PowerPoint renderer\n        \n        Args:\n            template_path: Path to a PPTX template file\n            theme: Theme configuration (colors, fonts, etc.)\n        \"\"\"\n        self.template_path = template_path\n        self.theme = theme or self._default_theme()\n        \n    def _default_theme(self) -> Dict[str, Any]:\n        \"\"\"Create a default theme configuration\"\"\"\n        return {\n            \"colors\": {\n                \"primary\": \"4472C4\",  # Blue\n                \"secondary\": \"ED7D31\",  # Orange\n                \"text\": \"000000\",  # Black\n                \"background\": \"FFFFFF\"  # White\n            },\n            \"fonts\": {\n                \"title\": {\n                    \"name\": \"Calibri\",\n                    \"size\": 44,\n                    \"bold\": True\n                },\n                \"subtitle\": {\n                    \"name\": \"Calibri\",\n                    \"size\": 32,\n                    \"bold\": False\n                },\n                \"heading\": {\n                    \"name\": \"Calibri\",\n                    \"size\": 28,\n                    \"bold\": True\n                },\n                \"body\": {\n                    \"name\": \"Calibri\", \n                    \"size\": 18,\n                    \"bold\": False\n                }\n            },\n            \"slide_margins\": {\n                \"top\": 0.5,  # in inches\n                \"right\": 0.5,\n                \"bottom\": 0.5,\n                \"left\": 0.5\n            }\n        }\n    \n    def render(self, presentation_data: Dict[str, Any], output_path: str) -> bool:\n        \"\"\"Render a presentation to a PowerPoint file\n        \n        Args:\n            presentation_data: Presentation data structure\n            output_path: Path to save the PowerPoint file\n            \n        Returns:\n            Success status\n        \"\"\"\n        try:\n            # Create presentation from template or blank\n            if self.template_path and os.path.exists(self.template_path):\n                prs = Presentation(self.template_path)\n                logger.info(f\"Using template: {self.template_path}\")\n            else:\n                prs = Presentation()\n                logger.info(\"Using blank presentation\")\n            \n            # Set presentation properties\n            if hasattr(prs, 'core_properties'):\n                prs.core_properties.title = presentation_data.get(\"title\", \"Presentation\")\n                if \"author\" in presentation_data:\n                    prs.core_properties.author = presentation_data[\"author\"]\n            \n            # Render slides\n            for slide_data in presentation_data.get(\"slides\", []):\n                self._create_slide(prs, slide_data)\n            \n            # Save presentation\n            prs.save(output_path)\n            logger.info(f\"Presentation saved to {output_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error rendering presentation: {e}\")\n            return False\n    \n    def _create_slide(self, prs: Presentation, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create a single slide in the presentation\n        \n        Args:\n            prs: PowerPoint presentation object\n            slide_data: Slide data\n        \"\"\"\n        # Select appropriate layout\n        layout_name = slide_data.get(\"layout\", \"TITLE_AND_CONTENT\")\n        layout_idx = self._get_layout_index(prs, layout_name)\n        slide_layout = prs.slide_layouts[layout_idx]\n        \n        # Create slide\n        slide = prs.slides.add_slide(slide_layout)\n        \n        # Set background if specified\n        if \"background\" in slide_data:\n            self._set_background(slide, slide_data[\"background\"])\n        \n        # Set title\n        if hasattr(slide.shapes, 'title') and slide.shapes.title:\n            title_shape = slide.shapes.title\n            title_shape.text = slide_data.get(\"title\", \"\")\n            self._apply_text_formatting(title_shape.text_frame, self.theme[\"fonts\"][\"title\"])\n        \n        # Set subtitle if available\n        if \"subtitle\" in slide_data:\n            subtitle = slide_data[\"subtitle\"]\n            if subtitle:\n                for shape in slide.placeholders:\n                    if shape.placeholder_format.type == 2:  # Subtitle placeholder\n                        shape.text = subtitle\n                        self._apply_text_formatting(shape.text_frame, self.theme[\"fonts\"][\"subtitle\"])\n                        break\n        \n        # Process content blocks based on layout\n        if layout_name == \"TITLE_ONLY\":\n            # Title only, nothing else to do\n            pass\n            \n        elif layout_name == \"TITLE_AND_CONTENT\":\n            self._add_content_to_placeholder(slide, slide_data.get(\"blocks\", []))\n            \n        elif layout_name == \"TWO_COLUMNS\":\n            self._create_two_column_layout(slide, slide_data)\n            \n        elif layout_name == \"COMPARISON\":\n            self._create_comparison_layout(slide, slide_data)\n            \n        elif layout_name == \"IMAGE_WITH_CAPTION\":\n            self._create_image_with_caption(slide, slide_data)\n            \n        # Add notes if provided\n        if \"notes\" in slide_data and slide_data[\"notes\"]:\n            notes_slide = slide.notes_slide\n            notes_slide.notes_text_frame.text = slide_data[\"notes\"]\n    \n    def _get_layout_index(self, prs: Presentation, layout_name: str) -> int:\n        \"\"\"Get the index of a slide layout by name/type\n        \n        Args:\n            prs: PowerPoint presentation\n            layout_name: Name of layout\n            \n        Returns:\n            Index of layout\n        \"\"\"\n        # Map layout names to common PowerPoint layout indices\n        layout_map = {\n            \"TITLE_SLIDE\": 0,\n            \"TITLE_ONLY\": 0,\n            \"TITLE_AND_CONTENT\": 1,\n            \"SECTION_HEADER\": 2,\n            \"TWO_COLUMNS\": 3,\n            \"COMPARISON\": 3,\n            \"TITLE_AND_TWO_CONTENT\": 3,\n            \"BIG_NUMBER\": 5,\n            \"QUOTE\": 6,\n            \"IMAGE_ONLY\": 7,\n            \"IMAGE_WITH_CAPTION\": 8,\n            \"BLANK\": 6\n        }\n        \n        layout_idx = layout_map.get(layout_name, 1)  # Default to TITLE_AND_CONTENT\n        \n        # Ensure the layout index is valid for this presentation\n        if layout_idx >= len(prs.slide_layouts):\n            logger.warning(f\"Layout index {layout_idx} not available, falling back to index 1\")\n            return 1\n            \n        return layout_idx\n    \n    def _add_content_to_placeholder(self, slide, blocks: List[Dict[str, Any]]) -> None:\n        \"\"\"Add content blocks to the main content placeholder\n        \n        Args:\n            slide: PowerPoint slide\n            blocks: List of content blocks\n        \"\"\"\n        # Find the main content placeholder\n        content_placeholder = None\n        for shape in slide.placeholders:\n            if shape.placeholder_format.type == 1:  # Body placeholder\n                content_placeholder = shape\n                break\n        \n        if not content_placeholder:\n            # If no content placeholder, create shapes manually\n            self._create_content_shapes(slide, blocks)\n            return\n        \n        # Process content blocks\n        text_frame = content_placeholder.text_frame\n        text_frame.clear()\n        \n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            \n            if block_type == \"text\":\n                p = text_frame.add_paragraph()\n                p.text = block.get(\"content\", \"\")\n                self._apply_text_formatting(text_frame, self.theme[\"fonts\"][\"body\"], block.get(\"format\", {}))\n                \n            elif block_type == \"bullets\":\n                self._add_bullet_list(text_frame, block.get(\"items\", []))\n            \n            # Other block types are handled separately as they cannot go in a text placeholder\n        \n        # Process any image, chart, or table blocks separately\n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            \n            if block_type == \"image\":\n                # Add image as a separate shape\n                self._add_image(slide, block)\n                \n            elif block_type == \"chart\":\n                # Add chart as a separate shape\n                self._add_chart(slide, block)\n                \n            elif block_type == \"table\":\n                # Add table as a separate shape\n                self._add_table(slide, block)\n    \n    def _create_content_shapes(self, slide, blocks: List[Dict[str, Any]]) -> None:\n        \"\"\"Create shapes for content blocks manually\n        \n        Args:\n            slide: PowerPoint slide\n            blocks: List of content blocks\n        \"\"\"\n        # Calculate available space\n        slide_width = Inches(10)  # Standard PowerPoint slide width\n        slide_height = Inches(7.5)  # Standard PowerPoint slide height\n        \n        # Apply margins\n        left_margin = Inches(self.theme[\"slide_margins\"][\"left\"])\n        right_margin = Inches(self.theme[\"slide_margins\"][\"right\"])\n        top_margin = Inches(self.theme[\"slide_margins\"][\"top\"] + 1)  # Extra space for title\n        bottom_margin = Inches(self.theme[\"slide_margins\"][\"bottom\"])\n        \n        content_width = slide_width - left_margin - right_margin\n        content_height = slide_height - top_margin - bottom_margin\n        \n        current_y = top_margin\n        \n        # Process each content block\n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            position = block.get(\"position\", {})\n            \n            # Calculate horizontal position\n            h_align = position.get(\"horizontal\", Position.LEFT)\n            left = left_margin\n            width = content_width\n            \n            if h_align == Position.CENTER:\n                left = (slide_width - width) / 2\n            elif h_align == Position.RIGHT:\n                left = slide_width - right_margin - width\n            \n            # Process based on block type\n            if block_type == \"text\":\n                height = Inches(0.5 + (len(block.get(\"content\", \"\")) / 100))  # Estimate height\n                textbox = slide.shapes.add_textbox(left, current_y, width, height)\n                tf = textbox.text_frame\n                p = tf.add_paragraph()\n                p.text = block.get(\"content\", \"\")\n                self._apply_text_formatting(tf, self.theme[\"fonts\"][\"body\"], block.get(\"format\", {}))\n                current_y += height\n                \n            elif block_type == \"bullets\":\n                height = Inches(0.3 * len(block.get(\"items\", [])))  # Estimate height\n                textbox = slide.shapes.add_textbox(left, current_y, width, height)\n                tf = textbox.text_frame\n                self._add_bullet_list(tf, block.get(\"items\", []))\n                current_y += height\n                \n            elif block_type == \"image\":\n                # Get image dimensions\n                img_width = Inches(block.get(\"width\", 5) if block.get(\"width\") else 5)\n                img_height = Inches(block.get(\"height\", 3) if block.get(\"height\") else 3)\n                \n                # Adjust position based on alignment\n                img_left = left\n                if h_align == Position.CENTER:\n                    img_left = (slide_width - img_width) / 2\n                elif h_align == Position.RIGHT:\n                    img_left = slide_width - right_margin - img_width\n                \n                self._add_image(slide, block, img_left, current_y, img_width, img_height)\n                current_y += img_height\n                \n            elif block_type == \"chart\":\n                height = Inches(3)  # Default chart height\n                self._add_chart(slide, block, left, current_y, width, height)\n                current_y += height\n                \n            elif block_type == \"table\":\n                rows = len(block.get(\"rows\", [])) + 1  # +1 for header\n                height = Inches(0.4 * rows)\n                self._add_table(slide, block, left, current_y, width, height)\n                current_y += height\n                \n            # Add spacing between blocks\n            current_y += Inches(0.2)\n    \n    def _create_two_column_layout(self, slide, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create a two-column layout slide\n        \n        Args:\n            slide: PowerPoint slide\n            slide_data: Slide data\n        \"\"\"\n        # Get available space\n        slide_width = Inches(10)\n        slide_height = Inches(7.5)\n        \n        # Apply margins\n        left_margin = Inches(self.theme[\"slide_margins\"][\"left\"])\n        right_margin = Inches(self.theme[\"slide_margins\"][\"right\"])\n        top_margin = Inches(self.theme[\"slide_margins\"][\"top\"] + 1)  # Extra space for title\n        bottom_margin = Inches(self.theme[\"slide_margins\"][\"bottom\"])\n        \n        # Split columns\n        column_width = (slide_width - left_margin - right_margin - Inches(0.5)) / 2  # 0.5\" space between columns\n        \n        # Extract left and right column content\n        blocks = slide_data.get(\"blocks\", [])\n        left_blocks = []\n        right_blocks = []\n        \n        # Separate blocks into left and right columns\n        for i, block in enumerate(blocks):\n            if \"column\" in block and block[\"column\"] == \"right\":\n                right_blocks.append(block)\n            elif \"column\" in block and block[\"column\"] == \"left\":\n                left_blocks.append(block)\n            elif i % 2 == 0:\n                left_blocks.append(block)\n            else:\n                right_blocks.append(block)\n        \n        # Create left column\n        left_x = left_margin\n        left_y = top_margin\n        \n        for block in left_blocks:\n            height = self._add_block_to_position(slide, block, left_x, left_y, column_width)\n            left_y += height + Inches(0.2)  # Add spacing\n        \n        # Create right column\n        right_x = left_margin + column_width + Inches(0.5)\n        right_y = top_margin\n        \n        for block in right_blocks:\n            height = self._add_block_to_position(slide, block, right_x, right_y, column_width)\n            right_y += height + Inches(0.2)  # Add spacing\n    \n    def _create_comparison_layout(self, slide, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create a comparison layout slide\n        \n        Args:\n            slide: PowerPoint slide\n            slide_data: Slide data\n        \"\"\"\n        # This is similar to two-column layout but with a different visual styling\n        # and typically contains comparison elements (vs. vs.)\n        \n        # Get comparison title if it exists\n        comparison_title = slide_data.get(\"comparison_title\", \"\")\n        \n        if comparison_title:\n            # Add comparison title at the top\n            title_shape = slide.shapes.add_textbox(\n                Inches(1), Inches(1.5), Inches(8), Inches(0.5)\n            )\n            title_shape.text_frame.text = comparison_title\n            self._apply_text_formatting(title_shape.text_frame, self.theme[\"fonts\"][\"heading\"])\n        \n        # Then create the two-column layout\n        self._create_two_column_layout(slide, slide_data)\n    \n    def _create_image_with_caption(self, slide, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create an image with caption slide\n        \n        Args:\n            slide: PowerPoint slide\n            slide_data: Slide data\n        \"\"\"\n        # Get image block\n        image_block = None\n        for block in slide_data.get(\"blocks\", []):\n            if block.get(\"type\", \"\").lower() == \"image\":\n                image_block = block\n                break\n        \n        if not image_block:\n            logger.warning(\"No image block found for IMAGE_WITH_CAPTION layout\")\n            return\n        \n        # Get caption\n        caption = image_block.get(\"caption\", \"\")\n        \n        # Add image\n        self._add_image(slide, image_block, position_y=Inches(2))\n        \n        # Add caption below image\n        if caption:\n            caption_shape = slide.shapes.add_textbox(\n                Inches(1), Inches(5.5), Inches(8), Inches(0.5)\n            )\n            caption_shape.text_frame.text = caption\n            self._apply_text_formatting(caption_shape.text_frame, self.theme[\"fonts\"][\"body\"])\n            \n            # Center align caption\n            for paragraph in caption_shape.text_frame.paragraphs:\n                paragraph.alignment = PP_ALIGN.CENTER\n    \n    def _add_block_to_position(self, slide, block: Dict[str, Any], x: Any, y: Any, width: Any) -> float:\n        \"\"\"Add a content block at a specific position\n        \n        Args:\n            slide: PowerPoint slide\n            block: Content block\n            x: X-coordinate\n            y: Y-coordinate\n            width: Width\n            \n        Returns:\n            Height of the added block\n        \"\"\"\n        block_type = block.get(\"type\", \"text\").lower()\n        \n        if block_type == \"text\":\n            height = Inches(0.5 + (len(block.get(\"content\", \"\")) / 100))  # Estimate height\n            textbox = slide.shapes.add_textbox(x, y, width, height)\n            tf = textbox.text_frame\n            p = tf.add_paragraph()\n            p.text = block.get(\"content\", \"\")\n            self._apply_text_formatting(tf, self.theme[\"fonts\"][\"body\"], block.get(\"format\", {}))\n            return height\n            \n        elif block_type == \"bullets\":\n            height = Inches(0.3 * len(block.get(\"items\", [])))  # Estimate height\n            textbox = slide.shapes.add_textbox(x, y, width, height)\n            tf = textbox.text_frame\n            self._add_bullet_list(tf, block.get(\"items\", []))\n            return height\n            \n        elif block_type == \"image\":\n            img_width = Inches(block.get(\"width\", 4) if block.get(\"width\") else 4)\n            img_height = Inches(block.get(\"height\", 3) if block.get(\"height\") else 3)\n            \n            # Center image within the column\n            img_x = x + (width - img_width) / 2 if img_width < width else x\n            \n            self._add_image(slide, block, img_x, y, img_width, img_height)\n            return img_height\n            \n        elif block_type == \"chart\":\n            height = Inches(3)  # Default chart height\n            self._add_chart(slide, block, x, y, width, height)\n            return height\n            \n        elif block_type == \"table\":\n            rows = len(block.get(\"rows\", [])) + 1  # +1 for header\n            height = Inches(0.4 * rows)\n            self._add_table(slide, block, x, y, width, height)\n            return height\n            \n        elif block_type == \"quote\":\n            height = Inches(1.5)\n            self._add_quote(slide, block, x, y, width, height)\n            return height\n            \n        return Inches(0.5)  # Default height if no block type matched\n    \n    def _add_bullet_list(self, text_frame, items: List[Dict[str, Any]]) -> None:\n        \"\"\"Add a bullet list to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            items: List of bullet items\n        \"\"\"\n        for item in items:\n            p = text_frame.add_paragraph()\n            p.text = item.get(\"content\", \"\")\n            p.level = item.get(\"level\", 0)  # Indent level\n            p.bullet = True\n            \n            # Apply formatting\n            item_format = item.get(\"format\", {})\n            font = p.font\n            \n            if \"bold\" in item_format and item_format[\"bold\"]:\n                font.bold = True\n            if \"italic\" in item_format and item_format[\"italic\"]:\n                font.italic = True\n            if \"size\" in item_format:\n                font.size = Pt(item_format[\"size\"])\n            if \"color\" in item_format:\n                font.color.rgb = self._parse_color(item_format[\"color\"])\n            \n            # Process sub-bullets\n            for sub_item in item.get(\"sub_bullets\", []):\n                p = text_frame.add_paragraph()\n                p.text = sub_item.get(\"content\", \"\")\n                p.level = sub_item.get(\"level\", 1)  # Default to level 1 for sub-bullets\n                p.bullet = True\n                \n                # Apply formatting to sub-bullets\n                sub_format = sub_item.get(\"format\", {})\n                sub_font = p.font\n                \n                if \"bold\" in sub_format and sub_format[\"bold\"]:\n                    sub_font.bold = True\n                if \"italic\" in sub_format and sub_format[\"italic\"]:\n                    sub_font.italic = True\n                if \"size\" in sub_format:\n                    sub_font.size = Pt(sub_format[\"size\"])\n                if \"color\" in sub_format:\n                    sub_font.color.rgb = self._parse_color(sub_format[\"color\"])\n    \n    def _add_image(self, slide, block: Dict[str, Any], position_x=None, position_y=None, \n                  width=None, height=None) -> None:\n        \"\"\"Add an image to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Image block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        import requests\n        from io import BytesIO\n        \n        # Get image source\n        img_src = block.get(\"source\", \"\")\n        if not img_src:\n            logger.warning(\"No image source specified\")\n            return\n        \n        # Get image data\n        try:\n            if img_src.startswith((\"http://\", \"https://\")):\n                # Download from URL\n                response = requests.get(img_src)\n                response.raise_for_status()\n                img_data = BytesIO(response.content)\n            elif os.path.exists(img_src):\n                # Local file\n                img_data = img_src\n            else:\n                logger.error(f\"Image not found: {img_src}\")\n                return\n        except Exception as e:\n            logger.error(f\"Error loading image {img_src}: {e}\")\n            return\n        \n        # Get dimensions\n        img_width = width or Inches(block.get(\"width\", 5) if block.get(\"width\") else 5)\n        img_height = height or Inches(block.get(\"height\", 3) if block.get(\"height\") else 3)\n        \n        # Get position\n        position = block.get(\"position\", {})\n        h_align = position.get(\"horizontal\", Position.CENTER)\n        v_align = position.get(\"vertical\", Position.MIDDLE)\n        \n        # Calculate position if not provided\n        if position_x is None or position_y is None:\n            slide_width = Inches(10)\n            slide_height = Inches(7.5)\n            \n            # Calculate X position\n            if position_x is None:\n                if h_align == Position.LEFT:\n                    position_x = Inches(self.theme[\"slide_margins\"][\"left\"])\n                elif h_align == Position.RIGHT:\n                    position_x = slide_width - Inches(self.theme[\"slide_margins\"][\"right\"]) - img_width\n                else:  # CENTER\n                    position_x = (slide_width - img_width) / 2\n            \n            # Calculate Y position\n            if position_y is None:\n                if v_align == Position.TOP:\n                    position_y = Inches(self.theme[\"slide_margins\"][\"top\"] + 1)  # Below title\n                elif v_align == Position.BOTTOM:\n                    position_y = slide_height - Inches(self.theme[\"slide_margins\"][\"bottom\"]) - img_height\n                else:  # MIDDLE\n                    position_y = (slide_height - img_height) / 2\n        \n        # Add image to slide\n        try:\n            slide.shapes.add_picture(img_data, position_x, position_y, img_width, img_height)\n        except Exception as e:\n            logger.error(f\"Error adding image to slide: {e}\")\n    \n    def _add_table(self, slide, block: Dict[str, Any], position_x=None, position_y=None,\n                 width=None, height=None) -> None:\n        \"\"\"Add a table to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Table block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        # Get table data\n        headers = block.get(\"headers\", [])\n        rows = block.get(\"rows\", [])\n        \n        if not headers or not rows:\n            logger.warning(\"Table has no headers or rows\")\n            return\n        \n        # Calculate dimensions\n        table_width = width or Inches(8)\n        row_count = len(rows) + 1  # +1 for header row\n        col_count = len(headers)\n        \n        # Get position\n        if position_x is None:\n            position_x = Inches(1)\n        if position_y is None:\n            position_y = Inches(2)\n        \n        # Add table to slide\n        table = slide.shapes.add_table(row_count, col_count, position_x, position_y, table_width, height).table\n        \n        # Add headers\n        for i, header in enumerate(headers):\n            cell = table.cell(0, i)\n            cell.text = header\n            \n            # Format header\n            for paragraph in cell.text_frame.paragraphs:\n                for run in paragraph.runs:\n                    run.font.bold = True\n                    run.font.size = Pt(14)\n        \n        # Add rows\n        for i, row_data in enumerate(rows):\n            for j, cell_text in enumerate(row_data):\n                if j < col_count:  # Ensure we don't exceed column count\n                    cell = table.cell(i + 1, j)  # +1 to skip header row\n                    cell.text = cell_text\n                    \n                    # Format cell\n                    for paragraph in cell.text_frame.paragraphs:\n                        for run in paragraph.runs:\n                            run.font.size = Pt(12)\n    \n    def _add_chart(self, slide, block: Dict[str, Any], position_x=None, position_y=None,\n                 width=None, height=None) -> None:\n        \"\"\"Add a chart to a slide (placeholder implementation)\n        \n        Args:\n            slide: PowerPoint slide\n            block: Chart block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        # NOTE: This is a placeholder. Actual chart implementation would require\n        # more complex integration with python-pptx charts\n        \n        # Create a text box with chart information instead\n        chart_type = block.get(\"chart_type\", \"Unknown\")\n        chart_title = block.get(\"title\", \"Chart\")\n        \n        if position_x is None:\n            position_x = Inches(1)\n        if position_y is None:\n            position_y = Inches(2)\n        \n        chart_width = width or Inches(8)\n        chart_height = height or Inches(3)\n        \n        # Add a placeholder text box\n        shape = slide.shapes.add_textbox(position_x, position_y, chart_width, chart_height)\n        tf = shape.text_frame\n        \n        p = tf.add_paragraph()\n        p.text = f\"[{chart_type.upper()} CHART: {chart_title}]\"\n        p.alignment = PP_ALIGN.CENTER\n        \n        # Center the text vertically\n        tf.vertical_anchor = MSO_VERTICAL_ANCHOR.MIDDLE\n        \n        # Format text\n        for paragraph in tf.paragraphs:\n            for run in paragraph.runs:\n                run.font.size = Pt(18)\n                run.font.bold = True\n                run.font.color.rgb = self._parse_color(self.theme[\"colors\"][\"secondary\"])\n    \n    def _add_quote(self, slide, block: Dict[str, Any], position_x=None, position_y=None,\n                 width=None, height=None) -> None:\n        \"\"\"Add a quote to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Quote block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        # Get quote data\n        quote_text = block.get(\"quote\", \"\")\n        attribution = block.get(\"attribution\", \"\")\n        \n        if not quote_text:\n            logger.warning(\"Quote has no text\")\n            return\n        \n        # Get position\n        if position_x is None:\n            position_x = Inches(1)\n        if position_y is None:\n            position_y = Inches(2.5)\n        \n        quote_width = width or Inches(8)\n        quote_height = height or Inches(2)\n        \n        # Add quote\n        shape = slide.shapes.add_textbox(position_x, position_y, quote_width, quote_height)\n        tf = shape.text_frame\n        \n        # Add quote text\n        p = tf.add_paragraph()\n        p.text = f'\"{quote_text}\"'\n        p.alignment = PP_ALIGN.CENTER\n        \n        # Format quote\n        for run in p.runs:\n            run.font.italic = True\n            run.font.size = Pt(24)\n            run.font.bold = True\n            run.font.color.rgb = self._parse_color(self.theme[\"colors\"][\"primary\"])\n        \n        # Add attribution if provided\n        if attribution:\n            p = tf.add_paragraph()\n            p.text = f\"— {attribution}\"\n            p.alignment = PP_ALIGN.CENTER\n            \n            # Format attribution\n            for run in p.runs:\n                run.font.italic = True\n                run.font.size = Pt(18)\n    \n    def _set_background(self, slide, background: str) -> None:\n        \"\"\"Set slide background\n        \n        Args:\n            slide: PowerPoint slide\n            background: Background color or image path\n        \"\"\"\n        if not background:\n            return\n            \n        # Check if it's a color\n        if background.startswith(\"#\") or background in [\"white\", \"black\", \"blue\", \"red\", \"green\"]:\n            fill = slide.background.fill\n            fill.solid()\n            fill.fore_color.rgb = self._parse_color(background)\n        \n        # Check if it's an image path\n        elif os.path.exists(background) or background.startswith((\"http://\", \"https://\")):\n            # This would require more complex handling to set a background image\n            logger.warning(\"Background images not fully implemented yet\")\n    \n    def _apply_text_formatting(self, text_frame, font_settings: Dict[str, Any], \n                             extra_format: Dict[str, Any] = None) -> None:\n        \"\"\"Apply text formatting to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            font_settings: Font settings from theme\n            extra_format: Additional formatting to apply\n        \"\"\"\n        # Combine theme settings with extra formatting\n        format_settings = font_settings.copy()\n        if extra_format:\n            format_settings.update(extra_format)\n        \n        # Apply to all paragraphs and runs\n        for paragraph in text_frame.paragraphs:\n            for run in paragraph.runs:\n                if \"name\" in format_settings:\n                    run.font.name = format_settings[\"name\"]\n                \n                if \"size\" in format_settings:\n                    run.font.size = Pt(format_settings[\"size\"])\n                \n                if \"bold\" in format_settings:\n                    run.font.bold = format_settings[\"bold\"]\n                \n                if \"italic\" in format_settings:\n                    run.font.italic = format_settings[\"italic\"]\n                \n                if \"color\" in format_settings:\n                    run.font.color.rgb = self._parse_color(format_settings[\"color\"])\n    \n    def _parse_color(self, color_str: str) -> RGBColor:\n        \"\"\"Parse a color string into an RGBColor object\n        \n        Args:\n            color_str: Color string (hex, theme key, or color name)\n            \n        Returns:\n            RGBColor object\n        \"\"\"\n        # Check if it's a theme color\n        if color_str in self.theme[\"colors\"]:\n            color_str = self.theme[\"colors\"][color_str]\n        \n        # Handle hex colors\n        if color_str.startswith(\"#\"):\n            color_str = color_str[1:]  # Remove # prefix\n        \n        # Try to parse as hex\n        try:\n            if len(color_str) == 6:\n                r = int(color_str[0:2], 16)\n                g = int(color_str[2:4], 16)\n                b = int(color_str[4:6], 16)\n                return RGBColor(r, g, b)\n        except ValueError:\n            pass\n        \n        # Handle color names\n        color_map = {\n            \"black\": RGBColor(0, 0, 0),\n            \"white\": RGBColor(255, 255, 255),\n            \"red\": RGBColor(255, 0, 0),\n            \"green\": RGBColor(0, 128, 0),\n            \"blue\": RGBColor(0, 0, 255),\n            \"yellow\": RGBColor(255, 255, 0),\n            \"purple\": RGBColor(128, 0, 128),\n            \"orange\": RGBColor(255, 165, 0),\n            \"gray\": RGBColor(128, 128, 128)\n        }\n        \n        return color_map.get(color_str.lower(), RGBColor(0, 0, 0))  # Default to black\n```\n\n## 2. Google Slides API Integration\n\nNow let's add direct Google Slides API support:\n\n```python\n# makeslides/renderers/google_slides_renderer.py\nimport os\nimport json\nimport tempfile\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom googleapiclient.discovery import build\nfrom google.oauth2.credentials import Credentials\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\n\nlogger = logging.getLogger(__name__)\n\n# Define Google Slides API scopes\nSCOPES = ['https://www.googleapis.com/auth/presentations',\n          'https://www.googleapis.com/auth/drive']\n\nclass GoogleSlidesRenderer:\n    \"\"\"Renders presentations directly to Google Slides using the API\"\"\"\n    \n    def __init__(self, credentials_path: Optional[str] = None, token_path: Optional[str] = None):\n        \"\"\"Initialize the Google Slides renderer\n        \n        Args:\n            credentials_path: Path to the credentials.json file\n            token_path: Path to store/load the token.json file\n        \"\"\"\n        self.credentials_path = credentials_path or os.path.join(\n            os.path.expanduser(\"~\"), \".makeslides\", \"credentials.json\"\n        )\n        self.token_path = token_path or os.path.join(\n            os.path.expanduser(\"~\"), \".makeslides\", \"token.json\"\n        )\n        \n        # Ensure the token directory exists\n        os.makedirs(os.path.dirname(self.token_path), exist_ok=True)\n        \n        self.slides_service = None\n        self.drive_service = None\n    \n    def _initialize_services(self) -> bool:\n        \"\"\"Initialize the Google Slides and Drive services\n        \n        Returns:\n            Success status\n        \"\"\"\n        try:\n            creds = None\n            \n            # Check if token file exists\n            if os.path.exists(self.token_path):\n                creds = Credentials.from_authorized_user_info(\n                    json.loads(Path(self.token_path).read_text()), SCOPES\n                )\n            \n            # If credentials don't exist or are invalid, refresh or get new ones\n            if not creds or not creds.valid:\n                if creds and creds.expired and creds.refresh_token:\n                    creds.refresh(Request())\n                else:\n                    if not os.path.exists(self.credentials_path):\n                        logger.error(f\"Credentials file not found: {self.credentials_path}\")\n                        return False\n                    \n                    flow = InstalledAppFlow.from_client_secrets_file(\n                        self.credentials_path, SCOPES\n                    )\n                    creds = flow.run_local_server(port=0)\n                \n                # Save the credentials for the next run\n                with open(self.token_path, 'w') as token:\n                    token.write(creds.to_json())\n            \n            # Build services\n            self.slides_service = build('slides', 'v1', credentials=creds)\n            self.drive_service = build('drive', 'v3', credentials=creds)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error initializing Google services: {e}\")\n            return False\n    \n    def render(self, presentation_data: Dict[str, Any], output_path: Optional[str] = None) -> Optional[str]:\n        \"\"\"Render a presentation to Google Slides\n        \n        Args:\n            presentation_data: Presentation data structure\n            output_path: Path to save the presentation ID/URL (optional)\n            \n        Returns:\n            Google Slides URL or None on error\n        \"\"\"\n        # Initialize services\n        if not self._initialize_services():\n            return None\n        \n        try:\n            # Create a new presentation\n            title = presentation_data.get(\"title\", \"Generated Presentation\")\n            presentation = self.slides_service.presentations().create(\n                body={\"title\": title}\n            ).execute()\n            \n            presentation_id = presentation.get('presentationId')\n            logger.info(f\"Created new presentation with ID: {presentation_id}\")\n            \n            # Process slides\n            requests = []\n            \n            # Delete the default slide\n            default_slide_ids = self._get_existing_slide_ids(presentation_id)\n            for slide_id in default_slide_ids:\n                requests.append({\n                    'deleteObject': {\n                        'objectId': slide_id\n                    }\n                })\n            \n            # Add slides\n            for slide_data in presentation_data.get(\"slides\", []):\n                slide_requests = self._create_slide_requests(slide_data)\n                requests.extend(slide_requests)\n            \n            # Execute all requests\n            if requests:\n                self.slides_service.presentations().batchUpdate(\n                    presentationId=presentation_id,\n                    body={'requests': requests}\n                ).execute()\n            \n            # Get presentation URL\n            presentation_url = f\"https://docs.google.com/presentation/d/{presentation_id}/edit\"\n            \n            # Save URL to output file if specified\n            if output_path:\n                with open(output_path, 'w') as f:\n                    f.write(presentation_url)\n            \n            logger.info(f\"Presentation created at: {presentation_url}\")\n            return presentation_url\n            \n        except Exception as e:\n            logger.error(f\"Error creating Google Slides presentation: {e}\")\n            return None\n    \n    def upload_pptx(self, pptx_path: str) -> Optional[str]:\n        \"\"\"Upload a PPTX file to Google Slides\n        \n        Args:\n            pptx_path: Path to the PPTX file\n            \n        Returns:\n            Google Slides URL or None on error\n        \"\"\"\n        # Initialize services\n        if not self._initialize_services():\n            return None\n        \n        try:\n            # Upload the file to Google Drive first\n            file_metadata = {\n                'name': os.path.basename(pptx_path),\n                'mimeType': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            }\n            \n            media = MediaFileUpload(\n                pptx_path,\n                mimetype='application/vnd.openxmlformats-officedocument.presentationml.presentation',\n                resumable=True\n            )\n            \n            file = self.drive_service.files().create(\n                body=file_metadata,\n                media_body=media,\n                fields='id'\n            ).execute()\n            \n            file_id = file.get('id')\n            logger.info(f\"Uploaded PPTX to Drive with ID: {file_id}\")\n            \n            # Import to Google Slides\n            drive_data = self.drive_service.files().get(fileId=file_id).execute()\n            presentation_id = drive_data.get('id')\n            \n            # Get presentation URL\n            presentation_url = f\"https://docs.google.com/presentation/d/{presentation_id}/edit\"\n            \n            logger.info(f\"PPTX imported to Google Slides at: {presentation_url}\")\n            return presentation_url\n            \n        except Exception as e:\n            logger.error(f\"Error uploading PPTX to Google Slides: {e}\")\n            return None\n    \n    def _get_existing_slide_ids(self, presentation_id: str) -> List[str]:\n        \"\"\"Get the IDs of existing slides in a presentation\n        \n        Args:\n            presentation_id: Presentation ID\n            \n        Returns:\n            List of slide IDs\n        \"\"\"\n        presentation = self.slides_service.presentations().get(\n            presentationId=presentation_id\n        ).execute()\n        \n        slide_ids = []\n        for slide in presentation.get('slides', []):\n            slide_ids.append(slide.get('objectId'))\n        \n        return slide_ids\n    \n    def _create_slide_requests(self, slide_data: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Create Google Slides API requests for a slide\n        \n        Args:\n            slide_data: Slide data\n            \n        Returns:\n            List of Google Slides API requests\n        \"\"\"\n        requests = []\n        \n        # Generate a unique slide ID\n        slide_id = f\"slide_{id(slide_data)}\"\n        \n        # Determine layout based on slide type\n        layout = slide_data.get(\"layout\", \"TITLE_AND_CONTENT\")\n        layout_mapping = {\n            \"TITLE_ONLY\": \"TITLE\",\n            \"TITLE_AND_CONTENT\": \"TITLE_AND_BODY\",\n            \"SECTION_HEADER\": \"SECTION_HEADER\",\n            \"TWO_COLUMNS\": \"TWO_COLUMNS\",\n            \"COMPARISON\": \"COMPARISON\",\n            \"BIG_NUMBER\": \"BIG_NUMBER\",\n            \"QUOTE\": \"QUOTE\",\n            \"IMAGE_ONLY\": \"BLANK\",\n            \"IMAGE_WITH_CAPTION\": \"CAPTION_ONLY\",\n            \"BLANK\": \"BLANK\"\n        }\n        \n        predefined_layout = layout_mapping.get(layout, \"TITLE_AND_BODY\")\n        \n        # Create a new slide\n        requests.append({\n            'createSlide': {\n                'objectId': slide_id,\n                'slideLayoutReference': {\n                    'predefinedLayout': predefined_layout\n                }\n            }\n        })\n        \n        # Add title\n        if \"title\" in slide_data:\n            title_id = f\"{slide_id}_title\"\n            requests.append({\n                'createShape': {\n                    'objectId': title_id,\n                    'shapeType': 'TEXT_BOX',\n                    'elementProperties': {\n                        'pageObjectId': slide_id,\n                        'size': {\n                            'width': {'magnitude': 540, 'unit': 'PT'},\n                            'height': {'magnitude': 50, 'unit': 'PT'}\n                        },\n                        'transform': {\n                            'scaleX': 1,\n                            'scaleY': 1,\n                            'translateX': 40,\n                            'translateY': 20,\n                            'unit': 'PT'\n                        }\n                    }\n                }\n            })\n            \n            requests.append({\n                'insertText': {\n                    'objectId': title_id,\n                    'text': slide_data[\"title\"]\n                }\n            })\n            \n            # Format title text\n            requests.append({\n                'updateTextStyle': {\n                    'objectId': title_id,\n                    'style': {\n                        'bold': True,\n                        'fontSize': {\n                            'magnitude': 28,\n                            'unit': 'PT'\n                        }\n                    },\n                    'fields': 'bold,fontSize'\n                }\n            })\n        \n        # Process content blocks\n        blocks = slide_data.get(\"blocks\", [])\n        \n        if layout == \"TWO_COLUMNS\":\n            # Special handling for two-column layout\n            left_blocks = []\n            right_blocks = []\n            \n            # Separate blocks into left and right columns\n            for i, block in enumerate(blocks):\n                if \"column\" in block and block[\"column\"] == \"right\":\n                    right_blocks.append(block)\n                elif \"column\" in block and block[\"column\"] == \"left\":\n                    left_blocks.append(block)\n                elif i % 2 == 0:\n                    left_blocks.append(block)\n                else:\n                    right_blocks.append(block)\n            \n            # Create left column\n            if left_blocks:\n                left_id = f\"{slide_id}_left\"\n                requests.append({\n                    'createShape': {\n                        'objectId': left_id,\n                        'shapeType': 'TEXT_BOX',\n                        'elementProperties': {\n                            'pageObjectId': slide_id,\n                            'size': {\n                                'width': {'magnitude': 260, 'unit': 'PT'},\n                                'height': {'magnitude': 300, 'unit': 'PT'}\n                            },\n                            'transform': {\n                                'scaleX': 1,\n                                'scaleY': 1,\n                                'translateX': 40,\n                                'translateY': 100,\n                                'unit': 'PT'\n                            }\n                        }\n                    }\n                })\n                \n                # Insert content for left column\n                left_content = self._blocks_to_text(left_blocks)\n                requests.append({\n                    'insertText': {\n                        'objectId': left_id,\n                        'text': left_content\n                    }\n                })\n            \n            # Create right column\n            if right_blocks:\n                right_id = f\"{slide_id}_right\"\n                requests.append({\n                    'createShape': {\n                        'objectId': right_id,\n                        'shapeType': 'TEXT_BOX',\n                        'elementProperties': {\n                            'pageObjectId': slide_id,\n                            'size': {\n                                'width': {'magnitude': 260, 'unit': 'PT'},\n                                'height': {'magnitude': 300, 'unit': 'PT'}\n                            },\n                            'transform': {\n                                'scaleX': 1,\n                                'scaleY': 1,\n                                'translateX': 320,\n                                'translateY': 100,\n                                'unit': 'PT'\n                            }\n                        }\n                    }\n                })\n                \n                # Insert content for right column\n                right_content = self._blocks_to_text(right_blocks)\n                requests.append({\n                    'insertText': {\n                        'objectId': right_id,\n                        'text': right_content\n                    }\n                })\n        else:\n            # Standard layouts - create a single content box\n            if blocks:\n                content_id = f\"{slide_id}_content\"\n                requests.append({\n                    'createShape': {\n                        'objectId': content_id,\n                        'shapeType': 'TEXT_BOX',\n                        'elementProperties': {\n                            'pageObjectId': slide_id,\n                            'size': {\n                                'width': {'magnitude': 540, 'unit': 'PT'},\n                                'height': {'magnitude': 300, 'unit': 'PT'}\n                            },\n                            'transform': {\n                                'scaleX': 1,\n                                'scaleY': 1,\n                                'translateX': 40,\n                                'translateY': 100,\n                                'unit': 'PT'\n                            }\n                        }\n                    }\n                })\n                \n                # Insert content\n                content_text = self._blocks_to_text(blocks)\n                requests.append({\n                    'insertText': {\n                        'objectId': content_id,\n                        'text': content_text\n                    }\n                })\n                \n                # Add images\n                for block in blocks:\n                    if block.get(\"type\") == \"image\":\n                        image_requests = self._create_image_requests(slide_id, block)\n                        requests.extend(image_requests)\n        \n        # Add speaker notes if available\n        if \"notes\" in slide_data and slide_data[\"notes\"]:\n            requests.append({\n                'createParagraphBullets': {\n                    'objectId': slide_id,\n                    'textRange': {\n                        'type': 'FIXED_RANGE',\n                        'startIndex': 0,\n                        'endIndex': 1\n                    },\n                    'bulletPreset': 'BULLET_DISC_CIRCLE_SQUARE'\n                }\n            })\n            \n            requests.append({\n                'insertText': {\n                    'objectId': slide_id,\n                    'speakerNotesObjectId': f\"{slide_id}_notes\",\n                    'text': slide_data[\"notes\"]\n                }\n            })\n        \n        return requests\n    \n    def _blocks_to_text(self, blocks: List[Dict[str, Any]]) -> str:\n        \"\"\"Convert content blocks to text\n        \n        Args:\n            blocks: List of content blocks\n            \n        Returns:\n            Text representation\n        \"\"\"\n        text = \"\"\n        \n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            \n            if block_type == \"text\":\n                text += block.get(\"content\", \"\") + \"\\n\\n\"\n                \n            elif block_type == \"bullets\":\n                for item in block.get(\"items\", []):\n                    text += \"• \" + item.get(\"content\", \"\") + \"\\n\"\n                    \n                    # Add sub-bullets\n                    for sub_item in item.get(\"sub_bullets\", []):\n                        text += \"  - \" + sub_item.get(\"content\", \"\") + \"\\n\"\n                \n                text += \"\\n\"\n                \n            elif block_type == \"quote\":\n                text += f'\"{block.get(\"quote\", \"\")}\"'\n                \n                if \"attribution\" in block:\n                    text += f'\\n— {block.get(\"attribution\")}'\n                \n                text += \"\\n\\n\"\n                \n            elif block_type == \"table\":\n                # Add table headers\n                headers = block.get(\"headers\", [])\n                if headers:\n                    text += \" | \".join(headers) + \"\\n\"\n                    text += \"-\" * (len(\" | \".join(headers))) + \"\\n\"\n                \n                # Add table rows\n                for row in block.get(\"rows\", []):\n                    text += \" | \".join(row) + \"\\n\"\n                \n                text += \"\\n\"\n        \n        return text\n    \n    def _create_image_requests(self, slide_id: str, block: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Create requests to add an image to a slide\n        \n        Args:\n            slide_id: Slide ID\n            block: Image block\n            \n        Returns:\n            List of Google Slides API requests\n        \"\"\"\n        requests = []\n        \n        # Get image source\n        img_src = block.get(\"source\", \"\")\n        if not img_src:\n            return requests\n        \n        # Images must have a URL for Google Slides API\n        if not img_src.startswith((\"http://\", \"https://\")):\n            logger.warning(f\"Google Slides API requires image URLs, skipping local image: {img_src}\")\n            return requests\n        \n        # Generate image ID\n        image_id = f\"{slide_id}_image_{id(block)}\"\n        \n        # Get image position\n        position = block.get(\"position\", {})\n        h_align = position.get(\"horizontal\", \"CENTER\")\n        \n        # Calculate position\n        transform = {\n            'scaleX': 1,\n            'scaleY': 1,\n            'unit': 'PT'\n        }\n        \n        if h_align == \"LEFT\":\n            transform['translateX'] = 40\n        elif h_align == \"RIGHT\":\n            transform['translateX'] = 400\n        else:  # CENTER\n            transform['translateX'] = 220\n        \n        # Y position is below title by default\n        transform['translateY'] = 150\n        \n        # Create image element\n        requests.append({\n            'createImage': {\n                'objectId': image_id,\n                'url': img_src,\n                'elementProperties': {\n                    'pageObjectId': slide_id,\n                    'size': {\n                        'width': {'magnitude': 300, 'unit': 'PT'},\n                        'height': {'magnitude': 200, 'unit': 'PT'}\n                    },\n                    'transform': transform\n                }\n            }\n        })\n        \n        return requests\n```\n\n## 3. Factory Pattern for Renderer Selection\n\nLet's create a factory to choose between renderers:\n\n```python\n# makeslides/renderers/factory.py\nfrom typing import Dict, Any, Optional\nimport logging\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\ndef create_renderer(output_format: str = \"pptx\", **kwargs) -> Any:\n    \"\"\"Create and return the appropriate renderer\n    \n    Args:\n        output_format: Format to render to (\"pptx\" or \"google_slides\")\n        **kwargs: Additional options for the renderer\n        \n    Returns:\n        Renderer instance\n    \"\"\"\n    if output_format.lower() == \"pptx\":\n        from .pptx_renderer import PptxRenderer\n        return PptxRenderer(\n            template_path=kwargs.get(\"template_path\"),\n            theme=kwargs.get(\"theme\")\n        )\n    \n    elif output_format.lower() in [\"google_slides\", \"google\", \"slides\"]:\n        from .google_slides_renderer import GoogleSlidesRenderer\n        return GoogleSlidesRenderer(\n            credentials_path=kwargs.get(\"credentials_path\"),\n            token_path=kwargs.get(\"token_path\")\n        )\n    \n    else:\n        logger.error(f\"Unsupported output format: {output_format}\")\n        raise ValueError(f\"Unsupported output format: {output_format}\")\n```\n\n## 4. Visual Review with LLM\n\nLet's add the capability to visually review slides using Claude:\n\n```python\n# makeslides/review/visual_reviewer.py\nimport os\nimport tempfile\nimport base64\nimport logging\nimport anthropic\nfrom typing import Dict, Any, List\nfrom pathlib import Path\nimport subprocess\nfrom io import BytesIO\nfrom PIL import Image\n\nlogger = logging.getLogger(__name__)\n\nclass VisualReviewer:\n    \"\"\"Reviews presentation visuals using Claude's vision capabilities\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        \"\"\"Initialize the visual reviewer\n        \n        Args:\n            api_key: Anthropic API key (optional, defaults to env var)\n        \"\"\"\n        self.api_key = api_key or os.environ.get(\"ANTHROPIC_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"Anthropic API key not provided and ANTHROPIC_API_KEY environment variable not set\")\n        \n        self.client = anthropic.Anthropic(api_key=self.api_key)\n    \n    def review_pptx(self, pptx_path: str) -> Dict[str, Any]:\n        \"\"\"Review a PowerPoint presentation\n        \n        Args:\n            pptx_path: Path to PPTX file\n            \n        Returns:\n            Review results\n        \"\"\"\n        # Extract slides as images\n        slide_images = self._extract_slides_from_pptx(pptx_path)\n        \n        if not slide_images:\n            logger.error(\"Failed to extract slides from PowerPoint\")\n            return {\"success\": False, \"error\": \"Failed to extract slides\"}\n        \n        # Review each slide\n        review_results = []\n        \n        for i, image_data in enumerate(slide_images):\n            try:\n                # Review individual slide\n                slide_review = self._review_single_slide(image_data, slide_number=i+1)\n                review_results.append(slide_review)\n                \n            except Exception as e:\n                logger.error(f\"Error reviewing slide {i+1}: {e}\")\n                review_results.append({\n                    \"slide_number\": i+1,\n                    \"success\": False,\n                    \"error\": str(e)\n                })\n        \n        # Generate overall review\n        overall_review = self._generate_overall_review(review_results)\n        \n        return {\n            \"success\": True,\n            \"overall_review\": overall_review,\n            \"slide_reviews\": review_results\n        }\n    \n    def _extract_slides_from_pptx(self, pptx_path: str) -> List[bytes]:\n        \"\"\"Extract slides as images from a PowerPoint file\n        \n        Args:\n            pptx_path: Path to PPTX file\n            \n        Returns:\n            List of image data (bytes)\n        \"\"\"\n        slides = []\n        \n        try:\n            # Create a temporary directory to store slide images\n            with tempfile.TemporaryDirectory() as temp_dir:\n                # Use LibreOffice to convert PPTX to images\n                # Note: This requires LibreOffice to be installed\n                try:\n                    cmd = [\n                        \"libreoffice\", \"--headless\", \"--convert-to\", \"png\",\n                        \"--outdir\", temp_dir, pptx_path\n                    ]\n                    subprocess.run(cmd, check=True, capture_output=True)\n                except subprocess.CalledProcessError:\n                    logger.warning(\"LibreOffice conversion failed, trying alternative method\")\n                    \n                    # Alternative: Use python-pptx to extract slides\n                    # This is less accurate but doesn't require external dependencies\n                    from pptx import Presentation\n                    from pptx.enum.shapes import MSO_SHAPE_TYPE\n                    \n                    prs = Presentation(pptx_path)\n                    for i, slide in enumerate(prs.slides):\n                        # Create a blank image\n                        img = Image.new('RGB', (960, 540), (255, 255, 255))\n                        \n                        # Save the blank image with slide number\n                        img_path = os.path.join(temp_dir, f\"slide_{i+1:02d}.png\")\n                        img.save(img_path)\n                \n                # Read generated images\n                for file in sorted(os.listdir(temp_dir)):\n                    if file.endswith(\".png\"):\n                        file_path = os.path.join(temp_dir, file)\n                        with open(file_path, \"rb\") as f:\n                            slides.append(f.read())\n        \n        except Exception as e:\n            logger.error(f\"Error extracting slides: {e}\")\n        \n        return slides\n    \n    def _review_single_slide(self, image_data: bytes, slide_number: int) -> Dict[str, Any]:\n        \"\"\"Review a single slide\n        \n        Args:\n            image_data: Slide image data\n            slide_number: Slide number\n            \n        Returns:\n            Review result\n        \"\"\"\n        # Convert image to base64\n        base64_image = base64.b64encode(image_data).decode(\"utf-8\")\n        \n        # Prepare message for Claude\n        messages = [\n            {\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"image\",\n                        \"source\": {\n                            \"type\": \"base64\",\n                            \"media_type\": \"image/png\",\n                            \"data\": base64_image\n                        }\n                    },\n                    {\n                        \"type\": \"text\",\n                        \"text\": f\"\"\"Please review this presentation slide (Slide {slide_number}) and provide feedback on:\n1. Visual design and layout\n2. Content clarity and organization\n3. Use of text (amount, size, readability)\n4. Use of visuals (images, diagrams, charts)\n5. Specific improvements that could be made\n\nFormat your response as a JSON object with the following keys:\n- rating: A score from 1-10 rating the overall slide quality\n- strengths: Array of 2-3 key strengths of the slide\n- weaknesses: Array of 2-3 areas that need improvement\n- recommendations: Array of 3-5 specific, actionable improvements\n\"\"\"\n                    }\n                ]\n            }\n        ]\n        \n        # Send request to Claude\n        response = self.client.messages.create(\n            model=\"claude-3-7-sonnet-20250219\",\n            max_tokens=1500,\n            system=\"You are a presentation design expert providing helpful and constructive feedback. Focus on specific, actionable advice. Return valid JSON only, with no surrounding explanation.\",\n            messages=messages\n        )\n        \n        # Parse response\n        response_text = response.content[0].text\n        \n        # Extract JSON from response\n        import re\n        import json\n        \n        json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n        json_match = re.search(json_pattern, response_text)\n        \n        if json_match:\n            review_json = json_match.group(1)\n        else:\n            review_json = response_text\n        \n        try:\n            review_data = json.loads(review_json)\n            review_data[\"slide_number\"] = slide_number\n            review_data[\"success\"] = True\n            return review_data\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse JSON from Claude response for slide {slide_number}\")\n            return {\n                \"slide_number\": slide_number,\n                \"success\": False,\n                \"error\": \"Failed to parse review data\",\n                \"raw_response\": response_text\n            }\n    \n    def _generate_overall_review(self, slide_reviews: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Generate an overall review of the presentation\n        \n        Args:\n            slide_reviews: List of individual slide reviews\n            \n        Returns:\n            Overall review\n        \"\"\"\n        # Prepare summary of slide reviews for Claude\n        successful_reviews = [r for r in slide_reviews if r.get(\"success\", False)]\n        \n        if not successful_reviews:\n            return {\n                \"overall_rating\": 0,\n                \"summary\": \"Unable to generate overall review due to failed slide reviews.\",\n                \"key_issues\": [],\n                \"key_strengths\": [],\n                \"recommendations\": []\n            }\n        \n        # Calculate average rating\n        ratings = [r.get(\"rating\", 0) for r in successful_reviews]\n        avg_rating = sum(ratings) / len(ratings) if ratings else 0\n        \n        # Collect all strengths and weaknesses\n        all_strengths = []\n        all_weaknesses = []\n        \n        for review in successful_reviews:\n            all_strengths.extend(review.get(\"strengths\", []))\n            all_weaknesses.extend(review.get(\"weaknesses\", []))\n        \n        # Identify common themes\n        from collections import Counter\n        \n        # Custom function to find similar items\n        def find_similar(items):\n            # Simple approach: group by common keywords\n            keywords = {}\n            for item in items:\n                words = set(w.lower() for w in item.split() if len(w) > 3)\n                for word in words:\n                    if word not in keywords:\n                        keywords[word] = []\n                    keywords[word].append(item)\n            \n            # Return groups with multiple items\n            return [group for group in keywords.values() if len(group) > 1]\n        \n        common_strengths = find_similar(all_strengths)\n        common_weaknesses = find_similar(all_weaknesses)\n        \n        # Generate overall recommendations\n        overall_recommendations = []\n        if common_weaknesses:\n            for group in common_weaknesses[:3]:  # Top 3 weakness groups\n                if group:\n                    overall_recommendations.append(f\"Improve {group[0].lower()}\")\n        \n        return {\n            \"overall_rating\": round(avg_rating, 1),\n            \"summary\": f\"Presentation has an average slide rating of {round(avg_rating, 1)}/10 across {len(successful_reviews)} slides.\",\n            \"key_issues\": [group[0] for group in common_weaknesses[:3] if group],\n            \"key_strengths\": [group[0] for group in common_strengths[:3] if group],\n            \"recommendations\": overall_recommendations\n        }\n```\n\n## 5. Main Controller Class\n\nNow, let's create a central controller that ties everything together:\n\n```python\n# makeslides/core/controller.py\nimport os\nimport logging\nimport json\nimport tempfile\nfrom typing import Dict, Any, Optional, Union, List\nfrom pathlib import Path\nimport anthropic\nfrom ..renderers.factory import create_renderer\nfrom ..review.visual_reviewer import VisualReviewer\n\nlogger = logging.getLogger(__name__)\n\nclass SlidesController:\n    \"\"\"Main controller for the slide generation process\"\"\"\n    \n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize the slides controller\n        \n        Args:\n            config: Configuration options\n        \"\"\"\n        self.config = config or {}\n        self.api_key = self.config.get(\"api_key\") or os.environ.get(\"ANTHROPIC_API_KEY\")\n        \n        if not self.api_key:\n            raise ValueError(\"Anthropic API key not provided and ANTHROPIC_API_KEY environment variable not set\")\n        \n        self.client = anthropic.Anthropic(api_key=self.api_key)\n    \n    def create_presentation(self, content: str, output_format: str = \"pptx\", \n                           output_path: Optional[str] = None, theme: Optional[Dict[str, Any]] = None,\n                           template_path: Optional[str] = None, review: bool = False) -> Dict[str, Any]:\n        \"\"\"Create a presentation from content\n        \n        Args:\n            content: Input content (markdown, text, etc.)\n            output_format: Output format (\"pptx\" or \"google_slides\")\n            output_path: Path to save output\n            theme: Theme configuration\n            template_path: Path to template file\n            review: Whether to review the presentation\n            \n        Returns:\n            Result information\n        \"\"\"\n        try:\n            # 1. Analyze content and create presentation structure\n            logger.info(\"Analyzing content and generating presentation structure...\")\n            presentation_data = self._analyze_content(content)\n            \n            if not presentation_data:\n                return {\"success\": False, \"error\": \"Failed to analyze content\"}\n            \n            # 2. Create renderer for requested format\n            renderer = create_renderer(\n                output_format=output_format,\n                template_path=template_path,\n                theme=theme\n            )\n            \n            # 3. Determine output path if not provided\n            if not output_path:\n                if output_format.lower() == \"pptx\":\n                    output_path = \"presentation.pptx\"\n                else:\n                    output_path = \"presentation.txt\"  # Will contain URL for Google Slides\n            \n            # 4. Render presentation\n            logger.info(f\"Rendering presentation to {output_format}...\")\n            result = renderer.render(presentation_data, output_path)\n            \n            if not result:\n                return {\"success\": False, \"error\": f\"Failed to render {output_format} presentation\"}\n            \n            # 5. Review presentation if requested\n            review_results = None\n            if review and output_format.lower() == \"pptx\":\n                logger.info(\"Reviewing presentation...\")\n                reviewer = VisualReviewer(api_key=self.api_key)\n                review_results = reviewer.review_pptx(output_path)\n            \n            # 6. Return results\n            return {\n                \"success\": True,\n                \"output_path\": output_path,\n                \"output_format\": output_format,\n                \"slide_count\": len(presentation_data.get(\"slides\", [])),\n                \"presentation_title\": presentation_data.get(\"title\", \"\"),\n                \"presentation_url\": result if isinstance(result, str) else None,\n                \"review_results\": review_results\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error creating presentation: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def _analyze_content(self, content: str) -> Dict[str, Any]:\n        \"\"\"Analyze content and generate presentation structure\n        \n        Args:\n            content: Input content\n            \n        Returns:\n            Presentation data structure\n        \"\"\"\n        try:\n            # Build prompt for Claude\n            prompt = f\"\"\"Please analyze the following content and create a comprehensive presentation structure.\n\nThe presentation should include:\n1. An appropriate title\n2. Section headers as needed\n3. A logical flow of slides\n4. Appropriate layout choices for each slide\n5. Rich content including text, bullet points, and suggestions for visuals\n\nCONTENT TO ANALYZE:\n{content}\n\nReturn a JSON object with the following structure:\n{{\n  \"title\": \"Presentation Title\",\n  \"author\": \"Author Name\",\n  \"slides\": [\n    {{\n      \"title\": \"Slide Title\",\n      \"layout\": \"LAYOUT_TYPE\", \n      \"blocks\": [\n        {{\n          \"type\": \"text|bullets|image|chart|table|quote\",\n          // Additional properties based on type\n        }}\n      ],\n      \"notes\": \"Speaker notes\"\n    }}\n  ]\n}}\n\nValid layout types include: TITLE_ONLY, TITLE_AND_CONTENT, SECTION_HEADER, TWO_COLUMNS, COMPARISON, BIG_NUMBER, QUOTE, IMAGE_ONLY, IMAGE_WITH_CAPTION, BLANK\n\nFor bullets blocks, use the format:\n{{\n  \"type\": \"bullets\",\n  \"items\": [\n    {{\n      \"content\": \"Bullet text\",\n      \"sub_bullets\": [\n        {{ \"content\": \"Sub-bullet text\" }}\n      ]\n    }}\n  ]\n}}\n\nFor image blocks, use the format:\n{{\n  \"type\": \"image\",\n  \"source\": \"https://example.com/image.jpg\",\n  \"caption\": \"Image caption\",\n  \"position\": {{ \"horizontal\": \"LEFT|CENTER|RIGHT\", \"vertical\": \"TOP|MIDDLE|BOTTOM\" }}\n}}\n\nBe thoughtful about slide layout selection and content organization. Aim for clarity, visual appeal, and effective communication.\n\"\"\"\n            \n            # Call Claude with extended thinking\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=16000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=\"You are an expert presentation designer who creates well-structured, professional presentations. Return valid JSON only with no additional explanation.\",\n                messages=[{\"role\": \"user\", \"content\": prompt}]\n            )\n            \n            # Parse JSON response\n            response_text = response.content[0].text\n            \n            # Extract JSON from response\n            import re\n            import json\n            \n            json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n            json_match = re.search(json_pattern, response_text)\n            \n            if json_match:\n                presentation_json = json_match.group(1)\n            else:\n                presentation_json = response_text\n            \n            presentation_data = json.loads(presentation_json)\n            \n            # Validate required keys\n            if \"title\" not in presentation_data or \"slides\" not in presentation_data:\n                logger.error(\"Missing required keys in presentation data\")\n                return {}\n            \n            return presentation_data\n            \n        except Exception as e:\n            logger.error(f\"Error analyzing content: {e}\")\n            return {}\n    \n    def refine_presentation(self, presentation_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Refine a presentation structure\n        \n        Args:\n            presentation_data: Presentation data\n            \n        Returns:\n            Refined presentation data\n        \"\"\"\n        try:\n            # Convert presentation data to JSON string\n            presentation_json = json.dumps(presentation_data, indent=2)\n            \n            # Build prompt for Claude\n            prompt = f\"\"\"Please review and improve the following presentation structure.\n\nFocus on:\n1. Visual design and layout consistency\n2. Content flow and organization\n3. Appropriate use of layouts\n4. Completeness and clarity\n\nCURRENT PRESENTATION STRUCTURE:\n{presentation_json}\n\nReturn the improved presentation structure as a valid JSON object with the exact same format.\n\"\"\"\n            \n            # Call Claude with extended thinking\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=16000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=\"You are an expert presentation designer who refines and improves presentation structures. Return valid JSON only with no additional explanation.\",\n                messages=[{\"role\": \"user\", \"content\": prompt}]\n            )\n            \n            # Parse JSON response\n            response_text = response.content[0].text\n            \n            # Extract JSON from response\n            import re\n            import json\n            \n            json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n            json_match = re.search(json_pattern, response_text)\n            \n            if json_match:\n                refined_json = json_match.group(1)\n            else:\n                refined_json = response_text\n            \n            refined_data = json.loads(refined_json)\n            \n            # Validate required keys\n            if \"title\" not in refined_data or \"slides\" not in refined_data:\n                logger.error(\"Missing required keys in refined presentation data\")\n                return presentation_data\n            \n            return refined_data\n            \n        except Exception as e:\n            logger.error(f\"Error refining presentation: {e}\")\n            return presentation_data\n```\n\n## 6. Command Line Interface\n\nLet's create a CLI interface for the tool:\n\n```python\n# makeslides/cli.py\nimport argparse\nimport json\nimport logging\nimport os\nimport sys\nfrom pathlib import Path\nfrom .core.controller import SlidesController\n\ndef setup_logging(level: str = \"INFO\"):\n    \"\"\"Set up logging configuration\"\"\"\n    logging.basicConfig(\n        level=getattr(logging, level),\n        format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        handlers=[logging.StreamHandler()]\n    )\n\ndef main():\n    \"\"\"Main CLI entry point\"\"\"\n    parser = argparse.ArgumentParser(description=\"Create slides from content\")\n    \n    # Input options\n    parser.add_argument(\"input\", help=\"Input content file (markdown, text)\")\n    \n    # Output options\n    parser.add_argument(\"--format\", choices=[\"pptx\", \"google_slides\"], default=\"pptx\",\n                      help=\"Output format (default: pptx)\")\n    parser.add_argument(\"--output\", help=\"Output path\")\n    \n    # Visual options\n    parser.add_argument(\"--template\", help=\"Path to template file\")\n    parser.add_argument(\"--theme\", help=\"Path to theme JSON file\")\n    \n    # Advanced options\n    parser.add_argument(\"--review\", action=\"store_true\", help=\"Review presentation after creation\")\n    parser.add_argument(\"--log-level\", choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"], default=\"INFO\",\n                      help=\"Logging level\")\n    parser.add_argument(\"--credentials\", help=\"Path to Google API credentials (for Google Slides)\")\n    \n    args = parser.parse_args()\n    \n    # Set up logging\n    setup_logging(args.log_level)\n    \n    # Check if input file exists\n    input_path = Path(args.input)\n    if not input_path.exists():\n        print(f\"Input file not found: {input_path}\")\n        sys.exit(1)\n    \n    # Read input content\n    try:\n        content = input_path.read_text(encoding=\"utf-8\")\n    except Exception as e:\n        print(f\"Error reading input file: {e}\")\n        sys.exit(1)\n    \n    # Load theme if provided\n    theme = None\n    if args.theme:\n        theme_path = Path(args.theme)\n        if theme_path.exists():\n            try:\n                theme = json.loads(theme_path.read_text(encoding=\"utf-8\"))\n            except Exception as e:\n                print(f\"Error reading theme file: {e}\")\n                sys.exit(1)\n    \n    # Determine output path\n    output_path = args.output\n    if not output_path:\n        if args.format == \"pptx\":\n            output_path = input_path.with_suffix(\".pptx\")\n        else:\n            output_path = input_path.with_suffix(\".slides.txt\")\n    \n    # Create controller\n    config = {}\n    if args.credentials:\n        config[\"credentials_path\"] = args.credentials\n    \n    try:\n        controller = SlidesController(config)\n        \n        # Create presentation\n        result = controller.create_presentation(\n            content=content,\n            output_format=args.format,\n            output_path=output_path,\n            theme=theme,\n            template_path=args.template,\n            review=args.review\n        )\n        \n        # Handle result\n        if result[\"success\"]:\n            print(f\"✓ Successfully created presentation: {result['output_path']}\")\n            \n            if \"presentation_url\" in result and result[\"presentation_url\"]:\n                print(f\"✓ Presentation URL: {result['presentation_url']}\")\n            \n            if \"review_results\" in result and result[\"review_results\"]:\n                print(\"\\nPresentation Review:\")\n                overall = result[\"review_results\"].get(\"overall_review\", {})\n                print(f\"- Overall Rating: {overall.get('overall_rating', 'N/A')}/10\")\n                print(f\"- Summary: {overall.get('summary', 'N/A')}\")\n                \n                if \"key_strengths\" in overall and overall[\"key_strengths\"]:\n                    print(\"\\nKey Strengths:\")\n                    for strength in overall[\"key_strengths\"]:\n                        print(f\"  ✓ {strength}\")\n                \n                if \"key_issues\" in overall and overall[\"key_issues\"]:\n                    print(\"\\nKey Issues:\")\n                    for issue in overall[\"key_issues\"]:\n                        print(f\"  ! {issue}\")\n                \n                if \"recommendations\" in overall and overall[\"recommendations\"]:\n                    print(\"\\nRecommendations:\")\n                    for rec in overall[\"recommendations\"]:\n                        print(f\"  > {rec}\")\n        else:\n            print(f\"✗ Failed to create presentation: {result.get('error', 'Unknown error')}\")\n            sys.exit(1)\n            \n    except Exception as e:\n        print(f\"Error creating presentation: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Summary and Next Steps\n\nI've provided a comprehensive implementation that addresses all your requirements:\n\n1. **Enhanced PPTX Renderer**: Supports positioning, templates, themes, and various content types\n2. **Google Slides API**: Direct integration without md2gslides\n3. **Factory Pattern**: Easily switch between output formats\n4. **Visual Review**: Uses Claude's vision capabilities to provide feedback on slides\n5. **Command Line Interface**: User-friendly CLI for the entire process\n\n### Next Steps:\n\n1. **Testing**: Create unit tests for core components\n2. **Templates**: Build a library of reusable templates and themes\n3. **Advanced Visualization**: Improve chart and diagram rendering\n4. **Web Interface**: Create a simple web UI for interacting with the tool\n5. **Theme Gallery**: Allow users to browse and apply different themes\n\n### Implementation Notes:\n\n1. The PowerPoint renderer now supports all the positioning and layout options you requested.\n2. Google Slides API integration provides both direct creation and PPTX upload.\n3. The visual review feature allows Claude to critique the actual appearance of slides.\n4. The factory pattern makes it easy to add more renderers in the future.\n\nThis should provide a solid foundation for your intelligent slide generator with the flexibility to evolve with your needs.",
      "created_at": "2025-05-21T13:39:08.650921Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-21T13:34:59.294842Z",
            "stop_timestamp": "2025-05-21T13:35:06.950539Z",
            "flags": null,
            "type": "thinking",
            "thinking": "Let me review the project code and your latest requirements. You want to:\n\n1. Remove md2gslides dependency since we'll focus on generating content directly\n2. Generate content primarily as PPTX and possibly use Google Slides API directly\n3. Explore possibility of uploading a PPTX to Google Slides via API\n4. Potentially use vision capabilities to have the LLM critique generated slides\n5. Support templates (fonts, styles, colors, sizes)\n6. Add positioning capabilities for text blocks (left/right alignment)\n7. Support Google Slides themes to allow for different layouts/styles\n\nLooking at the provided code in the context window:\n\nThe project appears to be \"MakeSlides\", a CLI tool for converting training facilitator guides into slide presentations. It currently uses Claude to process facilitator guides into structured JSON, which is then converted to markdown format compatible with md2gslides, and finally used to generate Google Slides presentations.\n\nKey files include:\n- CLAUDE.md - Overview of the project\n- config.yaml - Configuration for the Claude prompt\n- asset_manager.py - Manages image and diagram assets\n- renderer.py - Renders Mermaid diagrams to local image files\n- parser.py - Converts facilitator guides to JSON using Claude\n- embed_images.py - Embeds images in the markdown\n- generator.py - Converts JSON to markdown\n- builder.py - Creates Google Slides from markdown using md2gslides\n- pptx_builder.py - Basic PowerPoint builder\n\nThere's also a \"paste.txt\" document that outlines a proposed modular component architecture and implementation plan, which seems relevant to your desired improvements.\n\nBased on this, I'll propose a set of modifications and additions to move the project forward:\n\n1. Enhance the pptx_builder.py to support more features (positioning, templates, etc.)\n2. Add direct Google Slides API integration\n3. Create a factory pattern for renderers\n4. Add visual review capabilities\n5. Improve template support\n\nLet me draft the key files needed for these improvements.",
            "summaries": [
              {
                "summary": "Thinking about refactoring project workflow with Google Slides API and content generation strategies"
              },
              {
                "summary": "Exploring project modifications and content generation strategies"
              },
              {
                "summary": "Engineered modular slide generation strategy with API integration."
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-05-21T13:35:07.229154Z",
            "stop_timestamp": "2025-05-21T13:39:08.498404Z",
            "flags": null,
            "type": "text",
            "text": "# Moving MakeSlides Forward: Direct PPT and Google Slides Integration\n\nBased on your requests and the existing codebase, I'll focus on enhancing the presentation generation capabilities with direct PPTX creation and Google Slides API integration, while removing the md2gslides dependency. Let's implement the necessary changes:\n\n## 1. Enhanced PPTX Renderer with Template Support\n\nFirst, let's improve the PowerPoint renderer to support templates, positioning, and themes:\n\n```python\n# makeslides/renderers/pptx_renderer.py\nfrom pptx import Presentation\nfrom pptx.util import Inches, Pt\nfrom pptx.enum.text import PP_ALIGN, MSO_VERTICAL_ANCHOR\nfrom pptx.dml.color import RGBColor\nfrom pathlib import Path\nimport logging\nimport os\nfrom typing import Dict, Any, Optional, List, Tuple, Union\n\nlogger = logging.getLogger(__name__)\n\nclass Position:\n    \"\"\"Helper class for positioning elements on slides\"\"\"\n    LEFT = \"left\"\n    RIGHT = \"right\"\n    CENTER = \"center\"\n    TOP = \"top\"\n    MIDDLE = \"middle\"\n    BOTTOM = \"bottom\"\n    FULL = \"full\"\n\nclass PptxRenderer:\n    \"\"\"Renders presentations to PowerPoint files with enhanced positioning and template support\"\"\"\n    \n    def __init__(self, template_path: Optional[str] = None, theme: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize the PowerPoint renderer\n        \n        Args:\n            template_path: Path to a PPTX template file\n            theme: Theme configuration (colors, fonts, etc.)\n        \"\"\"\n        self.template_path = template_path\n        self.theme = theme or self._default_theme()\n        \n    def _default_theme(self) -> Dict[str, Any]:\n        \"\"\"Create a default theme configuration\"\"\"\n        return {\n            \"colors\": {\n                \"primary\": \"4472C4\",  # Blue\n                \"secondary\": \"ED7D31\",  # Orange\n                \"text\": \"000000\",  # Black\n                \"background\": \"FFFFFF\"  # White\n            },\n            \"fonts\": {\n                \"title\": {\n                    \"name\": \"Calibri\",\n                    \"size\": 44,\n                    \"bold\": True\n                },\n                \"subtitle\": {\n                    \"name\": \"Calibri\",\n                    \"size\": 32,\n                    \"bold\": False\n                },\n                \"heading\": {\n                    \"name\": \"Calibri\",\n                    \"size\": 28,\n                    \"bold\": True\n                },\n                \"body\": {\n                    \"name\": \"Calibri\", \n                    \"size\": 18,\n                    \"bold\": False\n                }\n            },\n            \"slide_margins\": {\n                \"top\": 0.5,  # in inches\n                \"right\": 0.5,\n                \"bottom\": 0.5,\n                \"left\": 0.5\n            }\n        }\n    \n    def render(self, presentation_data: Dict[str, Any], output_path: str) -> bool:\n        \"\"\"Render a presentation to a PowerPoint file\n        \n        Args:\n            presentation_data: Presentation data structure\n            output_path: Path to save the PowerPoint file\n            \n        Returns:\n            Success status\n        \"\"\"\n        try:\n            # Create presentation from template or blank\n            if self.template_path and os.path.exists(self.template_path):\n                prs = Presentation(self.template_path)\n                logger.info(f\"Using template: {self.template_path}\")\n            else:\n                prs = Presentation()\n                logger.info(\"Using blank presentation\")\n            \n            # Set presentation properties\n            if hasattr(prs, 'core_properties'):\n                prs.core_properties.title = presentation_data.get(\"title\", \"Presentation\")\n                if \"author\" in presentation_data:\n                    prs.core_properties.author = presentation_data[\"author\"]\n            \n            # Render slides\n            for slide_data in presentation_data.get(\"slides\", []):\n                self._create_slide(prs, slide_data)\n            \n            # Save presentation\n            prs.save(output_path)\n            logger.info(f\"Presentation saved to {output_path}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error rendering presentation: {e}\")\n            return False\n    \n    def _create_slide(self, prs: Presentation, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create a single slide in the presentation\n        \n        Args:\n            prs: PowerPoint presentation object\n            slide_data: Slide data\n        \"\"\"\n        # Select appropriate layout\n        layout_name = slide_data.get(\"layout\", \"TITLE_AND_CONTENT\")\n        layout_idx = self._get_layout_index(prs, layout_name)\n        slide_layout = prs.slide_layouts[layout_idx]\n        \n        # Create slide\n        slide = prs.slides.add_slide(slide_layout)\n        \n        # Set background if specified\n        if \"background\" in slide_data:\n            self._set_background(slide, slide_data[\"background\"])\n        \n        # Set title\n        if hasattr(slide.shapes, 'title') and slide.shapes.title:\n            title_shape = slide.shapes.title\n            title_shape.text = slide_data.get(\"title\", \"\")\n            self._apply_text_formatting(title_shape.text_frame, self.theme[\"fonts\"][\"title\"])\n        \n        # Set subtitle if available\n        if \"subtitle\" in slide_data:\n            subtitle = slide_data[\"subtitle\"]\n            if subtitle:\n                for shape in slide.placeholders:\n                    if shape.placeholder_format.type == 2:  # Subtitle placeholder\n                        shape.text = subtitle\n                        self._apply_text_formatting(shape.text_frame, self.theme[\"fonts\"][\"subtitle\"])\n                        break\n        \n        # Process content blocks based on layout\n        if layout_name == \"TITLE_ONLY\":\n            # Title only, nothing else to do\n            pass\n            \n        elif layout_name == \"TITLE_AND_CONTENT\":\n            self._add_content_to_placeholder(slide, slide_data.get(\"blocks\", []))\n            \n        elif layout_name == \"TWO_COLUMNS\":\n            self._create_two_column_layout(slide, slide_data)\n            \n        elif layout_name == \"COMPARISON\":\n            self._create_comparison_layout(slide, slide_data)\n            \n        elif layout_name == \"IMAGE_WITH_CAPTION\":\n            self._create_image_with_caption(slide, slide_data)\n            \n        # Add notes if provided\n        if \"notes\" in slide_data and slide_data[\"notes\"]:\n            notes_slide = slide.notes_slide\n            notes_slide.notes_text_frame.text = slide_data[\"notes\"]\n    \n    def _get_layout_index(self, prs: Presentation, layout_name: str) -> int:\n        \"\"\"Get the index of a slide layout by name/type\n        \n        Args:\n            prs: PowerPoint presentation\n            layout_name: Name of layout\n            \n        Returns:\n            Index of layout\n        \"\"\"\n        # Map layout names to common PowerPoint layout indices\n        layout_map = {\n            \"TITLE_SLIDE\": 0,\n            \"TITLE_ONLY\": 0,\n            \"TITLE_AND_CONTENT\": 1,\n            \"SECTION_HEADER\": 2,\n            \"TWO_COLUMNS\": 3,\n            \"COMPARISON\": 3,\n            \"TITLE_AND_TWO_CONTENT\": 3,\n            \"BIG_NUMBER\": 5,\n            \"QUOTE\": 6,\n            \"IMAGE_ONLY\": 7,\n            \"IMAGE_WITH_CAPTION\": 8,\n            \"BLANK\": 6\n        }\n        \n        layout_idx = layout_map.get(layout_name, 1)  # Default to TITLE_AND_CONTENT\n        \n        # Ensure the layout index is valid for this presentation\n        if layout_idx >= len(prs.slide_layouts):\n            logger.warning(f\"Layout index {layout_idx} not available, falling back to index 1\")\n            return 1\n            \n        return layout_idx\n    \n    def _add_content_to_placeholder(self, slide, blocks: List[Dict[str, Any]]) -> None:\n        \"\"\"Add content blocks to the main content placeholder\n        \n        Args:\n            slide: PowerPoint slide\n            blocks: List of content blocks\n        \"\"\"\n        # Find the main content placeholder\n        content_placeholder = None\n        for shape in slide.placeholders:\n            if shape.placeholder_format.type == 1:  # Body placeholder\n                content_placeholder = shape\n                break\n        \n        if not content_placeholder:\n            # If no content placeholder, create shapes manually\n            self._create_content_shapes(slide, blocks)\n            return\n        \n        # Process content blocks\n        text_frame = content_placeholder.text_frame\n        text_frame.clear()\n        \n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            \n            if block_type == \"text\":\n                p = text_frame.add_paragraph()\n                p.text = block.get(\"content\", \"\")\n                self._apply_text_formatting(text_frame, self.theme[\"fonts\"][\"body\"], block.get(\"format\", {}))\n                \n            elif block_type == \"bullets\":\n                self._add_bullet_list(text_frame, block.get(\"items\", []))\n            \n            # Other block types are handled separately as they cannot go in a text placeholder\n        \n        # Process any image, chart, or table blocks separately\n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            \n            if block_type == \"image\":\n                # Add image as a separate shape\n                self._add_image(slide, block)\n                \n            elif block_type == \"chart\":\n                # Add chart as a separate shape\n                self._add_chart(slide, block)\n                \n            elif block_type == \"table\":\n                # Add table as a separate shape\n                self._add_table(slide, block)\n    \n    def _create_content_shapes(self, slide, blocks: List[Dict[str, Any]]) -> None:\n        \"\"\"Create shapes for content blocks manually\n        \n        Args:\n            slide: PowerPoint slide\n            blocks: List of content blocks\n        \"\"\"\n        # Calculate available space\n        slide_width = Inches(10)  # Standard PowerPoint slide width\n        slide_height = Inches(7.5)  # Standard PowerPoint slide height\n        \n        # Apply margins\n        left_margin = Inches(self.theme[\"slide_margins\"][\"left\"])\n        right_margin = Inches(self.theme[\"slide_margins\"][\"right\"])\n        top_margin = Inches(self.theme[\"slide_margins\"][\"top\"] + 1)  # Extra space for title\n        bottom_margin = Inches(self.theme[\"slide_margins\"][\"bottom\"])\n        \n        content_width = slide_width - left_margin - right_margin\n        content_height = slide_height - top_margin - bottom_margin\n        \n        current_y = top_margin\n        \n        # Process each content block\n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            position = block.get(\"position\", {})\n            \n            # Calculate horizontal position\n            h_align = position.get(\"horizontal\", Position.LEFT)\n            left = left_margin\n            width = content_width\n            \n            if h_align == Position.CENTER:\n                left = (slide_width - width) / 2\n            elif h_align == Position.RIGHT:\n                left = slide_width - right_margin - width\n            \n            # Process based on block type\n            if block_type == \"text\":\n                height = Inches(0.5 + (len(block.get(\"content\", \"\")) / 100))  # Estimate height\n                textbox = slide.shapes.add_textbox(left, current_y, width, height)\n                tf = textbox.text_frame\n                p = tf.add_paragraph()\n                p.text = block.get(\"content\", \"\")\n                self._apply_text_formatting(tf, self.theme[\"fonts\"][\"body\"], block.get(\"format\", {}))\n                current_y += height\n                \n            elif block_type == \"bullets\":\n                height = Inches(0.3 * len(block.get(\"items\", [])))  # Estimate height\n                textbox = slide.shapes.add_textbox(left, current_y, width, height)\n                tf = textbox.text_frame\n                self._add_bullet_list(tf, block.get(\"items\", []))\n                current_y += height\n                \n            elif block_type == \"image\":\n                # Get image dimensions\n                img_width = Inches(block.get(\"width\", 5) if block.get(\"width\") else 5)\n                img_height = Inches(block.get(\"height\", 3) if block.get(\"height\") else 3)\n                \n                # Adjust position based on alignment\n                img_left = left\n                if h_align == Position.CENTER:\n                    img_left = (slide_width - img_width) / 2\n                elif h_align == Position.RIGHT:\n                    img_left = slide_width - right_margin - img_width\n                \n                self._add_image(slide, block, img_left, current_y, img_width, img_height)\n                current_y += img_height\n                \n            elif block_type == \"chart\":\n                height = Inches(3)  # Default chart height\n                self._add_chart(slide, block, left, current_y, width, height)\n                current_y += height\n                \n            elif block_type == \"table\":\n                rows = len(block.get(\"rows\", [])) + 1  # +1 for header\n                height = Inches(0.4 * rows)\n                self._add_table(slide, block, left, current_y, width, height)\n                current_y += height\n                \n            # Add spacing between blocks\n            current_y += Inches(0.2)\n    \n    def _create_two_column_layout(self, slide, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create a two-column layout slide\n        \n        Args:\n            slide: PowerPoint slide\n            slide_data: Slide data\n        \"\"\"\n        # Get available space\n        slide_width = Inches(10)\n        slide_height = Inches(7.5)\n        \n        # Apply margins\n        left_margin = Inches(self.theme[\"slide_margins\"][\"left\"])\n        right_margin = Inches(self.theme[\"slide_margins\"][\"right\"])\n        top_margin = Inches(self.theme[\"slide_margins\"][\"top\"] + 1)  # Extra space for title\n        bottom_margin = Inches(self.theme[\"slide_margins\"][\"bottom\"])\n        \n        # Split columns\n        column_width = (slide_width - left_margin - right_margin - Inches(0.5)) / 2  # 0.5\" space between columns\n        \n        # Extract left and right column content\n        blocks = slide_data.get(\"blocks\", [])\n        left_blocks = []\n        right_blocks = []\n        \n        # Separate blocks into left and right columns\n        for i, block in enumerate(blocks):\n            if \"column\" in block and block[\"column\"] == \"right\":\n                right_blocks.append(block)\n            elif \"column\" in block and block[\"column\"] == \"left\":\n                left_blocks.append(block)\n            elif i % 2 == 0:\n                left_blocks.append(block)\n            else:\n                right_blocks.append(block)\n        \n        # Create left column\n        left_x = left_margin\n        left_y = top_margin\n        \n        for block in left_blocks:\n            height = self._add_block_to_position(slide, block, left_x, left_y, column_width)\n            left_y += height + Inches(0.2)  # Add spacing\n        \n        # Create right column\n        right_x = left_margin + column_width + Inches(0.5)\n        right_y = top_margin\n        \n        for block in right_blocks:\n            height = self._add_block_to_position(slide, block, right_x, right_y, column_width)\n            right_y += height + Inches(0.2)  # Add spacing\n    \n    def _create_comparison_layout(self, slide, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create a comparison layout slide\n        \n        Args:\n            slide: PowerPoint slide\n            slide_data: Slide data\n        \"\"\"\n        # This is similar to two-column layout but with a different visual styling\n        # and typically contains comparison elements (vs. vs.)\n        \n        # Get comparison title if it exists\n        comparison_title = slide_data.get(\"comparison_title\", \"\")\n        \n        if comparison_title:\n            # Add comparison title at the top\n            title_shape = slide.shapes.add_textbox(\n                Inches(1), Inches(1.5), Inches(8), Inches(0.5)\n            )\n            title_shape.text_frame.text = comparison_title\n            self._apply_text_formatting(title_shape.text_frame, self.theme[\"fonts\"][\"heading\"])\n        \n        # Then create the two-column layout\n        self._create_two_column_layout(slide, slide_data)\n    \n    def _create_image_with_caption(self, slide, slide_data: Dict[str, Any]) -> None:\n        \"\"\"Create an image with caption slide\n        \n        Args:\n            slide: PowerPoint slide\n            slide_data: Slide data\n        \"\"\"\n        # Get image block\n        image_block = None\n        for block in slide_data.get(\"blocks\", []):\n            if block.get(\"type\", \"\").lower() == \"image\":\n                image_block = block\n                break\n        \n        if not image_block:\n            logger.warning(\"No image block found for IMAGE_WITH_CAPTION layout\")\n            return\n        \n        # Get caption\n        caption = image_block.get(\"caption\", \"\")\n        \n        # Add image\n        self._add_image(slide, image_block, position_y=Inches(2))\n        \n        # Add caption below image\n        if caption:\n            caption_shape = slide.shapes.add_textbox(\n                Inches(1), Inches(5.5), Inches(8), Inches(0.5)\n            )\n            caption_shape.text_frame.text = caption\n            self._apply_text_formatting(caption_shape.text_frame, self.theme[\"fonts\"][\"body\"])\n            \n            # Center align caption\n            for paragraph in caption_shape.text_frame.paragraphs:\n                paragraph.alignment = PP_ALIGN.CENTER\n    \n    def _add_block_to_position(self, slide, block: Dict[str, Any], x: Any, y: Any, width: Any) -> float:\n        \"\"\"Add a content block at a specific position\n        \n        Args:\n            slide: PowerPoint slide\n            block: Content block\n            x: X-coordinate\n            y: Y-coordinate\n            width: Width\n            \n        Returns:\n            Height of the added block\n        \"\"\"\n        block_type = block.get(\"type\", \"text\").lower()\n        \n        if block_type == \"text\":\n            height = Inches(0.5 + (len(block.get(\"content\", \"\")) / 100))  # Estimate height\n            textbox = slide.shapes.add_textbox(x, y, width, height)\n            tf = textbox.text_frame\n            p = tf.add_paragraph()\n            p.text = block.get(\"content\", \"\")\n            self._apply_text_formatting(tf, self.theme[\"fonts\"][\"body\"], block.get(\"format\", {}))\n            return height\n            \n        elif block_type == \"bullets\":\n            height = Inches(0.3 * len(block.get(\"items\", [])))  # Estimate height\n            textbox = slide.shapes.add_textbox(x, y, width, height)\n            tf = textbox.text_frame\n            self._add_bullet_list(tf, block.get(\"items\", []))\n            return height\n            \n        elif block_type == \"image\":\n            img_width = Inches(block.get(\"width\", 4) if block.get(\"width\") else 4)\n            img_height = Inches(block.get(\"height\", 3) if block.get(\"height\") else 3)\n            \n            # Center image within the column\n            img_x = x + (width - img_width) / 2 if img_width < width else x\n            \n            self._add_image(slide, block, img_x, y, img_width, img_height)\n            return img_height\n            \n        elif block_type == \"chart\":\n            height = Inches(3)  # Default chart height\n            self._add_chart(slide, block, x, y, width, height)\n            return height\n            \n        elif block_type == \"table\":\n            rows = len(block.get(\"rows\", [])) + 1  # +1 for header\n            height = Inches(0.4 * rows)\n            self._add_table(slide, block, x, y, width, height)\n            return height\n            \n        elif block_type == \"quote\":\n            height = Inches(1.5)\n            self._add_quote(slide, block, x, y, width, height)\n            return height\n            \n        return Inches(0.5)  # Default height if no block type matched\n    \n    def _add_bullet_list(self, text_frame, items: List[Dict[str, Any]]) -> None:\n        \"\"\"Add a bullet list to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            items: List of bullet items\n        \"\"\"\n        for item in items:\n            p = text_frame.add_paragraph()\n            p.text = item.get(\"content\", \"\")\n            p.level = item.get(\"level\", 0)  # Indent level\n            p.bullet = True\n            \n            # Apply formatting\n            item_format = item.get(\"format\", {})\n            font = p.font\n            \n            if \"bold\" in item_format and item_format[\"bold\"]:\n                font.bold = True\n            if \"italic\" in item_format and item_format[\"italic\"]:\n                font.italic = True\n            if \"size\" in item_format:\n                font.size = Pt(item_format[\"size\"])\n            if \"color\" in item_format:\n                font.color.rgb = self._parse_color(item_format[\"color\"])\n            \n            # Process sub-bullets\n            for sub_item in item.get(\"sub_bullets\", []):\n                p = text_frame.add_paragraph()\n                p.text = sub_item.get(\"content\", \"\")\n                p.level = sub_item.get(\"level\", 1)  # Default to level 1 for sub-bullets\n                p.bullet = True\n                \n                # Apply formatting to sub-bullets\n                sub_format = sub_item.get(\"format\", {})\n                sub_font = p.font\n                \n                if \"bold\" in sub_format and sub_format[\"bold\"]:\n                    sub_font.bold = True\n                if \"italic\" in sub_format and sub_format[\"italic\"]:\n                    sub_font.italic = True\n                if \"size\" in sub_format:\n                    sub_font.size = Pt(sub_format[\"size\"])\n                if \"color\" in sub_format:\n                    sub_font.color.rgb = self._parse_color(sub_format[\"color\"])\n    \n    def _add_image(self, slide, block: Dict[str, Any], position_x=None, position_y=None, \n                  width=None, height=None) -> None:\n        \"\"\"Add an image to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Image block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        import requests\n        from io import BytesIO\n        \n        # Get image source\n        img_src = block.get(\"source\", \"\")\n        if not img_src:\n            logger.warning(\"No image source specified\")\n            return\n        \n        # Get image data\n        try:\n            if img_src.startswith((\"http://\", \"https://\")):\n                # Download from URL\n                response = requests.get(img_src)\n                response.raise_for_status()\n                img_data = BytesIO(response.content)\n            elif os.path.exists(img_src):\n                # Local file\n                img_data = img_src\n            else:\n                logger.error(f\"Image not found: {img_src}\")\n                return\n        except Exception as e:\n            logger.error(f\"Error loading image {img_src}: {e}\")\n            return\n        \n        # Get dimensions\n        img_width = width or Inches(block.get(\"width\", 5) if block.get(\"width\") else 5)\n        img_height = height or Inches(block.get(\"height\", 3) if block.get(\"height\") else 3)\n        \n        # Get position\n        position = block.get(\"position\", {})\n        h_align = position.get(\"horizontal\", Position.CENTER)\n        v_align = position.get(\"vertical\", Position.MIDDLE)\n        \n        # Calculate position if not provided\n        if position_x is None or position_y is None:\n            slide_width = Inches(10)\n            slide_height = Inches(7.5)\n            \n            # Calculate X position\n            if position_x is None:\n                if h_align == Position.LEFT:\n                    position_x = Inches(self.theme[\"slide_margins\"][\"left\"])\n                elif h_align == Position.RIGHT:\n                    position_x = slide_width - Inches(self.theme[\"slide_margins\"][\"right\"]) - img_width\n                else:  # CENTER\n                    position_x = (slide_width - img_width) / 2\n            \n            # Calculate Y position\n            if position_y is None:\n                if v_align == Position.TOP:\n                    position_y = Inches(self.theme[\"slide_margins\"][\"top\"] + 1)  # Below title\n                elif v_align == Position.BOTTOM:\n                    position_y = slide_height - Inches(self.theme[\"slide_margins\"][\"bottom\"]) - img_height\n                else:  # MIDDLE\n                    position_y = (slide_height - img_height) / 2\n        \n        # Add image to slide\n        try:\n            slide.shapes.add_picture(img_data, position_x, position_y, img_width, img_height)\n        except Exception as e:\n            logger.error(f\"Error adding image to slide: {e}\")\n    \n    def _add_table(self, slide, block: Dict[str, Any], position_x=None, position_y=None,\n                 width=None, height=None) -> None:\n        \"\"\"Add a table to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Table block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        # Get table data\n        headers = block.get(\"headers\", [])\n        rows = block.get(\"rows\", [])\n        \n        if not headers or not rows:\n            logger.warning(\"Table has no headers or rows\")\n            return\n        \n        # Calculate dimensions\n        table_width = width or Inches(8)\n        row_count = len(rows) + 1  # +1 for header row\n        col_count = len(headers)\n        \n        # Get position\n        if position_x is None:\n            position_x = Inches(1)\n        if position_y is None:\n            position_y = Inches(2)\n        \n        # Add table to slide\n        table = slide.shapes.add_table(row_count, col_count, position_x, position_y, table_width, height).table\n        \n        # Add headers\n        for i, header in enumerate(headers):\n            cell = table.cell(0, i)\n            cell.text = header\n            \n            # Format header\n            for paragraph in cell.text_frame.paragraphs:\n                for run in paragraph.runs:\n                    run.font.bold = True\n                    run.font.size = Pt(14)\n        \n        # Add rows\n        for i, row_data in enumerate(rows):\n            for j, cell_text in enumerate(row_data):\n                if j < col_count:  # Ensure we don't exceed column count\n                    cell = table.cell(i + 1, j)  # +1 to skip header row\n                    cell.text = cell_text\n                    \n                    # Format cell\n                    for paragraph in cell.text_frame.paragraphs:\n                        for run in paragraph.runs:\n                            run.font.size = Pt(12)\n    \n    def _add_chart(self, slide, block: Dict[str, Any], position_x=None, position_y=None,\n                 width=None, height=None) -> None:\n        \"\"\"Add a chart to a slide (placeholder implementation)\n        \n        Args:\n            slide: PowerPoint slide\n            block: Chart block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        # NOTE: This is a placeholder. Actual chart implementation would require\n        # more complex integration with python-pptx charts\n        \n        # Create a text box with chart information instead\n        chart_type = block.get(\"chart_type\", \"Unknown\")\n        chart_title = block.get(\"title\", \"Chart\")\n        \n        if position_x is None:\n            position_x = Inches(1)\n        if position_y is None:\n            position_y = Inches(2)\n        \n        chart_width = width or Inches(8)\n        chart_height = height or Inches(3)\n        \n        # Add a placeholder text box\n        shape = slide.shapes.add_textbox(position_x, position_y, chart_width, chart_height)\n        tf = shape.text_frame\n        \n        p = tf.add_paragraph()\n        p.text = f\"[{chart_type.upper()} CHART: {chart_title}]\"\n        p.alignment = PP_ALIGN.CENTER\n        \n        # Center the text vertically\n        tf.vertical_anchor = MSO_VERTICAL_ANCHOR.MIDDLE\n        \n        # Format text\n        for paragraph in tf.paragraphs:\n            for run in paragraph.runs:\n                run.font.size = Pt(18)\n                run.font.bold = True\n                run.font.color.rgb = self._parse_color(self.theme[\"colors\"][\"secondary\"])\n    \n    def _add_quote(self, slide, block: Dict[str, Any], position_x=None, position_y=None,\n                 width=None, height=None) -> None:\n        \"\"\"Add a quote to a slide\n        \n        Args:\n            slide: PowerPoint slide\n            block: Quote block\n            position_x: X-coordinate (optional)\n            position_y: Y-coordinate (optional)\n            width: Width (optional)\n            height: Height (optional)\n        \"\"\"\n        # Get quote data\n        quote_text = block.get(\"quote\", \"\")\n        attribution = block.get(\"attribution\", \"\")\n        \n        if not quote_text:\n            logger.warning(\"Quote has no text\")\n            return\n        \n        # Get position\n        if position_x is None:\n            position_x = Inches(1)\n        if position_y is None:\n            position_y = Inches(2.5)\n        \n        quote_width = width or Inches(8)\n        quote_height = height or Inches(2)\n        \n        # Add quote\n        shape = slide.shapes.add_textbox(position_x, position_y, quote_width, quote_height)\n        tf = shape.text_frame\n        \n        # Add quote text\n        p = tf.add_paragraph()\n        p.text = f'\"{quote_text}\"'\n        p.alignment = PP_ALIGN.CENTER\n        \n        # Format quote\n        for run in p.runs:\n            run.font.italic = True\n            run.font.size = Pt(24)\n            run.font.bold = True\n            run.font.color.rgb = self._parse_color(self.theme[\"colors\"][\"primary\"])\n        \n        # Add attribution if provided\n        if attribution:\n            p = tf.add_paragraph()\n            p.text = f\"— {attribution}\"\n            p.alignment = PP_ALIGN.CENTER\n            \n            # Format attribution\n            for run in p.runs:\n                run.font.italic = True\n                run.font.size = Pt(18)\n    \n    def _set_background(self, slide, background: str) -> None:\n        \"\"\"Set slide background\n        \n        Args:\n            slide: PowerPoint slide\n            background: Background color or image path\n        \"\"\"\n        if not background:\n            return\n            \n        # Check if it's a color\n        if background.startswith(\"#\") or background in [\"white\", \"black\", \"blue\", \"red\", \"green\"]:\n            fill = slide.background.fill\n            fill.solid()\n            fill.fore_color.rgb = self._parse_color(background)\n        \n        # Check if it's an image path\n        elif os.path.exists(background) or background.startswith((\"http://\", \"https://\")):\n            # This would require more complex handling to set a background image\n            logger.warning(\"Background images not fully implemented yet\")\n    \n    def _apply_text_formatting(self, text_frame, font_settings: Dict[str, Any], \n                             extra_format: Dict[str, Any] = None) -> None:\n        \"\"\"Apply text formatting to a text frame\n        \n        Args:\n            text_frame: PowerPoint text frame\n            font_settings: Font settings from theme\n            extra_format: Additional formatting to apply\n        \"\"\"\n        # Combine theme settings with extra formatting\n        format_settings = font_settings.copy()\n        if extra_format:\n            format_settings.update(extra_format)\n        \n        # Apply to all paragraphs and runs\n        for paragraph in text_frame.paragraphs:\n            for run in paragraph.runs:\n                if \"name\" in format_settings:\n                    run.font.name = format_settings[\"name\"]\n                \n                if \"size\" in format_settings:\n                    run.font.size = Pt(format_settings[\"size\"])\n                \n                if \"bold\" in format_settings:\n                    run.font.bold = format_settings[\"bold\"]\n                \n                if \"italic\" in format_settings:\n                    run.font.italic = format_settings[\"italic\"]\n                \n                if \"color\" in format_settings:\n                    run.font.color.rgb = self._parse_color(format_settings[\"color\"])\n    \n    def _parse_color(self, color_str: str) -> RGBColor:\n        \"\"\"Parse a color string into an RGBColor object\n        \n        Args:\n            color_str: Color string (hex, theme key, or color name)\n            \n        Returns:\n            RGBColor object\n        \"\"\"\n        # Check if it's a theme color\n        if color_str in self.theme[\"colors\"]:\n            color_str = self.theme[\"colors\"][color_str]\n        \n        # Handle hex colors\n        if color_str.startswith(\"#\"):\n            color_str = color_str[1:]  # Remove # prefix\n        \n        # Try to parse as hex\n        try:\n            if len(color_str) == 6:\n                r = int(color_str[0:2], 16)\n                g = int(color_str[2:4], 16)\n                b = int(color_str[4:6], 16)\n                return RGBColor(r, g, b)\n        except ValueError:\n            pass\n        \n        # Handle color names\n        color_map = {\n            \"black\": RGBColor(0, 0, 0),\n            \"white\": RGBColor(255, 255, 255),\n            \"red\": RGBColor(255, 0, 0),\n            \"green\": RGBColor(0, 128, 0),\n            \"blue\": RGBColor(0, 0, 255),\n            \"yellow\": RGBColor(255, 255, 0),\n            \"purple\": RGBColor(128, 0, 128),\n            \"orange\": RGBColor(255, 165, 0),\n            \"gray\": RGBColor(128, 128, 128)\n        }\n        \n        return color_map.get(color_str.lower(), RGBColor(0, 0, 0))  # Default to black\n```\n\n## 2. Google Slides API Integration\n\nNow let's add direct Google Slides API support:\n\n```python\n# makeslides/renderers/google_slides_renderer.py\nimport os\nimport json\nimport tempfile\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional, List\nfrom googleapiclient.discovery import build\nfrom google.oauth2.credentials import Credentials\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\n\nlogger = logging.getLogger(__name__)\n\n# Define Google Slides API scopes\nSCOPES = ['https://www.googleapis.com/auth/presentations',\n          'https://www.googleapis.com/auth/drive']\n\nclass GoogleSlidesRenderer:\n    \"\"\"Renders presentations directly to Google Slides using the API\"\"\"\n    \n    def __init__(self, credentials_path: Optional[str] = None, token_path: Optional[str] = None):\n        \"\"\"Initialize the Google Slides renderer\n        \n        Args:\n            credentials_path: Path to the credentials.json file\n            token_path: Path to store/load the token.json file\n        \"\"\"\n        self.credentials_path = credentials_path or os.path.join(\n            os.path.expanduser(\"~\"), \".makeslides\", \"credentials.json\"\n        )\n        self.token_path = token_path or os.path.join(\n            os.path.expanduser(\"~\"), \".makeslides\", \"token.json\"\n        )\n        \n        # Ensure the token directory exists\n        os.makedirs(os.path.dirname(self.token_path), exist_ok=True)\n        \n        self.slides_service = None\n        self.drive_service = None\n    \n    def _initialize_services(self) -> bool:\n        \"\"\"Initialize the Google Slides and Drive services\n        \n        Returns:\n            Success status\n        \"\"\"\n        try:\n            creds = None\n            \n            # Check if token file exists\n            if os.path.exists(self.token_path):\n                creds = Credentials.from_authorized_user_info(\n                    json.loads(Path(self.token_path).read_text()), SCOPES\n                )\n            \n            # If credentials don't exist or are invalid, refresh or get new ones\n            if not creds or not creds.valid:\n                if creds and creds.expired and creds.refresh_token:\n                    creds.refresh(Request())\n                else:\n                    if not os.path.exists(self.credentials_path):\n                        logger.error(f\"Credentials file not found: {self.credentials_path}\")\n                        return False\n                    \n                    flow = InstalledAppFlow.from_client_secrets_file(\n                        self.credentials_path, SCOPES\n                    )\n                    creds = flow.run_local_server(port=0)\n                \n                # Save the credentials for the next run\n                with open(self.token_path, 'w') as token:\n                    token.write(creds.to_json())\n            \n            # Build services\n            self.slides_service = build('slides', 'v1', credentials=creds)\n            self.drive_service = build('drive', 'v3', credentials=creds)\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Error initializing Google services: {e}\")\n            return False\n    \n    def render(self, presentation_data: Dict[str, Any], output_path: Optional[str] = None) -> Optional[str]:\n        \"\"\"Render a presentation to Google Slides\n        \n        Args:\n            presentation_data: Presentation data structure\n            output_path: Path to save the presentation ID/URL (optional)\n            \n        Returns:\n            Google Slides URL or None on error\n        \"\"\"\n        # Initialize services\n        if not self._initialize_services():\n            return None\n        \n        try:\n            # Create a new presentation\n            title = presentation_data.get(\"title\", \"Generated Presentation\")\n            presentation = self.slides_service.presentations().create(\n                body={\"title\": title}\n            ).execute()\n            \n            presentation_id = presentation.get('presentationId')\n            logger.info(f\"Created new presentation with ID: {presentation_id}\")\n            \n            # Process slides\n            requests = []\n            \n            # Delete the default slide\n            default_slide_ids = self._get_existing_slide_ids(presentation_id)\n            for slide_id in default_slide_ids:\n                requests.append({\n                    'deleteObject': {\n                        'objectId': slide_id\n                    }\n                })\n            \n            # Add slides\n            for slide_data in presentation_data.get(\"slides\", []):\n                slide_requests = self._create_slide_requests(slide_data)\n                requests.extend(slide_requests)\n            \n            # Execute all requests\n            if requests:\n                self.slides_service.presentations().batchUpdate(\n                    presentationId=presentation_id,\n                    body={'requests': requests}\n                ).execute()\n            \n            # Get presentation URL\n            presentation_url = f\"https://docs.google.com/presentation/d/{presentation_id}/edit\"\n            \n            # Save URL to output file if specified\n            if output_path:\n                with open(output_path, 'w') as f:\n                    f.write(presentation_url)\n            \n            logger.info(f\"Presentation created at: {presentation_url}\")\n            return presentation_url\n            \n        except Exception as e:\n            logger.error(f\"Error creating Google Slides presentation: {e}\")\n            return None\n    \n    def upload_pptx(self, pptx_path: str) -> Optional[str]:\n        \"\"\"Upload a PPTX file to Google Slides\n        \n        Args:\n            pptx_path: Path to the PPTX file\n            \n        Returns:\n            Google Slides URL or None on error\n        \"\"\"\n        # Initialize services\n        if not self._initialize_services():\n            return None\n        \n        try:\n            # Upload the file to Google Drive first\n            file_metadata = {\n                'name': os.path.basename(pptx_path),\n                'mimeType': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            }\n            \n            media = MediaFileUpload(\n                pptx_path,\n                mimetype='application/vnd.openxmlformats-officedocument.presentationml.presentation',\n                resumable=True\n            )\n            \n            file = self.drive_service.files().create(\n                body=file_metadata,\n                media_body=media,\n                fields='id'\n            ).execute()\n            \n            file_id = file.get('id')\n            logger.info(f\"Uploaded PPTX to Drive with ID: {file_id}\")\n            \n            # Import to Google Slides\n            drive_data = self.drive_service.files().get(fileId=file_id).execute()\n            presentation_id = drive_data.get('id')\n            \n            # Get presentation URL\n            presentation_url = f\"https://docs.google.com/presentation/d/{presentation_id}/edit\"\n            \n            logger.info(f\"PPTX imported to Google Slides at: {presentation_url}\")\n            return presentation_url\n            \n        except Exception as e:\n            logger.error(f\"Error uploading PPTX to Google Slides: {e}\")\n            return None\n    \n    def _get_existing_slide_ids(self, presentation_id: str) -> List[str]:\n        \"\"\"Get the IDs of existing slides in a presentation\n        \n        Args:\n            presentation_id: Presentation ID\n            \n        Returns:\n            List of slide IDs\n        \"\"\"\n        presentation = self.slides_service.presentations().get(\n            presentationId=presentation_id\n        ).execute()\n        \n        slide_ids = []\n        for slide in presentation.get('slides', []):\n            slide_ids.append(slide.get('objectId'))\n        \n        return slide_ids\n    \n    def _create_slide_requests(self, slide_data: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Create Google Slides API requests for a slide\n        \n        Args:\n            slide_data: Slide data\n            \n        Returns:\n            List of Google Slides API requests\n        \"\"\"\n        requests = []\n        \n        # Generate a unique slide ID\n        slide_id = f\"slide_{id(slide_data)}\"\n        \n        # Determine layout based on slide type\n        layout = slide_data.get(\"layout\", \"TITLE_AND_CONTENT\")\n        layout_mapping = {\n            \"TITLE_ONLY\": \"TITLE\",\n            \"TITLE_AND_CONTENT\": \"TITLE_AND_BODY\",\n            \"SECTION_HEADER\": \"SECTION_HEADER\",\n            \"TWO_COLUMNS\": \"TWO_COLUMNS\",\n            \"COMPARISON\": \"COMPARISON\",\n            \"BIG_NUMBER\": \"BIG_NUMBER\",\n            \"QUOTE\": \"QUOTE\",\n            \"IMAGE_ONLY\": \"BLANK\",\n            \"IMAGE_WITH_CAPTION\": \"CAPTION_ONLY\",\n            \"BLANK\": \"BLANK\"\n        }\n        \n        predefined_layout = layout_mapping.get(layout, \"TITLE_AND_BODY\")\n        \n        # Create a new slide\n        requests.append({\n            'createSlide': {\n                'objectId': slide_id,\n                'slideLayoutReference': {\n                    'predefinedLayout': predefined_layout\n                }\n            }\n        })\n        \n        # Add title\n        if \"title\" in slide_data:\n            title_id = f\"{slide_id}_title\"\n            requests.append({\n                'createShape': {\n                    'objectId': title_id,\n                    'shapeType': 'TEXT_BOX',\n                    'elementProperties': {\n                        'pageObjectId': slide_id,\n                        'size': {\n                            'width': {'magnitude': 540, 'unit': 'PT'},\n                            'height': {'magnitude': 50, 'unit': 'PT'}\n                        },\n                        'transform': {\n                            'scaleX': 1,\n                            'scaleY': 1,\n                            'translateX': 40,\n                            'translateY': 20,\n                            'unit': 'PT'\n                        }\n                    }\n                }\n            })\n            \n            requests.append({\n                'insertText': {\n                    'objectId': title_id,\n                    'text': slide_data[\"title\"]\n                }\n            })\n            \n            # Format title text\n            requests.append({\n                'updateTextStyle': {\n                    'objectId': title_id,\n                    'style': {\n                        'bold': True,\n                        'fontSize': {\n                            'magnitude': 28,\n                            'unit': 'PT'\n                        }\n                    },\n                    'fields': 'bold,fontSize'\n                }\n            })\n        \n        # Process content blocks\n        blocks = slide_data.get(\"blocks\", [])\n        \n        if layout == \"TWO_COLUMNS\":\n            # Special handling for two-column layout\n            left_blocks = []\n            right_blocks = []\n            \n            # Separate blocks into left and right columns\n            for i, block in enumerate(blocks):\n                if \"column\" in block and block[\"column\"] == \"right\":\n                    right_blocks.append(block)\n                elif \"column\" in block and block[\"column\"] == \"left\":\n                    left_blocks.append(block)\n                elif i % 2 == 0:\n                    left_blocks.append(block)\n                else:\n                    right_blocks.append(block)\n            \n            # Create left column\n            if left_blocks:\n                left_id = f\"{slide_id}_left\"\n                requests.append({\n                    'createShape': {\n                        'objectId': left_id,\n                        'shapeType': 'TEXT_BOX',\n                        'elementProperties': {\n                            'pageObjectId': slide_id,\n                            'size': {\n                                'width': {'magnitude': 260, 'unit': 'PT'},\n                                'height': {'magnitude': 300, 'unit': 'PT'}\n                            },\n                            'transform': {\n                                'scaleX': 1,\n                                'scaleY': 1,\n                                'translateX': 40,\n                                'translateY': 100,\n                                'unit': 'PT'\n                            }\n                        }\n                    }\n                })\n                \n                # Insert content for left column\n                left_content = self._blocks_to_text(left_blocks)\n                requests.append({\n                    'insertText': {\n                        'objectId': left_id,\n                        'text': left_content\n                    }\n                })\n            \n            # Create right column\n            if right_blocks:\n                right_id = f\"{slide_id}_right\"\n                requests.append({\n                    'createShape': {\n                        'objectId': right_id,\n                        'shapeType': 'TEXT_BOX',\n                        'elementProperties': {\n                            'pageObjectId': slide_id,\n                            'size': {\n                                'width': {'magnitude': 260, 'unit': 'PT'},\n                                'height': {'magnitude': 300, 'unit': 'PT'}\n                            },\n                            'transform': {\n                                'scaleX': 1,\n                                'scaleY': 1,\n                                'translateX': 320,\n                                'translateY': 100,\n                                'unit': 'PT'\n                            }\n                        }\n                    }\n                })\n                \n                # Insert content for right column\n                right_content = self._blocks_to_text(right_blocks)\n                requests.append({\n                    'insertText': {\n                        'objectId': right_id,\n                        'text': right_content\n                    }\n                })\n        else:\n            # Standard layouts - create a single content box\n            if blocks:\n                content_id = f\"{slide_id}_content\"\n                requests.append({\n                    'createShape': {\n                        'objectId': content_id,\n                        'shapeType': 'TEXT_BOX',\n                        'elementProperties': {\n                            'pageObjectId': slide_id,\n                            'size': {\n                                'width': {'magnitude': 540, 'unit': 'PT'},\n                                'height': {'magnitude': 300, 'unit': 'PT'}\n                            },\n                            'transform': {\n                                'scaleX': 1,\n                                'scaleY': 1,\n                                'translateX': 40,\n                                'translateY': 100,\n                                'unit': 'PT'\n                            }\n                        }\n                    }\n                })\n                \n                # Insert content\n                content_text = self._blocks_to_text(blocks)\n                requests.append({\n                    'insertText': {\n                        'objectId': content_id,\n                        'text': content_text\n                    }\n                })\n                \n                # Add images\n                for block in blocks:\n                    if block.get(\"type\") == \"image\":\n                        image_requests = self._create_image_requests(slide_id, block)\n                        requests.extend(image_requests)\n        \n        # Add speaker notes if available\n        if \"notes\" in slide_data and slide_data[\"notes\"]:\n            requests.append({\n                'createParagraphBullets': {\n                    'objectId': slide_id,\n                    'textRange': {\n                        'type': 'FIXED_RANGE',\n                        'startIndex': 0,\n                        'endIndex': 1\n                    },\n                    'bulletPreset': 'BULLET_DISC_CIRCLE_SQUARE'\n                }\n            })\n            \n            requests.append({\n                'insertText': {\n                    'objectId': slide_id,\n                    'speakerNotesObjectId': f\"{slide_id}_notes\",\n                    'text': slide_data[\"notes\"]\n                }\n            })\n        \n        return requests\n    \n    def _blocks_to_text(self, blocks: List[Dict[str, Any]]) -> str:\n        \"\"\"Convert content blocks to text\n        \n        Args:\n            blocks: List of content blocks\n            \n        Returns:\n            Text representation\n        \"\"\"\n        text = \"\"\n        \n        for block in blocks:\n            block_type = block.get(\"type\", \"text\").lower()\n            \n            if block_type == \"text\":\n                text += block.get(\"content\", \"\") + \"\\n\\n\"\n                \n            elif block_type == \"bullets\":\n                for item in block.get(\"items\", []):\n                    text += \"• \" + item.get(\"content\", \"\") + \"\\n\"\n                    \n                    # Add sub-bullets\n                    for sub_item in item.get(\"sub_bullets\", []):\n                        text += \"  - \" + sub_item.get(\"content\", \"\") + \"\\n\"\n                \n                text += \"\\n\"\n                \n            elif block_type == \"quote\":\n                text += f'\"{block.get(\"quote\", \"\")}\"'\n                \n                if \"attribution\" in block:\n                    text += f'\\n— {block.get(\"attribution\")}'\n                \n                text += \"\\n\\n\"\n                \n            elif block_type == \"table\":\n                # Add table headers\n                headers = block.get(\"headers\", [])\n                if headers:\n                    text += \" | \".join(headers) + \"\\n\"\n                    text += \"-\" * (len(\" | \".join(headers))) + \"\\n\"\n                \n                # Add table rows\n                for row in block.get(\"rows\", []):\n                    text += \" | \".join(row) + \"\\n\"\n                \n                text += \"\\n\"\n        \n        return text\n    \n    def _create_image_requests(self, slide_id: str, block: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Create requests to add an image to a slide\n        \n        Args:\n            slide_id: Slide ID\n            block: Image block\n            \n        Returns:\n            List of Google Slides API requests\n        \"\"\"\n        requests = []\n        \n        # Get image source\n        img_src = block.get(\"source\", \"\")\n        if not img_src:\n            return requests\n        \n        # Images must have a URL for Google Slides API\n        if not img_src.startswith((\"http://\", \"https://\")):\n            logger.warning(f\"Google Slides API requires image URLs, skipping local image: {img_src}\")\n            return requests\n        \n        # Generate image ID\n        image_id = f\"{slide_id}_image_{id(block)}\"\n        \n        # Get image position\n        position = block.get(\"position\", {})\n        h_align = position.get(\"horizontal\", \"CENTER\")\n        \n        # Calculate position\n        transform = {\n            'scaleX': 1,\n            'scaleY': 1,\n            'unit': 'PT'\n        }\n        \n        if h_align == \"LEFT\":\n            transform['translateX'] = 40\n        elif h_align == \"RIGHT\":\n            transform['translateX'] = 400\n        else:  # CENTER\n            transform['translateX'] = 220\n        \n        # Y position is below title by default\n        transform['translateY'] = 150\n        \n        # Create image element\n        requests.append({\n            'createImage': {\n                'objectId': image_id,\n                'url': img_src,\n                'elementProperties': {\n                    'pageObjectId': slide_id,\n                    'size': {\n                        'width': {'magnitude': 300, 'unit': 'PT'},\n                        'height': {'magnitude': 200, 'unit': 'PT'}\n                    },\n                    'transform': transform\n                }\n            }\n        })\n        \n        return requests\n```\n\n## 3. Factory Pattern for Renderer Selection\n\nLet's create a factory to choose between renderers:\n\n```python\n# makeslides/renderers/factory.py\nfrom typing import Dict, Any, Optional\nimport logging\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\ndef create_renderer(output_format: str = \"pptx\", **kwargs) -> Any:\n    \"\"\"Create and return the appropriate renderer\n    \n    Args:\n        output_format: Format to render to (\"pptx\" or \"google_slides\")\n        **kwargs: Additional options for the renderer\n        \n    Returns:\n        Renderer instance\n    \"\"\"\n    if output_format.lower() == \"pptx\":\n        from .pptx_renderer import PptxRenderer\n        return PptxRenderer(\n            template_path=kwargs.get(\"template_path\"),\n            theme=kwargs.get(\"theme\")\n        )\n    \n    elif output_format.lower() in [\"google_slides\", \"google\", \"slides\"]:\n        from .google_slides_renderer import GoogleSlidesRenderer\n        return GoogleSlidesRenderer(\n            credentials_path=kwargs.get(\"credentials_path\"),\n            token_path=kwargs.get(\"token_path\")\n        )\n    \n    else:\n        logger.error(f\"Unsupported output format: {output_format}\")\n        raise ValueError(f\"Unsupported output format: {output_format}\")\n```\n\n## 4. Visual Review with LLM\n\nLet's add the capability to visually review slides using Claude:\n\n```python\n# makeslides/review/visual_reviewer.py\nimport os\nimport tempfile\nimport base64\nimport logging\nimport anthropic\nfrom typing import Dict, Any, List\nfrom pathlib import Path\nimport subprocess\nfrom io import BytesIO\nfrom PIL import Image\n\nlogger = logging.getLogger(__name__)\n\nclass VisualReviewer:\n    \"\"\"Reviews presentation visuals using Claude's vision capabilities\"\"\"\n    \n    def __init__(self, api_key: Optional[str] = None):\n        \"\"\"Initialize the visual reviewer\n        \n        Args:\n            api_key: Anthropic API key (optional, defaults to env var)\n        \"\"\"\n        self.api_key = api_key or os.environ.get(\"ANTHROPIC_API_KEY\")\n        if not self.api_key:\n            raise ValueError(\"Anthropic API key not provided and ANTHROPIC_API_KEY environment variable not set\")\n        \n        self.client = anthropic.Anthropic(api_key=self.api_key)\n    \n    def review_pptx(self, pptx_path: str) -> Dict[str, Any]:\n        \"\"\"Review a PowerPoint presentation\n        \n        Args:\n            pptx_path: Path to PPTX file\n            \n        Returns:\n            Review results\n        \"\"\"\n        # Extract slides as images\n        slide_images = self._extract_slides_from_pptx(pptx_path)\n        \n        if not slide_images:\n            logger.error(\"Failed to extract slides from PowerPoint\")\n            return {\"success\": False, \"error\": \"Failed to extract slides\"}\n        \n        # Review each slide\n        review_results = []\n        \n        for i, image_data in enumerate(slide_images):\n            try:\n                # Review individual slide\n                slide_review = self._review_single_slide(image_data, slide_number=i+1)\n                review_results.append(slide_review)\n                \n            except Exception as e:\n                logger.error(f\"Error reviewing slide {i+1}: {e}\")\n                review_results.append({\n                    \"slide_number\": i+1,\n                    \"success\": False,\n                    \"error\": str(e)\n                })\n        \n        # Generate overall review\n        overall_review = self._generate_overall_review(review_results)\n        \n        return {\n            \"success\": True,\n            \"overall_review\": overall_review,\n            \"slide_reviews\": review_results\n        }\n    \n    def _extract_slides_from_pptx(self, pptx_path: str) -> List[bytes]:\n        \"\"\"Extract slides as images from a PowerPoint file\n        \n        Args:\n            pptx_path: Path to PPTX file\n            \n        Returns:\n            List of image data (bytes)\n        \"\"\"\n        slides = []\n        \n        try:\n            # Create a temporary directory to store slide images\n            with tempfile.TemporaryDirectory() as temp_dir:\n                # Use LibreOffice to convert PPTX to images\n                # Note: This requires LibreOffice to be installed\n                try:\n                    cmd = [\n                        \"libreoffice\", \"--headless\", \"--convert-to\", \"png\",\n                        \"--outdir\", temp_dir, pptx_path\n                    ]\n                    subprocess.run(cmd, check=True, capture_output=True)\n                except subprocess.CalledProcessError:\n                    logger.warning(\"LibreOffice conversion failed, trying alternative method\")\n                    \n                    # Alternative: Use python-pptx to extract slides\n                    # This is less accurate but doesn't require external dependencies\n                    from pptx import Presentation\n                    from pptx.enum.shapes import MSO_SHAPE_TYPE\n                    \n                    prs = Presentation(pptx_path)\n                    for i, slide in enumerate(prs.slides):\n                        # Create a blank image\n                        img = Image.new('RGB', (960, 540), (255, 255, 255))\n                        \n                        # Save the blank image with slide number\n                        img_path = os.path.join(temp_dir, f\"slide_{i+1:02d}.png\")\n                        img.save(img_path)\n                \n                # Read generated images\n                for file in sorted(os.listdir(temp_dir)):\n                    if file.endswith(\".png\"):\n                        file_path = os.path.join(temp_dir, file)\n                        with open(file_path, \"rb\") as f:\n                            slides.append(f.read())\n        \n        except Exception as e:\n            logger.error(f\"Error extracting slides: {e}\")\n        \n        return slides\n    \n    def _review_single_slide(self, image_data: bytes, slide_number: int) -> Dict[str, Any]:\n        \"\"\"Review a single slide\n        \n        Args:\n            image_data: Slide image data\n            slide_number: Slide number\n            \n        Returns:\n            Review result\n        \"\"\"\n        # Convert image to base64\n        base64_image = base64.b64encode(image_data).decode(\"utf-8\")\n        \n        # Prepare message for Claude\n        messages = [\n            {\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"image\",\n                        \"source\": {\n                            \"type\": \"base64\",\n                            \"media_type\": \"image/png\",\n                            \"data\": base64_image\n                        }\n                    },\n                    {\n                        \"type\": \"text\",\n                        \"text\": f\"\"\"Please review this presentation slide (Slide {slide_number}) and provide feedback on:\n1. Visual design and layout\n2. Content clarity and organization\n3. Use of text (amount, size, readability)\n4. Use of visuals (images, diagrams, charts)\n5. Specific improvements that could be made\n\nFormat your response as a JSON object with the following keys:\n- rating: A score from 1-10 rating the overall slide quality\n- strengths: Array of 2-3 key strengths of the slide\n- weaknesses: Array of 2-3 areas that need improvement\n- recommendations: Array of 3-5 specific, actionable improvements\n\"\"\"\n                    }\n                ]\n            }\n        ]\n        \n        # Send request to Claude\n        response = self.client.messages.create(\n            model=\"claude-3-7-sonnet-20250219\",\n            max_tokens=1500,\n            system=\"You are a presentation design expert providing helpful and constructive feedback. Focus on specific, actionable advice. Return valid JSON only, with no surrounding explanation.\",\n            messages=messages\n        )\n        \n        # Parse response\n        response_text = response.content[0].text\n        \n        # Extract JSON from response\n        import re\n        import json\n        \n        json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n        json_match = re.search(json_pattern, response_text)\n        \n        if json_match:\n            review_json = json_match.group(1)\n        else:\n            review_json = response_text\n        \n        try:\n            review_data = json.loads(review_json)\n            review_data[\"slide_number\"] = slide_number\n            review_data[\"success\"] = True\n            return review_data\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse JSON from Claude response for slide {slide_number}\")\n            return {\n                \"slide_number\": slide_number,\n                \"success\": False,\n                \"error\": \"Failed to parse review data\",\n                \"raw_response\": response_text\n            }\n    \n    def _generate_overall_review(self, slide_reviews: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Generate an overall review of the presentation\n        \n        Args:\n            slide_reviews: List of individual slide reviews\n            \n        Returns:\n            Overall review\n        \"\"\"\n        # Prepare summary of slide reviews for Claude\n        successful_reviews = [r for r in slide_reviews if r.get(\"success\", False)]\n        \n        if not successful_reviews:\n            return {\n                \"overall_rating\": 0,\n                \"summary\": \"Unable to generate overall review due to failed slide reviews.\",\n                \"key_issues\": [],\n                \"key_strengths\": [],\n                \"recommendations\": []\n            }\n        \n        # Calculate average rating\n        ratings = [r.get(\"rating\", 0) for r in successful_reviews]\n        avg_rating = sum(ratings) / len(ratings) if ratings else 0\n        \n        # Collect all strengths and weaknesses\n        all_strengths = []\n        all_weaknesses = []\n        \n        for review in successful_reviews:\n            all_strengths.extend(review.get(\"strengths\", []))\n            all_weaknesses.extend(review.get(\"weaknesses\", []))\n        \n        # Identify common themes\n        from collections import Counter\n        \n        # Custom function to find similar items\n        def find_similar(items):\n            # Simple approach: group by common keywords\n            keywords = {}\n            for item in items:\n                words = set(w.lower() for w in item.split() if len(w) > 3)\n                for word in words:\n                    if word not in keywords:\n                        keywords[word] = []\n                    keywords[word].append(item)\n            \n            # Return groups with multiple items\n            return [group for group in keywords.values() if len(group) > 1]\n        \n        common_strengths = find_similar(all_strengths)\n        common_weaknesses = find_similar(all_weaknesses)\n        \n        # Generate overall recommendations\n        overall_recommendations = []\n        if common_weaknesses:\n            for group in common_weaknesses[:3]:  # Top 3 weakness groups\n                if group:\n                    overall_recommendations.append(f\"Improve {group[0].lower()}\")\n        \n        return {\n            \"overall_rating\": round(avg_rating, 1),\n            \"summary\": f\"Presentation has an average slide rating of {round(avg_rating, 1)}/10 across {len(successful_reviews)} slides.\",\n            \"key_issues\": [group[0] for group in common_weaknesses[:3] if group],\n            \"key_strengths\": [group[0] for group in common_strengths[:3] if group],\n            \"recommendations\": overall_recommendations\n        }\n```\n\n## 5. Main Controller Class\n\nNow, let's create a central controller that ties everything together:\n\n```python\n# makeslides/core/controller.py\nimport os\nimport logging\nimport json\nimport tempfile\nfrom typing import Dict, Any, Optional, Union, List\nfrom pathlib import Path\nimport anthropic\nfrom ..renderers.factory import create_renderer\nfrom ..review.visual_reviewer import VisualReviewer\n\nlogger = logging.getLogger(__name__)\n\nclass SlidesController:\n    \"\"\"Main controller for the slide generation process\"\"\"\n    \n    def __init__(self, config: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize the slides controller\n        \n        Args:\n            config: Configuration options\n        \"\"\"\n        self.config = config or {}\n        self.api_key = self.config.get(\"api_key\") or os.environ.get(\"ANTHROPIC_API_KEY\")\n        \n        if not self.api_key:\n            raise ValueError(\"Anthropic API key not provided and ANTHROPIC_API_KEY environment variable not set\")\n        \n        self.client = anthropic.Anthropic(api_key=self.api_key)\n    \n    def create_presentation(self, content: str, output_format: str = \"pptx\", \n                           output_path: Optional[str] = None, theme: Optional[Dict[str, Any]] = None,\n                           template_path: Optional[str] = None, review: bool = False) -> Dict[str, Any]:\n        \"\"\"Create a presentation from content\n        \n        Args:\n            content: Input content (markdown, text, etc.)\n            output_format: Output format (\"pptx\" or \"google_slides\")\n            output_path: Path to save output\n            theme: Theme configuration\n            template_path: Path to template file\n            review: Whether to review the presentation\n            \n        Returns:\n            Result information\n        \"\"\"\n        try:\n            # 1. Analyze content and create presentation structure\n            logger.info(\"Analyzing content and generating presentation structure...\")\n            presentation_data = self._analyze_content(content)\n            \n            if not presentation_data:\n                return {\"success\": False, \"error\": \"Failed to analyze content\"}\n            \n            # 2. Create renderer for requested format\n            renderer = create_renderer(\n                output_format=output_format,\n                template_path=template_path,\n                theme=theme\n            )\n            \n            # 3. Determine output path if not provided\n            if not output_path:\n                if output_format.lower() == \"pptx\":\n                    output_path = \"presentation.pptx\"\n                else:\n                    output_path = \"presentation.txt\"  # Will contain URL for Google Slides\n            \n            # 4. Render presentation\n            logger.info(f\"Rendering presentation to {output_format}...\")\n            result = renderer.render(presentation_data, output_path)\n            \n            if not result:\n                return {\"success\": False, \"error\": f\"Failed to render {output_format} presentation\"}\n            \n            # 5. Review presentation if requested\n            review_results = None\n            if review and output_format.lower() == \"pptx\":\n                logger.info(\"Reviewing presentation...\")\n                reviewer = VisualReviewer(api_key=self.api_key)\n                review_results = reviewer.review_pptx(output_path)\n            \n            # 6. Return results\n            return {\n                \"success\": True,\n                \"output_path\": output_path,\n                \"output_format\": output_format,\n                \"slide_count\": len(presentation_data.get(\"slides\", [])),\n                \"presentation_title\": presentation_data.get(\"title\", \"\"),\n                \"presentation_url\": result if isinstance(result, str) else None,\n                \"review_results\": review_results\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error creating presentation: {e}\")\n            return {\"success\": False, \"error\": str(e)}\n    \n    def _analyze_content(self, content: str) -> Dict[str, Any]:\n        \"\"\"Analyze content and generate presentation structure\n        \n        Args:\n            content: Input content\n            \n        Returns:\n            Presentation data structure\n        \"\"\"\n        try:\n            # Build prompt for Claude\n            prompt = f\"\"\"Please analyze the following content and create a comprehensive presentation structure.\n\nThe presentation should include:\n1. An appropriate title\n2. Section headers as needed\n3. A logical flow of slides\n4. Appropriate layout choices for each slide\n5. Rich content including text, bullet points, and suggestions for visuals\n\nCONTENT TO ANALYZE:\n{content}\n\nReturn a JSON object with the following structure:\n{{\n  \"title\": \"Presentation Title\",\n  \"author\": \"Author Name\",\n  \"slides\": [\n    {{\n      \"title\": \"Slide Title\",\n      \"layout\": \"LAYOUT_TYPE\", \n      \"blocks\": [\n        {{\n          \"type\": \"text|bullets|image|chart|table|quote\",\n          // Additional properties based on type\n        }}\n      ],\n      \"notes\": \"Speaker notes\"\n    }}\n  ]\n}}\n\nValid layout types include: TITLE_ONLY, TITLE_AND_CONTENT, SECTION_HEADER, TWO_COLUMNS, COMPARISON, BIG_NUMBER, QUOTE, IMAGE_ONLY, IMAGE_WITH_CAPTION, BLANK\n\nFor bullets blocks, use the format:\n{{\n  \"type\": \"bullets\",\n  \"items\": [\n    {{\n      \"content\": \"Bullet text\",\n      \"sub_bullets\": [\n        {{ \"content\": \"Sub-bullet text\" }}\n      ]\n    }}\n  ]\n}}\n\nFor image blocks, use the format:\n{{\n  \"type\": \"image\",\n  \"source\": \"https://example.com/image.jpg\",\n  \"caption\": \"Image caption\",\n  \"position\": {{ \"horizontal\": \"LEFT|CENTER|RIGHT\", \"vertical\": \"TOP|MIDDLE|BOTTOM\" }}\n}}\n\nBe thoughtful about slide layout selection and content organization. Aim for clarity, visual appeal, and effective communication.\n\"\"\"\n            \n            # Call Claude with extended thinking\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=16000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=\"You are an expert presentation designer who creates well-structured, professional presentations. Return valid JSON only with no additional explanation.\",\n                messages=[{\"role\": \"user\", \"content\": prompt}]\n            )\n            \n            # Parse JSON response\n            response_text = response.content[0].text\n            \n            # Extract JSON from response\n            import re\n            import json\n            \n            json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n            json_match = re.search(json_pattern, response_text)\n            \n            if json_match:\n                presentation_json = json_match.group(1)\n            else:\n                presentation_json = response_text\n            \n            presentation_data = json.loads(presentation_json)\n            \n            # Validate required keys\n            if \"title\" not in presentation_data or \"slides\" not in presentation_data:\n                logger.error(\"Missing required keys in presentation data\")\n                return {}\n            \n            return presentation_data\n            \n        except Exception as e:\n            logger.error(f\"Error analyzing content: {e}\")\n            return {}\n    \n    def refine_presentation(self, presentation_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Refine a presentation structure\n        \n        Args:\n            presentation_data: Presentation data\n            \n        Returns:\n            Refined presentation data\n        \"\"\"\n        try:\n            # Convert presentation data to JSON string\n            presentation_json = json.dumps(presentation_data, indent=2)\n            \n            # Build prompt for Claude\n            prompt = f\"\"\"Please review and improve the following presentation structure.\n\nFocus on:\n1. Visual design and layout consistency\n2. Content flow and organization\n3. Appropriate use of layouts\n4. Completeness and clarity\n\nCURRENT PRESENTATION STRUCTURE:\n{presentation_json}\n\nReturn the improved presentation structure as a valid JSON object with the exact same format.\n\"\"\"\n            \n            # Call Claude with extended thinking\n            response = self.client.messages.create(\n                model=\"claude-3-7-sonnet-20250219\",\n                max_tokens=16000,\n                thinking={\"type\": \"enabled\", \"budget_tokens\": 16000},\n                system=\"You are an expert presentation designer who refines and improves presentation structures. Return valid JSON only with no additional explanation.\",\n                messages=[{\"role\": \"user\", \"content\": prompt}]\n            )\n            \n            # Parse JSON response\n            response_text = response.content[0].text\n            \n            # Extract JSON from response\n            import re\n            import json\n            \n            json_pattern = r\"```(?:json)?\\s*([\\s\\S]*?)\\s*```\"\n            json_match = re.search(json_pattern, response_text)\n            \n            if json_match:\n                refined_json = json_match.group(1)\n            else:\n                refined_json = response_text\n            \n            refined_data = json.loads(refined_json)\n            \n            # Validate required keys\n            if \"title\" not in refined_data or \"slides\" not in refined_data:\n                logger.error(\"Missing required keys in refined presentation data\")\n                return presentation_data\n            \n            return refined_data\n            \n        except Exception as e:\n            logger.error(f\"Error refining presentation: {e}\")\n            return presentation_data\n```\n\n## 6. Command Line Interface\n\nLet's create a CLI interface for the tool:\n\n```python\n# makeslides/cli.py\nimport argparse\nimport json\nimport logging\nimport os\nimport sys\nfrom pathlib import Path\nfrom .core.controller import SlidesController\n\ndef setup_logging(level: str = \"INFO\"):\n    \"\"\"Set up logging configuration\"\"\"\n    logging.basicConfig(\n        level=getattr(logging, level),\n        format=\"%(asctime)s [%(levelname)s] %(name)s: %(message)s\",\n        handlers=[logging.StreamHandler()]\n    )\n\ndef main():\n    \"\"\"Main CLI entry point\"\"\"\n    parser = argparse.ArgumentParser(description=\"Create slides from content\")\n    \n    # Input options\n    parser.add_argument(\"input\", help=\"Input content file (markdown, text)\")\n    \n    # Output options\n    parser.add_argument(\"--format\", choices=[\"pptx\", \"google_slides\"], default=\"pptx\",\n                      help=\"Output format (default: pptx)\")\n    parser.add_argument(\"--output\", help=\"Output path\")\n    \n    # Visual options\n    parser.add_argument(\"--template\", help=\"Path to template file\")\n    parser.add_argument(\"--theme\", help=\"Path to theme JSON file\")\n    \n    # Advanced options\n    parser.add_argument(\"--review\", action=\"store_true\", help=\"Review presentation after creation\")\n    parser.add_argument(\"--log-level\", choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"], default=\"INFO\",\n                      help=\"Logging level\")\n    parser.add_argument(\"--credentials\", help=\"Path to Google API credentials (for Google Slides)\")\n    \n    args = parser.parse_args()\n    \n    # Set up logging\n    setup_logging(args.log_level)\n    \n    # Check if input file exists\n    input_path = Path(args.input)\n    if not input_path.exists():\n        print(f\"Input file not found: {input_path}\")\n        sys.exit(1)\n    \n    # Read input content\n    try:\n        content = input_path.read_text(encoding=\"utf-8\")\n    except Exception as e:\n        print(f\"Error reading input file: {e}\")\n        sys.exit(1)\n    \n    # Load theme if provided\n    theme = None\n    if args.theme:\n        theme_path = Path(args.theme)\n        if theme_path.exists():\n            try:\n                theme = json.loads(theme_path.read_text(encoding=\"utf-8\"))\n            except Exception as e:\n                print(f\"Error reading theme file: {e}\")\n                sys.exit(1)\n    \n    # Determine output path\n    output_path = args.output\n    if not output_path:\n        if args.format == \"pptx\":\n            output_path = input_path.with_suffix(\".pptx\")\n        else:\n            output_path = input_path.with_suffix(\".slides.txt\")\n    \n    # Create controller\n    config = {}\n    if args.credentials:\n        config[\"credentials_path\"] = args.credentials\n    \n    try:\n        controller = SlidesController(config)\n        \n        # Create presentation\n        result = controller.create_presentation(\n            content=content,\n            output_format=args.format,\n            output_path=output_path,\n            theme=theme,\n            template_path=args.template,\n            review=args.review\n        )\n        \n        # Handle result\n        if result[\"success\"]:\n            print(f\"✓ Successfully created presentation: {result['output_path']}\")\n            \n            if \"presentation_url\" in result and result[\"presentation_url\"]:\n                print(f\"✓ Presentation URL: {result['presentation_url']}\")\n            \n            if \"review_results\" in result and result[\"review_results\"]:\n                print(\"\\nPresentation Review:\")\n                overall = result[\"review_results\"].get(\"overall_review\", {})\n                print(f\"- Overall Rating: {overall.get('overall_rating', 'N/A')}/10\")\n                print(f\"- Summary: {overall.get('summary', 'N/A')}\")\n                \n                if \"key_strengths\" in overall and overall[\"key_strengths\"]:\n                    print(\"\\nKey Strengths:\")\n                    for strength in overall[\"key_strengths\"]:\n                        print(f\"  ✓ {strength}\")\n                \n                if \"key_issues\" in overall and overall[\"key_issues\"]:\n                    print(\"\\nKey Issues:\")\n                    for issue in overall[\"key_issues\"]:\n                        print(f\"  ! {issue}\")\n                \n                if \"recommendations\" in overall and overall[\"recommendations\"]:\n                    print(\"\\nRecommendations:\")\n                    for rec in overall[\"recommendations\"]:\n                        print(f\"  > {rec}\")\n        else:\n            print(f\"✗ Failed to create presentation: {result.get('error', 'Unknown error')}\")\n            sys.exit(1)\n            \n    except Exception as e:\n        print(f\"Error creating presentation: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Summary and Next Steps\n\nI've provided a comprehensive implementation that addresses all your requirements:\n\n1. **Enhanced PPTX Renderer**: Supports positioning, templates, themes, and various content types\n2. **Google Slides API**: Direct integration without md2gslides\n3. **Factory Pattern**: Easily switch between output formats\n4. **Visual Review**: Uses Claude's vision capabilities to provide feedback on slides\n5. **Command Line Interface**: User-friendly CLI for the entire process\n\n### Next Steps:\n\n1. **Testing**: Create unit tests for core components\n2. **Templates**: Build a library of reusable templates and themes\n3. **Advanced Visualization**: Improve chart and diagram rendering\n4. **Web Interface**: Create a simple web UI for interacting with the tool\n5. **Theme Gallery**: Allow users to browse and apply different themes\n\n### Implementation Notes:\n\n1. The PowerPoint renderer now supports all the positioning and layout options you requested.\n2. Google Slides API integration provides both direct creation and PPTX upload.\n3. The visual review feature allows Claude to critique the actual appearance of slides.\n4. The factory pattern makes it easy to add more renderers in the future.\n\nThis should provide a solid foundation for your intelligent slide generator with the flexibility to evolve with your needs.",
            "citations": []
          }
        ],
        "updated_at": "2025-05-21T13:39:08.650921Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}