{
  "id": "6d878c23-0680-4fe4-988f-53fe934850a8",
  "source": "chatgpt",
  "title": "\"Updating Agent Relevancy Score\"",
  "created_at": "2023-05-20T20:15:15.486956",
  "updated_at": "2023-05-20T20:30:18",
  "summary": null,
  "message_count": 10,
  "messages": [
    {
      "id": "aaa2ebb3-5ea4-45ee-8dc1-e1550a71104b",
      "role": "user",
      "content": "when the agents are created I want them all to calculate their relevancy according to the topic of the parliament\nserver.py\nfrom datetime import datetime\nimport asyncio\nimport json\nfrom websockets import serve\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\nimport openai\n\n# Constants\nSET_PARLIAMENT = \"set_parliament\"\nSEND_MESSAGE = \"send_message\"\nADD_AGENTS = \"add_agents\"\nUPDATE_AGENTS = \"update_agents\"\nRECEIVE_MESSAGE = \"receive_message\"\nERROR = \"error\"\nTYPING = \"typing\"\nSTOPPED_TYPING = \"stopped_typing\"\n\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.parliament = None\n        self.start_server = serve(self.chat, self.host, self.port)\n\n    def configure_openai(self):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n\n    async def chat(self, websocket, path):\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == SET_PARLIAMENT:\n                await self.handle_set_parliament(websocket, data)\n            elif action == SEND_MESSAGE:\n                await self.handle_send_message(websocket, data)\n            elif action == ADD_AGENTS:\n                await self.handle_add_agents(websocket, data)\n            elif action in [TYPING, STOPPED_TYPING]:  \n                await self.handle_typing(websocket, data)\n\n    async def handle_typing(self, websocket, data):\n        sender = data.get('sender')\n        action = data.get('action')\n        is_typing = action == TYPING\n        for agent in self.parliament.agents:\n            if agent.name == sender:\n                agent.set_typing_status(is_typing)\n        # Send the typing status update to other clients:\n        await websocket.send(json.dumps({\n            \"action\": action,\n            \"sender\": sender,\n            \"is_typing\": is_typing \n        })) \n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        if parliament_name:\n            self.parliament = Parliament(parliament_name)\n\n    async def handle_send_message(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        sender = data.get(\"sender\")\n        user_message = data.get(\"message\")\n        timestamp = datetime.now()\n        await websocket.send(json.dumps({\n            \"action\": RECEIVE_MESSAGE,\n            \"message\": user_message,\n            \"sender\": sender,\n            \"timestamp\": timestamp.isoformat()}))\n        await self.parliament.broadcast_message(user_message, sender, timestamp)\n        print(f\"Broadcast message: {user_message}\")  # Add logging \n\n        # Sending agent info after broadcasting message\n        agent_info = await self.parliament.get_agents_info()\n        await websocket.send(json.dumps({\"action\": UPDATE_AGENTS, \"agents\": agent_info}))\n            \n    async def handle_add_agents(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n\n        agents_data = data.get(\"agents\")\n        if not agents_data:\n            await self.send_error(websocket, \"No agent data provided.\")\n            return\n\n        for agent_data in agents_data:\n            agent_name = agent_data.get(\"name\")  # Extract the name\n            speaking_pressure_increment = int(agent_data.get(\"speaking_pressure_increment\"))\n\n            other_agents = \", \".join([agent['name'] for agent in agents_data if agent['name'] != agent_name])\n            initial_context = (\n                f\"Hello assistant,  100\"\n            )\n            agent_type = agent_data.get(\"type\")\n            agent_class = self.parliament.agent_types.get(agent_type)  # Get OpenAIAgent or GPT4AllAgent\n            agent_instance = agent_class(initial_context)  # Properly instantiate the class\n            if isinstance(agent_instance, self.parliament.agent_types[agent_type]):\n                agent_instance = OpenAIAgent(initial_context)  # Create the OpenAIAgent instance\n                agent = Agent(self.parliament, agent_name, speaking_pressure_increment, initial_context, agent_type, agent_instance, websocket)\n                self.parliament.add_agent(agent)  # Pass the agent instance to add_agent\n            else: \n                print(\"Error occurred attempting to get agent message!\")\n                return \"Sorry, I'm unable to generate a relevant response at this time.\" \n                await self.send_error(websocket, f\"Unknown agent type: {agent_type}\")\n                continue\n\n    async def send_error(self, websocket, message):\n        await websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\n    def run(self):\n        self.configure_openai()\n        asyncio.get_event_loop().run_until_complete(self.start_server)\n        print(\"Starting WebSocket server...\")\n        print(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n        asyncio.get_event_loop().run_forever()\n\n\nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()\n\nparliament.py:\n\n\nPRESSURE_INCREMENT_INTERVAL = 15\nSPEAKING_PRESSURE_LIMIT = 100\nBROADCAST_DELAY = 1\nRELEVANCY_THRESHOLD = 100\nSTOPPED_TYPING = \"stopped_typing\"\nUPDATE_AGENTS = \"update_agents\"\n\nclass Agent:\n    def __init__(self, parliament, agent_name, speaking_pressure_increment, initial_context, agent_type, agent_instance, websocket=None):\n        self.name = agent_name\n        self.speaking_pressure_increment = speaking_pressure_increment\n        self.speaking_pressure = speaking_pressure_increment\n        self.context = initial_context\n        self.initial_context = initial_context\n        self.tagged = False\n        self.agent_type = agent_type\n        self.agent_instance = agent_instance\n        self.websocket = websocket\n        self.parliament = parliament\n        self.is_speaking = False\n        self.relevancy_score = 0\n        \n    def set_typing_status(self, status: bool):\n        self.is_typing = status\n\n    async def calculate_relevancy(self, chat_context):\n        relevancy_score = 0\n        if self.relevancy_score is None or self.initial_context != chat_context:\n            print(\"Calculating relevancy...\")\n            prompt = f\"you are '{self.initial_context}' and you are being asked to respond to '{chat_context}'. How relevant are you? Only respond with a number from 0 to 100, if you don't know say 1.\"\n            print(f\"Prompt: {prompt}\")\n            response = openai.Completion.create(\n                engine=\"text-davinci-001\",\n                prompt=prompt,\n                temperature=0.0,\n                max_tokens=300\n            )\n            print(f\"Response: {response}\")\n            stripped_response = re.sub(\"[^0-9]\", \"\", response.choices[0].text)\n            try:\n                relevancy_score = int(stripped_response)\n            except ValueError:\n                relevancy_score = 0\n            print(f\"Relevancy score: {relevancy_score}\")\n        else:\n            print(\"Relevancy score already calculated.\")\n        time.sleep(.5)\n        return relevancy_score\n\n    async def get_agent_message(self, truncated_chat_history):\n        message = \"\"\n        if isinstance(self.agent_instance, self.parliament.agent_types[self.agent_type]):\n            response = await self.agent_instance.get_response(truncated_chat_history)\n            message = f\"{response}\"\n        return message\n\n    async def respond(self):\n        await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n        await self.websocket.send(json.dumps({\"action\": \"stopped_typing\", \"sender\": self.name}))\n        agent_message = await self.get_agent_message(self.parliament.chat_history.truncated_chat_history)\n        await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n\n    def reset_relevancy_score(self):\n        self.relevancy_score = None\n\nclass ChatHistory:\n    def __init__(self):\n        self.chat_history = []\n        self.truncated_chat_history = \"\"\n\n    def add(self, message, sender, timestamp):\n        self.chat_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n        self.truncate_chat_history()\n\n    def truncate_chat_history(self, max_length=2000):\n        chat_history_str = '\\n'.join([message[\"message\"] for message in self.chat_history])\n        self.truncated_chat_history = chat_history_str[-max_length:]\n\n    def get_latest_message(self):\n        return self.chat_history[-1] if self.chat_history else None\n\nclass SpeakerManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    def should_speak(self, agent):\n        return agent.tagged or agent.speaking_pressure >= SPEAKING_PRESSURE_LIMIT\n\n\nclass OpenAIAgent:\n    def __init__(self, initial_context: str):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n        self.model = \"gpt-3.5-turbo\"\n        self.initial_context = initial_context\n\n    def get_response(self, truncated_chat):\n        system_msg = self.initial_context\n        messages=[]\n        messages.append({\"role\": \"assistant\", \"content\": truncated_chat})\n\n        max_retries = 3\n        retry_delay = 5\n\n        for i in range(max_retries):\n            try:\n                # Call the OpenAI API with the messages array\n                response = openai.ChatCompletion.create(\n                    model=self.model,\n                    messages=messages,\n                    max_tokens=150,\n                    temperature=0.5,\n                    top_p=1,\n                    frequency_penalty=0,\n                    presence_penalty=0,\n                )\n                # Extract and return the assistant's response from the API response\n                agent_response = response.choices[0].message[\"content\"].strip()\n                print(f\" {agent_response}\")  # Add logging\n                return agent_response\n\n            except RateLimitError as e:\n                print(f\"Rate limit error: {e}. Retrying in {retry_delay} seconds...\")\n                if i < max_retries - 1:  # Don't sleep on the last iteration\n                    time.sleep(retry_delay)\n                else:\n                    raise\n        return \"Sorry, I am unable to respond at the moment.\"\n\n\nclass GPT4AllAgent:\n    def __init__(self):\n        # Download and set up the GPT4All model\n        self._initialize_gpt4all_model()\n        self._initialize_llm_chain()\n\n    def _initialize_gpt4all_model(self):\n        local_path = \"/Users/bilalghalib/Projects/scripts/models/ggml-gpt4all-j.bin\"\n        Path(local_path).parent.mkdir(parents=True, exist_ok=True)\n\n        url = 'http://gpt4all.io/models/ggml-gpt4all-l13b-snoozy.bin'\n        response = requests.get(url, stream=True)\n\n        with open(local_path, 'wb') as f:\n            for chunk in tqdm(response.iter_content(chunk_size=8192)):\n                if chunk:\n                    f.write(chunk)\n\n        self.model_path = local_path\n\n    def _initialize_llm_chain(self):\n        template = \"\"\"{chat_history}\n\n        Question: {question}\n\n        Answer: Let's think step by step.\"\"\"\n        prompt = PromptTemplate(template=template, input_variables=[\"chat_history\", \"question\"])\n\n        callbacks = [StreamingStdOutCallbackHandler()]\n        llm = GPT4All(model=self.model_path, callbacks=callbacks, verbose=True)\n        self.llm_chain = LLMChain(prompt=prompt, llm=llm)\n\n    def get_response(self, chat_history, question):\n        return self.llm_chain.run(chat_history=chat_history, question=question)\n\n\n\n\n\nimport json\nfrom typing import List\n\nUPDATE_AGENTS = \"update_agents\"\n\nclass Parliament:\n    def __init__(self, name: str):  # Added name argument\n        self.name = name  # Added this line to store the name\n        self.agents: List[Agent] = []\n        self.agent_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n        self.agent_instances = {}\n        self.chat_history = ChatHistory()\n\n    async def handle_client(self, websocket, path):\n        async for message in websocket:\n            message = json.loads(message)\n            if message['action'] == 'send_message':\n                self.chat_history.add(message['message'], message['sender'], message['timestamp'])\n                for agent in self.agents:\n                    if agent.websocket == websocket:\n                        agent.reset_relevancy_score()\n\n                if message.get('reply_agent', None):\n                    for agent in self.agents:\n                        if agent.name == message['reply_agent']:\n                            await agent.respond()\n\n            elif message['action'] == 'request_agents':\n                await self.send_agent_list(websocket)\n\n            elif message['action'] == UPDATE_AGENTS:\n                self.update_agents(message['agents'], websocket)\n\n    async def send_agent_list(self, websocket):\n        agents_list = [{\"name\": agent.name, \"context\": agent.context} for agent in self.agents]\n        await websocket.send(json.dumps({\"action\": \"receive_agents\", \"agents\": agents_list}))\n\n    def update_agents(self, agents, websocket):\n        self.agents = []\n        for agent in agents:\n            self.agents.append(Agent(self, agent['name'], agent['context'], agent['type'], self.agent_instances[agent['type']], websocket))\n\n    def add_agent_type(self, agent_type_name, agent_type_class):\n        self.agent_types[agent_type_name] = agent_type_class\n\n    def add_agent_instance(self, agent_instance_name, agent_instance):\n        self.agent_instances[agent_instance_name] = agent_instance\n\n    def add_agent(self, agent):\n        self.agents.append(agent)\n        \n    async def broadcast_message(self, message, sender, timestamp):\n        self.chat_history.add(message, sender, timestamp)\n        mentioned_agents = self.identify_and_tag_mentioned_agents(message)\n\n#        await asyncio.sleep(BROADCAST_DELAY)\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent in self.agents:\n            if '@'+agent.name in message:\n                mentioned_agents.append(agent)\n                agent.speaking_pressure = SPEAKING_PRESSURE_LIMIT\n                agent.tagged = True\n        return mentioned_agents\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents:\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    async def get_agents_info(self) -> List[dict]:\n        agents_info = []\n        for agent in self.agents:\n            agents_info.append({\n                \"name\": agent.name,\n                \"speaking_pressure\": agent.speaking_pressure,\n                \"speaking_pressure_increment\": agent.speaking_pressure_increment, \n                \"context\": agent.context,\n                \"agent_type\": agent.agent_type,\n                \"relevancy_score\": agent.relevancy_score  # Return the cached score\n            })\n        return agents_info ",
      "created_at": "2023-05-20T20:15:15.490546",
      "sequence_order": 0,
      "parent_id": "0e18d120-fb07-49b5-b45f-7846c1e9b80e",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "9e953b27-e9aa-42da-b8c5-684fe33d5b46",
      "role": "assistant",
      "content": "To achieve this, you would have to modify the `Agent` class so that the relevancy of the agent is recalculated each time the agent is supposed to respond. Since the relevancy score is based on the current topic of the parliament, it would need to be updated every time the agent needs to respond, which presumably would be whenever the topic changes.\n\nHere is a way to do it: \n\nAdd the `self.relevancy_score = await self.calculate_relevancy(self.parliament.chat_history.get_latest_message())` line in the `Agent.respond` method:\n\n```python\nclass Agent:\n    ...\n    async def respond(self):\n        self.relevancy_score = await self.calculate_relevancy(self.parliament.chat_history.get_latest_message())\n        if self.relevancy_score >= RELEVANCY_THRESHOLD:\n            await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n            await asyncio.sleep(BROADCAST_DELAY)\n            await self.websocket.send(json.dumps({\"action\": \"stopped_typing\", \"sender\": self.name}))\n            agent_message = await self.get_agent_message(self.parliament.chat_history.truncated_chat_history)\n            await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n            self.speaking_pressure = self.speaking_pressure_increment\n```\n\nAlso, it looks like `calculate_relevancy` method tries to get the relevancy score from an AI model using OpenAI API, but this might not be the best approach. OpenAI models can generate human-like text, but they do not truly understand the context or the relevance of the topic. Therefore, it may not be reliable or accurate to get the relevancy score from the AI model.\n\nYou might want to consider implementing a different approach to calculate the relevancy score. For example, you can use a keyword matching approach where you calculate the number of keywords in the current topic that are present in the agent's context or specialty. Or, you might consider using a machine learning model that is specifically trained for topic relevance detection if you have such resources.\n\nI hope this helps! If you have any more questions or need further clarification, feel free to ask!",
      "created_at": "2023-05-20T20:16:03.025622",
      "sequence_order": 1,
      "parent_id": "aaa2ebb3-5ea4-45ee-8dc1-e1550a71104b",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa27cf7-d0f8-4070-8d2f-56a4338511d5",
      "role": "user",
      "content": "I want it to calculate the relevancy score as soon as the agents are created on instantiation of the agent. ",
      "created_at": "2023-05-20T20:16:55.895378",
      "sequence_order": 2,
      "parent_id": "9e953b27-e9aa-42da-b8c5-684fe33d5b46",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "d5016135-bf8b-4c5b-b3c5-b7ee34c12e25",
      "role": "assistant",
      "content": "To calculate the relevancy score as soon as the agents are created, you could perform the relevancy calculation within the Agent's `__init__` method. You'll need to make sure `calculate_relevancy` method doesn't require any parameters or adjust accordingly.\n\nHere's an example:\n\n```python\nclass Agent:\n    def __init__(self, parliament, agent_name, speaking_pressure_increment, initial_context, agent_type, agent_instance, websocket=None):\n        self.name = agent_name\n        self.speaking_pressure_increment = speaking_pressure_increment\n        self.speaking_pressure = speaking_pressure_increment\n        self.context = initial_context\n        self.initial_context = initial_context\n        self.tagged = False\n        self.agent_type = agent_type\n        self.agent_instance = agent_instance\n        self.websocket = websocket\n        self.parliament = parliament\n        self.is_speaking = False\n\n        # Calculate relevancy on instantiation\n        loop = asyncio.get_event_loop()\n        self.relevancy_score = loop.run_until_complete(self.calculate_relevancy())\n        # Here I used `asyncio.get_event_loop().run_until_complete()` to execute the async method.\n        # If you have a better way to execute async method in sync context, replace it with yours.\n\n    ...\n```\n\nRemember, the code above makes the agent wait until the relevancy calculation is complete before it finishes creating the agent. This could delay the process of creating agents if the relevancy calculation is time-consuming. Consider this when implementing this feature.\n\nAnother thing to note is that since we are calculating relevancy in the `__init__` method, the agent does not have any chat context yet. Depending on your application, this might not be desirable. You could also consider recalculating relevancy when an agent's context is updated if that makes sense in your application.",
      "created_at": "2023-05-20T20:18:05.796364",
      "sequence_order": 3,
      "parent_id": "aaa27cf7-d0f8-4070-8d2f-56a4338511d5",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2f5d8-a8ae-4b51-b1b5-f1591214c5f2",
      "role": "user",
      "content": "what do you think of this approach? \no have all agents calculate their relevancy when the parliament is created, you can add a startup method to the Parliament class. In that method, you can loop through the agents and call calculate_relevancy on each one, passing in the parliament topic.\nHere's an example:\nclass Parliament:\n    def __init__(self, name: str, topic: str):\n        self.name = name\n        self.topic = topic\n        ...\n        \n    async def startup(self):\n        for agent in self.agents:\n            relevancy = await agent.calculate_relevancy(self.topic)\n            agent.relevancy_score = relevancy \nThen in server.py, after creating the Parliament instance, call:\nawait parliament.startup()  # Call this to calculate relevancy scores\nThis will loop through each agent and calculate its relevancy to the given topic, caching the score on the agent.\nThe full code would be:\nparliament.py:\nclass Parliament:\n    def __init__(self, name: str, topic: str):\n        self.name = name\n        self.topic = topic\n        ... \n        \n    async def startup(self):\n        for agent in self.agents:\n            relevancy = await agent.calculate_relevancy(self.topic)\n            agent.relevancy_score = relevancy  \nserver.py:\nasync def handle_set_parliament(self, websocket, data):\n    parliament_name = data.get(\"name\")\n    topic = data.get(\"topic\")  # Get the topic from the request\n    if parliament_name and topic:\n        self.parliament = Parliament(parliament_name, topic)\n        await parliament.startup()   # Call to calculate relevancy scores \nLet me know if you have any other questions!",
      "created_at": "2023-05-20T20:18:30.315075",
      "sequence_order": 4,
      "parent_id": "d5016135-bf8b-4c5b-b3c5-b7ee34c12e25",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "b2f37692-e976-4c97-9e6f-31785acdf447",
      "role": "assistant",
      "content": "This approach you've described sounds perfectly reasonable and follows good design principles. By calculating each agent's relevancy score when the parliament is created and storing it in the agent instance, you are:\n\n1. Reducing the need to repeatedly calculate the score each time it's needed, thus improving performance.\n2. Making the code clearer and easier to understand by putting the calculation in a logically appropriate place.\n3. Following the principle of \"tell, don't ask\" by having the parliament instruct each agent to calculate its score, rather than having outside code need to ask the agent to do it.\n4. Making the server code cleaner and less likely to have bugs by moving the calculation out of `handle_set_parliament` and into the `Parliament` class where it belongs.\n\nSo, overall, this looks like a good approach to the problem you're trying to solve. \n\nJust make sure that any changes to the parliament or agents that could affect the relevancy score trigger a recalculation. For instance, if an agent's context can change over time, you might want to recalculate the relevancy score each time it does. Alternatively, if recalculations are expensive and the context changes frequently, you could use a scheduled task to recalculate scores at regular intervals.\n\nAdditionally, be mindful of error handling in the `startup` function. Since you're using asynchronous programming and any of the relevancy calculations could potentially fail, you'll want to ensure that these errors are handled gracefully and don't crash your program. \n\nRemember to ensure the topic is actually set before the `startup` method is called, and handle cases where it might not be. Without a set topic, the relevancy calculation might not make sense.",
      "created_at": "2023-05-20T20:19:16.158899",
      "sequence_order": 5,
      "parent_id": "aaa2f5d8-a8ae-4b51-b1b5-f1591214c5f2",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa269dd-ddc4-4820-b4b7-dce5f1a11a36",
      "role": "user",
      "content": "Traceback (most recent call last):\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/site-packages/websockets/legacy/server.py\", line 240, in handler\n    await self.ws_handler(self)\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/site-packages/websockets/legacy/server.py\", line 1186, in _ws_handler\n    return await cast(\n  File \"/Users/bilalghalib/Projects/scripts/Parliment/parliament-chat-nextjs/pages/parliament_backend/server.py\", line 40, in chat\n    await self.handle_typing(websocket, data)\n  File \"/Users/bilalghalib/Projects/scripts/Parliment/parliament-chat-nextjs/pages/parliament_backend/server.py\", line 46, in handle_typing\n    for agent in self.parliament.agents:\n\nin code:\nfrom datetime import datetime\nimport asyncio\nimport json\nfrom websockets import serve\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\nimport openai\n\n# Constants\nSET_PARLIAMENT = \"set_parliament\"\nSEND_MESSAGE = \"send_message\"\nADD_AGENTS = \"add_agents\"\nUPDATE_AGENTS = \"update_agents\"\nRECEIVE_MESSAGE = \"receive_message\"\nERROR = \"error\"\nTYPING = \"typing\"\nSTOPPED_TYPING = \"stopped_typing\"\n\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.parliament = None\n        self.start_server = serve(self.chat, self.host, self.port)\n\n    def configure_openai(self):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n\n    async def chat(self, websocket, path):\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == SET_PARLIAMENT:\n                await self.handle_set_parliament(websocket, data)\n            elif action == SEND_MESSAGE:\n                await self.handle_send_message(websocket, data)\n            elif action == ADD_AGENTS:\n                await self.handle_add_agents(websocket, data)\n            elif action in [TYPING, STOPPED_TYPING]:  \n                await self.handle_typing(websocket, data)\n\n    async def handle_typing(self, websocket, data):\n        sender = data.get('sender')\n        action = data.get('action')\n        is_typing = action == TYPING\n        for agent in self.parliament.agents:\n            if agent.name == sender:\n                agent.set_typing_status(is_typing)\n        # Send the typing status update to other clients:\n        await websocket.send(json.dumps({\n            \"action\": action,\n            \"sender\": sender,\n            \"is_typing\": is_typing \n        })) \n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        topic = data.get(\"topic\") \n        if parliament_name and topic:\n            self.parliament = Parliament(parliament_name, topic)\n            await self.parliament.startup() \n\n    async def handle_send_message(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        sender = data.get(\"sender\")\n        user_message = data.get(\"message\")\n        timestamp = datetime.now()\n        await websocket.send(json.dumps({\n            \"action\": RECEIVE_MESSAGE,\n            \"message\": user_message,\n            \"sender\": sender,\n            \"timestamp\": timestamp.isoformat()}))\n        await self.parliament.broadcast_message(user_message, sender, timestamp)\n        print(f\"Broadcast message: {user_message}\")  # Add logging \n\n        # Sending agent info after broadcasting message\n        agent_info = await self.parliament.get_agents_info()\n        await websocket.send(json.dumps({\"action\": UPDATE_AGENTS, \"agents\": agent_info}))\n            \n    async def handle_add_agents(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n\n        agents_data = data.get(\"agents\")\n        if not agents_data:\n            await self.send_error(websocket, \"No agent data provided.\")\n            return\n\n        for agent_data in agents_data:\n            agent_name = agent_data.get(\"name\")  # Extract the name\n            speaking_pressure_increment = int(agent_data.get(\"speaking_pressure_increment\"))\n\n            other_agents = \", \".join([agent['name'] for agent in agents_data if agent['name'] != agent_name])\n            initial_context = (\n                f\"Hello assistant, your name is: @{agent_data.get('name')} and your context is \"\n                f\"{agent_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n                f\"alongside your fellow agents in a parliament, which is a sort \"\n                f\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n                f\"with you are {other_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n                f\"{agent_data.get('speaking_pressure_increment')} out of 100\"\n            )\n            agent_type = agent_data.get(\"type\")\n            agent_class = self.parliament.agent_types.get(agent_type)  # Get OpenAIAgent or GPT4AllAgent\n            agent_instance = agent_class(initial_context)  # Properly instantiate the class\n            if isinstance(agent_instance, self.parliament.agent_types[agent_type]):\n                agent_instance = OpenAIAgent(initial_context)  # Create the OpenAIAgent instance\n                agent = Agent(self.parliament, agent_name, speaking_pressure_increment, initial_context, agent_type, agent_instance, websocket)\n                self.parliament.add_agent(agent)  # Pass the agent instance to add_agent\n            else: \n                print(\"Error occurred attempting to get agent message!\")\n                return \"Sorry, I'm unable to generate a relevant response at this time.\" \n                await self.send_error(websocket, f\"Unknown agent type: {agent_type}\")\n                continue\n\n    async def send_error(self, websocket, message):\n        await websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\n    def run(self):\n        self.configure_openai()\n        asyncio.get_event_loop().run_until_complete(self.start_server)\n        print(\"Starting WebSocket server...\")\n        print(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n        asyncio.get_event_loop().run_forever()\n\n\nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()\n",
      "created_at": "2023-05-20T20:24:23.908408",
      "sequence_order": 6,
      "parent_id": "b2f37692-e976-4c97-9e6f-31785acdf447",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "50cfe602-bb1e-4b06-ba94-c4d23b653a34",
      "role": "assistant",
      "content": "From the error traceback you provided, it appears the error is occurring in your `handle_typing` method, specifically at the line `for agent in self.parliament.agents:`. This suggests that `self.parliament` is `None` when the method is called, which means you're trying to access the `agents` attribute of `None`, and this is causing the error.\n\nYour `ParliamentServer` class initializes `self.parliament` to `None` in its `__init__` method. The `self.parliament` attribute is not set to a `Parliament` instance until `handle_set_parliament` is called. Therefore, if `handle_typing` is called before `handle_set_parliament`, `self.parliament` will still be `None` and you'll get this error.\n\nTo fix this issue, you should check that `self.parliament` is not `None` before trying to access its `agents` attribute in the `handle_typing` method. You can do this by adding an if statement at the beginning of the method:\n\n```python\nasync def handle_typing(self, websocket, data):\n    if not self.parliament:\n        await self.send_error(websocket, \"Parliament not set.\")\n        return\n    ...\n```\n\nThis way, if `self.parliament` is `None`, the method will send an error message and return immediately, preventing the line that caused the error from being executed.",
      "created_at": "2023-05-20T20:25:03.367548",
      "sequence_order": 7,
      "parent_id": "aaa269dd-ddc4-4820-b4b7-dce5f1a11a36",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2c464-2577-498c-8698-1a3e294a1c13",
      "role": "user",
      "content": "no error messages, just not seeing the user text typed up on the chat list:\nChat.js\nimport styles from './Chat.module.css';\nimport { debounce } from 'lodash';\nimport { useState, useEffect, useRef, useCallback } from 'react';\nimport { ListGroup, Form, Button, Spinner, ListGroupItem } from 'react-bootstrap';\nimport { FaTimes, FaReply } from 'react-icons/fa'; // Importing cross and reply icons\nimport { MentionsInput, Mention } from 'react-mentions';\n\nfunction Message({ message, sender, handleReply }) {\n  return (\n  <ListGroup.Item className={styles.messageItem}>\n    <div className={styles.flexCenter}>\n        <strong>{sender}:</strong>\n        <Button \n          variant=\"link\"\n          style={{ padding: 0, color: '#007bff', textDecoration: 'none' }}\n          onClick={() => handleReply(sender)}\n        >\n          <FaReply />\n        </Button>\n      </div>\n      {message.text}\n    </ListGroup.Item>\n  );\n}\n\nfunction AgentItem({ agent, handleClear, speakingQueue, handleReply }) {\n  const queueNumber = speakingQueue.indexOf(agent.name);\n  return (\n    <ListGroup.Item className={styles.agentItem}>\n      <div>\n        {agent.name}\n        <span style={{ marginLeft: '5px' }}>{agent.relevancy_score}%</span> {/* Add this line */}\n      </div>\n      {queueNumber !== -1 && <span> Queue: {queueNumber + 1}</span>}\n      <FaReply\n        style={{ color: 'blue', cursor: 'pointer', marginRight: '5px' }}\n        onClick={() => handleReply(agent.name)}\n      />\n      <FaTimes style={{ color: 'red', cursor: 'pointer' }} onClick={() => handleClear(agent.name)} />\n    </ListGroup.Item>\n  );\n}\n\n\nfunction Chat({ parliament, websocket }) {\n  const [messages, setMessages] = useState([]);\n  const [messageInput, setMessageInput] = useState('');\n  const [isSending, setIsSending] = useState(false);\n  const [agents, setAgents] = useState(parliament.agents);\n  const [speakingQueue, setSpeakingQueue] = useState([]);  // Add this line\n  const chatContainer = useRef(null);\n  const [isTyping, setIsTyping] = useState(false);\n  const [typingTimeoutId, setTypingTimeoutId] = useState(null);\n  const debouncedSendTypingStatus = useCallback(debounce(sendTypingStatus, 300), [sendTypingStatus]);\n\n  const defaultStyle = {\n    fontWeight: 'bold',\n    color: 'black',\n    fontSize: '16px',\n    padding: '10px',\n    borderRadius: '4px',\n    border: '1px solid #ccc',\n    width: '100%',\n    boxSizing: 'border-box',\n    outline: 'none',\n    resize: 'none',\n  };\n  \n  \n\n  function handleError(error) {\n    console.error(\"Websocket error: \", error);\n  }\n\n\n  useEffect(() => {\n    if (websocket) {\n      websocket.onmessage = handleReceiveMessage;\n      websocket.onerror = handleError;\n    }\n    setInitialMessages();\n  }, [parliament, websocket]);\n\n  useEffect(() => {\n    sendTypingStatus();\n  }, [isTyping]);\n\n  useEffect(() => {\n    chatContainer.current.scrollTop = chatContainer.current.scrollHeight;\n  }, [messages]);\n\n  function setInitialMessages() {\n    setMessages((prevMessages) => [\n      ...prevMessages,\n      {\n        sender: 'System',\n        text: `Parliament is in session, the topic of discussion is: ${parliament.topic}`,\n      },\n      {\n        sender: 'System',\n        text: `The parliament members are ${parliament.agents\n          .map((agent) => agent.name)\n          .join(', ')}, and ${parliament.username}`,\n      },\n    ]);\n  }\n  function handleReceiveMessage(event) {\n    const data = JSON.parse(event.data);\n    const { action, message, sender, updated_agents, queue } = data;\n\n    if (action === \"receive_message\") {\n      console.log(\"data received\")\n      console.log(data)\n      setMessages((prevMessages) => [\n        ...prevMessages.filter((message) => message.sender !== parliament.username || message.text !== \"typing...\"),\n        { sender, text: message },\n      ]);\n    } else if (action === \"typing\" && sender !== parliament.username) {\n      setMessages((prevMessages) => [\n        ...prevMessages.filter((message) => message.sender !== sender || message.text !== \"typing...\"),\n        { sender, text: \"typing...\" },\n      ]);\n    } else if (action === \"stopped_typing\" && sender !== parliament.username) {\n          clearTimeout(typingTimeoutId); \n    setMessages((prevMessages) => [\n        ...prevMessages.filter((message) => message.sender !== sender || message.text !== \"typing...\"),\n      ]);\n    } \n    else if (action === \"update_agents\") {\n      const updatedAgents = data.agents;\n      setAgents(prevAgents => {\n        const newAgents = [...prevAgents];\n        for (const agent of updatedAgents) {\n          const index = prevAgents.findIndex(a => a.name === agent.name);\n          newAgents[index].relevancy_score = agent.relevancy_score;  // Update just the relevancy_score\n        }\n        return newAgents;\n      });\n    }\n\n    if (updated_agents) {\n      setAgents(updated_agents);\n    }\n}\n\n  function handleClear(agentName) {\n    // Send a clear event to the server\n    websocket.send(\n      JSON.stringify({\n        action: 'clear_agent',\n        agent_name: agentName,\n      }),\n    );\n  }\n\n  function sendTypingStatus() {\n    websocket.send(\n      JSON.stringify({\n        action: 'typing',\n        sender: parliament.username,\n        is_typing: isTyping,\n      }),\n    );\n  }\n  \n  async function sendMessage() {\n    if (!messageInput.trim() || isSending) return;\n    setIsSending(true);\n    try {\n      console.log(`[${parliament.username}] Sending message to server...`);\n      console.log(messageInput.slice(0, 50) + '...');\n      websocket.send(\n        JSON.stringify({\n          action: 'send_message',\n          sender: parliament.username,\n          message: messageInput,\n        }),\n      );\n      console.log(`[${parliament.username}] Message sent!`);\n      setMessageInput('');\n      setIsTyping(false);\n      \n      // Call broadcast_message here\n      console.log(`[${parliament.username}] Sending broadcast message to server...`);\n      console.log(messageInput.slice(0, 50) + '...');\n      websocket.send(\n        JSON.stringify({\n          action: 'broadcast_message',\n          message: messageInput,\n          sender: parliament.username,\n        }),\n      );\n      console.log(`[${parliament.username}] Broadcast message sent!`);\n    } catch (error) {\n      console.log(`[${parliament.username}] Failed to send message:`, error);\n    } finally {\n      setIsSending(false);\n    }\n    }\n  \n  function handleReply(sender) {\n    setMessageInput(`@${sender} `);\n  }\n\n  const agentNames = agents.map(agent => ({ id: agent.name, display: agent.name }));\n\nreturn (\n    <div style={{ display: 'flex', gap: '1em' }}>\n      <div style={{ width: '70%' }}>\n        <h1>Parliament Chat</h1>\n        <ListGroup\n          ref={chatContainer}\n          style={{ height: '400px', overflowY: 'scroll' }}>\n          {messages.map((message, index) => (\n              <Message\n                  key={index}\n                  message={message}\n                  sender={message.sender}\n                  handleReply={handleReply}\n                  user={parliament.username}\n              />\n          ))}\n        </ListGroup>\n        <Form>\n          <Form.Group controlId=\"messageInput\">\n            <MentionsInput\n              autoFocus\n              value={messageInput}\n              onChange={(event, value, plainTextValue) => {\n                setMessageInput(plainTextValue);\n                setIsTyping(true);\n                debouncedSendTypingStatus();\n                clearTimeout(typingTimeoutId);\n                setTypingTimeoutId(setTimeout(() => setIsTyping(false), 2000));\n              }}\n              onKeyPress={(e) => {\n                if (e.key === 'Enter') {\n                  sendMessage();\n                  e.preventDefault();\n                }\n              }}\n              placeholder=\"Type your message...\"\n              style={defaultStyle} // styles for the input field\n            >\n              <Mention\n                trigger=\"@\"\n                data={agentNames}\n                displayTransform={(id, display) => `@${display}`}\n                className={styles.mentionStyle} // use your CSS module to style the mentions\n              />\n            </MentionsInput>\n          </Form.Group>\n        </Form>\n        <Button onClick={sendMessage} disabled={isSending}>\n          {isSending ? <Spinner animation=\"border\" size=\"sm\" /> : 'Send Message'}\n        </Button>\n      </div>\n      <div style={{ width: '20%', marginTop: '25px' }}> {/* You can adjust the marginTop as needed */}\n        <h2 style={{ fontSize: '1em' }}>Agents</h2>\n          <ListGroup>\n          {agents\n            .sort((a, b) => {\n              const aQueueNumber = speakingQueue.indexOf(a.name);\n              const bQueueNumber = speakingQueue.indexOf(b.name);\n              \n              // If both agents are in the queue, compare their positions\n              if (aQueueNumber !== -1 && bQueueNumber !== -1) {\n                return aQueueNumber - bQueueNumber;\n              }\n              \n              // If only one of the agents is in the queue, that agent comes first\n              if (aQueueNumber !== -1) {\n                return -1;\n              }\n              if (bQueueNumber !== -1) {\n                return 1;\n              }\n              \n              // If neither agent is in the queue, compare their names alphabetically\n              return a.name.localeCompare(b.name);\n            })\n            .map((agent, index) => (\n              <AgentItem\n                key={index}\n                agent={agent}\n                handleClear={handleClear}\n                speakingQueue={speakingQueue}\n                handleReply={handleReply} // Add this line\n              />\n            ))}\n        </ListGroup>\n      </div>\n    </div>\n  );\n}\n\nexport default Chat;\nserver.py\nfrom datetime import datetime\nimport asyncio\nimport json\nfrom websockets import serve\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\nimport openai\n\n# Constants\nSET_PARLIAMENT = \"set_parliament\"\nSEND_MESSAGE = \"send_message\"\nADD_AGENTS = \"add_agents\"\nUPDATE_AGENTS = \"update_agents\"\nRECEIVE_MESSAGE = \"receive_message\"\nERROR = \"error\"\nTYPING = \"typing\"\nSTOPPED_TYPING = \"stopped_typing\"\n\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.parliament = None\n        self.start_server = serve(self.chat, self.host, self.port)\n\n    def configure_openai(self):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n\n    async def chat(self, websocket, path):\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == SET_PARLIAMENT:\n                await self.handle_set_parliament(websocket, data)\n            elif action == SEND_MESSAGE:\n                await self.handle_send_message(websocket, data)\n            elif action == ADD_AGENTS:\n                await self.handle_add_agents(websocket, data)\n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        topic = data.get(\"topic\") \n        if parliament_name and topic:\n            self.parliament = Parliament(parliament_name, topic)\n            await self.parliament.startup() \n\n    async def handle_send_message(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        sender = data.get(\"sender\")\n        user_message = data.get(\"message\")\n        timestamp = datetime.now()\n        await websocket.send(json.dumps({\n            \"action\": RECEIVE_MESSAGE,\n            \"message\": user_message,\n            \"sender\": sender,\n            \"timestamp\": timestamp.isoformat()}))\n        await self.parliament.broadcast_message(user_message, sender, timestamp)\n        print(f\"Broadcast message: {user_message}\")  # Add logging \n\n        # Sending agent info after broadcasting message\n        agent_info = await self.parliament.get_agents_info()\n        await websocket.send(json.dumps({\"action\": UPDATE_AGENTS, \"agents\": agent_info}))\n            \n    async def handle_add_agents(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n\n        agents_data = data.get(\"agents\")\n        if not agents_data:\n            await self.send_error(websocket, \"No agent data provided.\")\n            return\n\n        for agent_data in agents_data:\n            agent_name = agent_data.get(\"name\")  # Extract the name\n            speaking_pressure_increment = int(agent_data.get(\"speaking_pressure_increment\"))\n\n            other_agents = \", \".join([agent['name'] for agent in agents_data if agent['name'] != agent_name])\n            initial_context = (\n                f\"Hello assistant, your name is: @{agent_data.get('name')} and your context is \"\n                f\"{agent_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n                f\"alongside your fellow agents in a parliament, which is a sort \"\n                f\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n                f\"with you are {other_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n                f\"{agent_data.get('speaking_pressure_increment')} out of 100\"\n            )\n            agent_type = agent_data.get(\"type\")\n            agent_class = self.parliament.agent_types.get(agent_type)  # Get OpenAIAgent or GPT4AllAgent\n            agent_instance = agent_class(initial_context)  # Properly instantiate the class\n            if isinstance(agent_instance, self.parliament.agent_types[agent_type]):\n                agent_instance = OpenAIAgent(initial_context)  # Create the OpenAIAgent instance\n                agent = Agent(self.parliament, agent_name, speaking_pressure_increment, initial_context, agent_type, agent_instance, websocket)\n                self.parliament.add_agent(agent)  # Pass the agent instance to add_agent\n            else: \n                print(\"Error occurred attempting to get agent message!\")\n                return \"Sorry, I'm unable to generate a relevant response at this time.\" \n                await self.send_error(websocket, f\"Unknown agent type: {agent_type}\")\n                continue\n\n    async def send_error(self, websocket, message):\n        await websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\n    def run(self):\n        self.configure_openai()\n        asyncio.get_event_loop().run_until_complete(self.start_server)\n        print(\"Starting WebSocket server...\")\n        print(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n        asyncio.get_event_loop().run_forever()\n\n\nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()\n",
      "created_at": "2023-05-20T20:30:18.112062",
      "sequence_order": 8,
      "parent_id": "50cfe602-bb1e-4b06-ba94-c4d23b653a34",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "008aaa69-1049-4189-983e-4cfc2d148c66",
      "role": "assistant",
      "content": "From the given code, there doesn't seem to be any obvious errors. But let's go through some possible reasons why you might not be seeing user text showing up in the chat list:\n\n1. **Websocket Connection**: Make sure your websocket connection is established correctly between your front-end and back-end, and it's sending and receiving data as expected.\n\n2. **Data Flow**: Verify the data flow between your front-end and back-end, especially the `handleReceiveMessage` function in your React component. Check if you're correctly receiving the data from the server, parsing it, and updating your component's state. You can do this by adding more console logs in this function and see if the expected data comes through when a message is sent.\n\n3. **Updating State**: Ensure you're updating the `messages` state correctly in your `handleReceiveMessage` function. In your current setup, you're adding the new message to the end of your `messages` array. \n\n4. **React Rendering**: Make sure your React component is rendering correctly and updating when the state changes. \n\n5. **Browser Console**: Check your browser's console for any errors or warnings. They can provide valuable information on what might be going wrong.\n\n6. **Server-side Errors**: Check if there are any errors or issues on the server-side when processing and forwarding the messages to the client. It's possible the issue is not with the React component but the server-side implementation.\n\nTry debugging with these points in mind, and see if you can figure out where the issue lies. It would also be helpful to check the network tab in your browser's developer tools to see the websocket messages coming in and going out to make sure everything's working as expected.",
      "created_at": "2023-05-20T20:30:53.298460",
      "sequence_order": 9,
      "parent_id": "aaa2c464-2577-498c-8698-1a3e294a1c13",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    }
  ]
}