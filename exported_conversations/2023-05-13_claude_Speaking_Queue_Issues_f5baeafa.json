{
  "id": "f5baeafa-4025-4d5f-b9d8-c6bf7b345293",
  "source": "claude",
  "title": "Speaking Queue Issues",
  "created_at": "2023-05-13T08:14:33.456974Z",
  "updated_at": "2023-05-13T08:17:29.286086Z",
  "summary": "",
  "message_count": 4,
  "messages": [
    {
      "id": "1ca3f426-eacf-4c13-9bfc-3f1dd5138b45",
      "role": "human",
      "content": "I'm having issues with the speaking queue in the chat.js\n\nimport styles from './Chat.module.css';\n\nimport { debounce } from 'lodash';\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nimport { ListGroup, Form, Button, Spinner, ListGroupItem } from 'react-bootstrap';\n\nimport { FaTimes, FaReply } from 'react-icons/fa'; // Importing cross and reply icons\n\nimport { MentionsInput, Mention } from 'react-mentions';\n\nfunction Message({ message, sender, handleReply }) {\n\nreturn (\n\n<ListGroup.Item className={styles.messageItem}>\n\n<div className={styles.flexCenter}>\n\n<strong>{sender}:</strong>\n\n<Button\n\nvariant=\"link\"\n\nstyle={{ padding: 0, color: '#007bff', textDecoration: 'none' }}\n\nonClick={() => handleReply(sender)}\n\n\\>\n\n<FaReply />\n\n</Button>\n\n</div>\n\n{message.text}\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction AgentItem({ agent, handleClear, speakingQueue, handleReply }) {\n\nconst queueNumber = speakingQueue.indexOf(agent.name);\n\nreturn (\n\n<ListGroup.Item className={styles.agentItem}>\n\n<span>{agent.relevancy}%</span>\n\n{agent.name}\n\n{queueNumber !== -1 && <span> Queue: {queueNumber + 1}</span>}\n\n<FaReply style={{ color: 'blue', cursor: 'pointer', marginRight: '5px' }} onClick={() => handleReply(agent.name)} /> {/\\* Add this line \\*/}\n\n<FaTimes style={{ color: 'red', cursor: 'pointer' }} onClick={() => handleClear(agent.name)} />\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction sortAgents(a, b) {\n\nconst aInQueue = speakingQueue.indexOf(a.name) !== -1;\n\nconst bInQueue = speakingQueue.indexOf(b.name) !== -1;\n\nif (aInQueue && bInQueue) {\n\nconst aQueueNumber = speakingQueue.indexOf(a.name);\n\nconst bQueueNumber = speakingQueue.indexOf(b.name);\n\nreturn aQueueNumber - bQueueNumber;\n\n}\n\nelse if (aInQueue) return -1;\n\nelse if (bInQueue) return 1;\n\nreturn a.name.localeCompare(b.name);\n\n}\n\nfunction Chat({ parliament, websocket }) {\n\nconst \\[messages, setMessages\\] = useState(\\[\\]);\n\nconst \\[messageInput, setMessageInput\\] = useState('');\n\nconst \\[isSending, setIsSending\\] = useState(false);\n\nconst \\[agents, setAgents\\] = useState(parliament.agents);\n\nconst \\[speakingQueue, setSpeakingQueue\\] = useState(\\[\\]);\n\nconst chatContainer = useRef(null);\n\nconst \\[isTyping, setIsTyping\\] = useState(false);\n\nconst \\[typingTimeoutId, setTypingTimeoutId\\] = useState(null);\n\nconst debouncedSendTypingStatus = useCallback(debounce(sendTypingStatus, 300), \\[sendTypingStatus\\]);\n\nconst defaultStyle = {\n\nfontWeight: 'bold',\n\ncolor: 'black',\n\nfontSize: '16px',\n\npadding: '10px',\n\nborderRadius: '4px',\n\nborder: '1px solid #ccc',\n\nwidth: '100%',\n\nboxSizing: 'border-box',\n\noutline: 'none',\n\nresize: 'none',\n\n};\n\nfunction handleError(error) {\n\nconsole.error(\"Websocket error: \", error);\n\n}\n\nuseEffect(() => {\n\nif (websocket) {\n\nwebsocket.onmessage = handleReceiveMessage;\n\nwebsocket.onerror = handleError;\n\n}\n\nsetInitialMessages();\n\n}, \\[parliament, websocket\\]);\n\nuseEffect(() => {\n\nsendTypingStatus();\n\n}, \\[isTyping\\]);\n\nuseEffect(() => {\n\nchatContainer.current.scrollTop = chatContainer.current.scrollHeight;\n\n}, \\[messages\\]);\n\nfunction setInitialMessages() {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages,\n\n{\n\nsender: 'System',\n\ntext: `Parliament is in session, the topic of discussion is: ${parliament.topic}`,\n\n},\n\n{\n\nsender: 'System',\n\ntext: \\`The parliament members are ${parliament.agents\n\n.map((agent) => agent.name)\n\n.join(', ')}, and ${parliament.username}\\`,\n\n},\n\n\\]);\n\n}\n\nfunction handleReceiveMessage(event) {\n\nconst data = JSON.parse(event.data);\n\nconst { action, message, sender, updated\\_agents } = data;\n\nif (action === \"receive\\_message\") {\n\nconst senderIsTyping = messages.some(m => m.sender === sender && m.text === 'typing...');\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages.filter(m => m.sender !== sender || m.text !== 'typing...'),\n\n{ sender, text: message }\n\n\\]);\n\nif (senderIsTyping) {\n\nsetMessages(prevMessages => \\[...prevMessages, { sender, text: 'typing...' }\\]);\n\n}\n\n// Also call setAgents() to update relevancy scores\n\nsetAgents(updated\\_agents);\n\n}\n\nif (action === \"update\\_agents\") {\n\nconst updatedAgents = updated\\_agents.map(agent => {\n\nagent.relevancy = agent.relevancy\\_score;\n\nreturn agent;\n\n});\n\nsetAgents(updatedAgents);\n\n}\n\n}\n\nfunction handleClear(agentName) {\n\n// Send a clear event to the server\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'clear\\_agent',\n\nagent\\_name: agentName,\n\n}),\n\n);\n\n}\n\nfunction sendTypingStatus() {\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'typing',\n\nsender: parliament.username,\n\nis\\_typing: isTyping,\n\n}),\n\n);\n\n}\n\nasync function sendMessage() {\n\nif (!messageInput.trim() || isSending) return;\n\nsetIsSending(true);\n\ntry {\n\nconsole.log(\\`\\[${parliament.username}\\] Sending message to server...\\`);\n\nconsole.log(messageInput.slice(0, 50) + '...');\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'send\\_message',\n\nsender: parliament.username,\n\nmessage: messageInput,\n\n}),\n\n);\n\nconsole.log(\\`\\[${parliament.username}\\] Message sent!\\`);\n\nsetMessageInput('');\n\nsetIsTyping(false);\n\n// Call broadcast\\_message here\n\nconsole.log(\\`\\[${parliament.username}\\] Sending broadcast message to server...\\`);\n\nconsole.log(messageInput.slice(0, 50) + '...');\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'broadcast\\_message',\n\nmessage: messageInput,\n\nsender: parliament.username,\n\n}),\n\n);\n\nconsole.log(\\`\\[${parliament.username}\\] Broadcast message sent!\\`);\n\n} catch (error) {\n\nconsole.log(\\`\\[${parliament.username}\\] Failed to send message:\\`, error);\n\n} finally {\n\nsetIsSending(false);\n\n}\n\n}\n\nfunction handleReply(sender) {\n\nsetMessageInput(\\`@${sender} \\`);\n\n}\n\nconst agentNames = agents.map(agent => ({ id: agent.name, display: agent.name }));\n\nreturn (\n\n<div style={{ display: 'flex', gap: '1em' }}>\n\n<div style={{ width: '70%' }}>\n\n<h1>Parliament Chat</h1>\n\n<ListGroup\n\nref={chatContainer}\n\nstyle={{ height: '400px', overflowY: 'scroll' }}>\n\n{messages.map((message, index) => (\n\n<Message\n\nkey={index}\n\nmessage={message}\n\nsender={message.sender}\n\nhandleReply={handleReply}\n\nuser={parliament.username}\n\n/>\n\n))}\n\n</ListGroup>\n\n<Form>\n\n<Form.Group controlId=\"messageInput\">\n\n<MentionsInput\n\nautoFocus\n\nvalue={messageInput}\n\nonChange={(event, value, plainTextValue) => {\n\nsetMessageInput(plainTextValue);\n\nsetIsTyping(true);\n\ndebouncedSendTypingStatus();\n\nclearTimeout(typingTimeoutId);\n\nsetTypingTimeoutId(setTimeout(() => setIsTyping(false), 2000));\n\n}}\n\nonKeyPress={(e) => {\n\nif (e.key === 'Enter') {\n\nsendMessage();\n\ne.preventDefault();\n\n}\n\n}}\n\nplaceholder=\"Type your message...\"\n\nstyle={defaultStyle} // styles for the input field\n\n\\>\n\n<Mention\n\ntrigger=\"@\"\n\ndata={agentNames}\n\ndisplayTransform={(id, display) => `@${display}`}\n\nclassName={styles.mentionStyle} // use your CSS module to style the mentions\n\n/>\n\n</MentionsInput>\n\n</Form.Group>\n\n</Form>\n\n<Button onClick={sendMessage} disabled={isSending}>\n\n{isSending ? <Spinner animation=\"border\" size=\"sm\" /> : 'Send Message'}\n\n</Button>\n\n</div>\n\n<div style={{ width: '20%', marginTop: '25px' }}> {/\\* You can adjust the marginTop as needed \\*/}\n\n<h2 style={{ fontSize: '1em' }}>Agents</h2>\n\n<ListGroup>\n\n{agents.sort(sortAgents).map((agent, index) => (\n\n<AgentItem\n\nkey={index}\n\nagent={agent}\n\nhandleClear={handleClear}\n\nspeakingQueue={speakingQueue}\n\nhandleReply={handleReply}\n\n/>\n\n))}\n\n</ListGroup>\n\n</div>\n\n</div>\n\n);\n\n}\n\nexport default Chat;\n\nHere's parliament.py\n\nimport asyncio\n\nimport random\n\nimport json\n\nimport openai\n\nfrom openai.error import RateLimitError\n\nimport time\n\nfrom typing import List\n\nfrom collections import deque\n\nPRESSURE\\_INCREMENT\\_INTERVAL = 15\n\nSPEAKING\\_PRESSURE\\_LIMIT = 100\n\nBROADCAST\\_DELAY = 10\n\nRELEVANCY\\_THRESHOLD = 100\n\nclass Agent:\n\ndef **init**(self, parliament, agent\\_name, speaking\\_pressure\\_increment, initial\\_context, agent\\_type, agent\\_instance, websocket=None):\n\nself.name = agent\\_name\n\nself.speaking\\_pressure\\_increment = speaking\\_pressure\\_increment\n\nself.context = initial\\_context\n\nself.initial\\_context = initial\\_context\n\nself.speaking\\_pressure = speaking\\_pressure\\_increment\n\nself.tagged = False\n\nself.agent\\_type = agent\\_type\n\nself.agent\\_instance = agent\\_instance\n\nself.websocket = websocket\n\nself.parliament = parliament\n\nself.is\\_speaking = False\n\ndef calculate\\_relevancy(self, chat\\_context: str) -> int:\n\nprint(\"Calculating relevancy...\")\n\nprompt = f\"Given this agent's initial context: '{self.initial\\_context}', and the following conversation: '{chat\\_context}', how relevant do you think the agent is to the current conversation from 0 to 100? Return the result as a number in digits and only the number.\"\n\nmessages = \\[\n\n{\"role\": \"system\", \"content\": self.initial\\_context},\n\n{\"role\": \"assistant\", \"content\": prompt},\n\n{\"role\": \"user\", \"content\": \"Please respond with a number only, even if it's not relevant. If it's not relevant, please enter 0.\"}\n\n\\]\n\nmax\\_attempts = 3\n\nattempt = 1\n\nrelevancy\\_score = None\n\nwhile attempt <= max\\_attempts:\n\ntry:\n\nresponse = openai.ChatCompletion.create(\n\nmodel=self.agent\\_instance.model,\n\nmessages=messages,\n\nmax\\_tokens=300\n\n)\n\nrelevancy\\_score = int(response.choices\\[0\\].message\\['content'\\].strip())\n\nbreak # Break out of the loop if a valid relevancy score is obtained\n\nexcept (ValueError, KeyError):\n\nprint(\"Invalid response received. Please enter a valid number.\")\n\nattempt += 1\n\nif relevancy\\_score is None:\n\nprint(\"Maximum number of attempts reached. Unable to retrieve a valid relevancy score.\")\n\nelse:\n\nprint(f\"Relevancy score for {self.name}: {relevancy\\_score}%\")\n\ntime.sleep(1)\n\nreturn relevancy\\_score\n\ndef should\\_speak(self):\n\nreturn self.parliament.speaker\\_manager.should\\_speak(self) # Call parliament's speaker\\_manager\n\nasync def try\\_to\\_speak(self):\n\nif self.should\\_speak() and not self.is\\_speaking:\n\nawait self.speak()\n\nasync def increment\\_pressure(self):\n\nwhile True:\n\nawait asyncio.sleep(PRESSURE\\_INCREMENT\\_INTERVAL)\n\nself.speaking\\_pressure += self.speaking\\_pressure\\_increment\n\nawait self.try\\_to\\_speak()\n\ndef get\\_agent\\_message(self, chat\\_history):\n\n\"\"\"\n\nGenerate a message from this agent based on the current chat history.\n\n\"\"\"\n\nmessage = \"\"\n\nif isinstance(self.agent\\_instance, self.parliament.agent\\_types\\[self.agent\\_type\\]):\n\nresponse = self.agent\\_instance.get\\_response(chat\\_history)\n\nmessage = f\"{response}\"\n\nreturn message\n\ndef in\\_queue(self):\n\nreturn self.name in self.parliament.speaking\\_queue.queue\n\nasync def speak(self):\n\nself.is\\_speaking = True\n\nawait self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n\nagent\\_message = self.get\\_agent\\_message(self.parliament.chat\\_history)\n\nawait self.websocket.send(json.dumps({\"action\": \"receive\\_message\", \"message\": agent\\_message, \"sender\": self.name}))\n\nself.speaking\\_pressure = 0\n\nself.is\\_speaking = False\n\nif self.in\\_queue():\n\nself.parliament.speaking\\_queue.remove(self.name)\n\ndef reset\\_pressure(self):\n\nself.speaking\\_pressure = 0\n\nclass ChatHistory:\n\ndef **init**(self):\n\nself.chat\\_history = \\[\\]\n\nself.truncated\\_chat\\_history = \\[\\]\n\ndef add(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\nself.truncate\\_chat\\_history()\n\ndef truncate\\_chat\\_history(self, max\\_length=2000):\n\n\"\"\"\n\nTruncate the chat history to the last max\\_length characters.\n\n\"\"\"\n\nchat\\_history\\_str = '\\\\n'.join(\\[message\\[\"message\"\\] for message in self.chat\\_history\\])\n\nself.truncated\\_chat\\_history = chat\\_history\\_str\\[-max\\_length:\\]\n\ndef last\\_message(self):\n\nreturn self.chat\\_history\\[-1\\] if self.chat\\_history else None\n\nclass SpeakingQueue:\n\ndef **init**(self):\n\nself.queue = deque()\n\ndef add(self, agent\\_name):\n\nself.queue.append(agent\\_name)\n\ndef pop(self):\n\nif len(self.queue) > 0:\n\nreturn self.queue.pop()\n\nelse:\n\nreturn None\n\ndef enqueue(self, name):\n\nself.queue.append(name)\n\ndef dequeue(self):\n\nreturn self.queue.popleft() if self.queue else None\n\ndef front(self):\n\nreturn self.queue\\[0\\] if self.queue else None\n\ndef remove(self, name):\n\nself.queue.remove(name)\n\ndef contains(self, name):\n\nreturn name in self.queue\n\ndef to\\_json(self):\n\nreturn list(self.queue)\n\nclass SpeakerManager:\n\ndef **init**(self, parliament):\n\nself.parliament = parliament\n\ndef should\\_speak(self, agent):\n\nreturn self.parliament.speaking\\_queue.front() == agent.name\n\nclass OpenAIAgent:\n\ndef **init**(self, initial\\_context: str):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nself.model = \"gpt-3.5-turbo\"\n\nself.initial\\_context = initial\\_context\n\ndef get\\_response(self, chat\\_history):\n\nsystem\\_msg = self.initial\\_context\n\nmessages = \\[{\"role\": \"system\", \"content\": system\\_msg}\\]\n\nfor message in chat\\_history.chat\\_history:\n\nrole = message\\[\"sender\"\\]\n\nmsg = message\\[\"message\"\\]\n\nmessages.append({\"role\": \"assistant\" if role != \"assistant\" else role, \"content\": msg})\n\nmax\\_retries = 3\n\nretry\\_delay = 5\n\nfor i in range(max\\_retries):\n\ntry:\n\n\\# Call the OpenAI API with the messages array\n\nresponse = openai.ChatCompletion.create(\n\nmodel=self.model,\n\nmessages=messages,\n\nmax\\_tokens=150,\n\ntemperature=0.5,\n\ntop\\_p=1,\n\nfrequency\\_penalty=0,\n\npresence\\_penalty=0,\n\n)\n\n\\# Extract and return the assistant's response from the API response\n\nagent\\_response = response.choices\\[0\\].message\\[\"content\"\\].strip()\n\nprint(f\" {agent\\_response}\") # Add logging\n\nreturn agent\\_response\n\nexcept RateLimitError as e:\n\nprint(f\"Rate limit error: {e}. Retrying in {retry\\_delay} seconds...\")\n\nif i < max\\_retries - 1: # Don't sleep on the last iteration\n\ntime.sleep(retry\\_delay)\n\nelse:\n\nraise\n\nreturn \"Sorry, I am unable to respond at the moment.\"\n\nclass GPT4AllAgent:\n\ndef **init**(self):\n\n\\# Download and set up the GPT4All model\n\nself.\\_initialize\\_gpt4all\\_model()\n\nself.\\_initialize\\_llm\\_chain()\n\ndef _initialize_gpt4all\\_model(self):\n\nlocal\\_path = \"/Users/bilalghalib/Projects/scripts/models/ggml-gpt4all-j.bin\"\n\nPath(local\\_path).parent.mkdir(parents=True, exist\\_ok=True)\n\nurl = 'http://gpt4all.io/models/ggml-gpt4all-l13b-snoozy.bin'\n\nresponse = requests.get(url, stream=True)\n\nwith open(local\\_path, 'wb') as f:\n\nfor chunk in tqdm(response.iter\\_content(chunk\\_size=8192)):\n\nif chunk:\n\nf.write(chunk)\n\nself.model\\_path = local\\_path\n\ndef _initialize_llm\\_chain(self):\n\ntemplate = \"\"\"{chat\\_history}\n\nQuestion: {question}\n\nAnswer: Let's think step by step.\"\"\"\n\nprompt = PromptTemplate(template=template, input\\_variables=\\[\"chat\\_history\", \"question\"\\])\n\ncallbacks = \\[StreamingStdOutCallbackHandler()\\]\n\nllm = GPT4All(model=self.model\\_path, callbacks=callbacks, verbose=True)\n\nself.llm\\_chain = LLMChain(prompt=prompt, llm=llm)\n\ndef get\\_response(self, chat\\_history, question):\n\nreturn self.llm\\_chain.run(chat\\_history=chat\\_history, question=question)\n\nclass Parliament:\n\ndef **init**(self, name: str):\n\nself.name = name\n\nself.speaker\\_manager = SpeakerManager(self)\n\nself.agents = {}\n\nself.chat\\_history = ChatHistory()\n\nself.speaking\\_queue = SpeakingQueue()\n\nself.agent\\_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n\nself.typing\\_status = {}\n\ndef set\\_typing\\_status(self, agent\\_name: str, status: bool):\n\nself.typing\\_status\\[agent\\_name\\] = status\n\ndef get\\_typing\\_status(self, agent\\_name: str):\n\nreturn self.typing\\_status.get(agent\\_name, False)\n\nasync def broadcast\\_message(self, message, sender, timestamp):\n\nself.chat\\_history.add(message, sender, timestamp)\n\nmentioned\\_agents = self.identify\\_and\\_tag\\_mentioned\\_agents(message)\n\nself.increment\\_speaking\\_pressure(mentioned\\_agents)\n\nself.update\\_speaking\\_queue()\n\nfor agent in self.agents.values():\n\nif not self.get\\_typing\\_status(agent.name):\n\nawait agent.try\\_to\\_speak()\n\nawait asyncio.sleep(BROADCAST\\_DELAY)\n\nfirst\\_agent\\_in\\_queue = self.speaking\\_queue.dequeue()\n\nif first\\_agent\\_in\\_queue and not self.get\\_typing\\_status(first\\_agent\\_in\\_queue):\n\nawait self.agents\\[first\\_agent\\_in\\_queue\\].speak()\n\ndef add\\_to\\_speaking\\_queue(self, agent):\n\nif not self.speaking\\_queue.contains(agent.name):\n\nself.speaking\\_queue.enqueue(agent.name)\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = SPEAKING\\_PRESSURE\\_LIMIT\n\nself.agents\\[agent\\_name\\].tagged = True\n\nreturn mentioned\\_agents\n\ndef get\\_speaking\\_queue(self):\n\nreturn self.speaking\\_queue\n\ndef add\\_agent(self, agent: Agent):\n\nself.agents\\[agent.name\\] = agent\n\nself.typing\\_status\\[agent.name\\] = False # Initialize typing status when adding an agent\n\nasyncio.create\\_task(agent.increment\\_pressure())\n\ndef remove\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\ndel self.agents\\[agent\\_name\\]\n\ndef get\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\nreturn self.agents\\[agent\\_name\\]\n\ndef add\\_to\\_chat\\_history(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = 100\n\nself.agents\\[agent\\_name\\].tagged = True\n\nprint(f\"Tagged agent: {agent\\_name}\") # Debug print\n\nreturn mentioned\\_agents\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef add\\_tagged\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.tagged and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef add\\_high\\_pressure\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.speaking\\_pressure > 100 and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef trigger\\_next\\_speaker(self):\n\nif self.speaking\\_queue:\n\nnext\\_speaker = self.get\\_agent(self.speaking\\_queue.pop()) # Remove the agent from the queue\n\ndef update\\_speaking\\_queue(self):\n\n\"\"\"Update the speaking queue by calculating relevancy for each agent and adding the most relevant agents to the queue.\"\"\"\n\nmost\\_relevant\\_agent = None\n\nhighest\\_relevancy\\_score = -1\n\nfor agent in self.agents.values():\n\nchat\\_context = self.chat\\_history.truncated\\_chat\\_history\n\nrelevancy\\_score = agent.calculate\\_relevancy(chat\\_context)\n\nif relevancy\\_score > highest\\_relevancy\\_score:\n\nhighest\\_relevancy\\_score = relevancy\\_score\n\nmost\\_relevant\\_agent = agent\n\n\\# Add the most relevant agent to the speaking queue\n\nif most\\_relevant\\_agent:\n\nself.speaking\\_queue.enqueue(most\\_relevant\\_agent.name)\n\nsorted\\_agents = self.get\\_sorted\\_agents\\_based\\_on\\_relevancy()\n\nfor agent in sorted\\_agents\\[:3\\]: # Add the N most relevant agents\n\nself.speaking\\_queue.add(agent.name)\n\nself.add\\_tagged\\_agents\\_to\\_queue()\n\nself.add\\_high\\_pressure\\_agents\\_to\\_queue()\n\nfor agent in self.agents.values():\n\nif agent.tagged and not agent.is\\_speaking:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\nself.trigger\\_next\\_speaker()\n\ndef get\\_sorted\\_agents\\_based\\_on\\_relevancy(self):\n\nreturn sorted(self.agents.values(), key=lambda agent: agent.calculate\\_relevancy(self.chat\\_history), reverse=True)\n\ndef get\\_agents\\_info(self) -> List\\[dict\\]:\n\nagents\\_info = \\[\\]\n\nfor agent\\_name, agent in self.agents.items():\n\nagents\\_info.append({\n\n\"name\": agent\\_name,\n\n\"speaking\\_pressure\": agent.speaking\\_pressure,\n\n\"speaking\\_pressure\\_increment\": agent.speaking\\_pressure\\_increment,\n\n\"context\": agent.context,\n\n\"agent\\_type\": agent.agent\\_type,\n\n\"relevancy\": agent.relevancy\\_score\n\n})\n\nreturn agents\\_info\n\nhere's server.py\n\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\n\nimport openai\n\n\\# Constants\n\nSET\\_PARLIAMENT = \"set\\_parliament\"\n\nSEND\\_MESSAGE = \"send\\_message\"\n\nADD\\_AGENTS = \"add\\_agents\"\n\nUPDATE\\_QUEUE = \"update\\_queue\"\n\nUPDATE\\_AGENTS = \"update\\_agents\"\n\nRECEIVE\\_MESSAGE = \"receive\\_message\"\n\nERROR = \"error\"\n\nTYPING = \"typing\"\n\nSTOPPED\\_TYPING = \"stopped\\_typing\"\n\nclass ParliamentServer:\n\ndef **init**(self, host=\"localhost\", port=8080):\n\nself.host = host\n\nself.port = port\n\nself.parliament = None\n\nself.start\\_server = serve(self.chat, self.host, self.port)\n\ndef configure\\_openai(self):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nasync def chat(self, websocket, path):\n\nasync for message in websocket:\n\ndata = json.loads(message)\n\naction = data.get(\"action\")\n\nif action == SET\\_PARLIAMENT:\n\nawait self.handle\\_set\\_parliament(websocket, data)\n\nelif action == SEND\\_MESSAGE:\n\nawait self.handle\\_send\\_message(websocket, data)\n\nelif action == ADD\\_AGENTS:\n\nawait self.handle\\_add\\_agents(websocket, data)\n\nelif action in \\[TYPING, STOPPED\\_TYPING\\]:\n\nawait self.handle\\_typing(websocket, data)\n\nasync def handle\\_typing(self, websocket, data):\n\nsender = data.get('sender')\n\naction = data.get('action')\n\nis\\_typing = action == TYPING\n\nself.parliament.set\\_typing\\_status(sender, is\\_typing)\n\n\\# Send the typing status update to other clients:\n\nawait websocket.send(json.dumps({\n\n\"action\": action,\n\n\"sender\": sender,\n\n\"is\\_typing\": is\\_typing\n\n}))\n\nasync def handle\\_set\\_parliament(self, websocket, data):\n\nparliament\\_name = data.get(\"name\")\n\nif parliament\\_name:\n\nself.parliament = Parliament(parliament\\_name)\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_send\\_message(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nsender = data.get(\"sender\")\n\nuser\\_message = data.get(\"message\")\n\ntimestamp = datetime.now()\n\nawait websocket.send(json.dumps({\n\n\"action\": RECEIVE\\_MESSAGE,\n\n\"message\": user\\_message,\n\n\"sender\": sender,\n\n\"timestamp\": timestamp.isoformat()}))\n\nawait self.parliament.broadcast\\_message(user\\_message, sender, timestamp)\n\nprint(f\"Broadcast message: {user\\_message}\") # Add logging\n\n\\# Sending agent info after broadcasting message\n\nagent\\_info = self.parliament.get\\_agents\\_info() # Assuming that this method returns agents' information\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_AGENTS, \"agents\": agent\\_info}))\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_add\\_agents(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nagents\\_data = data.get(\"agents\")\n\nif not agents\\_data:\n\nawait self.send\\_error(websocket, \"No agent data provided.\")\n\nreturn\n\nfor agent\\_data in agents\\_data:\n\nagent\\_name = agent\\_data.get(\"name\") # Extract the name\n\nspeaking\\_pressure\\_increment = int(agent\\_data.get(\"speaking\\_pressure\\_increment\"))\n\nother\\_agents = \", \".join(\\[agent\\['name'\\] for agent in agents\\_data if agent\\['name'\\] != agent\\_name\\])\n\ninitial\\_context = (\n\nf\"Hello assistant, your name is: @{agent\\_data.get('name')} and your context is \"\n\nf\"{agent\\_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n\nf\"alongside your fellow agents in a parliament, which is a sort \"\n\nf\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n\nf\"with you are {other\\_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n\nf\"{agent\\_data.get('speaking\\_pressure\\_increment')} out of 100\"\n\n)\n\nagent\\_type = agent\\_data.get(\"type\")\n\nagent\\_class = self.parliament.agent\\_types.get(agent\\_type)\n\nif not agent\\_class:\n\nawait self.send\\_error(websocket, f\"Unknown agent type: {agent\\_type}\")\n\ncontinue\n\nagent\\_instance = OpenAIAgent(initial\\_context) # Create the OpenAIAgent instance\n\nagent = Agent(self.parliament, agent\\_name, speaking\\_pressure\\_increment, initial\\_context, agent\\_type, agent\\_instance, websocket)\n\nself.parliament.add\\_agent(agent) # Pass the agent instance to add\\_agent\n\nawait self.update\\_queue(websocket)\n\nasync def update\\_queue(self, websocket):\n\nif self.parliament:\n\nspeaking\\_queue = self.parliament.get\\_speaking\\_queue()\n\nprint(f\"Queue updated: {speaking\\_queue.to\\_json()}\")\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_QUEUE, \"queue\": speaking\\_queue.to\\_json()}))\n\nasync def send\\_error(self, websocket, message):\n\nawait websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\ndef run(self):\n\nself.configure\\_openai()\n\nasyncio.get\\_event\\_loop().run\\_until\\_complete(self.start\\_server)\n\nprint(\"Starting WebSocket server...\")\n\nprint(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n\nasyncio.get\\_event\\_loop().run\\_forever()\n\nif **name** == \"\\_\\_main\\_\\_\":\n\nserver = ParliamentServer()\n\nserver.run()\n\nand here's settings.js\n\nimport { useState, useEffect } from 'react';\n\nimport { Button, Form, Table } from 'react-bootstrap';\n\nimport presets from './presets.json';\n\nfunction Settings({ onStartParliament, websocket }) {\n\nconst \\[parliamentName, setParliamentName\\] = useState('');\n\nconst \\[topic, setTopic\\] = useState('');\n\nconst \\[username, setUsername\\] = useState('');\n\nconst \\[agents, setAgents\\] = useState(\\[\\]);\n\nconst \\[selectedPreset, setSelectedPreset\\] = useState('');\n\nconst \\[isWebsocketOpen, setIsWebsocketOpen\\] = useState(false);\n\nuseEffect(() => {\n\nif (websocket) {\n\nwebsocket.onopen = () => {\n\nconsole.log(\"WebSocket connection opened.\");\n\nsetIsWebsocketOpen(true);\n\n};\n\nwebsocket.onclose = () => {\n\nconsole.log(\"WebSocket connection closed.\");\n\nsetIsWebsocketOpen(false);\n\n};\n\n}\n\n}, \\[websocket\\]);\n\nfunction addAgent() {\n\nsetAgents((prevAgents) => \\[\n\n...prevAgents,\n\n{ name: '', speaking\\_pressure\\_increment: '', context: '' },\n\n\\]);\n\n}\n\nfunction removeAgent(index) {\n\nsetAgents((prevAgents) => prevAgents.filter((\\_, i) => i !== index));\n\n}\n\nfunction applyPreset(preset) {\n\nsetSelectedPreset(preset);\n\nif (preset) {\n\nconst presetAgents = presets\\[preset\\].agents.map((agent) => ({\n\nname: agent.name,\n\nspeaking\\_pressure\\_increment: agent.pressure,\n\ncontext: agent.context\n\n}));\n\nsetAgents(presetAgents);\n\n} else {\n\nsetAgents(\\[\\]);\n\n}\n\n}\n\nfunction startParliament() {\n\nif (\n\n!parliamentName ||\n\n!topic ||\n\n!username ||\n\nagents.length === 0 ||\n\nagents.some(\n\n(agent) =>\n\n!agent.name || !agent.speaking\\_pressure\\_increment || !agent.context\n\n)\n\n) {\n\nalert('Please fill in all required fields and add at least one valid agent.');\n\nreturn;\n\n}\n\nconst set\\_parliament\\_data = {\n\n\"action\": \"set\\_parliament\",\n\n\"name\": parliamentName\n\n};\n\nwebsocket.send(JSON.stringify(set\\_parliament\\_data));\n\nonStartParliament({\n\nparliamentName,\n\ntopic,\n\nusername,\n\nagents,\n\n});\n\nconst agentData = agents.map(agent => ({\n\n\"name\": agent.name,\n\n\"speaking\\_pressure\\_increment\": agent.speaking\\_pressure\\_increment,\n\n\"context\": agent.context,\n\n\"type\": \"openai\", //\n\n\"agent\\_instance\": 'null', //\n\n}));\n\nconst add\\_agents\\_data = {\n\n\"action\": \"add\\_agents\",\n\n\"agents\": agentData,\n\n\"username\": username,\n\n\"topic\": topic,\n\n};\n\nwebsocket.send(JSON.stringify(add\\_agents\\_data));\n\n}\n\nreturn (\n\n<div>\n\n<h1>Create Parliament</h1>\n\n<Form.Group controlId=\"preset\">\n\n<Form.Label>Select Preset</Form.Label>\n\n<Form.Control\n\nas=\"select\"\n\nvalue={selectedPreset}\n\nonChange={(e) => applyPreset(e.target.value)}\n\n\\>\n\n<option value=\"\">None</option>\n\n{Object.keys(presets).map((presetName) => (\n\n<option key={presetName} value={presetName}>\n\n{presets\\[presetName\\].name}\n\n</option>\n\n))}\n\n</Form.Control>\n\n</Form.Group>\n\n<Form>\n\n<Form.Group controlId=\"parliamentName\">\n\n<Form.Label>Parliament Name</Form.Label>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Enter parliament name\"\n\nvalue={parliamentName}\n\nonChange={(e) => setParliamentName(e.target.value)}\n\n/>\n\n</Form.Group>\n\n<Form.Group controlId=\"topic\">\n\n<Form.Label>Topic of Discussion</Form.Label>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Enter topic\"\n\nvalue={topic}\n\nonChange={(e) => setTopic(e.target.value)}\n\n/>\n\n</Form.Group>\n\n<Form.Group controlId=\"username\">\n\n<Form.Label>Your Name</Form.Label>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Enter your name\"\n\nvalue={username}\n\nonChange={(e) => setUsername(e.target.value)}\n\n/>\n\n</Form.Group>\n\n</Form>\n\n<h2>Agents</h2>\n\n<Table striped bordered hover>\n\n<thead>\n\n<tr>\n\n<th>Name</th>\n\n<th>Speaking Pressure Threshold</th>\n\n<th>Context</th>\n\n<th></th>\n\n</tr>\n\n</thead>\n\n<tbody>\n\n{agents.map((agent, index) => (\n\n<tr key={index}>\n\n<td>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Agent Name\"\n\nvalue={agent.name}\n\nonChange={(e) =>\n\nsetAgents((prevAgents) => {\n\nconst updatedAgents = \\[...prevAgents\\];\n\nupdatedAgents\\[index\\].name = e.target.value;\n\nreturn updatedAgents;\n\n})\n\n}\n\n/>\n\n</td>\n\n<td>\n\n<Form.Control\n\ntype=\"number\"\n\nplaceholder=\"Speaking Pressure Threshold\"\n\nvalue={agent.speaking\\_pressure\\_increment}\n\nonChange={(e) =>\n\nsetAgents((prevAgents) => {\n\nconst updatedAgents = \\[...prevAgents\\];\n\nupdatedAgents\\[index\\].speaking\\_pressure\\_increment = e.target.value;\n\nreturn updatedAgents;\n\n})\n\n}\n\n/>\n\n</td>\n\n<td>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Agent Context\"\n\nvalue={agent.context}\n\nonChange={(e) =>\n\nsetAgents((prevAgents) => {\n\nconst updatedAgents = \\[...prevAgents\\];\n\nupdatedAgents\\[index\\].context = e.target.value;\n\nreturn updatedAgents;\n\n})\n\n}\n\n/>\n\n</td>\n\n<td>\n\n<Button variant=\"danger\" onClick={() => removeAgent(index)}>\n\nRemove\n\n</Button>\n\n</td>\n\n</tr>\n\n))}\n\n</tbody>\n\n</Table>\n\n<Button onClick={addAgent}>Add Agent</Button>\n\n<br />\n\n<br />\n\n<Button onClick={startParliament}>Start Parliament</Button>\n\n</div>\n\n);\n\n}\n\nexport default Settings;",
      "created_at": "2023-05-13T08:15:20.075594Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-13T08:15:20.075594Z",
            "stop_timestamp": "2023-05-13T08:15:20.075594Z",
            "flags": null,
            "type": "text",
            "text": "I'm having issues with the speaking queue in the chat.js\n\nimport styles from './Chat.module.css';\n\nimport { debounce } from 'lodash';\n\nimport { useState, useEffect, useRef, useCallback } from 'react';\n\nimport { ListGroup, Form, Button, Spinner, ListGroupItem } from 'react-bootstrap';\n\nimport { FaTimes, FaReply } from 'react-icons/fa'; // Importing cross and reply icons\n\nimport { MentionsInput, Mention } from 'react-mentions';\n\nfunction Message({ message, sender, handleReply }) {\n\nreturn (\n\n<ListGroup.Item className={styles.messageItem}>\n\n<div className={styles.flexCenter}>\n\n<strong>{sender}:</strong>\n\n<Button\n\nvariant=\"link\"\n\nstyle={{ padding: 0, color: '#007bff', textDecoration: 'none' }}\n\nonClick={() => handleReply(sender)}\n\n\\>\n\n<FaReply />\n\n</Button>\n\n</div>\n\n{message.text}\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction AgentItem({ agent, handleClear, speakingQueue, handleReply }) {\n\nconst queueNumber = speakingQueue.indexOf(agent.name);\n\nreturn (\n\n<ListGroup.Item className={styles.agentItem}>\n\n<span>{agent.relevancy}%</span>\n\n{agent.name}\n\n{queueNumber !== -1 && <span> Queue: {queueNumber + 1}</span>}\n\n<FaReply style={{ color: 'blue', cursor: 'pointer', marginRight: '5px' }} onClick={() => handleReply(agent.name)} /> {/\\* Add this line \\*/}\n\n<FaTimes style={{ color: 'red', cursor: 'pointer' }} onClick={() => handleClear(agent.name)} />\n\n</ListGroup.Item>\n\n);\n\n}\n\nfunction sortAgents(a, b) {\n\nconst aInQueue = speakingQueue.indexOf(a.name) !== -1;\n\nconst bInQueue = speakingQueue.indexOf(b.name) !== -1;\n\nif (aInQueue && bInQueue) {\n\nconst aQueueNumber = speakingQueue.indexOf(a.name);\n\nconst bQueueNumber = speakingQueue.indexOf(b.name);\n\nreturn aQueueNumber - bQueueNumber;\n\n}\n\nelse if (aInQueue) return -1;\n\nelse if (bInQueue) return 1;\n\nreturn a.name.localeCompare(b.name);\n\n}\n\nfunction Chat({ parliament, websocket }) {\n\nconst \\[messages, setMessages\\] = useState(\\[\\]);\n\nconst \\[messageInput, setMessageInput\\] = useState('');\n\nconst \\[isSending, setIsSending\\] = useState(false);\n\nconst \\[agents, setAgents\\] = useState(parliament.agents);\n\nconst \\[speakingQueue, setSpeakingQueue\\] = useState(\\[\\]);\n\nconst chatContainer = useRef(null);\n\nconst \\[isTyping, setIsTyping\\] = useState(false);\n\nconst \\[typingTimeoutId, setTypingTimeoutId\\] = useState(null);\n\nconst debouncedSendTypingStatus = useCallback(debounce(sendTypingStatus, 300), \\[sendTypingStatus\\]);\n\nconst defaultStyle = {\n\nfontWeight: 'bold',\n\ncolor: 'black',\n\nfontSize: '16px',\n\npadding: '10px',\n\nborderRadius: '4px',\n\nborder: '1px solid #ccc',\n\nwidth: '100%',\n\nboxSizing: 'border-box',\n\noutline: 'none',\n\nresize: 'none',\n\n};\n\nfunction handleError(error) {\n\nconsole.error(\"Websocket error: \", error);\n\n}\n\nuseEffect(() => {\n\nif (websocket) {\n\nwebsocket.onmessage = handleReceiveMessage;\n\nwebsocket.onerror = handleError;\n\n}\n\nsetInitialMessages();\n\n}, \\[parliament, websocket\\]);\n\nuseEffect(() => {\n\nsendTypingStatus();\n\n}, \\[isTyping\\]);\n\nuseEffect(() => {\n\nchatContainer.current.scrollTop = chatContainer.current.scrollHeight;\n\n}, \\[messages\\]);\n\nfunction setInitialMessages() {\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages,\n\n{\n\nsender: 'System',\n\ntext: `Parliament is in session, the topic of discussion is: ${parliament.topic}`,\n\n},\n\n{\n\nsender: 'System',\n\ntext: \\`The parliament members are ${parliament.agents\n\n.map((agent) => agent.name)\n\n.join(', ')}, and ${parliament.username}\\`,\n\n},\n\n\\]);\n\n}\n\nfunction handleReceiveMessage(event) {\n\nconst data = JSON.parse(event.data);\n\nconst { action, message, sender, updated\\_agents } = data;\n\nif (action === \"receive\\_message\") {\n\nconst senderIsTyping = messages.some(m => m.sender === sender && m.text === 'typing...');\n\nsetMessages((prevMessages) => \\[\n\n...prevMessages.filter(m => m.sender !== sender || m.text !== 'typing...'),\n\n{ sender, text: message }\n\n\\]);\n\nif (senderIsTyping) {\n\nsetMessages(prevMessages => \\[...prevMessages, { sender, text: 'typing...' }\\]);\n\n}\n\n// Also call setAgents() to update relevancy scores\n\nsetAgents(updated\\_agents);\n\n}\n\nif (action === \"update\\_agents\") {\n\nconst updatedAgents = updated\\_agents.map(agent => {\n\nagent.relevancy = agent.relevancy\\_score;\n\nreturn agent;\n\n});\n\nsetAgents(updatedAgents);\n\n}\n\n}\n\nfunction handleClear(agentName) {\n\n// Send a clear event to the server\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'clear\\_agent',\n\nagent\\_name: agentName,\n\n}),\n\n);\n\n}\n\nfunction sendTypingStatus() {\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'typing',\n\nsender: parliament.username,\n\nis\\_typing: isTyping,\n\n}),\n\n);\n\n}\n\nasync function sendMessage() {\n\nif (!messageInput.trim() || isSending) return;\n\nsetIsSending(true);\n\ntry {\n\nconsole.log(\\`\\[${parliament.username}\\] Sending message to server...\\`);\n\nconsole.log(messageInput.slice(0, 50) + '...');\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'send\\_message',\n\nsender: parliament.username,\n\nmessage: messageInput,\n\n}),\n\n);\n\nconsole.log(\\`\\[${parliament.username}\\] Message sent!\\`);\n\nsetMessageInput('');\n\nsetIsTyping(false);\n\n// Call broadcast\\_message here\n\nconsole.log(\\`\\[${parliament.username}\\] Sending broadcast message to server...\\`);\n\nconsole.log(messageInput.slice(0, 50) + '...');\n\nwebsocket.send(\n\nJSON.stringify({\n\naction: 'broadcast\\_message',\n\nmessage: messageInput,\n\nsender: parliament.username,\n\n}),\n\n);\n\nconsole.log(\\`\\[${parliament.username}\\] Broadcast message sent!\\`);\n\n} catch (error) {\n\nconsole.log(\\`\\[${parliament.username}\\] Failed to send message:\\`, error);\n\n} finally {\n\nsetIsSending(false);\n\n}\n\n}\n\nfunction handleReply(sender) {\n\nsetMessageInput(\\`@${sender} \\`);\n\n}\n\nconst agentNames = agents.map(agent => ({ id: agent.name, display: agent.name }));\n\nreturn (\n\n<div style={{ display: 'flex', gap: '1em' }}>\n\n<div style={{ width: '70%' }}>\n\n<h1>Parliament Chat</h1>\n\n<ListGroup\n\nref={chatContainer}\n\nstyle={{ height: '400px', overflowY: 'scroll' }}>\n\n{messages.map((message, index) => (\n\n<Message\n\nkey={index}\n\nmessage={message}\n\nsender={message.sender}\n\nhandleReply={handleReply}\n\nuser={parliament.username}\n\n/>\n\n))}\n\n</ListGroup>\n\n<Form>\n\n<Form.Group controlId=\"messageInput\">\n\n<MentionsInput\n\nautoFocus\n\nvalue={messageInput}\n\nonChange={(event, value, plainTextValue) => {\n\nsetMessageInput(plainTextValue);\n\nsetIsTyping(true);\n\ndebouncedSendTypingStatus();\n\nclearTimeout(typingTimeoutId);\n\nsetTypingTimeoutId(setTimeout(() => setIsTyping(false), 2000));\n\n}}\n\nonKeyPress={(e) => {\n\nif (e.key === 'Enter') {\n\nsendMessage();\n\ne.preventDefault();\n\n}\n\n}}\n\nplaceholder=\"Type your message...\"\n\nstyle={defaultStyle} // styles for the input field\n\n\\>\n\n<Mention\n\ntrigger=\"@\"\n\ndata={agentNames}\n\ndisplayTransform={(id, display) => `@${display}`}\n\nclassName={styles.mentionStyle} // use your CSS module to style the mentions\n\n/>\n\n</MentionsInput>\n\n</Form.Group>\n\n</Form>\n\n<Button onClick={sendMessage} disabled={isSending}>\n\n{isSending ? <Spinner animation=\"border\" size=\"sm\" /> : 'Send Message'}\n\n</Button>\n\n</div>\n\n<div style={{ width: '20%', marginTop: '25px' }}> {/\\* You can adjust the marginTop as needed \\*/}\n\n<h2 style={{ fontSize: '1em' }}>Agents</h2>\n\n<ListGroup>\n\n{agents.sort(sortAgents).map((agent, index) => (\n\n<AgentItem\n\nkey={index}\n\nagent={agent}\n\nhandleClear={handleClear}\n\nspeakingQueue={speakingQueue}\n\nhandleReply={handleReply}\n\n/>\n\n))}\n\n</ListGroup>\n\n</div>\n\n</div>\n\n);\n\n}\n\nexport default Chat;\n\nHere's parliament.py\n\nimport asyncio\n\nimport random\n\nimport json\n\nimport openai\n\nfrom openai.error import RateLimitError\n\nimport time\n\nfrom typing import List\n\nfrom collections import deque\n\nPRESSURE\\_INCREMENT\\_INTERVAL = 15\n\nSPEAKING\\_PRESSURE\\_LIMIT = 100\n\nBROADCAST\\_DELAY = 10\n\nRELEVANCY\\_THRESHOLD = 100\n\nclass Agent:\n\ndef **init**(self, parliament, agent\\_name, speaking\\_pressure\\_increment, initial\\_context, agent\\_type, agent\\_instance, websocket=None):\n\nself.name = agent\\_name\n\nself.speaking\\_pressure\\_increment = speaking\\_pressure\\_increment\n\nself.context = initial\\_context\n\nself.initial\\_context = initial\\_context\n\nself.speaking\\_pressure = speaking\\_pressure\\_increment\n\nself.tagged = False\n\nself.agent\\_type = agent\\_type\n\nself.agent\\_instance = agent\\_instance\n\nself.websocket = websocket\n\nself.parliament = parliament\n\nself.is\\_speaking = False\n\ndef calculate\\_relevancy(self, chat\\_context: str) -> int:\n\nprint(\"Calculating relevancy...\")\n\nprompt = f\"Given this agent's initial context: '{self.initial\\_context}', and the following conversation: '{chat\\_context}', how relevant do you think the agent is to the current conversation from 0 to 100? Return the result as a number in digits and only the number.\"\n\nmessages = \\[\n\n{\"role\": \"system\", \"content\": self.initial\\_context},\n\n{\"role\": \"assistant\", \"content\": prompt},\n\n{\"role\": \"user\", \"content\": \"Please respond with a number only, even if it's not relevant. If it's not relevant, please enter 0.\"}\n\n\\]\n\nmax\\_attempts = 3\n\nattempt = 1\n\nrelevancy\\_score = None\n\nwhile attempt <= max\\_attempts:\n\ntry:\n\nresponse = openai.ChatCompletion.create(\n\nmodel=self.agent\\_instance.model,\n\nmessages=messages,\n\nmax\\_tokens=300\n\n)\n\nrelevancy\\_score = int(response.choices\\[0\\].message\\['content'\\].strip())\n\nbreak # Break out of the loop if a valid relevancy score is obtained\n\nexcept (ValueError, KeyError):\n\nprint(\"Invalid response received. Please enter a valid number.\")\n\nattempt += 1\n\nif relevancy\\_score is None:\n\nprint(\"Maximum number of attempts reached. Unable to retrieve a valid relevancy score.\")\n\nelse:\n\nprint(f\"Relevancy score for {self.name}: {relevancy\\_score}%\")\n\ntime.sleep(1)\n\nreturn relevancy\\_score\n\ndef should\\_speak(self):\n\nreturn self.parliament.speaker\\_manager.should\\_speak(self) # Call parliament's speaker\\_manager\n\nasync def try\\_to\\_speak(self):\n\nif self.should\\_speak() and not self.is\\_speaking:\n\nawait self.speak()\n\nasync def increment\\_pressure(self):\n\nwhile True:\n\nawait asyncio.sleep(PRESSURE\\_INCREMENT\\_INTERVAL)\n\nself.speaking\\_pressure += self.speaking\\_pressure\\_increment\n\nawait self.try\\_to\\_speak()\n\ndef get\\_agent\\_message(self, chat\\_history):\n\n\"\"\"\n\nGenerate a message from this agent based on the current chat history.\n\n\"\"\"\n\nmessage = \"\"\n\nif isinstance(self.agent\\_instance, self.parliament.agent\\_types\\[self.agent\\_type\\]):\n\nresponse = self.agent\\_instance.get\\_response(chat\\_history)\n\nmessage = f\"{response}\"\n\nreturn message\n\ndef in\\_queue(self):\n\nreturn self.name in self.parliament.speaking\\_queue.queue\n\nasync def speak(self):\n\nself.is\\_speaking = True\n\nawait self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n\nagent\\_message = self.get\\_agent\\_message(self.parliament.chat\\_history)\n\nawait self.websocket.send(json.dumps({\"action\": \"receive\\_message\", \"message\": agent\\_message, \"sender\": self.name}))\n\nself.speaking\\_pressure = 0\n\nself.is\\_speaking = False\n\nif self.in\\_queue():\n\nself.parliament.speaking\\_queue.remove(self.name)\n\ndef reset\\_pressure(self):\n\nself.speaking\\_pressure = 0\n\nclass ChatHistory:\n\ndef **init**(self):\n\nself.chat\\_history = \\[\\]\n\nself.truncated\\_chat\\_history = \\[\\]\n\ndef add(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\nself.truncate\\_chat\\_history()\n\ndef truncate\\_chat\\_history(self, max\\_length=2000):\n\n\"\"\"\n\nTruncate the chat history to the last max\\_length characters.\n\n\"\"\"\n\nchat\\_history\\_str = '\\\\n'.join(\\[message\\[\"message\"\\] for message in self.chat\\_history\\])\n\nself.truncated\\_chat\\_history = chat\\_history\\_str\\[-max\\_length:\\]\n\ndef last\\_message(self):\n\nreturn self.chat\\_history\\[-1\\] if self.chat\\_history else None\n\nclass SpeakingQueue:\n\ndef **init**(self):\n\nself.queue = deque()\n\ndef add(self, agent\\_name):\n\nself.queue.append(agent\\_name)\n\ndef pop(self):\n\nif len(self.queue) > 0:\n\nreturn self.queue.pop()\n\nelse:\n\nreturn None\n\ndef enqueue(self, name):\n\nself.queue.append(name)\n\ndef dequeue(self):\n\nreturn self.queue.popleft() if self.queue else None\n\ndef front(self):\n\nreturn self.queue\\[0\\] if self.queue else None\n\ndef remove(self, name):\n\nself.queue.remove(name)\n\ndef contains(self, name):\n\nreturn name in self.queue\n\ndef to\\_json(self):\n\nreturn list(self.queue)\n\nclass SpeakerManager:\n\ndef **init**(self, parliament):\n\nself.parliament = parliament\n\ndef should\\_speak(self, agent):\n\nreturn self.parliament.speaking\\_queue.front() == agent.name\n\nclass OpenAIAgent:\n\ndef **init**(self, initial\\_context: str):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nself.model = \"gpt-3.5-turbo\"\n\nself.initial\\_context = initial\\_context\n\ndef get\\_response(self, chat\\_history):\n\nsystem\\_msg = self.initial\\_context\n\nmessages = \\[{\"role\": \"system\", \"content\": system\\_msg}\\]\n\nfor message in chat\\_history.chat\\_history:\n\nrole = message\\[\"sender\"\\]\n\nmsg = message\\[\"message\"\\]\n\nmessages.append({\"role\": \"assistant\" if role != \"assistant\" else role, \"content\": msg})\n\nmax\\_retries = 3\n\nretry\\_delay = 5\n\nfor i in range(max\\_retries):\n\ntry:\n\n\\# Call the OpenAI API with the messages array\n\nresponse = openai.ChatCompletion.create(\n\nmodel=self.model,\n\nmessages=messages,\n\nmax\\_tokens=150,\n\ntemperature=0.5,\n\ntop\\_p=1,\n\nfrequency\\_penalty=0,\n\npresence\\_penalty=0,\n\n)\n\n\\# Extract and return the assistant's response from the API response\n\nagent\\_response = response.choices\\[0\\].message\\[\"content\"\\].strip()\n\nprint(f\" {agent\\_response}\") # Add logging\n\nreturn agent\\_response\n\nexcept RateLimitError as e:\n\nprint(f\"Rate limit error: {e}. Retrying in {retry\\_delay} seconds...\")\n\nif i < max\\_retries - 1: # Don't sleep on the last iteration\n\ntime.sleep(retry\\_delay)\n\nelse:\n\nraise\n\nreturn \"Sorry, I am unable to respond at the moment.\"\n\nclass GPT4AllAgent:\n\ndef **init**(self):\n\n\\# Download and set up the GPT4All model\n\nself.\\_initialize\\_gpt4all\\_model()\n\nself.\\_initialize\\_llm\\_chain()\n\ndef _initialize_gpt4all\\_model(self):\n\nlocal\\_path = \"/Users/bilalghalib/Projects/scripts/models/ggml-gpt4all-j.bin\"\n\nPath(local\\_path).parent.mkdir(parents=True, exist\\_ok=True)\n\nurl = 'http://gpt4all.io/models/ggml-gpt4all-l13b-snoozy.bin'\n\nresponse = requests.get(url, stream=True)\n\nwith open(local\\_path, 'wb') as f:\n\nfor chunk in tqdm(response.iter\\_content(chunk\\_size=8192)):\n\nif chunk:\n\nf.write(chunk)\n\nself.model\\_path = local\\_path\n\ndef _initialize_llm\\_chain(self):\n\ntemplate = \"\"\"{chat\\_history}\n\nQuestion: {question}\n\nAnswer: Let's think step by step.\"\"\"\n\nprompt = PromptTemplate(template=template, input\\_variables=\\[\"chat\\_history\", \"question\"\\])\n\ncallbacks = \\[StreamingStdOutCallbackHandler()\\]\n\nllm = GPT4All(model=self.model\\_path, callbacks=callbacks, verbose=True)\n\nself.llm\\_chain = LLMChain(prompt=prompt, llm=llm)\n\ndef get\\_response(self, chat\\_history, question):\n\nreturn self.llm\\_chain.run(chat\\_history=chat\\_history, question=question)\n\nclass Parliament:\n\ndef **init**(self, name: str):\n\nself.name = name\n\nself.speaker\\_manager = SpeakerManager(self)\n\nself.agents = {}\n\nself.chat\\_history = ChatHistory()\n\nself.speaking\\_queue = SpeakingQueue()\n\nself.agent\\_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n\nself.typing\\_status = {}\n\ndef set\\_typing\\_status(self, agent\\_name: str, status: bool):\n\nself.typing\\_status\\[agent\\_name\\] = status\n\ndef get\\_typing\\_status(self, agent\\_name: str):\n\nreturn self.typing\\_status.get(agent\\_name, False)\n\nasync def broadcast\\_message(self, message, sender, timestamp):\n\nself.chat\\_history.add(message, sender, timestamp)\n\nmentioned\\_agents = self.identify\\_and\\_tag\\_mentioned\\_agents(message)\n\nself.increment\\_speaking\\_pressure(mentioned\\_agents)\n\nself.update\\_speaking\\_queue()\n\nfor agent in self.agents.values():\n\nif not self.get\\_typing\\_status(agent.name):\n\nawait agent.try\\_to\\_speak()\n\nawait asyncio.sleep(BROADCAST\\_DELAY)\n\nfirst\\_agent\\_in\\_queue = self.speaking\\_queue.dequeue()\n\nif first\\_agent\\_in\\_queue and not self.get\\_typing\\_status(first\\_agent\\_in\\_queue):\n\nawait self.agents\\[first\\_agent\\_in\\_queue\\].speak()\n\ndef add\\_to\\_speaking\\_queue(self, agent):\n\nif not self.speaking\\_queue.contains(agent.name):\n\nself.speaking\\_queue.enqueue(agent.name)\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = SPEAKING\\_PRESSURE\\_LIMIT\n\nself.agents\\[agent\\_name\\].tagged = True\n\nreturn mentioned\\_agents\n\ndef get\\_speaking\\_queue(self):\n\nreturn self.speaking\\_queue\n\ndef add\\_agent(self, agent: Agent):\n\nself.agents\\[agent.name\\] = agent\n\nself.typing\\_status\\[agent.name\\] = False # Initialize typing status when adding an agent\n\nasyncio.create\\_task(agent.increment\\_pressure())\n\ndef remove\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\ndel self.agents\\[agent\\_name\\]\n\ndef get\\_agent(self, agent\\_name: str):\n\nif agent\\_name not in self.agents:\n\nraise ValueError(f\"Agent '{agent\\_name}' not found.\")\n\nreturn self.agents\\[agent\\_name\\]\n\ndef add\\_to\\_chat\\_history(self, message, sender, timestamp):\n\nself.chat\\_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\ndef identify\\_and\\_tag\\_mentioned\\_agents(self, message):\n\nmentioned\\_agents = \\[\\]\n\nfor agent\\_name in self.agents:\n\nif '@'+agent\\_name in message:\n\nmentioned\\_agents.append(agent\\_name)\n\nself.agents\\[agent\\_name\\].speaking\\_pressure = 100\n\nself.agents\\[agent\\_name\\].tagged = True\n\nprint(f\"Tagged agent: {agent\\_name}\") # Debug print\n\nreturn mentioned\\_agents\n\ndef increment\\_speaking\\_pressure(self, mentioned\\_agents):\n\nfor agent in self.agents.values():\n\nif agent.name not in mentioned\\_agents:\n\nagent.speaking\\_pressure += agent.speaking\\_pressure\\_increment\n\ndef add\\_tagged\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.tagged and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef add\\_high\\_pressure\\_agents\\_to\\_queue(self):\n\nfor agent in self.agents.values():\n\nif agent.speaking\\_pressure > 100 and agent.name not in self.speaking\\_queue.queue:\n\nself.speaking\\_queue.add(agent.name)\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\ndef trigger\\_next\\_speaker(self):\n\nif self.speaking\\_queue:\n\nnext\\_speaker = self.get\\_agent(self.speaking\\_queue.pop()) # Remove the agent from the queue\n\ndef update\\_speaking\\_queue(self):\n\n\"\"\"Update the speaking queue by calculating relevancy for each agent and adding the most relevant agents to the queue.\"\"\"\n\nmost\\_relevant\\_agent = None\n\nhighest\\_relevancy\\_score = -1\n\nfor agent in self.agents.values():\n\nchat\\_context = self.chat\\_history.truncated\\_chat\\_history\n\nrelevancy\\_score = agent.calculate\\_relevancy(chat\\_context)\n\nif relevancy\\_score > highest\\_relevancy\\_score:\n\nhighest\\_relevancy\\_score = relevancy\\_score\n\nmost\\_relevant\\_agent = agent\n\n\\# Add the most relevant agent to the speaking queue\n\nif most\\_relevant\\_agent:\n\nself.speaking\\_queue.enqueue(most\\_relevant\\_agent.name)\n\nsorted\\_agents = self.get\\_sorted\\_agents\\_based\\_on\\_relevancy()\n\nfor agent in sorted\\_agents\\[:3\\]: # Add the N most relevant agents\n\nself.speaking\\_queue.add(agent.name)\n\nself.add\\_tagged\\_agents\\_to\\_queue()\n\nself.add\\_high\\_pressure\\_agents\\_to\\_queue()\n\nfor agent in self.agents.values():\n\nif agent.tagged and not agent.is\\_speaking:\n\nself.add\\_to\\_speaking\\_queue(agent)\n\nagent.tagged = False\n\nagent.speaking\\_pressure = 0 # Reset speaking pressure\n\nself.trigger\\_next\\_speaker()\n\ndef get\\_sorted\\_agents\\_based\\_on\\_relevancy(self):\n\nreturn sorted(self.agents.values(), key=lambda agent: agent.calculate\\_relevancy(self.chat\\_history), reverse=True)\n\ndef get\\_agents\\_info(self) -> List\\[dict\\]:\n\nagents\\_info = \\[\\]\n\nfor agent\\_name, agent in self.agents.items():\n\nagents\\_info.append({\n\n\"name\": agent\\_name,\n\n\"speaking\\_pressure\": agent.speaking\\_pressure,\n\n\"speaking\\_pressure\\_increment\": agent.speaking\\_pressure\\_increment,\n\n\"context\": agent.context,\n\n\"agent\\_type\": agent.agent\\_type,\n\n\"relevancy\": agent.relevancy\\_score\n\n})\n\nreturn agents\\_info\n\nhere's server.py\n\nfrom datetime import datetime\n\nimport asyncio\n\nimport json\n\nfrom websockets import serve\n\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\n\nimport openai\n\n\\# Constants\n\nSET\\_PARLIAMENT = \"set\\_parliament\"\n\nSEND\\_MESSAGE = \"send\\_message\"\n\nADD\\_AGENTS = \"add\\_agents\"\n\nUPDATE\\_QUEUE = \"update\\_queue\"\n\nUPDATE\\_AGENTS = \"update\\_agents\"\n\nRECEIVE\\_MESSAGE = \"receive\\_message\"\n\nERROR = \"error\"\n\nTYPING = \"typing\"\n\nSTOPPED\\_TYPING = \"stopped\\_typing\"\n\nclass ParliamentServer:\n\ndef **init**(self, host=\"localhost\", port=8080):\n\nself.host = host\n\nself.port = port\n\nself.parliament = None\n\nself.start\\_server = serve(self.chat, self.host, self.port)\n\ndef configure\\_openai(self):\n\nopenai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n\nopenai.api\\_key = \"sk-XXXXXXXXXXXXXXXXXXXX_REDACTED_REDACTED_REDACTED\"\n\nasync def chat(self, websocket, path):\n\nasync for message in websocket:\n\ndata = json.loads(message)\n\naction = data.get(\"action\")\n\nif action == SET\\_PARLIAMENT:\n\nawait self.handle\\_set\\_parliament(websocket, data)\n\nelif action == SEND\\_MESSAGE:\n\nawait self.handle\\_send\\_message(websocket, data)\n\nelif action == ADD\\_AGENTS:\n\nawait self.handle\\_add\\_agents(websocket, data)\n\nelif action in \\[TYPING, STOPPED\\_TYPING\\]:\n\nawait self.handle\\_typing(websocket, data)\n\nasync def handle\\_typing(self, websocket, data):\n\nsender = data.get('sender')\n\naction = data.get('action')\n\nis\\_typing = action == TYPING\n\nself.parliament.set\\_typing\\_status(sender, is\\_typing)\n\n\\# Send the typing status update to other clients:\n\nawait websocket.send(json.dumps({\n\n\"action\": action,\n\n\"sender\": sender,\n\n\"is\\_typing\": is\\_typing\n\n}))\n\nasync def handle\\_set\\_parliament(self, websocket, data):\n\nparliament\\_name = data.get(\"name\")\n\nif parliament\\_name:\n\nself.parliament = Parliament(parliament\\_name)\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_send\\_message(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nsender = data.get(\"sender\")\n\nuser\\_message = data.get(\"message\")\n\ntimestamp = datetime.now()\n\nawait websocket.send(json.dumps({\n\n\"action\": RECEIVE\\_MESSAGE,\n\n\"message\": user\\_message,\n\n\"sender\": sender,\n\n\"timestamp\": timestamp.isoformat()}))\n\nawait self.parliament.broadcast\\_message(user\\_message, sender, timestamp)\n\nprint(f\"Broadcast message: {user\\_message}\") # Add logging\n\n\\# Sending agent info after broadcasting message\n\nagent\\_info = self.parliament.get\\_agents\\_info() # Assuming that this method returns agents' information\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_AGENTS, \"agents\": agent\\_info}))\n\nawait self.update\\_queue(websocket)\n\nasync def handle\\_add\\_agents(self, websocket, data):\n\nif not self.parliament:\n\nawait self.send\\_error(websocket, \"Parliament not set.\")\n\nreturn\n\nagents\\_data = data.get(\"agents\")\n\nif not agents\\_data:\n\nawait self.send\\_error(websocket, \"No agent data provided.\")\n\nreturn\n\nfor agent\\_data in agents\\_data:\n\nagent\\_name = agent\\_data.get(\"name\") # Extract the name\n\nspeaking\\_pressure\\_increment = int(agent\\_data.get(\"speaking\\_pressure\\_increment\"))\n\nother\\_agents = \", \".join(\\[agent\\['name'\\] for agent in agents\\_data if agent\\['name'\\] != agent\\_name\\])\n\ninitial\\_context = (\n\nf\"Hello assistant, your name is: @{agent\\_data.get('name')} and your context is \"\n\nf\"{agent\\_data.get('context')}. Your job is to help {data.get('username')} by discussing {data.get('topic')} \"\n\nf\"alongside your fellow agents in a parliament, which is a sort \"\n\nf\"of town hall or large meeting, called {self.parliament.name}. The other agents discussing \"\n\nf\"with you are {other\\_agents}, please prefix their name with an @ when mentioning them, and don't @mention yourself. Your talkativity is \"\n\nf\"{agent\\_data.get('speaking\\_pressure\\_increment')} out of 100\"\n\n)\n\nagent\\_type = agent\\_data.get(\"type\")\n\nagent\\_class = self.parliament.agent\\_types.get(agent\\_type)\n\nif not agent\\_class:\n\nawait self.send\\_error(websocket, f\"Unknown agent type: {agent\\_type}\")\n\ncontinue\n\nagent\\_instance = OpenAIAgent(initial\\_context) # Create the OpenAIAgent instance\n\nagent = Agent(self.parliament, agent\\_name, speaking\\_pressure\\_increment, initial\\_context, agent\\_type, agent\\_instance, websocket)\n\nself.parliament.add\\_agent(agent) # Pass the agent instance to add\\_agent\n\nawait self.update\\_queue(websocket)\n\nasync def update\\_queue(self, websocket):\n\nif self.parliament:\n\nspeaking\\_queue = self.parliament.get\\_speaking\\_queue()\n\nprint(f\"Queue updated: {speaking\\_queue.to\\_json()}\")\n\nawait websocket.send(json.dumps({\"action\": UPDATE\\_QUEUE, \"queue\": speaking\\_queue.to\\_json()}))\n\nasync def send\\_error(self, websocket, message):\n\nawait websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\ndef run(self):\n\nself.configure\\_openai()\n\nasyncio.get\\_event\\_loop().run\\_until\\_complete(self.start\\_server)\n\nprint(\"Starting WebSocket server...\")\n\nprint(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n\nasyncio.get\\_event\\_loop().run\\_forever()\n\nif **name** == \"\\_\\_main\\_\\_\":\n\nserver = ParliamentServer()\n\nserver.run()\n\nand here's settings.js\n\nimport { useState, useEffect } from 'react';\n\nimport { Button, Form, Table } from 'react-bootstrap';\n\nimport presets from './presets.json';\n\nfunction Settings({ onStartParliament, websocket }) {\n\nconst \\[parliamentName, setParliamentName\\] = useState('');\n\nconst \\[topic, setTopic\\] = useState('');\n\nconst \\[username, setUsername\\] = useState('');\n\nconst \\[agents, setAgents\\] = useState(\\[\\]);\n\nconst \\[selectedPreset, setSelectedPreset\\] = useState('');\n\nconst \\[isWebsocketOpen, setIsWebsocketOpen\\] = useState(false);\n\nuseEffect(() => {\n\nif (websocket) {\n\nwebsocket.onopen = () => {\n\nconsole.log(\"WebSocket connection opened.\");\n\nsetIsWebsocketOpen(true);\n\n};\n\nwebsocket.onclose = () => {\n\nconsole.log(\"WebSocket connection closed.\");\n\nsetIsWebsocketOpen(false);\n\n};\n\n}\n\n}, \\[websocket\\]);\n\nfunction addAgent() {\n\nsetAgents((prevAgents) => \\[\n\n...prevAgents,\n\n{ name: '', speaking\\_pressure\\_increment: '', context: '' },\n\n\\]);\n\n}\n\nfunction removeAgent(index) {\n\nsetAgents((prevAgents) => prevAgents.filter((\\_, i) => i !== index));\n\n}\n\nfunction applyPreset(preset) {\n\nsetSelectedPreset(preset);\n\nif (preset) {\n\nconst presetAgents = presets\\[preset\\].agents.map((agent) => ({\n\nname: agent.name,\n\nspeaking\\_pressure\\_increment: agent.pressure,\n\ncontext: agent.context\n\n}));\n\nsetAgents(presetAgents);\n\n} else {\n\nsetAgents(\\[\\]);\n\n}\n\n}\n\nfunction startParliament() {\n\nif (\n\n!parliamentName ||\n\n!topic ||\n\n!username ||\n\nagents.length === 0 ||\n\nagents.some(\n\n(agent) =>\n\n!agent.name || !agent.speaking\\_pressure\\_increment || !agent.context\n\n)\n\n) {\n\nalert('Please fill in all required fields and add at least one valid agent.');\n\nreturn;\n\n}\n\nconst set\\_parliament\\_data = {\n\n\"action\": \"set\\_parliament\",\n\n\"name\": parliamentName\n\n};\n\nwebsocket.send(JSON.stringify(set\\_parliament\\_data));\n\nonStartParliament({\n\nparliamentName,\n\ntopic,\n\nusername,\n\nagents,\n\n});\n\nconst agentData = agents.map(agent => ({\n\n\"name\": agent.name,\n\n\"speaking\\_pressure\\_increment\": agent.speaking\\_pressure\\_increment,\n\n\"context\": agent.context,\n\n\"type\": \"openai\", //\n\n\"agent\\_instance\": 'null', //\n\n}));\n\nconst add\\_agents\\_data = {\n\n\"action\": \"add\\_agents\",\n\n\"agents\": agentData,\n\n\"username\": username,\n\n\"topic\": topic,\n\n};\n\nwebsocket.send(JSON.stringify(add\\_agents\\_data));\n\n}\n\nreturn (\n\n<div>\n\n<h1>Create Parliament</h1>\n\n<Form.Group controlId=\"preset\">\n\n<Form.Label>Select Preset</Form.Label>\n\n<Form.Control\n\nas=\"select\"\n\nvalue={selectedPreset}\n\nonChange={(e) => applyPreset(e.target.value)}\n\n\\>\n\n<option value=\"\">None</option>\n\n{Object.keys(presets).map((presetName) => (\n\n<option key={presetName} value={presetName}>\n\n{presets\\[presetName\\].name}\n\n</option>\n\n))}\n\n</Form.Control>\n\n</Form.Group>\n\n<Form>\n\n<Form.Group controlId=\"parliamentName\">\n\n<Form.Label>Parliament Name</Form.Label>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Enter parliament name\"\n\nvalue={parliamentName}\n\nonChange={(e) => setParliamentName(e.target.value)}\n\n/>\n\n</Form.Group>\n\n<Form.Group controlId=\"topic\">\n\n<Form.Label>Topic of Discussion</Form.Label>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Enter topic\"\n\nvalue={topic}\n\nonChange={(e) => setTopic(e.target.value)}\n\n/>\n\n</Form.Group>\n\n<Form.Group controlId=\"username\">\n\n<Form.Label>Your Name</Form.Label>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Enter your name\"\n\nvalue={username}\n\nonChange={(e) => setUsername(e.target.value)}\n\n/>\n\n</Form.Group>\n\n</Form>\n\n<h2>Agents</h2>\n\n<Table striped bordered hover>\n\n<thead>\n\n<tr>\n\n<th>Name</th>\n\n<th>Speaking Pressure Threshold</th>\n\n<th>Context</th>\n\n<th></th>\n\n</tr>\n\n</thead>\n\n<tbody>\n\n{agents.map((agent, index) => (\n\n<tr key={index}>\n\n<td>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Agent Name\"\n\nvalue={agent.name}\n\nonChange={(e) =>\n\nsetAgents((prevAgents) => {\n\nconst updatedAgents = \\[...prevAgents\\];\n\nupdatedAgents\\[index\\].name = e.target.value;\n\nreturn updatedAgents;\n\n})\n\n}\n\n/>\n\n</td>\n\n<td>\n\n<Form.Control\n\ntype=\"number\"\n\nplaceholder=\"Speaking Pressure Threshold\"\n\nvalue={agent.speaking\\_pressure\\_increment}\n\nonChange={(e) =>\n\nsetAgents((prevAgents) => {\n\nconst updatedAgents = \\[...prevAgents\\];\n\nupdatedAgents\\[index\\].speaking\\_pressure\\_increment = e.target.value;\n\nreturn updatedAgents;\n\n})\n\n}\n\n/>\n\n</td>\n\n<td>\n\n<Form.Control\n\ntype=\"text\"\n\nplaceholder=\"Agent Context\"\n\nvalue={agent.context}\n\nonChange={(e) =>\n\nsetAgents((prevAgents) => {\n\nconst updatedAgents = \\[...prevAgents\\];\n\nupdatedAgents\\[index\\].context = e.target.value;\n\nreturn updatedAgents;\n\n})\n\n}\n\n/>\n\n</td>\n\n<td>\n\n<Button variant=\"danger\" onClick={() => removeAgent(index)}>\n\nRemove\n\n</Button>\n\n</td>\n\n</tr>\n\n))}\n\n</tbody>\n\n</Table>\n\n<Button onClick={addAgent}>Add Agent</Button>\n\n<br />\n\n<br />\n\n<Button onClick={startParliament}>Start Parliament</Button>\n\n</div>\n\n);\n\n}\n\nexport default Settings;",
            "citations": []
          }
        ],
        "updated_at": "2023-05-13T08:15:20.075594Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "20498a30-2b9f-4e4b-86e3-7ec948bc65ad",
      "role": "assistant",
      "content": " The issue seems to be in the handleReply() method in Chat.js. Currently, when you click the reply icon next to an agent's name, it simply prepends @ and the agent's name to the message input. However, this does not actually tag the agent or increment their speaking pressure.\n\nTo fix this, handleReply() should do the following:\n\n1. Prepend @agentName to the message input as it currently does.\n\n2. Call identifyAndTagMentionedAgents() on the parliament instance to tag the agent.\n\n3. Increment the agent's speaking pressure to 100.\n\n4. Add the agent to the speaking queue.\n\nThe updated handleReply() method would be:\n\n```js\nfunction handleReply(sender) {\n  setMessageInput(`@${sender} `);\n  \n  parliament.identifyAndTagMentionedAgents(sender);\n  \n  parliament.getAgent(sender).speakingPressure = 100;\n  \n  parliament.addAgentToSpeakingQueue(parliament.getAgent(sender));\n}\n```\n\nThis will properly tag the agent, increment their pressure and add them to the speaking queue when you click the reply icon.\n\nLet me know if this helps resolve the issues you were having with the speaking queue!",
      "created_at": "2023-05-13T08:15:33.917050Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-13T08:15:33.917050Z",
            "stop_timestamp": "2023-05-13T08:15:33.917050Z",
            "flags": null,
            "type": "text",
            "text": " The issue seems to be in the handleReply() method in Chat.js. Currently, when you click the reply icon next to an agent's name, it simply prepends @ and the agent's name to the message input. However, this does not actually tag the agent or increment their speaking pressure.\n\nTo fix this, handleReply() should do the following:\n\n1. Prepend @agentName to the message input as it currently does.\n\n2. Call identifyAndTagMentionedAgents() on the parliament instance to tag the agent.\n\n3. Increment the agent's speaking pressure to 100.\n\n4. Add the agent to the speaking queue.\n\nThe updated handleReply() method would be:\n\n```js\nfunction handleReply(sender) {\n  setMessageInput(`@${sender} `);\n  \n  parliament.identifyAndTagMentionedAgents(sender);\n  \n  parliament.getAgent(sender).speakingPressure = 100;\n  \n  parliament.addAgentToSpeakingQueue(parliament.getAgent(sender));\n}\n```\n\nThis will properly tag the agent, increment their pressure and add them to the speaking queue when you click the reply icon.\n\nLet me know if this helps resolve the issues you were having with the speaking queue!",
            "citations": []
          }
        ],
        "updated_at": "2023-05-13T08:15:33.917050Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "58ca4022-b5ed-4226-9447-fac7f907758a",
      "role": "human",
      "content": "getting this issue: **Unhandled Runtime Error**\n\n**ReferenceError: Can't find variable: speakingQueue**\n\n##### **Call Stack**\n\n###### **sort**\n\n\\[native code\\]\n\n###### **dispatchEvent**\n\n\\[native code\\]\n\n###### **performSyncWorkOnRoot**",
      "created_at": "2023-05-13T08:17:13.615520Z",
      "sequence_order": 2,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-13T08:17:13.615520Z",
            "stop_timestamp": "2023-05-13T08:17:13.615520Z",
            "flags": null,
            "type": "text",
            "text": "getting this issue: **Unhandled Runtime Error**\n\n**ReferenceError: Can't find variable: speakingQueue**\n\n##### **Call Stack**\n\n###### **sort**\n\n\\[native code\\]\n\n###### **dispatchEvent**\n\n\\[native code\\]\n\n###### **performSyncWorkOnRoot**",
            "citations": []
          }
        ],
        "updated_at": "2023-05-13T08:17:13.615520Z",
        "attachments": [],
        "files": []
      }
    },
    {
      "id": "b9f074a2-7600-4dc5-85bb-7e9e6869a00d",
      "role": "assistant",
      "content": " Ah I see, it looks like speakingQueue is undefined in that context. There are a few ways to fix this:\n\n1. Pass the speakingQueue as an argument to the component/function that is throwing the error:\n\n```js\nfunction Component({ speakingQueue }) {\n  // Use speakingQueue here\n}\n```\n\nThen when calling the component, pass the parliament's speakingQueue:\n\n```js\n<Component speakingQueue={parliament.speakingQueue} /> \n```\n\n2. Store the speakingQueue in a context and access it from the context in the component:\n\n```js\nconst SpeakingQueueContext = React.createContext();\n\nfunction ParliamentProvider({ children }) {\n  const [speakingQueue, setSpeakingQueue] = useState(null);\n  \n  // ...\n  \n  return (\n    <SpeakingQueueContext.Provider value={speakingQueue}>\n      {children}\n    </SpeakingQueueContext.Provider>\n  )\n}\n\nfunction Component() {\n  const speakingQueue = useContext(SpeakingQueueContext);\n  // Use speakingQueue here\n}\n```\n\n3. Define speakingQueue as a global or module variable that the component can access:\n\n```js\n// Somewhere at the top \nlet speakingQueue;\n\nfunction setSpeakingQueue(queue) {\n  speakingQueue = queue;\n}\n\nfunction Component() {\n  // Use speakingQueue here\n} \n```\n\nThen call `setSpeakingQueue(parliament.speakingQueue);` to make it available to the Component.\n\nAny of these options should resolve the ReferenceError you're seeing by providing the proper context for accessing the speakingQueue. Let me know if you have any other questions!",
      "created_at": "2023-05-13T08:17:29.286086Z",
      "sequence_order": 3,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2023-05-13T08:17:29.286086Z",
            "stop_timestamp": "2023-05-13T08:17:29.286086Z",
            "flags": null,
            "type": "text",
            "text": " Ah I see, it looks like speakingQueue is undefined in that context. There are a few ways to fix this:\n\n1. Pass the speakingQueue as an argument to the component/function that is throwing the error:\n\n```js\nfunction Component({ speakingQueue }) {\n  // Use speakingQueue here\n}\n```\n\nThen when calling the component, pass the parliament's speakingQueue:\n\n```js\n<Component speakingQueue={parliament.speakingQueue} /> \n```\n\n2. Store the speakingQueue in a context and access it from the context in the component:\n\n```js\nconst SpeakingQueueContext = React.createContext();\n\nfunction ParliamentProvider({ children }) {\n  const [speakingQueue, setSpeakingQueue] = useState(null);\n  \n  // ...\n  \n  return (\n    <SpeakingQueueContext.Provider value={speakingQueue}>\n      {children}\n    </SpeakingQueueContext.Provider>\n  )\n}\n\nfunction Component() {\n  const speakingQueue = useContext(SpeakingQueueContext);\n  // Use speakingQueue here\n}\n```\n\n3. Define speakingQueue as a global or module variable that the component can access:\n\n```js\n// Somewhere at the top \nlet speakingQueue;\n\nfunction setSpeakingQueue(queue) {\n  speakingQueue = queue;\n}\n\nfunction Component() {\n  // Use speakingQueue here\n} \n```\n\nThen call `setSpeakingQueue(parliament.speakingQueue);` to make it available to the Component.\n\nAny of these options should resolve the ReferenceError you're seeing by providing the proper context for accessing the speakingQueue. Let me know if you have any other questions!",
            "citations": []
          }
        ],
        "updated_at": "2023-05-13T08:17:29.286086Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}