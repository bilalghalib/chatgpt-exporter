{
  "id": "842a8b0c-205d-437c-a8e3-8cf14bb11144",
  "source": "claude",
  "title": "Troubleshooting Terminal Commands and API Integration",
  "created_at": "2025-05-14T05:57:26.968551Z",
  "updated_at": "2025-05-14T05:58:26.966166Z",
  "summary": "",
  "message_count": 2,
  "messages": [
    {
      "id": "da9222c0-2441-456b-a858-890068397a07",
      "role": "human",
      "content": "what do you think of these terminal results from your suggestions and thi splan: zsh: command not found: # zsh: command not found: # (node:67987) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead. (Use `node --trace-deprecation ...` to show where the warning was created)  **○** Compiling /api/langchain/memory/extract ...  **✓** Compiled /api/langchain/memory/extract in 4.4s (800 modules) Rate limiting is not configured, allowing request  POST /api/langchain/memory/extract 200 in 13688ms API Response: {   \"success\": true,   \"data\": {     \"newMemories\": [       {         \"content\": \"The user is planning a trip to Japan next month\",         \"rationale\": \"This reveals the user's immediate future plans and interest in travel, specifically to Japan\",         \"confidence\": 0.95,         \"category\": \"goal\",         \"id\": \"CTKrx1eDJZO_CXfv5vI1K\",         \"timestamp\": \"2025-05-14T05:54:46.978Z\",         \"source\": \"conversation\"       },       {         \"content\": \"The user has been learning Japanese for two years\",         \"rationale\": \"This shows a significant time investment in learning a language, indicating strong interest in Japanese culture and commitment to personal development\",         \"confidence\": 0.9,         \"category\": \"knowledge\",         \"id\": \"B855n4KsWLjIWnTTfHoyT\",         \"timestamp\": \"2025-05-14T05:54:46.978Z\",         \"source\": \"conversation\"       },       {         \"content\": \"The user is excited about their upcoming trip\",         \"rationale\": \"This reveals the user's emotional state and enthusiasm for travel and new experiences\",         \"confidence\": 0.8,         \"category\": \"personality\",         \"id\": \"fvCXF7bR23dZ849QjJjX_\",         \"timestamp\": \"2025-05-14T05:54:46.978Z\",         \"source\": \"conversation\"       }     ],     \"reasoning\": \"The user's message provides clear information about their immediate plans, long-term interests, and emotional state. The upcoming trip to Japan is a concrete goal, while the two years of language study demonstrate sustained interest and knowledge acquisition. The expressed excitement gives insight into their personality and attitude towards new experiences. These pieces of information are highly relevant for understanding the user's interests, goals, and character.\"   } } Test passed: true (base) bilalghalib@Cruzer-2 cursive-app %\n\nCan you give me files to replace in full zsh: command not found: #\nzsh: command not found: #\n(node:67987) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.\n(Use `node --trace-deprecation ...` to show where the warning was created)\n **○** Compiling /api/langchain/memory/extract ...\n **✓** Compiled /api/langchain/memory/extract in 4.4s (800 modules)\nRate limiting is not configured, allowing request\n POST /api/langchain/memory/extract 200 in 13688ms\nAPI Response: {\n  \"success\": true,\n  \"data\": {\n    \"newMemories\": [\n      {\n        \"content\": \"The user is planning a trip to Japan next month\",\n        \"rationale\": \"This reveals the user's immediate future plans and interest in travel, specifically to Japan\",\n        \"confidence\": 0.95,\n        \"category\": \"goal\",\n        \"id\": \"CTKrx1eDJZO_CXfv5vI1K\",\n        \"timestamp\": \"2025-05-14T05:54:46.978Z\",\n        \"source\": \"conversation\"\n      },\n      {\n        \"content\": \"The user has been learning Japanese for two years\",\n        \"rationale\": \"This shows a significant time investment in learning a language, indicating strong interest in Japanese culture and commitment to personal development\",\n        \"confidence\": 0.9,\n        \"category\": \"knowledge\",\n        \"id\": \"B855n4KsWLjIWnTTfHoyT\",\n        \"timestamp\": \"2025-05-14T05:54:46.978Z\",\n        \"source\": \"conversation\"\n      },\n      {\n        \"content\": \"The user is excited about their upcoming trip\",\n        \"rationale\": \"This reveals the user's emotional state and enthusiasm for travel and new experiences\",\n        \"confidence\": 0.8,\n        \"category\": \"personality\",\n        \"id\": \"fvCXF7bR23dZ849QjJjX_\",\n        \"timestamp\": \"2025-05-14T05:54:46.978Z\",\n        \"source\": \"conversation\"\n      }\n    ],\n    \"reasoning\": \"The user's message provides clear information about their immediate plans, long-term interests, and emotional state. The upcoming trip to Japan is a concrete goal, while the two years of language study demonstrate sustained interest and knowledge acquisition. The expressed excitement gives insight into their personality and attitude towards new experiences. These pieces of information are highly relevant for understanding the user's interests, goals, and character.\"\n  }\n}\nTest passed: true\n(base) bilalghalib@Cruzer-2 cursive-app %",
      "created_at": "2025-05-14T05:57:29.224220Z",
      "sequence_order": 0,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-14T05:57:29.220720Z",
            "stop_timestamp": "2025-05-14T05:57:29.220720Z",
            "flags": null,
            "type": "text",
            "text": "what do you think of these terminal results from your suggestions and thi splan: zsh: command not found: # zsh: command not found: # (node:67987) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead. (Use `node --trace-deprecation ...` to show where the warning was created)  **○** Compiling /api/langchain/memory/extract ...  **✓** Compiled /api/langchain/memory/extract in 4.4s (800 modules) Rate limiting is not configured, allowing request  POST /api/langchain/memory/extract 200 in 13688ms API Response: {   \"success\": true,   \"data\": {     \"newMemories\": [       {         \"content\": \"The user is planning a trip to Japan next month\",         \"rationale\": \"This reveals the user's immediate future plans and interest in travel, specifically to Japan\",         \"confidence\": 0.95,         \"category\": \"goal\",         \"id\": \"CTKrx1eDJZO_CXfv5vI1K\",         \"timestamp\": \"2025-05-14T05:54:46.978Z\",         \"source\": \"conversation\"       },       {         \"content\": \"The user has been learning Japanese for two years\",         \"rationale\": \"This shows a significant time investment in learning a language, indicating strong interest in Japanese culture and commitment to personal development\",         \"confidence\": 0.9,         \"category\": \"knowledge\",         \"id\": \"B855n4KsWLjIWnTTfHoyT\",         \"timestamp\": \"2025-05-14T05:54:46.978Z\",         \"source\": \"conversation\"       },       {         \"content\": \"The user is excited about their upcoming trip\",         \"rationale\": \"This reveals the user's emotional state and enthusiasm for travel and new experiences\",         \"confidence\": 0.8,         \"category\": \"personality\",         \"id\": \"fvCXF7bR23dZ849QjJjX_\",         \"timestamp\": \"2025-05-14T05:54:46.978Z\",         \"source\": \"conversation\"       }     ],     \"reasoning\": \"The user's message provides clear information about their immediate plans, long-term interests, and emotional state. The upcoming trip to Japan is a concrete goal, while the two years of language study demonstrate sustained interest and knowledge acquisition. The expressed excitement gives insight into their personality and attitude towards new experiences. These pieces of information are highly relevant for understanding the user's interests, goals, and character.\"   } } Test passed: true (base) bilalghalib@Cruzer-2 cursive-app %\n\nCan you give me files to replace in full zsh: command not found: #\nzsh: command not found: #\n(node:67987) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.\n(Use `node --trace-deprecation ...` to show where the warning was created)\n **○** Compiling /api/langchain/memory/extract ...\n **✓** Compiled /api/langchain/memory/extract in 4.4s (800 modules)\nRate limiting is not configured, allowing request\n POST /api/langchain/memory/extract 200 in 13688ms\nAPI Response: {\n  \"success\": true,\n  \"data\": {\n    \"newMemories\": [\n      {\n        \"content\": \"The user is planning a trip to Japan next month\",\n        \"rationale\": \"This reveals the user's immediate future plans and interest in travel, specifically to Japan\",\n        \"confidence\": 0.95,\n        \"category\": \"goal\",\n        \"id\": \"CTKrx1eDJZO_CXfv5vI1K\",\n        \"timestamp\": \"2025-05-14T05:54:46.978Z\",\n        \"source\": \"conversation\"\n      },\n      {\n        \"content\": \"The user has been learning Japanese for two years\",\n        \"rationale\": \"This shows a significant time investment in learning a language, indicating strong interest in Japanese culture and commitment to personal development\",\n        \"confidence\": 0.9,\n        \"category\": \"knowledge\",\n        \"id\": \"B855n4KsWLjIWnTTfHoyT\",\n        \"timestamp\": \"2025-05-14T05:54:46.978Z\",\n        \"source\": \"conversation\"\n      },\n      {\n        \"content\": \"The user is excited about their upcoming trip\",\n        \"rationale\": \"This reveals the user's emotional state and enthusiasm for travel and new experiences\",\n        \"confidence\": 0.8,\n        \"category\": \"personality\",\n        \"id\": \"fvCXF7bR23dZ849QjJjX_\",\n        \"timestamp\": \"2025-05-14T05:54:46.978Z\",\n        \"source\": \"conversation\"\n      }\n    ],\n    \"reasoning\": \"The user's message provides clear information about their immediate plans, long-term interests, and emotional state. The upcoming trip to Japan is a concrete goal, while the two years of language study demonstrate sustained interest and knowledge acquisition. The expressed excitement gives insight into their personality and attitude towards new experiences. These pieces of information are highly relevant for understanding the user's interests, goals, and character.\"\n  }\n}\nTest passed: true\n(base) bilalghalib@Cruzer-2 cursive-app %",
            "citations": []
          }
        ],
        "updated_at": "2025-05-14T05:57:29.224220Z",
        "attachments": [
          {
            "file_name": "paste.txt",
            "file_size": 15418,
            "file_type": "txt",
            "extracted_content": "this is what we tried, how can i confirm it's working and how do i evolve the project, can you give me a terminal code to give you all the files oyu need to review exported into a .txt? # LangChain Migration to Server-Only API Routes\n## Migration Overview\nThis document outlines the migration of all LangChain and other server-side only code to API routes in our Next.js application. This approach resolves build and runtime errors related to running server-only packages in client environments.\n## Completed Changes\n1. API Routes Creation\n   - Created /api/langchain/memory/extract.ts for memory extraction\n   - Created /api/langchain/questions/evaluate.ts for question evaluation \n   - Updated /api/claude/unified-chat.ts for all chat functionality\n2. Client/Server Code Split\n   - Created client versions of all server-side modules:\n     - memoryExtractor.client.ts\n     - questionEvaluator.client.ts\n     - configLoader.client.ts\n   - Added dynamic imports for server/client:\n     - Created src/lib/chat/server/chatService.ts\n     - Created src/lib/chat/client/chatService.ts\n     - Updated src/lib/chat/index.ts to import the right version\n3. Next.js Configuration\n   - Updated webpack aliases in next.config.js\n   - Added proper fallbacks for Node.js modules\n   - Configured module imports to use client versions in browser\n4. Client-Side Service Layer\n   - Created services/api/langchainService.ts \n   - Implemented API clients that closely match original function signatures\n## Rationale for Migration\n1. Server-only Dependencies\n   - LangChain and Anthropic SDK use Node.js APIs unavailable in browsers\n   - File system operations for config loading don't work in browsers\n2. Security Benefits\n   - API keys are no longer exposed to client code\n   - Better control over rate limits and API access\n3. Performance Improvements\n   - Smaller client-side bundle sizes\n   - Efficient API-only data transfers\n## Remaining Work\n1. Complete API Route Migration\n   - Move any remaining direct LangChain usage to API routes\n   - Create API route for parliament functionality\n2. Error Handling Improvements\n   - Implement comprehensive error handling in API routes\n   - Add better client-side fallback for network failures\n3. Production Testing\n   - Verify API route functionality in production environment\n   - Test performance with high traffic volumes\n## How to Add New LangChain Features\n1. Server-Side Implementation\n   - Create a new API route in /pages/api/langchain/ \n   - Use the real LangChain code here with Node.js APIs\n2. Client-Side Service\n   - Add a new function to langchainService.ts\n   - Implement proper error handling and response parsing\n3. Client Usage\n   - Import from the service layer: import { newFeature } from '@/services/api/langchainService'\n   - Call as if it were a local function\n## Benefits of This Approach\n1. Separation of Concerns\n   - Clear division between client and server responsibilities\n   - Improved code organization and maintainability\n2. Build and Runtime Compatibility\n   - No more build errors related to Node.js APIs\n   - No runtime errors with browser incompatibilities\n3. Future Scalability\n   - API routes can be moved to serverless functions\n   - Easier to optimize and scale individual endpointsEditStrategized LangChain migration review and project evolution tactics.4sThe user is asking me to help validate their LangChain migration to server-side API routes and to provide a terminal command to export files for review. They've shared a migration overview document which shows what work they've already completed.\nLet's break this down into parts:\n\nFirst, I need to provide a terminal command to export all the relevant files into a .txt file for my review\nSecond, I should help them confirm that their migration is working correctly\nThird, I should give recommendations on how to evolve the project\n\nFor the terminal command, I'll create something that will find and concatenate all the relevant files. I'll focus on the files mentioned in their migration document:\n\nAPI routes: /api/langchain/memory/extract.ts, /api/langchain/questions/evaluate.ts, /api/claude/unified-chat.ts\nClient/server splits: memoryExtractor.client.ts, questionEvaluator.client.ts, configLoader.client.ts, src/lib/chat/server/chatService.ts, src/lib/chat/client/chatService.ts, src/lib/chat/index.ts\nConfiguration: next.config.js\nService layer: services/api/langchainService.ts\n\nI should create a command that grabs all these files and also looks for any other relevant files that might help me understand their implementation.\nFor confirming the migration is working, I'll suggest:\n\nTesting approaches for their API endpoints\nMonitoring methods to look for client-side errors\nPerformance validation techniques\n\nFor evolving the project, I'll suggest:\n\nRefinements to their architecture\nTesting improvements\nPerformance optimizations\nDeployment strategies\nDocumentation practices\nValidating Your LangChain Server Migration\nFirst, let's create a terminal command to export the key files for review:\nbash# Create a comprehensive export of all relevant files\nfind ./src -type f \\( -name \"*.ts\" -o -name \"*.tsx\" -o -name \"*.js\" -o -name \"*.jsx\" \\) \\\n  -not -path \"*/node_modules/*\" \\\n  -not -path \"*/.next/*\" \\\n  | grep -E '(api/|langchain|chat|memory|question|config|service)' \\\n  | xargs cat > project_review_export.txt\nConfirming Your Migration Is Working\nHere's a step-by-step verification process:\n1. API Endpoint Testing\nbash# Create a quick test script to verify your memory extraction endpoint\ncat > test_memory_api.js << 'EOF'\nconst fetch = require('node-fetch');\n\nasync function testMemoryExtraction() {\n  try {\n    const response = await fetch('http://localhost:3000/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        userMessage: \"I'm really excited about my upcoming trip to Japan next month. I've been learning Japanese for two years now.\",\n        currentMemories: [],\n        extractionThreshold: 0.5\n      })\n    });\n    \n    const result = await response.json();\n    console.log('API Response:', JSON.stringify(result, null, 2));\n    console.log('Test passed:', response.status === 200 && result.success);\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n}\n\ntestMemoryExtraction();\nEOF\n\n# Run the test script\nnode test_memory_api.js\n2. Client-Side Monitoring\nAdd this to your main layout component:\ntypescript// Add error boundary monitoring\nuseEffect(() => {\n  const handleError = (event: ErrorEvent) => {\n    console.error('Client-side error:', event.error);\n    // Optionally send to analytics\n  };\n  window.addEventListener('error', handleError);\n  return () => window.removeEventListener('error', handleError);\n}, []);\n3. Network Request Monitoring\nAdd this to your main component:\ntypescript// Add a simple request logger\nconst logApiCall = async (url: string, method: string, body?: any) => {\n  console.log(`API Request: ${method} ${url}`);\n  try {\n    const startTime = performance.now();\n    const response = await fetch(url, {\n      method,\n      headers: { 'Content-Type': 'application/json' },\n      body: body ? JSON.stringify(body) : undefined\n    });\n    const data = await response.json();\n    const elapsed = (performance.now() - startTime).toFixed(2);\n    console.log(`API Response (${elapsed}ms):`, { \n      status: response.status, \n      success: response.ok,\n      data: data.success ? '✓' : data.error \n    });\n    return { response, data };\n  } catch (error) {\n    console.error(`API Error (${url}):`, error);\n    throw error;\n  }\n};\n\n// Use this instead of raw fetch calls for debugging\nHow to Evolve Your Project\n1. Add API Request Validation\nbash# Install zod for validation\nnpm install zod\n\n# Create a validation helper\nmkdir -p src/lib/validation\ntouch src/lib/validation/apiSchemas.ts\nAdd this to apiSchemas.ts:\ntypescriptimport { z } from 'zod';\n\nexport const memoryExtractionSchema = z.object({\n  userMessage: z.string().min(1),\n  currentMemories: z.array(z.object({\n    content: z.string(),\n    category: z.string(),\n    confidence: z.number()\n  })).optional().default([]),\n  extractionThreshold: z.number().min(0).max(1).optional().default(0.5)\n});\n\nexport type MemoryExtractionRequest = z.infer<typeof memoryExtractionSchema>;\n\n// Add more schemas as needed\nUse it in your API route:\ntypescriptimport { memoryExtractionSchema } from '@/lib/validation/apiSchemas';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  try {\n    const validatedData = memoryExtractionSchema.parse(req.body);\n    // Now use validatedData which is type-safe\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return res.status(400).json({ success: false, error: error.errors });\n    }\n    throw error;\n  }\n  // Rest of handler...\n}\n2. Add API Response Caching\nCreate a middleware for your API routes:\ntypescript// src/middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  // Only apply to langchain API routes that might benefit from caching\n  if (request.nextUrl.pathname.startsWith('/api/langchain/')) {\n    const response = NextResponse.next();\n    response.headers.set('Cache-Control', 'max-age=60, stale-while-revalidate=300');\n    return response;\n  }\n  return NextResponse.next();\n}\n\nexport const config = {\n  matcher: '/api/langchain/:path*',\n};\n3. Add API Rate Limiting\nbash# Install rate limiting packages\nnpm install @upstash/ratelimit @upstash/redis\nAdd rate limiting to your API routes:\ntypescriptimport { Ratelimit } from \"@upstash/ratelimit\";\nimport { Redis } from \"@upstash/redis\";\n\n// Create a new ratelimiter that allows 5 requests per 10 seconds\nconst ratelimit = new Ratelimit({\n  redis: Redis.fromEnv(),\n  limiter: Ratelimit.slidingWindow(5, \"10 s\"),\n});\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Get user IP for rate limiting\n  const ip = req.headers[\"x-forwarded-for\"] || \"anonymous\";\n  const { success, limit, reset, remaining } = await ratelimit.limit(\n    typeof ip === \"string\" ? ip : \"anonymous\"\n  );\n\n  // Return rate limit response if limit is reached\n  if (!success) {\n    return res.status(429).json({\n      success: false,\n      error: \"Too many requests\",\n      limit,\n      remaining,\n      reset\n    });\n  }\n\n  // Rest of your API logic...\n}\n4. Implement Enhanced Error Handling\nCreate a central error handler:\ntypescript// src/lib/errorHandler.ts\nexport class ApiError extends Error {\n  statusCode: number;\n  \n  constructor(message: string, statusCode: number = 500) {\n    super(message);\n    this.statusCode = statusCode;\n  }\n}\n\nexport const handleApiError = (error: unknown, res: NextApiResponse) => {\n  console.error('API Error:', error);\n  \n  if (error instanceof ApiError) {\n    return res.status(error.statusCode).json({\n      success: false,\n      error: error.message\n    });\n  }\n  \n  if (error instanceof Error) {\n    return res.status(500).json({\n      success: false,\n      error: process.env.NODE_ENV === 'production' \n        ? 'Internal server error' \n        : error.message\n    });\n  }\n  \n  return res.status(500).json({\n    success: false,\n    error: 'Unknown error occurred'\n  });\n};\n5. Monitoring and Analytics\nbash# Install OpenTelemetry packages\nnpm install @opentelemetry/api @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node\nCreate an instrumentation setup:\ntypescript// src/lib/monitoring/telemetry.ts\nimport { NodeSDK } from '@opentelemetry/sdk-node';\nimport { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';\n\n// Only initialize in server environment\nif (typeof window === 'undefined') {\n  const sdk = new NodeSDK({\n    instrumentations: [getNodeAutoInstrumentations()]\n  });\n  \n  sdk.start();\n  console.log('OpenTelemetry instrumentation started');\n  \n  // Handle graceful shutdown\n  process.on('SIGTERM', () => {\n    sdk.shutdown()\n      .then(() => console.log('OpenTelemetry SDK shut down'))\n      .catch(err => console.error('Error shutting down OpenTelemetry SDK', err))\n      .finally(() => process.exit(0));\n  });\n}\n6. Documentation with Swagger/OpenAPI\nbash# Install Swagger UI packages\nnpm install swagger-ui-react swagger-jsdoc\nAdd API documentation:\ntypescript// src/pages/api-docs.tsx\nimport { useState } from 'react';\nimport { GetStaticProps } from 'next';\nimport dynamic from 'next/dynamic';\nimport swaggerJsdoc from 'swagger-jsdoc';\n\n// Dynamically import SwaggerUI to avoid SSR issues\nconst SwaggerUI = dynamic(import('swagger-ui-react'), { ssr: false });\n\nconst options = {\n  definition: {\n    openapi: '3.0.0',\n    info: {\n      title: 'LangChain API',\n      version: '1.0.0',\n      description: 'API documentation for LangChain integration',\n    },\n  },\n  apis: ['./src/pages/api/**/*.ts'],\n};\n\nconst ApiDocs = ({ spec }: { spec: Record<string, any> }) => {\n  return (\n    <div className=\"swagger-wrapper\">\n      <SwaggerUI spec={spec} />\n    </div>\n  );\n};\n\nexport const getStaticProps: GetStaticProps = async () => {\n  const spec = swaggerJsdoc(options);\n  return {\n    props: {\n      spec,\n    },\n  };\n};\n\nexport default ApiDocs;\nThen document your API endpoints:\ntypescript/**\n * @swagger\n * /api/langchain/memory/extract:\n *   post:\n *     summary: Extract memories from user message\n *     requestBody:\n *       required: true\n *       content:\n *         application/json:\n *           schema:\n *             type: object\n *             required:\n *               - userMessage\n *             properties:\n *               userMessage:\n *                 type: string\n *               currentMemories:\n *                 type: array\n *               extractionThreshold:\n *                 type: number\n *     responses:\n *       200:\n *         description: Successful memory extraction\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Your handler code...\n}\n7. Testing API Endpoints with Jest\nbash# Install testing packages\nnpm install --save-dev jest @testing-library/react msw\nCreate API tests:\ntypescript// src/tests/api/memory-extraction.test.ts\nimport { rest } from 'msw';\nimport { setupServer } from 'msw/node';\nimport { extractMemories } from '@/services/api/langchainService';\n\nconst server = setupServer(\n  rest.post('/api/langchain/memory/extract', (req, res, ctx) => {\n    return res(\n      ctx.json({\n        success: true,\n        data: {\n          newMemories: [\n            {\n              id: 'test-id-1',\n              content: 'User is learning Japanese',\n              category: 'interest',\n              confidence: 0.9,\n              timestamp: '2023-01-01T00:00:00.000Z'\n            }\n          ],\n          reasoning: 'Test reasoning'\n        }\n      })\n    );\n  })\n);\n\nbeforeAll(() => server.listen());\nafterEach(() => server.resetHandlers());\nafterAll(() => server.close());\n\ndescribe('Memory Extraction API', () => {\n  it('successfully extracts memories from user message', async () => {\n    const result = await extractMemories('I love learning Japanese');\n    expect(result.newMemories).toHaveLength(1);\n    expect(result.newMemories[0].content).toBe('User is learning Japanese');\n  });\n});\nBy implementing these improvements, you'll have a robust, maintainable, and well-tested API architecture for your LangChain integration."
          },
          {
            "file_name": "paste-2.txt",
            "file_size": 270003,
            "file_type": "txt",
            "extracted_content": "import React, { useState } from 'react';\nimport { usePublicQuestions } from '@/hooks/usePublicQuestions';\nimport { ModerationResult } from '@/types/publicQuestions';\n\ninterface QuestionSubmitFormProps {\n  onSuccess?: () => void;\n}\n\nconst QuestionSubmitForm: React.FC<QuestionSubmitFormProps> = ({\n  onSuccess\n}) => {\n  const [question, setQuestion] = useState('');\n  const [description, setDescription] = useState('');\n  const [tags, setTags] = useState<string[]>([]);\n  const [tagInput, setTagInput] = useState('');\n  const [showResult, setShowResult] = useState(false);\n  \n  const { \n    submitQuestion, \n    submitting, \n    submitResult, \n    submitError \n  } = usePublicQuestions();\n  \n  // Handle tag addition\n  const addTag = () => {\n    if (tagInput.trim() && !tags.includes(tagInput.trim())) {\n      setTags([...tags, tagInput.trim()]);\n      setTagInput('');\n    }\n  };\n  \n  // Handle tag deletion\n  const removeTag = (tagToRemove: string) => {\n    setTags(tags.filter(tag => tag !== tagToRemove));\n  };\n  \n  // Handle tag input keydown (enter to add)\n  const handleTagKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      e.preventDefault();\n      addTag();\n    }\n  };\n  \n  // Handle form submission\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!question.trim()) return;\n    \n    const result = await submitQuestion({\n      question: question.trim(),\n      description: description.trim() || undefined,\n      tags\n    });\n    \n    if (result) {\n      setShowResult(true);\n      if (onSuccess) onSuccess();\n    }\n  };\n  \n  // Reset form\n  const handleReset = () => {\n    setQuestion('');\n    setDescription('');\n    setTags([]);\n    setTagInput('');\n    setShowResult(false);\n  };\n  \n  // Render moderator decision card\n  const renderModeratorDecision = (moderationResult: ModerationResult) => {\n    const decisionClasses = {\n      APPROVE: 'bg-green-50 border-green-200 text-green-800',\n      REJECT: 'bg-red-50 border-red-200 text-red-800',\n      REVISE: 'bg-yellow-50 border-yellow-200 text-yellow-800'\n    };\n    \n    return (\n      <div className={`p-4 rounded-md border ${decisionClasses[moderationResult.decision]} mb-4`}>\n        <h3 className=\"text-lg font-medium mb-2\">\n          Moderator Decision: {moderationResult.decision}\n        </h3>\n        <p className=\"mb-2\">{moderationResult.reasoning}</p>\n        \n        {moderationResult.problematicElements && moderationResult.problematicElements.length > 0 && (\n          <div className=\"mb-2\">\n            <h4 className=\"font-medium\">Issues Identified:</h4>\n            <ul className=\"list-disc pl-5\">\n              {moderationResult.problematicElements.map((element, i) => (\n                <li key={i}>{element}</li>\n              ))}\n            </ul>\n          </div>\n        )}\n        \n        {moderationResult.suggestedRevision && (\n          <div>\n            <h4 className=\"font-medium\">Suggested Revision:</h4>\n            <p className=\"italic\">{moderationResult.suggestedRevision}</p>\n          </div>\n        )}\n      </div>\n    );\n  };\n  \n  // Render submission result\n  const renderSubmitResult = () => {\n    if (!submitResult) return null;\n    \n    return (\n      <div className=\"border rounded-lg p-4 mb-6\">\n        <h3 className=\"text-lg font-medium mb-4\">Question Submission Result</h3>\n        \n        {renderModeratorDecision(submitResult.moderationResult)}\n        \n        {submitResult.status === 'approved' && (\n          <div className=\"bg-green-50 p-4 rounded-md border border-green-200 mb-4\">\n            <p className=\"text-green-800\">\n              Your question has been approved and is now visible to the community.\n            </p>\n          </div>\n        )}\n        \n        {submitResult.status === 'pending' && (\n          <div className=\"bg-yellow-50 p-4 rounded-md border border-yellow-200 mb-4\">\n            <p className=\"text-yellow-800\">\n              Your question is pending review before being published.\n            </p>\n          </div>\n        )}\n        \n        {submitResult.status === 'rejected' && (\n          <div className=\"bg-red-50 p-4 rounded-md border border-red-200 mb-4\">\n            <p className=\"text-red-800\">\n              Your question was rejected and will not be published.\n            </p>\n          </div>\n        )}\n        \n        {submitResult.improvedQuestion && (\n          <div className=\"bg-blue-50 p-4 rounded-md border border-blue-200 mb-4\">\n            <h4 className=\"font-medium text-blue-800 mb-2\">Improved Version:</h4>\n            <p className=\"text-blue-900\">{submitResult.improvedQuestion}</p>\n          </div>\n        )}\n        \n        <div className=\"flex justify-end\">\n          <button\n            onClick={handleReset}\n            className=\"px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700\"\n          >\n            Ask Another Question\n          </button>\n        </div>\n      </div>\n    );\n  };\n  \n  // If showing result, render that instead of the form\n  if (showResult) {\n    return renderSubmitResult();\n  }\n  \n  return (\n    <div className=\"bg-white rounded-lg shadow p-6\">\n      <h2 className=\"text-xl font-semibold mb-6\">Ask a Question</h2>\n      \n      {submitError && (\n        <div className=\"bg-red-50 p-4 rounded-md border border-red-200 mb-4\">\n          <p className=\"text-red-800\">{submitError}</p>\n        </div>\n      )}\n      \n      <form onSubmit={handleSubmit}>\n        <div className=\"mb-4\">\n          <label htmlFor=\"question\" className=\"block text-sm font-medium text-gray-700 mb-1\">\n            Your Question\n          </label>\n          <textarea\n            id=\"question\"\n            className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500\"\n            rows={3}\n            value={question}\n            onChange={(e) => setQuestion(e.target.value)}\n            placeholder=\"What would you like to ask the community?\"\n            required\n          />\n        </div>\n        \n        <div className=\"mb-4\">\n          <label htmlFor=\"description\" className=\"block text-sm font-medium text-gray-700 mb-1\">\n            Additional Context (Optional)\n          </label>\n          <textarea\n            id=\"description\"\n            className=\"w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500\"\n            rows={2}\n            value={description}\n            onChange={(e) => setDescription(e.target.value)}\n            placeholder=\"Add any context or background information that might help others understand your question\"\n          />\n        </div>\n        \n        <div className=\"mb-6\">\n          <label htmlFor=\"tags\" className=\"block text-sm font-medium text-gray-700 mb-1\">\n            Tags (Optional)\n          </label>\n          <div className=\"flex flex-wrap gap-2 mb-2\">\n            {tags.map(tag => (\n              <span \n                key={tag} \n                className=\"bg-purple-100 text-purple-800 px-2 py-1 rounded-full text-sm flex items-center\"\n              >\n                {tag}\n                <button \n                  type=\"button\" \n                  onClick={() => removeTag(tag)}\n                  className=\"ml-1 text-purple-600 hover:text-purple-800\"\n                >\n                  &times;\n                </button>\n              </span>\n            ))}\n          </div>\n          <div className=\"flex\">\n            <input\n              id=\"tags\"\n              className=\"flex-1 px-3 py-2 border border-gray-300 rounded-l-md shadow-sm focus:outline-none focus:ring-2 focus:ring-purple-500\"\n              value={tagInput}\n              onChange={(e) => setTagInput(e.target.value)}\n              onKeyDown={handleTagKeyDown}\n              placeholder=\"Add tags to categorize your question\"\n            />\n            <button\n              type=\"button\"\n              onClick={addTag}\n              className=\"px-4 py-2 bg-gray-200 text-gray-700 rounded-r-md hover:bg-gray-300\"\n            >\n              Add\n            </button>\n          </div>\n        </div>\n        \n        <div className=\"flex justify-between items-center\">\n          <p className=\"text-sm text-gray-500\">\n            Your question will be reviewed before being published.\n          </p>\n          <button\n            type=\"submit\"\n            disabled={submitting || !question.trim()}\n            className=\"px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 disabled:opacity-50\"\n          >\n            {submitting ? (\n              <>\n                <span className=\"inline-block mr-2 w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin\"></span>\n                Submitting...\n              </>\n            ) : 'Submit Question'}\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default QuestionSubmitForm;import React, { useState } from 'react';\nimport { usePublicQuestions } from '@/hooks/usePublicQuestions';\nimport { PublicQuestion } from '@/types/publicQuestions';\nimport Link from 'next/link';\n\ninterface QuestionsListProps {\n  initialQuestions?: PublicQuestion[];\n  showFilters?: boolean;\n  showPagination?: boolean;\n  showVoting?: boolean;\n  maxHeight?: string;\n  emptyMessage?: string;\n}\n\nconst QuestionsList: React.FC<QuestionsListProps> = ({\n  initialQuestions,\n  showFilters = true,\n  showPagination = true,\n  showVoting = true,\n  maxHeight,\n  emptyMessage = \"No questions found.\"\n}) => {\n  // Use the questions hook\n  const {\n    questions: hookQuestions,\n    loading,\n    error,\n    total,\n    totalPages,\n    page,\n    limit,\n    sort,\n    direction,\n    status,\n    userVotes,\n    voting,\n    applyFilters,\n    voteOnQuestion,\n    setPage\n  } = usePublicQuestions();\n  \n  // Use either passed in questions or ones from the hook\n  const questions = initialQuestions || hookQuestions;\n  \n  // Local filter state\n  const [localSort, setLocalSort] = useState(sort);\n  const [localDirection, setLocalDirection] = useState(direction);\n  const [localStatus, setLocalStatus] = useState(status);\n  \n  // Apply filters handler\n  const handleApplyFilters = () => {\n    applyFilters({\n      sort: localSort,\n      direction: localDirection,\n      status: localStatus,\n      page: 1 // Reset to first page when filters change\n    });\n  };\n  \n  // Vote handler\n  const handleVote = async (questionId: string, voteType: 1 | -1) => {\n    await voteOnQuestion(questionId, voteType);\n  };\n  \n  // Render a question card\n  const renderQuestionCard = (question: PublicQuestion) => {\n    const userVote = userVotes?.[question.id] || null;\n    \n    return (\n      <div \n        key={question.id}\n        className=\"border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow bg-white\"\n      >\n        <div className=\"flex\">\n          {/* Vote controls */}\n          {showVoting && (\n            <div className=\"flex flex-col items-center mr-4\">\n              <button\n                onClick={() => handleVote(question.id, 1)}\n                disabled={voting}\n                className={`p-1 rounded ${\n                  userVote === 1 \n                    ? 'bg-purple-100 text-purple-600' \n                    : 'text-gray-500 hover:text-purple-600'\n                }`}\n              >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 15l7-7 7 7\" />\n                </svg>\n              </button>\n              \n              <span className=\"my-1 font-medium text-gray-700\">\n                {question.vote_score}\n              </span>\n              \n              <button\n                onClick={() => handleVote(question.id, -1)}\n                disabled={voting}\n                className={`p-1 rounded ${\n                  userVote === -1 \n                    ? 'bg-purple-100 text-purple-600' \n                    : 'text-gray-500 hover:text-purple-600'\n                }`}\n              >\n                <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-6 w-6\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n                </svg>\n              </button>\n            </div>\n          )}\n          \n          {/* Question content */}\n          <div className=\"flex-1\">\n            <Link href={`/questions/${question.id}`} className=\"block\">\n              <h3 className=\"text-lg font-medium text-gray-900 hover:text-purple-600\">\n                {question.content}\n              </h3>\n            </Link>\n            \n            {question.description && (\n              <p className=\"mt-1 text-gray-600 text-sm line-clamp-2\">\n                {question.description}\n              </p>\n            )}\n            \n            <div className=\"mt-2 flex flex-wrap items-center gap-2\">\n              {/* Quality score */}\n              <div className=\"flex items-center\">\n                <div className=\"w-16 h-1.5 bg-gray-200 rounded-full\">\n                  <div \n                    className=\"h-1.5 rounded-full\" \n                    style={{ \n                      width: `${Math.min(Math.round(question.quality_score * 10), 100)}%`,\n                      backgroundColor: getScoreColor(question.quality_score)\n                    }}\n                  ></div>\n                </div>\n                <span className=\"ml-1 text-xs text-gray-500\">\n                  {Math.round(question.quality_score * 10) / 10}/10\n                </span>\n              </div>\n              \n              {/* Tags */}\n              {question.tags && question.tags.length > 0 && (\n                <div className=\"flex flex-wrap gap-1\">\n                  {question.tags.map(tag => (\n                    <span\n                      key={tag}\n                      className=\"bg-gray-100 text-gray-700 px-2 py-0.5 rounded-full text-xs\"\n                    >\n                      {tag}\n                    </span>\n                  ))}\n                </div>\n              )}\n              \n              {/* Date */}\n              <span className=\"text-xs text-gray-500 ml-auto\">\n                {new Date(question.created_at).toLocaleDateString()}\n              </span>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  };\n  \n  // Get color based on score\n  const getScoreColor = (score: number) => {\n    if (score >= 8) return '#22C55E'; // Green\n    if (score >= 6) return '#16A34A'; // Darker green\n    if (score >= 4) return '#EAB308'; // Yellow\n    if (score >= 2) return '#F97316'; // Orange\n    return '#EF4444'; // Red\n  };\n  \n  return (\n    <div>\n      {/* Filters */}\n      {showFilters && (\n        <div className=\"mb-6 bg-white rounded-lg p-4 border border-gray-200\">\n          <div className=\"flex flex-wrap gap-4\">\n            <div>\n              <label htmlFor=\"sort\" className=\"block text-sm font-medium text-gray-700 mb-1\">\n                Sort By\n              </label>\n              <select\n                id=\"sort\"\n                value={localSort}\n                onChange={(e) => setLocalSort(e.target.value)}\n                className=\"rounded-md border border-gray-300 p-2 text-sm\"\n              >\n                <option value=\"total_score\">Combined Score</option>\n                <option value=\"quality_score\">Quality Score</option>\n                <option value=\"vote_score\">Vote Score</option>\n                <option value=\"created_at\">Date Added</option>\n              </select>\n            </div>\n            \n            <div>\n              <label htmlFor=\"direction\" className=\"block text-sm font-medium text-gray-700 mb-1\">\n                Direction\n              </label>\n              <select\n                id=\"direction\"\n                value={localDirection}\n                onChange={(e) => setLocalDirection(e.target.value as 'asc' | 'desc')}\n                className=\"rounded-md border border-gray-300 p-2 text-sm\"\n              >\n                <option value=\"desc\">Highest First</option>\n                <option value=\"asc\">Lowest First</option>\n              </select>\n            </div>\n            \n            <div>\n              <label htmlFor=\"status\" className=\"block text-sm font-medium text-gray-700 mb-1\">\n                Status\n              </label>\n              <select\n                id=\"status\"\n                value={localStatus}\n                onChange={(e) => setLocalStatus(e.target.value as 'approved' | 'pending' | 'rejected')}\n                className=\"rounded-md border border-gray-300 p-2 text-sm\"\n              >\n                <option value=\"approved\">Approved</option>\n                <option value=\"pending\">Pending</option>\n                <option value=\"rejected\">Rejected</option>\n              </select>\n            </div>\n            \n            <div className=\"flex items-end\">\n              <button\n                onClick={handleApplyFilters}\n                className=\"px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700\"\n              >\n                Apply Filters\n              </button>\n            </div>\n          </div>\n        </div>\n      )}\n      \n      {/* Error message */}\n      {error && (\n        <div className=\"bg-red-50 p-4 rounded-md border border-red-200 mb-4\">\n          <p className=\"text-red-800\">{error}</p>\n        </div>\n      )}\n      \n      {/* Loading state */}\n      {loading ? (\n        <div className=\"flex justify-center py-8\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-purple-500\"></div>\n        </div>\n      ) : (\n        <>\n          {/* Questions list */}\n          <div \n            className={`space-y-4 ${maxHeight ? `overflow-y-auto max-h-[${maxHeight}]` : ''}`}\n            style={maxHeight ? { maxHeight } : {}}\n          >\n            {questions.length > 0 ? (\n              questions.map(renderQuestionCard)\n            ) : (\n              <div className=\"text-center py-8 text-gray-500\">\n                <p>{emptyMessage}</p>\n              </div>\n            )}\n          </div>\n          \n          {/* Pagination */}\n          {showPagination && totalPages > 1 && (\n            <div className=\"mt-6 flex justify-center\">\n              <nav className=\"flex items-center\">\n                <button\n                  onClick={() => setPage(Math.max(1, page - 1))}\n                  disabled={page === 1}\n                  className=\"px-3 py-1 rounded-md mr-2 border border-gray-300 disabled:opacity-50\"\n                >\n                  Previous\n                </button>\n                \n                <div className=\"flex items-center space-x-1\">\n                  {[...Array(Math.min(5, totalPages))].map((_, i) => {\n                    let pageNum = page;\n                    \n                    if (totalPages <= 5) {\n                      // Show all pages if 5 or fewer\n                      pageNum = i + 1;\n                    } else if (page <= 3) {\n                      // At start, show first 5 pages\n                      pageNum = i + 1;\n                    } else if (page >= totalPages - 2) {\n                      // At end, show last 5 pages\n                      pageNum = totalPages - 4 + i;\n                    } else {\n                      // In middle, show current page and 2 on each side\n                      pageNum = page - 2 + i;\n                    }\n                    \n                    return (\n                      <button\n                        key={pageNum}\n                        onClick={() => setPage(pageNum)}\n                        className={`w-8 h-8 rounded-md ${\n                          page === pageNum\n                            ? 'bg-purple-600 text-white'\n                            : 'border border-gray-300 hover:bg-gray-100'\n                        }`}\n                      >\n                        {pageNum}\n                      </button>\n                    );\n                  })}\n                </div>\n                \n                <button\n                  onClick={() => setPage(Math.min(totalPages, page + 1))}\n                  disabled={page === totalPages}\n                  className=\"px-3 py-1 rounded-md ml-2 border border-gray-300 disabled:opacity-50\"\n                >\n                  Next\n                </button>\n              </nav>\n            </div>\n          )}\n          \n          {/* Results count */}\n          {totalPages > 0 && (\n            <div className=\"mt-2 text-center text-sm text-gray-500\">\n              Showing {Math.min(limit, questions.length)} of {total} questions\n            </div>\n          )}\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default QuestionsList;import React, { useState, useEffect } from 'react';\nimport { usePublicQuestions } from '@/hooks/usePublicQuestions';\nimport { PublicQuestion, QuestionQualityScore } from '@/types/publicQuestions';\n\ninterface QuestionDetailProps {\n  questionId: string;\n}\n\nconst QuestionDetail: React.FC<QuestionDetailProps> = ({ questionId }) => {\n  const [question, setQuestion] = useState<PublicQuestion | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { voteOnQuestion } = usePublicQuestions();\n  \n  // Fetch question details\n  useEffect(() => {\n    async function fetchQuestionDetails() {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(`/api/questions/${questionId}`);\n        \n        if (!response.ok) {\n          const errorData = await response.json();\n          throw new Error(errorData.error || 'Failed to fetch question');\n        }\n        \n        const data = await response.json();\n        setQuestion(data);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Unknown error';\n        setError(errorMessage);\n      } finally {\n        setLoading(false);\n      }\n    }\n    \n    if (questionId) {\n      fetchQuestionDetails();\n    }\n  }, [questionId]);\n  \n  // Handle voting\n  const handleVote = async (voteType: 1 | -1) => {\n    if (!question) return;\n    \n    const result = await voteOnQuestion(question.id, voteType);\n    \n    if (result) {\n      // Update the question with new vote data\n      setQuestion(prev => {\n        if (!prev) return prev;\n        \n        const currentUserVote = prev.votes?.userVote;\n        let upvotes = prev.votes?.upvotes || 0;\n        let downvotes = prev.votes?.downvotes || 0;\n        \n        // Update vote counts based on previous and new vote\n        if (currentUserVote === 1 && voteType !== 1) upvotes--;\n        if (currentUserVote === -1 && voteType !== -1) downvotes--;\n        if (currentUserVote !== 1 && voteType === 1) upvotes++;\n        if (currentUserVote !== -1 && voteType === -1) downvotes++;\n        \n        return {\n          ...prev,\n          vote_score: result.voteScore,\n          total_score: result.totalScore,\n          votes: {\n            upvotes,\n            downvotes,\n            userVote: currentUserVote === voteType ? null : voteType\n          }\n        };\n      });\n    }\n  };\n  \n  // Get color based on score\n  const getScoreColor = (score: number) => {\n    if (score >= 8) return '#22C55E'; // Green\n    if (score >= 6) return '#16A34A'; // Darker green\n    if (score >= 4) return '#EAB308'; // Yellow\n    if (score >= 2) return '#F97316'; // Orange\n    return '#EF4444'; // Red\n  };\n  \n  // Format date\n  const formatDate = (dateString: string) => {\n    const date = new Date(dateString);\n    return date.toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n  \n  // Render quality scores\n  const renderQualityScores = (scores: QuestionQualityScore[]) => {\n    return (\n      <div className=\"space-y-3\">\n        {scores.map(score => (\n          <div key={score.criteria_id}>\n            <div className=\"flex justify-between mb-1\">\n              <span className=\"text-sm font-medium\">\n                {score.criteria?.name || 'Dimension'}\n              </span>\n              <span className=\"text-sm font-medium\">\n                {score.score.toFixed(1)}/10\n              </span>\n            </div>\n            <div className=\"w-full h-2 bg-gray-200 rounded-full\">\n              <div \n                className=\"h-2 rounded-full\" \n                style={{ \n                  width: `${score.score * 10}%`,\n                  backgroundColor: getScoreColor(score.score)\n                }}\n              ></div>\n            </div>\n            <p className=\"text-xs text-gray-600 mt-1\">{score.reasoning}</p>\n          </div>\n        ))}\n      </div>\n    );\n  };\n  \n  // Render revision history\n  const renderRevisionHistory = () => {\n    if (!question?.question_revisions || question.question_revisions.length === 0) {\n      return null;\n    }\n    \n    return (\n      <div className=\"mt-6 border-t border-gray-200 pt-6\">\n        <h3 className=\"text-lg font-medium mb-4\">Revision History</h3>\n        \n        <div className=\"space-y-4\">\n          {question.question_revisions.map(revision => (\n            <div key={revision.id} className=\"border border-gray-200 rounded-lg p-4\">\n              <div className=\"flex justify-between mb-2\">\n                <span className=\"text-sm font-medium capitalize\">{revision.revision_type.replace('_', ' ')}</span>\n                <span className=\"text-xs text-gray-500\">{formatDate(revision.created_at)}</span>\n              </div>\n              \n              <div className=\"flex gap-4\">\n                <div className=\"flex-1 p-3 bg-red-50 rounded\">\n                  <p className=\"text-xs text-red-800 mb-1\">Original</p>\n                  <p className=\"text-sm\">{revision.original_content}</p>\n                </div>\n                <div className=\"flex-1 p-3 bg-green-50 rounded\">\n                  <p className=\"text-xs text-green-800 mb-1\">Revised</p>\n                  <p className=\"text-sm\">{revision.revised_content}</p>\n                </div>\n              </div>\n              \n              {revision.revision_notes && (\n                <div className=\"mt-2 text-sm text-gray-700\">\n                  <span className=\"font-medium\">Notes:</span> {revision.revision_notes}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n  \n  if (loading) {\n    return (\n      <div className=\"flex justify-center py-8\">\n        <div className=\"animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-purple-500\"></div>\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div className=\"bg-red-50 p-4 rounded-md border border-red-200\">\n        <p className=\"text-red-800\">{error}</p>\n      </div>\n    );\n  }\n  \n  if (!question) {\n    return (\n      <div className=\"text-center py-8 text-gray-500\">\n        <p>Question not found.</p>\n      </div>\n    );\n  }\n  \n  return (\n    <div className=\"bg-white rounded-lg shadow p-6\">\n      <div className=\"flex gap-6\">\n        {/* Voting column */}\n        <div className=\"flex flex-col items-center\">\n          <button\n            onClick={() => handleVote(1)}\n            className={`p-2 rounded-full ${\n              question.votes?.userVote === 1 \n                ? 'bg-purple-100 text-purple-600' \n                : 'text-gray-500 hover:text-purple-600 hover:bg-purple-50'\n            }`}\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-8 w-8\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 15l7-7 7 7\" />\n            </svg>\n          </button>\n          \n          <span className=\"my-2 text-xl font-bold text-gray-700\">\n            {question.vote_score}\n          </span>\n          \n          <button\n            onClick={() => handleVote(-1)}\n            className={`p-2 rounded-full ${\n              question.votes?.userVote === -1 \n                ? 'bg-purple-100 text-purple-600' \n                : 'text-gray-500 hover:text-purple-600 hover:bg-purple-50'\n            }`}\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-8 w-8\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n            </svg>\n          </button>\n        </div>\n        \n        {/* Main content */}\n        <div className=\"flex-1\">\n          <h1 className=\"text-2xl font-semibold text-gray-900 mb-4\">\n            {question.content}\n          </h1>\n          \n          {question.description && (\n            <div className=\"mb-4 text-gray-700\">\n              <p>{question.description}</p>\n            </div>\n          )}\n          \n          <div className=\"flex flex-wrap gap-2 mb-4\">\n            {question.tags?.map(tag => (\n              <span\n                key={tag}\n                className=\"bg-purple-100 text-purple-800 px-2 py-1 rounded-full text-sm\"\n              >\n                {tag}\n              </span>\n            ))}\n          </div>\n          \n          <div className=\"flex items-center text-sm text-gray-500\">\n            <span>Asked {formatDate(question.created_at)}</span>\n            {question.created_at !== question.updated_at && (\n              <span className=\"ml-4\">\n                Updated {formatDate(question.updated_at)}\n              </span>\n            )}\n          </div>\n        </div>\n      </div>\n      \n      {/* Quality scores */}\n      {question.question_quality_scores && question.question_quality_scores.length > 0 && (\n        <div className=\"mt-6 border-t border-gray-200 pt-6\">\n          <h3 className=\"text-lg font-medium mb-4\">Quality Assessment</h3>\n          \n          <div className=\"mb-4 flex items-center\">\n            <span className=\"text-lg font-semibold mr-2\">\n              Overall Score: {question.quality_score.toFixed(1)}/10\n            </span>\n            <div className=\"w-full max-w-md h-2.5 bg-gray-200 rounded-full ml-2\">\n              <div \n                className=\"h-2.5 rounded-full\" \n                style={{ \n                  width: `${question.quality_score * 10}%`,\n                  backgroundColor: getScoreColor(question.quality_score)\n                }}\n              ></div>\n            </div>\n          </div>\n          \n          {renderQualityScores(question.question_quality_scores)}\n        </div>\n      )}\n      \n      {/* Revision history */}\n      {renderRevisionHistory()}\n    </div>\n  );\n};\n\nexport default QuestionDetail;import { ChatAnthropic } from \"@langchain/anthropic\";\nimport { PromptTemplate, StructuredOutputParser } from '@/lib/langchainCore';\nimport { getPromptTemplate } from \"./configLoader\";\nimport { z } from \"zod\";\nimport { nanoid } from \"nanoid\";\nimport { supabase } from \"./supabaseClient\";\n\n// Types\ninterface ModerationResult {\n  decision: \"APPROVE\" | \"REJECT\" | \"REVISE\";\n  reasoning: string;\n  problematicElements?: string[];\n  suggestedRevision?: string;\n}\n\ninterface EvaluationScore {\n  score: number;\n  justification: string;\n  improvementSuggestion?: string;\n}\n\ninterface QuestionEvaluation {\n  clarity: EvaluationScore;\n  depth: EvaluationScore;\n  relevance: EvaluationScore;\n  originality: EvaluationScore;\n  engagement: EvaluationScore;\n  strengths: string[];\n  areasForImprovement: string[];\n  suggestedRevision?: string;\n}\n\ninterface ImprovedQuestion {\n  originalQuestion: string;\n  improvedQuestion: string;\n  improvementReasoning: string;\n  changes: {\n    clarity?: string;\n    depth?: string;\n    relevance?: string;\n    originality?: string;\n    engagement?: string;\n  };\n}\n\n// Setup the Anthropic model\nconst getModel = () => {\n  const apiKey = process.env.ANTHROPIC_API_KEY;\n  if (!apiKey) throw new Error(\"ANTHROPIC_API_KEY is not set\");\n  \n  return new ChatAnthropic({\n    modelName: \"claude-3-sonnet-20240229\",\n    anthropicApiKey: apiKey,\n  });\n};\n\n// Output parser for moderation\nconst moderationParser = StructuredOutputParser.fromZodSchema(\n  z.object({\n    decision: z.enum([\"APPROVE\", \"REJECT\", \"REVISE\"]),\n    reasoning: z.string(),\n    problematicElements: z.array(z.string()).optional(),\n    suggestedRevision: z.string().optional(),\n  })\n);\n\n// Output parser for quality evaluation\nconst evaluationParser = StructuredOutputParser.fromZodSchema(\n  z.object({\n    clarity: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    depth: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    relevance: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    originality: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    engagement: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    strengths: z.array(z.string()),\n    areasForImprovement: z.array(z.string()),\n    suggestedRevision: z.string().optional(),\n  })\n);\n\n// Output parser for question improvements\nconst improvementParser = StructuredOutputParser.fromZodSchema(\n  z.object({\n    originalQuestion: z.string(),\n    improvedQuestion: z.string(),\n    improvementReasoning: z.string(),\n    changes: z.object({\n      clarity: z.string().optional(),\n      depth: z.string().optional(),\n      relevance: z.string().optional(),\n      originality: z.string().optional(),\n      engagement: z.string().optional(),\n    }),\n  })\n);\n\n// Get the prompt templates\nconst getModerationPrompt = () => {\n  const template = getPromptTemplate('public_questions', 'moderation') || '';\n  return PromptTemplate.fromTemplate(template);\n};\n\nconst getEvaluationPrompt = () => {\n  const template = getPromptTemplate('public_questions', 'evaluation') || '';\n  return PromptTemplate.fromTemplate(template);\n};\n\nconst getImprovementPrompt = () => {\n  const template = getPromptTemplate('public_questions', 'improvement') || '';\n  return PromptTemplate.fromTemplate(template);\n};\n\n/**\n * Moderate a question for prohibited content\n */\nexport async function moderateQuestion(question: string): Promise<ModerationResult> {\n  const model = getModel();\n  const prompt = getModerationPrompt();\n  \n  const formattedPrompt = await prompt.format({\n    question,\n    formatInstructions: moderationParser.getFormatInstructions(),\n  });\n  \n  const response = await model.invoke(formattedPrompt);\n  return moderationParser.parse(response.content);\n}\n\n/**\n * Evaluate a question's quality across multiple dimensions\n */\nexport async function evaluateQuestionQuality(question: string): Promise<QuestionEvaluation> {\n  const model = getModel();\n  const prompt = getEvaluationPrompt();\n  \n  const formattedPrompt = await prompt.format({\n    question,\n    formatInstructions: evaluationParser.getFormatInstructions(),\n  });\n  \n  const response = await model.invoke(formattedPrompt);\n  return evaluationParser.parse(response.content);\n}\n\n/**\n * Improve a question based on evaluation feedback\n */\nexport async function improveQuestion(\n  question: string, \n  evaluationNotes: string\n): Promise<ImprovedQuestion> {\n  const model = getModel();\n  const prompt = getImprovementPrompt();\n  \n  const formattedPrompt = await prompt.format({\n    question,\n    evaluationNotes,\n    formatInstructions: improvementParser.getFormatInstructions(),\n  });\n  \n  const response = await model.invoke(formattedPrompt);\n  return improvementParser.parse(response.content);\n}\n\n/**\n * Process a new question submission, including moderation, evaluation and scoring\n */\nexport async function processQuestionSubmission(\n  question: string,\n  userId: string,\n  description?: string,\n  tags: string[] = []\n): Promise<{ \n  questionId: string;\n  status: string;\n  moderationResult: ModerationResult;\n  evaluation?: QuestionEvaluation;\n  improvedQuestion?: string;\n}> {\n  try {\n    // Step 1: Moderate the question\n    console.log(\"Moderating question:\", question);\n    const moderationResult = await moderateQuestion(question);\n    \n    // If the question should be rejected, don't proceed with evaluation\n    if (moderationResult.decision === \"REJECT\") {\n      // Save the rejected question\n      const { data, error } = await supabase\n        .from('public_questions')\n        .insert({\n          user_id: userId,\n          content: question,\n          description,\n          status: 'rejected',\n          moderation_result: moderationResult,\n          tags,\n          created_at: new Date().toISOString()\n        })\n        .select('id')\n        .single();\n        \n      if (error) throw error;\n      \n      return {\n        questionId: data.id,\n        status: 'rejected',\n        moderationResult\n      };\n    }\n    \n    // Step 2: Evaluate the question quality\n    console.log(\"Evaluating question quality\");\n    const evaluation = await evaluateQuestionQuality(question);\n    \n    // Calculate the quality score (weighted average)\n    const getCriteriaWeights = async () => {\n      const { data, error } = await supabase\n        .from('question_quality_criteria')\n        .select('name, weight');\n        \n      if (error) throw error;\n      \n      const weights: Record<string, number> = {};\n      data.forEach(c => {\n        weights[c.name.toLowerCase()] = c.weight;\n      });\n      \n      return weights;\n    };\n    \n    const weights = await getCriteriaWeights();\n    const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);\n    \n    const qualityScore = (\n      (evaluation.clarity.score * (weights.clarity || 1)) +\n      (evaluation.depth.score * (weights.depth || 1.2)) +\n      (evaluation.relevance.score * (weights.relevance || 1)) +\n      (evaluation.originality.score * (weights.originality || 0.8)) +\n      (evaluation.engagement.score * (weights.engagement || 1))\n    ) / totalWeight;\n    \n    // Step 3: If moderation suggests revision or quality is low, improve the question\n    let improvedQuestion: string | undefined;\n    \n    if (moderationResult.decision === \"REVISE\" || \n        Object.values(evaluation).some(dim => \n          typeof dim === 'object' && 'score' in dim && dim.score < 7)) {\n      \n      console.log(\"Improving question\");\n      \n      // Format evaluation notes\n      const evaluationNotes = `\n        Moderation result: ${moderationResult.decision}\n        ${moderationResult.reasoning}\n        ${moderationResult.problematicElements ? `Problem areas: ${moderationResult.problematicElements.join(', ')}` : ''}\n        \n        Quality Scores:\n        - Clarity: ${evaluation.clarity.score}/10 - ${evaluation.clarity.justification}\n        - Depth: ${evaluation.depth.score}/10 - ${evaluation.depth.justification}\n        - Relevance: ${evaluation.relevance.score}/10 - ${evaluation.relevance.justification}\n        - Originality: ${evaluation.originality.score}/10 - ${evaluation.originality.justification}\n        - Engagement: ${evaluation.engagement.score}/10 - ${evaluation.engagement.justification}\n        \n        Areas for improvement:\n        ${evaluation.areasForImprovement.map(area => `- ${area}`).join('\\n')}\n      `;\n      \n      const improvement = await improveQuestion(question, evaluationNotes);\n      improvedQuestion = improvement.improvedQuestion;\n      \n      // Save the revision\n      await supabase\n        .from('question_revisions')\n        .insert({\n          original_content: question,\n          revised_content: improvedQuestion,\n          revision_type: 'llm_improvement',\n          revision_notes: improvement.improvementReasoning\n        });\n    }\n    \n    // Step 4: Save the question and quality scores to the database\n    const finalContent = improvedQuestion || question;\n    const finalStatus = moderationResult.decision === \"APPROVE\" ? \"approved\" : \"pending\";\n    \n    // Insert the question\n    const { data: questionData, error: questionError } = await supabase\n      .from('public_questions')\n      .insert({\n        user_id: userId,\n        content: finalContent,\n        description,\n        status: finalStatus,\n        moderation_result: moderationResult,\n        quality_score: qualityScore,\n        tags,\n        created_at: new Date().toISOString()\n      })\n      .select('id')\n      .single();\n      \n    if (questionError) throw questionError;\n    \n    const questionId = questionData.id;\n    \n    // Get all criteria IDs\n    const { data: criteriaData, error: criteriaError } = await supabase\n      .from('question_quality_criteria')\n      .select('id, name');\n      \n    if (criteriaError) throw criteriaError;\n    \n    // Map criteria names to IDs\n    const criteriaMap: Record<string, string> = {};\n    criteriaData.forEach(c => {\n      criteriaMap[c.name.toLowerCase()] = c.id;\n    });\n    \n    // Insert quality scores\n    const qualityScores = [\n      {\n        question_id: questionId,\n        criteria_id: criteriaMap.clarity,\n        score: evaluation.clarity.score,\n        reasoning: evaluation.clarity.justification\n      },\n      {\n        question_id: questionId,\n        criteria_id: criteriaMap.depth,\n        score: evaluation.depth.score,\n        reasoning: evaluation.depth.justification\n      },\n      {\n        question_id: questionId,\n        criteria_id: criteriaMap.relevance,\n        score: evaluation.relevance.score,\n        reasoning: evaluation.relevance.justification\n      },\n      {\n        question_id: questionId,\n        criteria_id: criteriaMap.originality,\n        score: evaluation.originality.score,\n        reasoning: evaluation.originality.justification\n      },\n      {\n        question_id: questionId,\n        criteria_id: criteriaMap.engagement,\n        score: evaluation.engagement.score,\n        reasoning: evaluation.engagement.justification\n      }\n    ];\n    \n    const { error: scoresError } = await supabase\n      .from('question_quality_scores')\n      .insert(qualityScores);\n      \n    if (scoresError) throw scoresError;\n    \n    return {\n      questionId,\n      status: finalStatus,\n      moderationResult,\n      evaluation,\n      improvedQuestion\n    };\n  } catch (error) {\n    console.error(\"Error processing question submission:\", error);\n    throw error;\n  }\n}\n\n/**\n * Vote on a question (upvote or downvote)\n */\nexport async function voteOnQuestion(\n  questionId: string, \n  userId: string, \n  voteType: 1 | -1\n): Promise<void> {\n  try {\n    // Check if the user has already voted\n    const { data: existingVote, error: checkError } = await supabase\n      .from('question_votes')\n      .select('id, vote_type')\n      .eq('question_id', questionId)\n      .eq('user_id', userId)\n      .single();\n      \n    if (checkError && checkError.code !== 'PGRST116') {\n      throw checkError;\n    }\n    \n    if (existingVote) {\n      // If the vote is the same, remove it (toggle off)\n      if (existingVote.vote_type === voteType) {\n        const { error: deleteError } = await supabase\n          .from('question_votes')\n          .delete()\n          .eq('id', existingVote.id);\n          \n        if (deleteError) throw deleteError;\n      } else {\n        // Change the vote type\n        const { error: updateError } = await supabase\n          .from('question_votes')\n          .update({ vote_type: voteType })\n          .eq('id', existingVote.id);\n          \n        if (updateError) throw updateError;\n      }\n    } else {\n      // Create a new vote\n      const { error: insertError } = await supabase\n        .from('question_votes')\n        .insert({\n          question_id: questionId,\n          user_id: userId,\n          vote_type: voteType\n        });\n        \n      if (insertError) throw insertError;\n    }\n    \n    // The triggers will automatically update the vote_score and total_score fields\n  } catch (error) {\n    console.error(\"Error voting on question:\", error);\n    throw error;\n  }\n}// src/lib/questionEvaluator.client.ts\n// Client-side version of questionEvaluator\n// This imports from the API service instead of using LangChain directly\n\nimport { evaluateQuestion } from '@/services/api/langchainService';\n\n// Types mirroring those in the server file\ninterface ModerationResult {\n  decision: \"APPROVE\" | \"REJECT\" | \"REVISE\";\n  reasoning: string;\n  problematicElements?: string[];\n  suggestedRevision?: string;\n}\n\ninterface EvaluationScore {\n  score: number;\n  justification: string;\n  improvementSuggestion?: string;\n}\n\ninterface QuestionEvaluation {\n  clarity: EvaluationScore;\n  depth: EvaluationScore;\n  relevance: EvaluationScore;\n  originality: EvaluationScore;\n  engagement: EvaluationScore;\n  strengths: string[];\n  areasForImprovement: string[];\n  suggestedRevision?: string;\n}\n\ninterface ImprovedQuestion {\n  originalQuestion: string;\n  improvedQuestion: string;\n  improvementReasoning: string;\n  changes: {\n    clarity?: string;\n    depth?: string;\n    relevance?: string;\n    originality?: string;\n    engagement?: string;\n  };\n}\n\n/**\n * Evaluate a question's quality across multiple dimensions\n * Client-side version that calls API endpoint\n */\nexport async function evaluateQuestionQuality(question: string): Promise<QuestionEvaluation> {\n  return await evaluateQuestion(question);\n}\n\n/**\n * Other functions are stubbed for client-side\n */\n\nexport async function moderateQuestion(question: string): Promise<ModerationResult> {\n  console.warn('moderateQuestion called from client-side');\n  return {\n    decision: \"APPROVE\",\n    reasoning: \"Client-side stub - moderation happens on the server\"\n  };\n}\n\nexport async function improveQuestion(\n  question: string, \n  evaluationNotes: string\n): Promise<ImprovedQuestion> {\n  console.warn('improveQuestion called from client-side');\n  return {\n    originalQuestion: question,\n    improvedQuestion: question,\n    improvementReasoning: \"Client-side stub - improvement happens on the server\",\n    changes: {}\n  };\n}\n\nexport async function processQuestionSubmission(\n  question: string,\n  userId: string,\n  description?: string,\n  tags: string[] = []\n): Promise<{ \n  questionId: string;\n  status: string;\n  moderationResult: ModerationResult;\n  evaluation?: QuestionEvaluation;\n  improvedQuestion?: string;\n}> {\n  console.warn('processQuestionSubmission called from client-side');\n  return {\n    questionId: 'client-side-mock-id',\n    status: 'pending',\n    moderationResult: {\n      decision: \"APPROVE\",\n      reasoning: \"Client-side stub - processing happens on the server\"\n    }\n  };\n}\n\nexport async function voteOnQuestion(\n  questionId: string, \n  userId: string, \n  voteType: 1 | -1\n): Promise<void> {\n  console.warn('voteOnQuestion called from client-side');\n  // This is a stub - voting happens on the server\n}\n\nexport default {\n  evaluateQuestionQuality,\n  moderateQuestion,\n  improveQuestion,\n  processQuestionSubmission,\n  voteOnQuestion\n};/**\n * Chat Service Module\n * \n * Provides unified handling of chat functionality with Anthropic Claude API\n */\nimport Anthropic from '@anthropic-ai/sdk';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Initialize Anthropic client\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nlet anthropic: Anthropic | null = null;\n\ntry {\n  anthropic = new Anthropic({ apiKey });\n  console.log('Anthropic client initialized successfully');\n} catch (error) {\n  console.error('Failed to initialize Anthropic client:', error);\n}\n\n/**\n * Determines if the service is in demo mode (no API key)\n */\nexport const isDemoMode = (): boolean => {\n  return !anthropic || !apiKey || apiKey.trim() === '';\n};\n\n/**\n * Transforms messages array for Claude API compatibility\n * Extracts system message and returns cleaned messages\n */\nexport const prepareMessagesForClaude = (messages: any[]) => {\n  if (!messages || !Array.isArray(messages)) {\n    throw new Error('Invalid messages format');\n  }\n\n  // Extract system message if present\n  const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n  \n  // Filter out system messages - they should be passed as a separate parameter\n  const filteredMessages = messages\n    .filter(msg => msg.role !== 'system')\n    .map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n  return { \n    systemMessage, \n    messages: filteredMessages\n  };\n};\n\n/**\n * Processes AI response for user context and memory\n */\nexport const processResponse = async (userId: string | null, response: string, userMessage: string, includeUserContext = true) => {\n  if (!userId || !includeUserContext) return;\n\n  try {\n    // Process for traditional user context\n    await processResponseForUserContext(userId, response);\n\n    // Process user message for memory extraction\n    if (userMessage) {\n      await processMessageForMemories(userId, userMessage);\n    }\n  } catch (error) {\n    console.error('Error processing response for user context:', error);\n  }\n};\n\n/**\n * Gets demo response content for fallback/development use\n */\nexport const getDemoResponse = (): string => {\n  return \"This is a demo response from Claude. In production, this would be an actual response based on your input. The app is currently running in demo mode without a Claude API key.\";\n};\n\n/**\n * Creates a fallback response object for error cases\n */\nexport const createFallbackResponse = (error?: any): any => {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  \n  return {\n    content: [{\n      type: 'text',\n      text: `Sorry, there was an error contacting the AI service: ${errorMessage}. This is a fallback response.`\n    }],\n    model: \"claude-3-fallback\",\n    role: 'assistant'\n  };\n};\n\nexport default {\n  anthropic,\n  isDemoMode,\n  prepareMessagesForClaude,\n  processResponse,\n  getDemoResponse,\n  createFallbackResponse\n};/**\n * Server-side Chat Service Module\n * \n * Provides unified handling of chat functionality with Anthropic Claude API\n * IMPORTANT: This module is server-side only and should not be imported on the client\n */\nimport Anthropic from '@anthropic-ai/sdk';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Initialize Anthropic client (only on server)\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nlet anthropic: Anthropic | null = null;\n\n// Only initialize on server\nif (typeof window === 'undefined') {\n  try {\n    anthropic = new Anthropic({ apiKey });\n    console.log('Anthropic client initialized successfully');\n  } catch (error) {\n    console.error('Failed to initialize Anthropic client:', error);\n  }\n}\n\n/**\n * Determines if the service is in demo mode (no API key)\n */\nexport const isDemoMode = (): boolean => {\n  return !anthropic || !apiKey || apiKey.trim() === '';\n};\n\n/**\n * Transforms messages array for Claude API compatibility\n * Extracts system message and returns cleaned messages\n */\nexport const prepareMessagesForClaude = (messages: any[]) => {\n  if (!messages || !Array.isArray(messages)) {\n    throw new Error('Invalid messages format');\n  }\n\n  // Extract system message if present\n  const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n  \n  // Filter out system messages - they should be passed as a separate parameter\n  const filteredMessages = messages\n    .filter(msg => msg.role !== 'system')\n    .map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n  return { \n    systemMessage, \n    messages: filteredMessages\n  };\n};\n\n/**\n * Processes AI response for user context and memory\n */\nexport const processResponse = async (userId: string | null, response: string, userMessage: string, includeUserContext = true) => {\n  if (!userId || !includeUserContext) return;\n\n  try {\n    // Process for traditional user context\n    await processResponseForUserContext(userId, response);\n\n    // Process user message for memory extraction\n    if (userMessage) {\n      await processMessageForMemories(userId, userMessage);\n    }\n  } catch (error) {\n    console.error('Error processing response for user context:', error);\n  }\n};\n\n/**\n * Gets demo response content for fallback/development use\n */\nexport const getDemoResponse = (): string => {\n  return \"This is a demo response from Claude. In production, this would be an actual response based on your input. The app is currently running in demo mode without a Claude API key.\";\n};\n\n/**\n * Creates a fallback response object for error cases\n */\nexport const createFallbackResponse = (error?: any): any => {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  \n  return {\n    content: [{\n      type: 'text',\n      text: `Sorry, there was an error contacting the AI service: ${errorMessage}. This is a fallback response.`\n    }],\n    model: \"claude-3-fallback\",\n    role: 'assistant'\n  };\n};\n\nexport default {\n  anthropic,\n  isDemoMode,\n  prepareMessagesForClaude,\n  processResponse,\n  getDemoResponse,\n  createFallbackResponse\n};/**\n * Chat Module Index\n * \n * Exports all chat-related functionality from a single entry point\n * Conditionally imports server or client version based on environment\n */\nimport nodeIntegration from './nodeIntegration';\n\n// Conditionally import the right chatService implementation\nlet chatService: any;\n\nif (typeof window === 'undefined') {\n  // Server-side\n  // Dynamic import to avoid browser errors with server-only code\n  const serverModule = require('./server/chatService');\n  chatService = serverModule.default || serverModule;\n} else {\n  // Client-side\n  // Dynamic import to ensure client-side code is used in the browser\n  const clientModule = require('./client/chatService');\n  chatService = clientModule.default || clientModule;\n}\n\nexport {\n  chatService,\n  nodeIntegration\n};\n\nexport default {\n  chatService,\n  nodeIntegration\n};/**\n * Node Integration Service\n * \n * Handles integration between chat messages and the node-based canvas system\n */\nimport { supabase } from '@/lib/supabaseClient';\nimport { Node, Relationship } from '@/types/thread';\n\n/**\n * Creates a node from a chat message\n */\nexport const createNodeFromMessage = async (\n  message: any, \n  notebookId: string,\n  position?: { x: number, y: number }\n): Promise<Node | null> => {\n  if (!notebookId || !message) return null;\n  \n  try {\n    // Determine node type based on message role\n    const nodeType = message.role === 'user' ? 'question' : 'response';\n    \n    // Use provided position or generate a default one\n    const nodePosition = position || { x: 100 + Math.random() * 200, y: 100 + Math.random() * 200 };\n    \n    // Create the node\n    const { data: node, error } = await supabase\n      .from('nodes')\n      .insert({\n        content: message.content,\n        type: nodeType,\n        notebook_id: notebookId,\n        position: nodePosition,\n        metadata: {\n          source: 'chat',\n          chatMessageId: message.id,\n          timestamp: message.created_at || new Date().toISOString()\n        },\n        messages: [{\n          id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n          role: message.role,\n          content: message.content,\n          created_at: message.created_at || new Date().toISOString()\n        }],\n        isConversationNode: true,\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return node;\n  } catch (error) {\n    console.error('Error creating node from message:', error);\n    return null;\n  }\n};\n\n/**\n * Creates a relationship between two nodes\n */\nexport const createNodeRelationship = async (\n  fromNodeId: string,\n  toNodeId: string,\n  type: 'supports' | 'contradicts' | 'questions' | 'extends' | 'tensions',\n  notebookId: string\n): Promise<Relationship | null> => {\n  if (!fromNodeId || !toNodeId || !notebookId) return null;\n  \n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .insert({\n        from_node_id: fromNodeId,\n        to_node_id: toNodeId,\n        type,\n        notebook_id: notebookId,\n        context: 'Created from chat',\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n    \n    if (error) throw error;\n    return data;\n  } catch (error) {\n    console.error('Error creating relationship between nodes:', error);\n    return null;\n  }\n};\n\n/**\n * Adds a message to an existing node\n */\nexport const addMessageToNode = async (\n  nodeId: string,\n  message: {\n    role: 'user' | 'assistant' | 'system',\n    content: string,\n    id?: string\n  }\n): Promise<boolean> => {\n  if (!nodeId || !message) return false;\n  \n  try {\n    // First, get the current node to access its messages\n    const { data: node, error: fetchError } = await supabase\n      .from('nodes')\n      .select('messages')\n      .eq('id', nodeId)\n      .single();\n    \n    if (fetchError) throw fetchError;\n    \n    // Prepare the new message with ID if not provided\n    const newMessage = {\n      id: message.id || `msg_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`,\n      role: message.role,\n      content: message.content,\n      created_at: new Date().toISOString()\n    };\n    \n    // Add the new message to the existing messages array\n    const updatedMessages = [\n      ...(node.messages || []),\n      newMessage\n    ];\n    \n    // Update the node with the new messages array\n    const { error: updateError } = await supabase\n      .from('nodes')\n      .update({\n        messages: updatedMessages,\n        lastMessageId: newMessage.id,\n        isConversationNode: true\n      })\n      .eq('id', nodeId);\n    \n    if (updateError) throw updateError;\n    return true;\n  } catch (error) {\n    console.error('Error adding message to node:', error);\n    return false;\n  }\n};\n\nexport default {\n  createNodeFromMessage,\n  createNodeRelationship,\n  addMessageToNode\n};/**\n * Client-side Chat Service Module\n * \n * Provides mock implementations for the chat service functionality\n * This is used in the browser to avoid loading server-only modules\n */\n\n/**\n * Determines if the service is in demo mode (always true for client)\n */\nexport const isDemoMode = (): boolean => {\n  return true; // Client is always in \"demo\" mode\n};\n\n/**\n * Transforms messages array for Claude API compatibility (client version)\n */\nexport const prepareMessagesForClaude = (messages: any[]) => {\n  if (!messages || !Array.isArray(messages)) {\n    throw new Error('Invalid messages format');\n  }\n\n  // Extract system message if present\n  const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n  \n  // Filter out system messages\n  const filteredMessages = messages\n    .filter(msg => msg.role !== 'system')\n    .map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n  return { \n    systemMessage, \n    messages: filteredMessages\n  };\n};\n\n/**\n * Mock processing function for client\n */\nexport const processResponse = async (userId: string | null, response: string, userMessage: string, includeUserContext = true) => {\n  console.log('Client-side mock of processResponse called');\n  return Promise.resolve();\n};\n\n/**\n * Gets demo response content for fallback/development use\n */\nexport const getDemoResponse = (): string => {\n  return \"This is a client-side mock response. API calls will be made from the server.\";\n};\n\n/**\n * Creates a fallback response object for error cases\n */\nexport const createFallbackResponse = (error?: any): any => {\n  const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n  \n  return {\n    content: [{\n      type: 'text',\n      text: `Client-side mock fallback response: ${errorMessage}`\n    }],\n    model: \"claude-3-client-mock\",\n    role: 'assistant'\n  };\n};\n\n// Client-side mockable object\nconst mockAnthroic = {\n  messages: {\n    create: async () => {\n      return {\n        content: [{ type: 'text', text: 'This is a client-side mock response' }],\n        model: 'claude-3-client-mock',\n        role: 'assistant'\n      };\n    }\n  }\n};\n\nexport default {\n  anthropic: mockAnthroic,\n  isDemoMode,\n  prepareMessagesForClaude,\n  processResponse,\n  getDemoResponse,\n  createFallbackResponse\n};// src/lib/configLoader.client.ts\n\n// Simple cache for pre-loaded prompts\nconst promptCache: Record<string, string> = {};\n\n/**\n * Get a prompt template by category and name\n * Client-side safe version - uses pre-loaded templates or returns default values\n */\nexport function getPromptTemplate(category: string, name: string): string | null {\n  const cacheKey = `${category}:${name}`;\n  \n  // Return from cache if available\n  if (promptCache[cacheKey]) {\n    return promptCache[cacheKey];\n  }\n  \n  // In client-side, return null (API will handle the actual template loading)\n  console.warn(`Prompt for ${category}/${name} was requested in browser environment`);\n  return null;\n}\n\n/**\n * Preload a prompt template for client use\n * Call this function to make templates available on the client side\n */\nexport function preloadPromptTemplate(category: string, name: string, template: string): void {\n  const cacheKey = `${category}:${name}`;\n  promptCache[cacheKey] = template;\n}\n\n/**\n * Get a notebook template prompt\n * Client-side safe version\n */\nexport function getNotebookTemplate(templateName: string): string | null {\n  const cacheKey = `notebook_defaults:${templateName}`;\n  \n  // Return from cache if available\n  if (promptCache[cacheKey]) {\n    return promptCache[cacheKey];\n  }\n  \n  // Default system prompt for client-side\n  if (templateName === 'system_prompt') {\n    return \"You are a helpful AI assistant embedded in a notebook application. Help the user with their tasks and provide thoughtful answers.\";\n  }\n  \n  // In client-side, return null (API will handle the actual template loading)\n  console.warn(`Notebook template ${templateName} was requested in browser environment`);\n  return null;\n}\n\nexport default {\n  getPromptTemplate,\n  preloadPromptTemplate,\n  getNotebookTemplate\n};// Import modules with safeguards for client-side\nimport yaml from 'yaml';\n\n// Cache for loaded config\nconst configCache: Record<string, any> = {};\n\n// Default configurations for when we're on the client side\nconst defaultConfigs: Record<string, any> = {\n  prompts: {\n    theory_of_mind: {\n      memory_extraction: \"Default system prompt for memory extraction\"\n    },\n    public_questions: {\n      moderation: \"Default moderation prompt\",\n      evaluation: \"Default evaluation prompt\",\n      improvement: \"Default improvement prompt\"\n    },\n    notebook_defaults: {\n      system_prompt: \"You are a helpful AI assistant embedded in a notebook application.\"\n    }\n  }\n};\n\n/**\n * Load configuration from a YAML file (server-side only)\n * @param configName Name of the config file (without extension)\n * @returns Parsed configuration object\n */\nexport function loadConfig(configName: string): any {\n  // Return from cache if available\n  if (configCache[configName]) {\n    return configCache[configName];\n  }\n\n  // Check if we're on the client side\n  if (typeof window !== 'undefined') {\n    console.log(`Using default config for \"${configName}\" on client-side`);\n    return defaultConfigs[configName] || null;\n  }\n\n  try {\n    // We're on the server side, so we can use fs\n    const fs = require('fs');\n    const path = require('path');\n    \n    // Determine file path\n    const configPath = path.resolve(process.cwd(), 'src', 'config', `${configName}.yaml`);\n    \n    // Read file\n    const fileContents = fs.readFileSync(configPath, 'utf8');\n    \n    // Parse YAML\n    const config = yaml.parse(fileContents);\n    \n    // Cache the result\n    configCache[configName] = config;\n    \n    return config;\n  } catch (error) {\n    console.error(`Error loading config \"${configName}\":`, error);\n    \n    // Fall back to default config\n    return defaultConfigs[configName] || null;\n  }\n}\n\n/**\n * Get a specific prompt from the prompts configuration\n * @param promptCategory Category of the prompt (e.g. 'theory_of_mind', 'parliament')\n * @param promptName Name of the prompt within the category\n * @returns The prompt template string\n */\nexport function getPromptTemplate(promptCategory: string, promptName: string): string | null {\n  try {\n    const promptsConfig = loadConfig('prompts');\n    \n    if (!promptsConfig || !promptsConfig[promptCategory] || !promptsConfig[promptCategory][promptName]) {\n      console.error(`Prompt not found: ${promptCategory}.${promptName}`);\n      return null;\n    }\n    \n    return promptsConfig[promptCategory][promptName];\n  } catch (error) {\n    console.error(`Error getting prompt template \"${promptCategory}.${promptName}\":`, error);\n    return null;\n  }\n}\n\n/**\n * Get a notebook template prompt\n * @param templateName Name of the notebook template\n * @returns The system prompt for the template\n */\nexport function getNotebookTemplate(templateName: string): string | null {\n  try {\n    const promptsConfig = loadConfig('prompts');\n    \n    if (!promptsConfig || !promptsConfig.notebook_defaults || !promptsConfig.notebook_defaults[templateName]) {\n      // Return the default system prompt if the requested template doesn't exist\n      if (promptsConfig?.notebook_defaults?.system_prompt) {\n        return promptsConfig.notebook_defaults.system_prompt;\n      }\n      \n      console.error(`Notebook template not found: ${templateName}`);\n      return null;\n    }\n    \n    return promptsConfig.notebook_defaults[templateName];\n  } catch (error) {\n    console.error(`Error getting notebook template \"${templateName}\":`, error);\n    return null;\n  }\n}// Mock implementation of memoryExtractor.ts for client-side rendering\nimport { MemoryEntry, MemoryExtractionResponse } from \"@/types/theoryOfMind\";\n\n// Mock of ChatAnthropic\nclass ChatAnthropicMock {\n  constructor() {}\n  invoke() {\n    return { content: '{\"newMemories\":[],\"reasoning\":\"This is a mock response\"}' };\n  }\n}\n\n// Helper function to mock memory extraction\nexport async function extractMemoriesFromText(\n  userMessage: string,\n  currentMemories: MemoryEntry[] = [],\n  extractionThreshold = 0.5\n): Promise<MemoryExtractionResponse> {\n  console.warn('Using mock memory extractor - server-side only functionality');\n  return {\n    newMemories: [],\n    reasoning: \"Client-side mock - memory extraction not available in the browser\"\n  };\n}\n\n// Mock for the memory extractor graph\nexport async function createMemoryExtractorGraph() {\n  return {\n    invoke: async () => ({\n      newMemories: [],\n      reasoning: \"Client-side mock - memory extraction not available in the browser\"\n    })\n  };\n}\n\n// Export mocks of all the imports from the original file\nexport const ChatAnthropic = ChatAnthropicMock;\nexport const StateGraph = class StateGraph {\n  constructor() {}\n  addNode() {}\n  addEdge() {}\n  setEntryPoint() {}\n  compile() {\n    return {\n      invoke: async () => ({\n        extraction_result: {\n          newMemories: [],\n          reasoning: \"Client-side mock\"\n        }\n      })\n    };\n  }\n};\n\nexport const LangGraphFunction = class LangGraphFunction {\n  constructor() {}\n};\n\nexport const RunnableLambda = class RunnableLambda {\n  constructor() {\n    return {\n      func: () => null,\n      afunc: async () => null,\n      invoke: async () => null\n    };\n  }\n};\n\nexport const RunnablePassthrough = class RunnablePassthrough {\n  constructor() {}\n  static from() {\n    return new RunnablePassthrough();\n  }\n};\n\nexport const StructuredOutputParser = class StructuredOutputParser {\n  constructor() {}\n  static fromZodSchema() {\n    return new StructuredOutputParser();\n  }\n  static zodSchema() {\n    return null;\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n  parse() {\n    return {\n      newMemories: [],\n      reasoning: \"Mock reasoning\"\n    };\n  }\n};\n\nexport const PromptTemplate = class PromptTemplate {\n  constructor() {}\n  static fromTemplate() {\n    return new PromptTemplate();\n  }\n  format() {\n    return \"Mock prompt\";\n  }\n};//memoryExtractor.ts \n\nimport { ChatAnthropic } from \"@langchain/anthropic\";\nimport { StateGraph } from \"@langchain/langgraph\";\n// Import from our server/client compatible module\nimport { PromptTemplate, StructuredOutputParser, RunnableLambda } from '@/lib/langchainCore';\nimport { nanoid } from \"nanoid\";\nimport { z } from \"zod\";\n\nimport {\n  MemoryEntry,\n  MemoryExtractionRequest,\n  MemoryExtractionResponse,\n} from \"@/types/theoryOfMind\";\nimport { getPromptTemplate } from \"./configLoader\";\n\n\n// Model setup\nconst getAnthropicModel = () => {\n  const apiKey = process.env.ANTHROPIC_API_KEY;\n  if (!apiKey) throw new Error(\"ANTHROPIC_API_KEY is not set\");\n\n  return new ChatAnthropic({\n    modelName: \"claude-3-5-sonnet-20240620\",\n    temperature: 0.2,\n    anthropicApiKey: apiKey,\n  });\n};\n\n// Memory extraction output parser\nconst memoryExtractorSchema = z.object({\n  newMemories: z.array(\n    z.object({\n      content: z.string(),\n      rationale: z.string(),\n      confidence: z.number().min(0).max(1),\n      category: z.enum([\n        \"interest\",\n        \"preference\",\n        \"belief\",\n        \"knowledge\",\n        \"experience\",\n        \"demographic\",\n        \"personality\",\n        \"goal\",\n        \"relationship\",\n        \"communication_style\",\n        \"meta\",\n      ]),\n    })\n  ),\n  reasoning: z.string(),\n});\n\nconst memoryExtractorOutputParser = StructuredOutputParser.fromZodSchema(memoryExtractorSchema);\n\n// Prompt template\nconst MEMORY_EXTRACTION_PROMPT = PromptTemplate.fromTemplate(\n  getPromptTemplate(\"theory_of_mind\", \"memory_extraction\") ||\n    `You are a specialized AI system that extracts important information about users to build a Theory of Mind.\n\nYour task is to analyze the following message to identify any potential information that would help understand the user better.\nOnly extract meaningful information that reveals something significant about the user. Don't include trivial details.\n\n## User message:\n{userMessage}\n\n## Current memories about the user (if any):\n{currentMemoriesFormatted}\n\nFor each piece of significant information, provide:\n1. The content (the specific memory/fact about the user)\n2. A rationale for why this is relevant and useful for understanding the user\n3. A confidence score (0.0-1.0) of how certain you are about this information\n4. The best category for this memory\n\nOnly include information that meets a confidence threshold of {extractionThreshold}.\n\nRespond in this exact JSON format:\n{formatInstructions}`\n);\n\n// Node to format current memories\nconst formatCurrentMemories = (\n  input: MemoryExtractionRequest\n): string => {\n  const { currentMemories = [] } = input;\n  if (currentMemories.length === 0) return \"No current memories.\";\n  return currentMemories\n    .map(\n      (m) =>\n        `- ${m.content} (${m.category}, confidence: ${m.confidence})`\n    )\n    .join(\"\\n\");\n};\n\n// Node to extract memories\nconst extractMemories = async (\n  input: MemoryExtractionRequest & { currentMemoriesFormatted: string }\n): Promise<MemoryExtractionResponse> => {\n  const model = getAnthropicModel();\n\n  const extractionPrompt = await MEMORY_EXTRACTION_PROMPT.format({\n    userMessage: input.userMessage,\n    currentMemoriesFormatted: input.currentMemoriesFormatted,\n    extractionThreshold: input.extractionThreshold || 0.5,\n    formatInstructions:\n      memoryExtractorOutputParser.getFormatInstructions(),\n  });\n\n  const rawExtraction = await model.invoke(extractionPrompt);\n  const extraction = await memoryExtractorOutputParser.parse(\n    rawExtraction.content\n  );\n\n  const newMemories: MemoryEntry[] = extraction.newMemories.map((m) => ({\n    ...m,\n    id: nanoid(),\n    timestamp: new Date().toISOString(),\n    source: \"conversation\",\n  }));\n\n  return {\n    newMemories,\n    reasoning: extraction.reasoning,\n  };\n};\n\n// LangGraph setup\nexport async function createMemoryExtractorGraph() {\n  const workflow = new StateGraph({\n    channels: {\n      current_memories_formatted: {\n        value: null,\n        default: () => null,\n      },\n      extraction_result: {\n        value: null,\n        default: () => null,\n      },\n    },\n  });\n\n  workflow.addNode(\n    \"format_current_memories\",\n    new RunnableLambda({\n      func: formatCurrentMemories,\n      afunc: async (input) => formatCurrentMemories(input),\n    })\n  );\n\n  workflow.addNode(\n    \"extract_memories\",\n    new RunnableLambda({\n      func: extractMemories,\n      afunc: async (input) => extractMemories(input as any),\n    })\n  );\n\n  workflow.addEdge(\"format_current_memories\", \"extract_memories\");\n  workflow.setEntryPoint(\"format_current_memories\");\n\n  const memoryExtractorChain = new RunnableLambda({\n    func: async (input: MemoryExtractionRequest) => {\n      const processedInput = {\n        ...input,\n        currentMemories: input.currentMemories || [],\n        extractionThreshold: input.extractionThreshold || 0.5,\n      };\n      const executor = workflow.compile();\n      const result = await executor.invoke(processedInput);\n      return result.extraction_result as MemoryExtractionResponse;\n    },\n  });\n\n  return memoryExtractorChain;\n}\n\n// Public API\nexport async function extractMemoriesFromText(\n  userMessage: string,\n  currentMemories: MemoryEntry[] = [],\n  extractionThreshold = 0.5\n): Promise<MemoryExtractionResponse> {\n  const extractor = await createMemoryExtractorGraph();\n  return await extractor.invoke({\n    userMessage,\n    currentMemories,\n    extractionThreshold,\n  });\n}\n// src/lib/langchainCore.ts\n// Next.js compatible module for LangChain exports\n// This provides server-side imports with client-side fallbacks\n\n// Dynamically import to handle Next.js dual environment\n// Client-side mocks are imported from empty-module.mjs for consistency\n\nimport { \n  PromptTemplate as MockPromptTemplate,\n  StructuredOutputParser as MockStructuredOutputParser,\n  RunnableLambda as MockRunnableLambda \n} from '@/lib/empty-module.mjs';\n\n// Set default exports to client-side mocks\nlet PromptTemplate = MockPromptTemplate;\nlet StructuredOutputParser = MockStructuredOutputParser;\nlet RunnableLambda = MockRunnableLambda;\n\n// Server-side overrides when running on the server\nif (typeof window === 'undefined') {\n  try {\n    // This will only run on the server\n    const serverModules = {\n      prompts: require('@langchain/core/prompts'),\n      outputParsers: require('@langchain/core/output_parsers'),\n      runnables: require('@langchain/core/runnables')\n    };\n    \n    // Override with real implementations\n    PromptTemplate = serverModules.prompts.PromptTemplate;\n    StructuredOutputParser = serverModules.outputParsers.StructuredOutputParser;\n    RunnableLambda = serverModules.runnables.RunnableLambda;\n  } catch (error) {\n    console.error('Error importing LangChain server modules:', error);\n    // Keep using the mock implementations if imports fail\n  }\n}\n\n// Export the resolved implementations\nexport { PromptTemplate, StructuredOutputParser, RunnableLambda };// src/lib/memoryExtractor.client.ts\n// Client-side version of memoryExtractor\n// This imports from the API service instead of using LangChain directly\n\nimport { extractMemories } from '@/services/api/langchainService';\nimport { MemoryEntry, MemoryExtractionRequest, MemoryExtractionResponse } from '@/types/theoryOfMind';\n\n/**\n * Extract memories from text\n * Client-side version that calls API endpoint\n */\nexport async function extractMemoriesFromText(\n  userMessage: string,\n  currentMemories: MemoryEntry[] = [],\n  extractionThreshold = 0.5\n): Promise<MemoryExtractionResponse> {\n  return await extractMemories(userMessage, currentMemories, extractionThreshold);\n}\n\n/**\n * Create memory extractor graph\n * Client-side version returns a mock function that calls the API\n */\nexport async function createMemoryExtractorGraph() {\n  return {\n    invoke: async (input: MemoryExtractionRequest) => {\n      const result = await extractMemories(\n        input.userMessage,\n        input.currentMemories || [],\n        input.extractionThreshold || 0.5\n      );\n      return result;\n    }\n  };\n}\n\nexport default {\n  extractMemoriesFromText,\n  createMemoryExtractorGraph\n};// src/pages/api/langchain/memory/extract.ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { ChatAnthropic } from \"@langchain/anthropic\";\nimport { StateGraph } from \"@langchain/langgraph\";\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport { StructuredOutputParser } from '@langchain/core/output_parsers';\nimport { RunnableLambda } from '@langchain/core/runnables';\nimport { nanoid } from \"nanoid\";\nimport { z } from \"zod\";\nimport { getPromptTemplate } from \"@/lib/configLoader\";\nimport { supabase } from \"@/lib/supabaseClient\";\n\n// Define response type\ntype ApiResponse = {\n  success: boolean;\n  data?: any;\n  error?: string;\n};\n\n// Memory extraction output parser\nconst memoryExtractorSchema = z.object({\n  newMemories: z.array(\n    z.object({\n      content: z.string(),\n      rationale: z.string(),\n      confidence: z.number().min(0).max(1),\n      category: z.enum([\n        \"interest\",\n        \"preference\",\n        \"belief\",\n        \"knowledge\",\n        \"experience\",\n        \"demographic\",\n        \"personality\",\n        \"goal\",\n        \"relationship\",\n        \"communication_style\",\n        \"meta\",\n      ]),\n    })\n  ),\n  reasoning: z.string(),\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ success: false, error: 'Method not allowed' });\n  }\n\n  try {\n    const { userMessage, currentMemories = [], extractionThreshold = 0.5 } = req.body;\n\n    if (!userMessage) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Missing required parameter: userMessage' \n      });\n    }\n\n    // Model setup\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      return res.status(500).json({ \n        success: false, \n        error: 'ANTHROPIC_API_KEY is not set' \n      });\n    }\n\n    const model = new ChatAnthropic({\n      modelName: \"claude-3-5-sonnet-20240620\",\n      temperature: 0.2,\n      anthropicApiKey: apiKey,\n    });\n\n    // Format current memories\n    const currentMemoriesFormatted = currentMemories.length === 0 \n      ? \"No current memories.\" \n      : currentMemories.map((m: any) =>\n          `- ${m.content} (${m.category}, confidence: ${m.confidence})`\n        ).join(\"\\n\");\n\n    // Prompt template\n    const PROMPT_TEMPLATE = getPromptTemplate(\"theory_of_mind\", \"memory_extraction\") ||\n      `You are a specialized AI system that extracts important information about users to build a Theory of Mind.\n\n      Your task is to analyze the following message to identify any potential information that would help understand the user better.\n      Only extract meaningful information that reveals something significant about the user. Don't include trivial details.\n\n      ## User message:\n      {userMessage}\n\n      ## Current memories about the user (if any):\n      {currentMemoriesFormatted}\n\n      For each piece of significant information, provide:\n      1. The content (the specific memory/fact about the user)\n      2. A rationale for why this is relevant and useful for understanding the user\n      3. A confidence score (0.0-1.0) of how certain you are about this information\n      4. The best category for this memory\n\n      Only include information that meets a confidence threshold of {extractionThreshold}.\n\n      Respond in this exact JSON format:\n      {formatInstructions}`;\n\n    const memoryExtractorOutputParser = StructuredOutputParser.fromZodSchema(memoryExtractorSchema);\n\n    const extractionPrompt = await PromptTemplate.fromTemplate(PROMPT_TEMPLATE).format({\n      userMessage,\n      currentMemoriesFormatted,\n      extractionThreshold,\n      formatInstructions: memoryExtractorOutputParser.getFormatInstructions(),\n    });\n\n    const rawExtraction = await model.invoke(extractionPrompt);\n    const extraction = await memoryExtractorOutputParser.parse(rawExtraction.content);\n\n    const newMemories = extraction.newMemories.map((m) => ({\n      ...m,\n      id: nanoid(),\n      timestamp: new Date().toISOString(),\n      source: \"conversation\",\n    }));\n\n    // Return the successful response\n    return res.status(200).json({\n      success: true,\n      data: {\n        newMemories,\n        reasoning: extraction.reasoning,\n      }\n    });\n  } catch (error: any) {\n    console.error('Error in memory extraction:', error);\n    return res.status(500).json({\n      success: false,\n      error: error.message || 'An unknown error occurred'\n    });\n  }\n}// src/pages/api/langchain/questions/evaluate.ts\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { ChatAnthropic } from \"@langchain/anthropic\";\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport { StructuredOutputParser } from '@langchain/core/output_parsers';\nimport { z } from \"zod\";\nimport { getPromptTemplate } from \"@/lib/configLoader\";\nimport { supabase } from \"@/lib/supabaseClient\";\n\n// Define response type\ntype ApiResponse = {\n  success: boolean;\n  data?: any;\n  error?: string;\n};\n\n// Output parser for quality evaluation\nconst evaluationParser = StructuredOutputParser.fromZodSchema(\n  z.object({\n    clarity: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    depth: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    relevance: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    originality: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    engagement: z.object({\n      score: z.number().min(0).max(10),\n      justification: z.string(),\n      improvementSuggestion: z.string().optional(),\n    }),\n    strengths: z.array(z.string()),\n    areasForImprovement: z.array(z.string()),\n    suggestedRevision: z.string().optional(),\n  })\n);\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ success: false, error: 'Method not allowed' });\n  }\n\n  try {\n    const { question } = req.body;\n\n    if (!question) {\n      return res.status(400).json({ \n        success: false, \n        error: 'Missing required parameter: question' \n      });\n    }\n\n    // Model setup\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      return res.status(500).json({ \n        success: false, \n        error: 'ANTHROPIC_API_KEY is not set' \n      });\n    }\n\n    const model = new ChatAnthropic({\n      modelName: \"claude-3-sonnet-20240229\",\n      anthropicApiKey: apiKey,\n    });\n\n    // Get evaluation prompt\n    const template = getPromptTemplate('public_questions', 'evaluation') || '';\n    const prompt = PromptTemplate.fromTemplate(template);\n    \n    const formattedPrompt = await prompt.format({\n      question,\n      formatInstructions: evaluationParser.getFormatInstructions(),\n    });\n    \n    const response = await model.invoke(formattedPrompt);\n    const evaluation = await evaluationParser.parse(response.content);\n    \n    // Return the successful response\n    return res.status(200).json({\n      success: true,\n      data: evaluation\n    });\n  } catch (error: any) {\n    console.error('Error in question evaluation:', error);\n    return res.status(500).json({\n      success: false,\n      error: error.message || 'An unknown error occurred'\n    });\n  }\n}// Simplified fallback version of the chat API without the complexity\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport Anthropic from '@anthropic-ai/sdk';\n\n// Initialize Anthropic client directly with the API key\nconst anthropic = new Anthropic({\n  apiKey: process.env.ANTHROPIC_API_KEY || '',\n});\n\n// Basic demo response for demo mode\nconst demoResponse = `This is a simplified fallback API response.\nIn production, this would be an actual response from Claude AI.\nThe main API endpoint might be experiencing issues.`;\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  console.log('Simple fallback API called');\n  \n  // Only handle POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Get request parameters\n    const { messages, stream = false } = req.body;\n    \n    // Validate messages\n    if (!messages || !Array.isArray(messages)) {\n      return res.status(400).json({ error: 'Invalid messages parameter' });\n    }\n\n    // Demo mode response - always return the demo content\n    const isDemoMode = process.env.NODE_ENV === 'development' || !process.env.ANTHROPIC_API_KEY;\n    if (isDemoMode) {\n      return res.status(200).json({\n        content: demoResponse,\n        model: \"claude-3-demo\",\n        role: 'assistant'\n      });\n    }\n\n    // If we have a valid API key, try to use the Anthropic client\n    try {\n      // Extract system message if present\n      const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n      \n      // Filter out system messages - they should be passed as a separate parameter\n      const filteredMessages = messages\n        .filter(msg => msg.role !== 'system')\n        .map(msg => ({\n          role: msg.role,\n          content: msg.content\n        }));\n      \n      console.log(\"Making request to Claude with:\", {\n        model: 'claude-3-haiku-20240307',\n        system: systemMessage,\n        messagesCount: filteredMessages.length\n      });\n      \n      // Make a simple, non-streaming request to Anthropic\n      const response = await anthropic.messages.create({\n        model: 'claude-3-haiku-20240307', // Use Haiku for faster responses\n        max_tokens: 1000,\n        system: systemMessage,\n        messages: filteredMessages,\n        temperature: 0.7 // Add temperature for more natural responses\n      });\n\n      // Extract text from the response\n      const textContent = response.content\n        .filter(block => block.type === 'text')\n        .map(block => 'text' in block ? block.text : '')\n        .join('\\n');\n\n      // Return the simple, processed response\n      return res.status(200).json({\n        content: textContent,\n        model: response.model,\n        role: 'assistant'\n      });\n    } catch (error) {\n      console.error('API error:', error);\n      \n      // Return a fallback even for API errors\n      return res.status(200).json({\n        content: `Sorry, there was an error contacting the AI service: ${error.message || 'Unknown error'}`,\n        model: \"claude-3-fallback\",\n        role: 'assistant'\n      });\n    }\n  } catch (error) {\n    console.error('Unexpected error:', error);\n    \n    // Final fallback response\n    return res.status(200).json({\n      content: \"An unexpected error occurred. The API might be temporarily unavailable.\",\n      model: \"claude-3-fallback\",\n      role: 'assistant'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\n\n// Initialize Anthropic client when we have an API key\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nconst isValidApiKey = apiKey && apiKey.trim() !== '';\nconst anthropic = isValidApiKey\n  ? new Anthropic({ apiKey })\n  : null;\n\nconsole.log('Transcribe API initialized:', {\n  hasApiKey: Boolean(apiKey),\n  apiKeyLength: apiKey ? apiKey.length : 0,\n  nodeEnv: process.env.NODE_ENV\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Log headers for debugging\n  console.log('Request headers:', {\n    host: req.headers.host,\n    origin: req.headers.origin,\n    referer: req.headers.referer,\n    'content-type': req.headers['content-type'],\n    'content-length': req.headers['content-length']\n  });\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n  \n  // Check if API key is configured\n  const isDemoMode = !anthropic || !isValidApiKey;\n  \n  // Get the session if we need it\n  const { data: { session } } = await supabase.auth.getSession();\n  \n  // Log auth info for debugging\n  console.log('Auth check (transcribe):', { \n    hasSession: !!session,\n    sessionUser: session?.user?.email || 'none',\n    productionEnv: process.env.NODE_ENV === 'production'\n  });\n\n  // ALWAYS BYPASS AUTH CHECK FOR NOW - can be enabled later\n  const requireAuth = false;\n  if (requireAuth && !session && !isDemoMode) {\n    console.log('Rejecting request: Unauthorized');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { image, selectionInfo, thumbnail, notebookId } = req.body;\n\n    // Enhanced debug logging\n    console.log('Image data check:', {\n      hasImageData: Boolean(image),\n      imageDataType: typeof image,\n      imageDataLength: typeof image === 'string' ? image.length : 0,\n      hasSelectionInfo: Boolean(selectionInfo),\n      hasThumbnail: Boolean(thumbnail),\n      notebookId: notebookId || 'none',\n      bodyKeys: Object.keys(req.body),\n      contentType: req.headers['content-type']\n    });\n\n    // Validate image data\n    if (!image) {\n      console.error('Missing image data in request');\n      return res.status(400).json({ \n        error: 'Missing image data',\n        debug: { bodyKeys: Object.keys(req.body) }\n      });\n    }\n    \n    // Validate image data is not empty or too small\n    // Reduced the threshold to allow smaller images\n    if (typeof image === 'string' && image.length < 500) {\n      console.error('Image data appears to be too small or empty');\n      return res.status(200).json({\n        transcription: \"Error: The selected area appears to be empty or too small to transcribe. Please select a larger area with visible content.\",\n        tags: [\"error\", \"empty-selection\"],\n        error: \"Selected area too small\"\n      });\n    }\n    \n    // Log image data details for debugging\n    const debug = req.body.debug === true;\n    if (debug) {\n      console.log('Image data details:', {\n        imageLength: typeof image === 'string' ? image.length : 0,\n        selectionInfo: selectionInfo || 'none',\n        notebookId: notebookId || 'none',\n      });\n    }\n\n    // Always provide a response whether in demo mode or not\n    // This ensures the client always gets something useful\n    if (isDemoMode || !anthropic) {\n      console.log('Using demo mode for transcription');\n      return res.status(200).json({\n        transcription: \"This is a demo transcription. In production, this would be the actual text transcribed from your handwriting by Claude.\",\n        tags: [\"demo\", \"handwriting\", \"note\", \"sample\", \"cursive\"]\n      });\n    }\n\n    // Call Claude API to transcribe the image\n    try {\n      const response = await anthropic.messages.create({\n        model: 'claude-3-5-sonnet-20240620',\n        max_tokens: 1024,\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'image',\n                source: {\n                  type: 'base64',\n                  media_type: 'image/png',\n                  data: image,\n                },\n              },\n              {\n                type: 'text',\n                text: 'Your task is to transcribe any visible handwritten text or drawings from this image. This image is a selection from a canvas with a white background. Some selections may contain very faint or subtle lines that are difficult to see - please look carefully. Please respond ONLY in valid JSON with the following structure:\\n' +\n                  '{\\n' +\n                  '  \"transcription\": \"transcription of any visible handwriting, drawing description, or text\",\\n' +\n                  '  \"tags\": [\"tag1\", \"tag2\", \"tag3\", \"tag4\", \"tag5\"],\\n' +\n                  '  \"hasContent\": true or false\\n' +\n                  '}\\n\\n' +\n                  'Important notes:\\n' +\n                  '1. Set \"hasContent\" to false if you cannot see any content at all, and provide a message indicating the selection appears empty\\n' +\n                  '2. For subtle drawings or lines, describe what you can see even if it\\'s faint\\n' +\n                  '3. For drawings, briefly describe what is drawn\\n' +\n                  '4. Provide up to 5 relevant tags based on the content\\n' +\n                  '5. Maintain line breaks and formatting as much as possible\\n' +\n                  '6. If you see ANY content at all, even faint lines or marks, please describe them rather than saying there is no content'\n              },\n            ],\n          },\n        ],\n      });\n\n      // Parse the response to extract the JSON\n      try {\n        const content = response.content[0];\n        // Check if the content is a text block\n        if (!content || !('text' in content)) {\n          throw new Error('Response did not contain text content');\n        }\n        const textContent = content.text;\n        const parsedResponse = JSON.parse(textContent);\n        \n        return res.status(200).json({\n          transcription: parsedResponse.transcription || '',\n          tags: parsedResponse.tags || [],\n        });\n      } catch (parseError) {\n        console.error('Error parsing Claude response as JSON:', parseError);\n        \n        // Attempt to extract transcription using regex as fallback\n        const content = response.content[0];\n        // Check if the content is a text block\n        if (!content || !('text' in content)) {\n          throw new Error('Failed to extract text from Claude response');\n        }\n        const textContent = content.text;\n        \n        const transcriptionMatch = textContent.match(/\"transcription\":\\s*\"([^\"]*)\"/);\n        const transcription = transcriptionMatch ? transcriptionMatch[1] : '';\n        \n        return res.status(200).json({\n          transcription,\n          tags: [],\n          rawResponse: textContent,\n        });\n      }\n    } catch (apiError) {\n      console.error('Claude API error:', apiError);\n      \n      // Even on API error, return a demo response to avoid breaking the client\n      return res.status(200).json({\n        transcription: \"Sorry, there was an error with the transcription service. This is a fallback response.\",\n        tags: [\"error\", \"fallback\", \"demo\"],\n        errorDetails: apiError instanceof Error ? apiError.message : 'Unknown API error'\n      });\n    }\n  } catch (error) {\n    console.error('Unexpected error in handler:', error);\n    \n    // Return demo response even on errors to avoid breaking client\n    return res.status(200).json({\n      transcription: \"An unexpected error occurred. This is a fallback response.\",\n      tags: [\"error\", \"fallback\", \"unexpected\"],\n      errorDetails: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport Anthropic from '@anthropic-ai/sdk';\nimport { AnthropicStream, StreamingTextResponse } from 'ai';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Initialize Anthropic client when we have an API key\nconst apiKey = process.env.ANTHROPIC_API_KEY || '';\nconst isValidApiKey = apiKey && apiKey.trim() !== '';\nlet anthropic = null;\n\n// Wrap in try-catch to handle initialization errors\ntry {\n  anthropic = isValidApiKey ? new Anthropic({ apiKey }) : null;\n  // Try a simple operation to verify client is working\n  if (anthropic) {\n    console.log('Anthropic client initialized successfully');\n  }\n} catch (error) {\n  console.error('Failed to initialize Anthropic client:', error);\n  anthropic = null;\n}\n\nconsole.log('Chat API initialized:', {\n  hasApiKey: Boolean(apiKey),\n  apiKeyLength: apiKey ? apiKey.length : 0,\n  nodeEnv: process.env.NODE_ENV\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Log headers for debugging\n  console.log('Request headers:', {\n    host: req.headers.host,\n    origin: req.headers.origin,\n    referer: req.headers.referer,\n    'content-type': req.headers['content-type']\n  });\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n\n  // Check if API key is configured\n  const isDemoMode = !anthropic || !isValidApiKey;\n\n  // Get the session if we need it\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Log auth info for debugging\n  console.log('Auth check (chat):', {\n    hasSession: !!session,\n    sessionUser: session?.user?.email || 'none',\n    productionEnv: process.env.NODE_ENV === 'production'\n  });\n\n  // ALWAYS BYPASS AUTH CHECK FOR NOW - can be enabled later\n  const requireAuth = false;\n  if (requireAuth && !session && !isDemoMode) {\n    console.log('Rejecting request: Unauthorized');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { messages: rawMessages, stream = false, model = 'claude-3-5-sonnet-20240620', includeUserContext = true, notebookId } = req.body;\n    const userId = session?.user?.id || null;\n\n    if (!rawMessages || !Array.isArray(rawMessages)) {\n      return res.status(400).json({ error: 'Invalid or missing messages parameter' });\n    }\n\n    // Log the raw messages for debugging\n    console.log('Raw messages received:', JSON.stringify(rawMessages.slice(0, 2), null, 2));\n\n    // IMPORTANT: Deep clean messages to ONLY include fields accepted by Claude API\n    // Claude API strictly rejects any extra fields like 'timestamp'\n    const messages = rawMessages.map(msg => {\n      // Explicitly extract only the fields Claude accepts and nothing else\n      const { role, content } = msg;\n      return { role, content };\n    });\n\n    // Double-check that no timestamps are present\n    const hasInvalidFields = messages.some(msg =>\n      Object.keys(msg).some(key => key !== 'role' && key !== 'content')\n    );\n\n    if (hasInvalidFields) {\n      console.warn('WARNING: Invalid fields detected in messages after cleaning!');\n      console.warn('Forcing strict cleanup...');\n\n      // Force a stringification and re-parsing to eliminate any unexpected fields\n      const strippedMessages = JSON.parse(JSON.stringify(messages))\n        .map(msg => ({ role: msg.role, content: msg.content }));\n\n      console.log('Strictly cleaned messages:', JSON.stringify(strippedMessages.slice(0, 2), null, 2));\n    }\n\n    // Log the cleaned messages\n    console.log('Cleaned messages:', JSON.stringify(messages.slice(0, 2), null, 2));\n\n    // Always provide a response whether in demo mode or not\n    if (isDemoMode || !anthropic) {\n      console.log('Using demo mode for chat');\n\n      if (stream) {\n        // Provide a mock streaming response for demo mode\n        const demoResponse = \"This is a demo response from Claude. In production, this would be an actual response based on your handwritten text. The app is currently running in demo mode without a Claude API key. Your handwriting would be analyzed and I'd provide a thoughtful, detailed response.\";\n\n        // Use the AI SDK's streaming response functionality to simulate streaming\n        const encoder = new TextEncoder();\n        const stream = new ReadableStream({\n          async start(controller) {\n            for (const word of demoResponse.split(' ')) {\n              controller.enqueue(encoder.encode(`data: ${JSON.stringify({\n                id: `chatmsg-${Date.now()}`,\n                object: 'chat.completion.chunk',\n                created: Date.now(),\n                model: \"claude-3-demo\",\n                delta: { content: word + ' ' },\n                role: 'assistant'\n              })}\\n\\n`));\n              await new Promise(resolve => setTimeout(resolve, 50));\n            }\n            controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n            controller.close();\n          }\n        });\n\n        return new Response(stream, {\n          headers: {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            'Connection': 'keep-alive'\n          }\n        });\n      } else {\n        // Non-streaming demo response\n        return res.status(200).json({\n          content: [{\n            type: 'text',\n            text: \"This is a demo response from Claude. In production, this would be an actual response based on your handwritten text.\"\n          }],\n          model: \"claude-3-demo\",\n          role: 'assistant'\n        });\n      }\n    }\n\n    try {\n      if (stream) {\n        // Create a proper stream using the Anthropic client\n        // Add verbose logging to diagnose the 500 error\n        console.log('About to call Anthropic API with:', {\n          modelToUse: model,\n          messageCount: messages.length,\n          firstUserMessage: messages.find(m => m.role === 'user')?.content?.substring(0, 50) + '...',\n        });\n        \n        // Wrap in try-catch for better error logging\n        try {\n          // Extract system message if present\n          const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n          \n          // Filter out system messages - they should be passed as a separate parameter\n          const filteredMessages = messages.filter(msg => msg.role !== 'system');\n          \n          const response = await anthropic.messages.create({\n            model,\n            max_tokens: 4000,\n            system: systemMessage,\n            messages: filteredMessages,\n            stream: true,\n          });\n\n        // Create a variable to track the full response\n        let fullResponse = '';\n        \n        // Create a transform stream to intercept chunks and collect the full response\n        const transformStream = new TransformStream({\n          transform(chunk, controller) {\n            // Pass through all chunks\n            controller.enqueue(chunk);\n            \n            // Try to extract content\n            try {\n              const text = new TextDecoder().decode(chunk);\n              if (text.includes('data:')) {\n                const match = text.match(/data: (.+?)(?=\\n|$)/g);\n                if (match) {\n                  for (const dataLine of match) {\n                    try {\n                      // Skip [DONE] events\n                      if (dataLine === 'data: [DONE]') continue;\n                      \n                      // Parse the JSON data\n                      const data = JSON.parse(dataLine.slice(6));\n                      \n                      // Handle different response formats\n                      if (data.delta?.content) {\n                        // Anthropic format\n                        fullResponse += data.delta.content;\n                      } else if (data.choices?.[0]?.delta?.content) {\n                        // OpenAI-like format\n                        fullResponse += data.choices[0].delta.content;\n                      } else if (typeof data.content === 'string') {\n                        // Direct content format\n                        fullResponse += data.content;\n                      }\n                    } catch (e) {\n                      // Quietly ignore parse errors in non-content chunks\n                      console.debug('Error parsing chunk:', e);\n                    }\n                  }\n                }\n              }\n            } catch (e) {\n              // Ignore any errors in content extraction\n            }\n          }\n        });\n        \n        // Create a copy of the original stream\n        const responseStream = AnthropicStream(response);\n        const readableStream = responseStream.pipeThrough(transformStream);\n        \n        // Process user context in the background\n        const userContextProcessing = async () => {\n          try {\n            // Handle memory extraction first (doesn't need response)\n            if (userId && includeUserContext) {\n              const userMessage = messages\n                .filter(msg => msg.role === 'user')\n                .pop()?.content as string || '';\n\n              if (userMessage) {\n                await processMessageForMemories(userId, userMessage);\n              }\n            }\n          } catch (error) {\n            console.error('Error processing user context:', error);\n          }\n        };\n        \n        // Start memory extraction in the background\n        userContextProcessing();\n        \n        // Also process the full response when the stream ends\n        readableStream.pipeTo(\n          new WritableStream({\n            close() {\n              if (userId && includeUserContext && fullResponse) {\n                processResponseForUserContext(userId, fullResponse)\n                  .catch(error => console.error('Error processing response context:', error));\n              }\n            }\n          })\n        ).catch(e => console.error('Stream processing error:', e));\n\n        // Return the stream as a streaming response\n        return new StreamingTextResponse(readableStream);\n        } catch (streamError) {\n          console.error('Streaming API call failed with error:', streamError);\n          console.error('Error details:', {\n            name: streamError instanceof Error ? streamError.name : 'Unknown',\n            message: streamError instanceof Error ? streamError.message : 'Unknown error',\n            status: streamError.status || 'No status',\n            stack: streamError instanceof Error ? streamError.stack : 'No stack trace',\n          });\n          \n          // Provide a fallback non-streaming response\n          const fallbackResponse = \"Sorry, there was an error with the streaming API. Trying with non-streaming instead.\";\n          \n          // Use non-streaming API as fallback\n          try {\n            console.log('Attempting fallback to non-streaming API');\n            // Extract system message if present\n            const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n            \n            // Filter out system messages - they should be passed as a separate parameter\n            const filteredMessages = messages.filter(msg => msg.role !== 'system');\n            \n            const fallbackApiResponse = await anthropic.messages.create({\n              model,\n              max_tokens: 1000,\n              system: systemMessage,\n              messages: filteredMessages,\n            });\n            \n            const textContent = fallbackApiResponse.content\n              .filter(block => block.type === 'text')\n              .map(block => 'text' in block ? block.text : '')\n              .join('\\n');\n              \n            // Return as streamed response for consistency\n            const encoder = new TextEncoder();\n            const stream = new ReadableStream({\n              start(controller) {\n                controller.enqueue(encoder.encode(`data: ${JSON.stringify({\n                  id: `chatmsg-${Date.now()}`,\n                  object: 'chat.completion.chunk',\n                  created: Date.now(),\n                  model: model,\n                  delta: { content: textContent },\n                  role: 'assistant'\n                })}\\n\\n`));\n                controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n                controller.close();\n              }\n            });\n            \n            return new StreamingTextResponse(stream);\n          } catch (fallbackError) {\n            console.error('Even fallback API call failed:', fallbackError);\n            throw streamError; // Re-throw original error for consistent error handling\n          }\n        }\n      } else {\n        // Handle non-streaming response\n        // Extract system message if present\n        const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n        \n        // Filter out system messages - they should be passed as a separate parameter\n        const filteredMessages = messages.filter(msg => msg.role !== 'system');\n        \n        const response = await anthropic.messages.create({\n          model,\n          max_tokens: 4000,\n          system: systemMessage,\n          messages: filteredMessages,\n        });\n\n        // Process the response for user context (if we have a userId)\n        if (userId && includeUserContext && response.content) {\n          const responseText = response.content\n            .filter(block => block.type === 'text')\n            .map(block => 'text' in block ? block.text : '')\n            .join('\\n');\n\n          try {\n            // Process for traditional user context\n            await processResponseForUserContext(userId, responseText);\n\n            // Also process for Theory of Mind memory extraction - get the user message\n            const userMessage = messages\n              .filter(msg => msg.role === 'user')\n              .pop()?.content as string || '';\n\n            if (userMessage) {\n              // Process the user's message to extract memories\n              await processMessageForMemories(userId, userMessage);\n            }\n          } catch (contextError) {\n            console.error('Error processing response for user context:', contextError);\n          }\n        }\n\n        return res.status(200).json(response);\n      }\n    } catch (apiError) {\n      console.error('Claude API error:', apiError);\n\n      // Log more detailed error info\n      console.error('Detailed API error:', {\n        name: apiError instanceof Error ? apiError.name : 'Unknown',\n        message: apiError instanceof Error ? apiError.message : 'Unknown error',\n        stack: apiError instanceof Error ? apiError.stack : 'No stack trace',\n      });\n\n      // Return a demo response even on API error\n      if (stream) {\n        const encoder = new TextEncoder();\n        const errorStream = new ReadableStream({\n          start(controller) {\n            const errorResponse = \"Sorry, there was an error contacting the AI service. This is a fallback response to prevent the application from breaking.\";\n            controller.enqueue(encoder.encode(`data: ${JSON.stringify({\n              id: `chatmsg-${Date.now()}`,\n              object: 'chat.completion.chunk',\n              created: Date.now(),\n              model: \"claude-3-demo\",\n              delta: { content: errorResponse },\n              role: 'assistant'\n            })}\\n\\n`));\n            controller.enqueue(encoder.encode('data: [DONE]\\n\\n'));\n            controller.close();\n          }\n        });\n\n        return new Response(errorStream, {\n          headers: {\n            'Content-Type': 'text/event-stream',\n            'Cache-Control': 'no-cache, no-transform',\n            'Connection': 'keep-alive'\n          }\n        });\n      } else {\n        return res.status(200).json({\n          content: [{\n            type: 'text',\n            text: \"Sorry, there was an error contacting the AI service. This is a fallback response to prevent the application from breaking.\"\n          }],\n          model: \"claude-3-demo\",\n          role: 'assistant'\n        });\n      }\n    }\n  } catch (error) {\n    console.error('Unexpected error in handler:', error);\n    console.error('Error details:', {\n      type: typeof error,\n      message: error instanceof Error ? error.message : String(error),\n      stack: error instanceof Error ? error.stack : 'No stack trace'\n    });\n\n    // For unexpected errors, still try to return something useful\n    return res.status(200).json({\n      content: [{\n        type: 'text',\n        text: \"An unexpected error occurred. This is a fallback response.\"\n      }],\n      model: \"claude-3-demo\",\n      role: 'assistant',\n      errorDetails: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}// src/pages/api/claude/stream.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { supabase } from '@/lib/supabaseClient';\nimport { Anthropic } from '@anthropic-ai/sdk';\nimport { nanoid } from 'nanoid';\n\n// Rate limiting\nconst rateLimit = {\n  windowMs: 60 * 1000, // 1 minute\n  max: 10 // max 10 requests per minute\n};\n\n// In-memory store for rate limiting\nconst ipRequestCounts = new Map<string, { count: number; resetTime: number }>();\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress || 'unknown';\n  const ipStr = Array.isArray(ip) ? ip[0] : ip;\n\n  // Apply rate limiting\n  const now = Date.now();\n  const ipData = ipRequestCounts.get(ipStr);\n  \n  if (ipData && now < ipData.resetTime) {\n    if (ipData.count >= rateLimit.max) {\n      return res.status(429).json({ \n        error: 'Too many requests',\n        message: 'Please try again later'\n      });\n    }\n    ipData.count += 1;\n  } else {\n    ipRequestCounts.set(ipStr, {\n      count: 1,\n      resetTime: now + rateLimit.windowMs\n    });\n  }\n\n  // Only allow POST\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { threadId, message, systemPrompt } = req.body;\n\n    if (!threadId || !message) {\n      return res.status(400).json({ error: 'Missing required parameters' });\n    }\n\n    // Verify the thread exists\n    const { data: threadData, error: threadError } = await supabase\n      .from('threads')\n      .select('id, notebook_id')\n      .eq('id', threadId)\n      .single();\n\n    if (threadError || !threadData) {\n      return res.status(404).json({ error: 'Thread not found' });\n    }\n\n    // Get previous messages from this thread for context\n    const { data: messagesData, error: messagesError } = await supabase\n      .from('thread_messages')\n      .select('content, role, created_at')\n      .eq('thread_id', threadId)\n      .order('created_at', { ascending: true })\n      .limit(20); // Limit context window\n\n    if (messagesError) {\n      return res.status(500).json({ error: 'Failed to fetch thread messages' });\n    }\n\n    // Format message history for Claude\n    const messageHistory = messagesData.map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n    // Add system message if provided\n    if (systemPrompt) {\n      messageHistory.unshift({\n        role: 'system',\n        content: systemPrompt\n      });\n    }\n\n    // Generate a message ID for this response\n    const messageId = nanoid();\n\n    // Contact Claude API\n    const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;\n    \n    if (!ANTHROPIC_API_KEY) {\n      return res.status(500).json({ error: 'API key not configured' });\n    }\n\n    // Initialize Anthropic client\n    const anthropic = new Anthropic({\n      apiKey: ANTHROPIC_API_KEY,\n    });\n    \n    try {\n      // Use non-streaming mode for simplicity\n      const response = await anthropic.messages.create({\n        model: 'claude-3-haiku-20240307',\n        messages: messageHistory,\n        system: systemPrompt || \"You are a helpful AI assistant in a notebook application. Keep responses concise.\",\n        max_tokens: 1024\n      });\n\n      // Extract content text safely\n      const content = response.content[0].type === 'text'\n        ? response.content[0].text\n        : 'Unable to generate response';\n\n      // Save the message to the database\n      const { error: insertError } = await supabase.from('thread_messages').insert({\n        id: messageId,\n        thread_id: threadId,\n        content,\n        role: 'assistant'\n      });\n\n      if (insertError) {\n        console.error('Error saving message to database:', insertError);\n      }\n\n      // Return the message\n      return res.status(200).json({\n        threadId,\n        messageId,\n        content,\n        role: 'assistant'\n      });\n    } catch (anthropicError) {\n      console.error('Error from Anthropic:', anthropicError);\n      return res.status(500).json({ \n        error: 'Claude API error', \n        details: anthropicError instanceof Error ? anthropicError.message : 'Unknown error'\n      });\n    }\n  } catch (error) {\n    console.error('Error in AI API:', error);\n    return res.status(500).json({ \n      error: 'Internal server error',\n      message: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}/**\n * Unified Chat API handler for Claude\n * Handles both streaming and non-streaming requests\n */\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport chatService from '@/lib/chat/server/chatService';\n\n// Configure longer timeout\nexport const config = {\n  api: {\n    bodyParser: {\n      sizeLimit: '4mb',\n    },\n    responseLimit: '8mb',\n  },\n};\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only accept POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Initialize Supabase client\n    const supabase = createPagesServerClient({ req, res });\n    const { data: { session } } = await supabase.auth.getSession();\n    const userId = session?.user?.id || null;\n\n    // Extract request parameters\n    const { \n      messages, \n      stream = false, \n      model = 'claude-3-sonnet-20240229', \n      includeUserContext = true,\n      notebookId \n    } = req.body;\n\n    // Basic validation\n    if (!messages || !Array.isArray(messages)) {\n      return res.status(400).json({ error: 'Invalid messages parameter' });\n    }\n\n    // Check if we're in demo mode (no API key)\n    if (chatService.isDemoMode()) {\n      // Return a demo response\n      return res.status(200).json({\n        content: chatService.getDemoResponse(),\n        model: \"claude-3-demo\",\n        role: 'assistant'\n      });\n    }\n\n    // Extract system message and prepare messages\n    const systemMessage = messages.find(msg => msg.role === 'system')?.content || '';\n    const cleanedMessages = messages.filter(msg => msg.role !== 'system').map(msg => ({\n      role: msg.role,\n      content: msg.content\n    }));\n\n    // Handle non-streaming response (always use this for simplicity)\n    try {\n      // Make the API call using the chatService\n      const response = await chatService.anthropic.messages.create({\n        model,\n        max_tokens: 4000,\n        system: systemMessage,\n        messages: cleanedMessages,\n      });\n\n      // Extract text content\n      const textContent = response.content\n        .filter(block => block.type === 'text')\n        .map(block => block.text)\n        .join('\\n');\n        \n      // Process response for user context if needed (do this async)\n      if (userId && includeUserContext) {\n        const lastUserMessage = messages\n          .filter(msg => msg.role === 'user')\n          .pop()?.content || '';\n          \n        chatService.processResponse(userId, textContent, lastUserMessage, includeUserContext)\n          .catch(err => console.error('Error processing response:', err));\n      }\n\n      // Return response\n      return res.status(200).json({\n        content: textContent,\n        model: response.model,\n        role: 'assistant'\n      });\n    } catch (error) {\n      console.error('Error in chat response:', error);\n      return res.status(500).json({ \n        success: false, \n        error: error.message || 'An unknown error occurred'\n      });\n    }\n  } catch (error) {\n    console.error('Unexpected error in chat handler:', error);\n    return res.status(500).json({ \n      success: false, \n      error: 'An unknown error occurred'\n    });\n  }\n}import type { NextApiRequest, NextApiResponse } from 'next';\nimport { v4 as uuidv4 } from 'uuid';\n\ninterface Stroke {\n  id: string;\n  path: { x: number; y: number }[];\n  color: string;\n  width: number;\n  createdAt: string;\n}\n\n// Simulated in-memory store (replace with database in production)\nconst strokes: Record<string, Stroke> = {};\n\nexport default function handler(req: NextApiRequest, res: NextApiResponse) {\n  if (req.method === 'POST') {\n    const { path, color, width } = req.body;\n\n    if (!Array.isArray(path) || path.some(p => typeof p.x !== 'number' || typeof p.y !== 'number')) {\n      return res.status(400).json({ error: 'Invalid or missing stroke path' });\n    }\n\n    const id = uuidv4();\n    const newStroke: Stroke = {\n      id,\n      path,\n      color: typeof color === 'string' ? color : '#000000',\n      width: typeof width === 'number' ? width : 2,\n      createdAt: new Date().toISOString(),\n    };\n\n    strokes[id] = newStroke;\n\n    return res.status(201).json({ success: true, stroke: newStroke });\n  } else {\n    res.setHeader('Allow', 'POST');\n    return res.status(405).json({ error: 'Method Not Allowed' });\n  }\n}\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { queryMemories } from '@/lib/theoryOfMindService';\nimport { MemoryQueryRequest } from '@/types/theoryOfMind';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Only allow POST requests for memory queries\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n\n  // Check authentication\n  const { data: { session } } = await supabase.auth.getSession();\n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  try {\n    // Extract query parameters\n    const { query, relevanceThreshold, maxResults } = req.body as MemoryQueryRequest;\n    \n    if (!query) {\n      return res.status(400).json({ error: 'Missing required parameter: query' });\n    }\n    \n    // Execute the memory query\n    const result = await queryMemories(session.user.id, {\n      query,\n      relevanceThreshold,\n      maxResults\n    });\n    \n    return res.status(200).json(result);\n  } catch (error) {\n    console.error('Error in memory query:', error);\n    return res.status(500).json({ \n      error: 'Internal server error',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { getUserTheoryOfMind, getMemoryStatistics } from '@/lib/theoryOfMindService';\nimport { supabase } from '@/lib/supabaseClient';\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  // Get token from the request\n  const token = req.headers.authorization?.split(' ')[1];\n\n  if (!token) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  try {\n    // Verify the token and get the user\n    const { data: { user }, error } = await supabase.auth.getUser(token);\n\n    if (error || !user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    // Get the theory of mind and stats\n    const tom = await getUserTheoryOfMind(user.id);\n    const stats = await getMemoryStatistics(user.id);\n\n    // Return the data\n    res.status(200).json({\n      theoryOfMind: tom,\n      memoryStats: stats\n    });\n  } catch (error) {\n    console.error('Error in memory-stats API:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { anthropic } from '@ai-sdk/anthropic';\nimport { generateText } from 'ai';\n\n// Get environment variables\nconst ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY || '';\nconst isValidApiKey = ANTHROPIC_API_KEY && ANTHROPIC_API_KEY.trim() !== '';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  console.log('AI SDK Transcribe API request received');\n  \n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n\n  // Check if API key is configured\n  const isDemoMode = !isValidApiKey;\n\n  // Get the session if we need it\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Log auth info for debugging\n  console.log('Auth check (transcribe):', {\n    hasSession: !!session,\n    sessionUser: session?.user?.email || 'none',\n    productionEnv: process.env.NODE_ENV === 'production'\n  });\n\n  // ALWAYS BYPASS AUTH CHECK FOR NOW - can be enabled later\n  const requireAuth = false;\n  if (requireAuth && !session && !isDemoMode) {\n    console.log('Rejecting request: Unauthorized');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { image, notebookId, model = 'claude-3-5-sonnet-20240620' } = req.body;\n\n    // Validate the image data\n    if (!image) {\n      console.error('Missing image data in request');\n      return res.status(400).json({ \n        error: 'Missing image data',\n        debug: { bodyKeys: Object.keys(req.body) }\n      });\n    }\n\n    // If in demo mode, return a demo response\n    if (isDemoMode) {\n      console.log('Using demo mode for transcription');\n      return res.status(200).json({\n        transcription: \"This is a demo transcription. In production, this would be the actual text transcribed from your handwriting by Claude.\",\n        tags: [\"demo\", \"handwriting\", \"note\", \"sample\"]\n      });\n    }\n\n    try {\n      // Use AI SDK for transcription\n      const response = await generateText({\n        model: anthropic(model),\n        system: \"You are a helpful assistant that transcribes handwritten text from images.\",\n        prompt: [\n          {\n            type: \"image\",\n            source: {\n              type: \"base64\",\n              media_type: \"image/png\",\n              data: image\n            }\n          },\n          {\n            type: \"text\",\n            text: \"Transcribe this handwritten text and respond in valid JSON with the following structure:\\n\" +\n              \"{\\n\" +\n              \"  \\\"transcription\\\": \\\"provide only transcription of the handwriting\\\",\\n\" +\n              \"  \\\"tags\\\": [\\\"tag1\\\", \\\"tag2\\\", \\\"tag3\\\", \\\"tag4\\\", \\\"tag5\\\"]\\n\" +\n              \"}\\n\" +\n              \"Provide up to 5 relevant tags for the content.\"\n          }\n        ],\n        temperature: 0.2,\n        maxTokens: 1024,\n      });\n\n      try {\n        // Parse the JSON response\n        const parsedResponse = JSON.parse(response.text);\n        \n        return res.status(200).json({\n          transcription: parsedResponse.transcription || '',\n          tags: parsedResponse.tags || [],\n          notebookId\n        });\n      } catch (parseError) {\n        console.error('Error parsing transcription response as JSON:', parseError);\n        \n        // Attempt to extract transcription using regex as fallback\n        const textContent = response.text;\n        const transcriptionMatch = textContent.match(/\"transcription\":\\s*\"([^\"]*)\"/);\n        const transcription = transcriptionMatch ? transcriptionMatch[1] : '';\n        \n        return res.status(200).json({\n          transcription,\n          tags: [],\n          notebookId,\n          rawResponse: textContent,\n        });\n      }\n    } catch (apiError) {\n      console.error('Claude API error:', apiError);\n      \n      // Return a fallback response\n      return res.status(200).json({\n        transcription: \"Sorry, there was an error with the transcription service. This is a fallback response.\",\n        tags: [\"error\", \"fallback\"],\n        notebookId,\n        errorDetails: apiError instanceof Error ? apiError.message : 'Unknown API error'\n      });\n    }\n  } catch (error) {\n    console.error('Unexpected error in handler:', error);\n    \n    // Return fallback response\n    return res.status(200).json({\n      transcription: \"An unexpected error occurred. This is a fallback response.\",\n      tags: [\"error\", \"unexpected\"],\n      errorDetails: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { StreamingTextResponse } from 'ai';\nimport { anthropic } from '@ai-sdk/anthropic';\nimport { streamText } from 'ai';\nimport { processResponseForUserContext } from '@/lib/userContextUtils';\nimport { processMessageForMemories } from '@/lib/theoryOfMindService';\n\n// Get environment variables\nconst ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY || '';\nconst isValidApiKey = ANTHROPIC_API_KEY && ANTHROPIC_API_KEY.trim() !== '';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  console.log('AI SDK Chat API request received');\n  \n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n\n  // Check if API key is configured\n  const isDemoMode = !isValidApiKey;\n\n  // Get the session if we need it\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Log auth info for debugging\n  console.log('Auth check (chat):', {\n    hasSession: !!session,\n    sessionUser: session?.user?.email || 'none',\n    productionEnv: process.env.NODE_ENV === 'production'\n  });\n\n  // ALWAYS BYPASS AUTH CHECK FOR NOW - can be enabled later\n  const requireAuth = false;\n  if (requireAuth && !session && !isDemoMode) {\n    console.log('Rejecting request: Unauthorized');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    const { messages: rawMessages, stream = true, model = 'claude-3-5-sonnet-20240620', includeUserContext = true } = req.body;\n    const userId = session?.user?.id || null;\n\n    if (!rawMessages || !Array.isArray(rawMessages)) {\n      return res.status(400).json({ error: 'Invalid or missing messages parameter' });\n    }\n\n    // Clean the messages to have just the expected fields\n    const messages = rawMessages.map(msg => {\n      const { role, content } = msg;\n      return { role, content };\n    });\n\n    // If demo mode or no API key, return a demo response\n    if (isDemoMode) {\n      console.log('Using demo mode for chat');\n      \n      if (stream) {\n        const demoResponse = \"This is a demo response from Claude. In production, this would be an actual response based on your query. The app is currently running in demo mode without a Claude API key.\";\n        \n        const chunks = demoResponse.split('. ');\n        for (const chunk of chunks) {\n          await new Promise(resolve => setTimeout(resolve, 300));\n          res.write(`data: ${JSON.stringify({ \n            type: 'chunk', \n            data: { content: chunk + '. ' } \n          })}\\n\\n`);\n        }\n        \n        res.write(`data: ${JSON.stringify({ type: 'done' })}\\n\\n`);\n        res.end();\n        return;\n      } else {\n        return res.status(200).json({\n          content: \"This is a demo response from Claude. In production, this would be an actual response based on your query.\",\n          model: \"claude-3-demo\"\n        });\n      }\n    }\n\n    // Extract the system message if present\n    let systemMessage = '';\n    const nonSystemMessages = messages.filter(msg => {\n      if (msg.role === 'system') {\n        systemMessage = msg.content;\n        return false;\n      }\n      return true;\n    });\n\n    try {\n      if (stream) {\n        // Using Vercel AI SDK with Anthropic for streaming\n        // Create an in-flight variable to capture the full response for processing\n        let fullResponse = '';\n        \n        // Create stream with anthropic client\n        const anthropicClient = anthropic(model);\n        const stream = await anthropicClient.chat({\n          messages: nonSystemMessages,\n          system: systemMessage || \"You are a helpful AI assistant.\",\n          max_tokens: 1024,\n        });\n        \n        // Create a TransformStream to intercept and collect chunks\n        const transformStream = new TransformStream({\n          transform(chunk, controller) {\n            // Parse the chunk and extract content\n            const decodedChunk = new TextDecoder().decode(chunk);\n            if (decodedChunk.includes('content')) {\n              try {\n                // Extract content from the event data\n                const match = decodedChunk.match(/data: (.*)/);  \n                if (match && match[1]) {\n                  const jsonData = JSON.parse(match[1]);\n                  if (jsonData.delta?.content) {\n                    fullResponse += jsonData.delta.content;\n                  }\n                }\n              } catch (e) {\n                // Silently handle parse errors for non-content chunks\n              }\n            }\n            // Pass through all chunks\n            controller.enqueue(chunk);\n          }\n        });\n        \n        // Create modified stream that processes content when done\n        stream.pipeThrough(transformStream).pipeTo(\n          new WritableStream({\n            close() {\n              // Process the complete response after stream finishes\n              if (userId && includeUserContext && fullResponse) {\n                try {\n                  // Process for traditional user context\n                  processResponseForUserContext(userId, fullResponse);\n                  \n                  // Also process Theory of Mind\n                  const userMessage = messages\n                    .filter(msg => msg.role === 'user')\n                    .pop()?.content || '';\n                    \n                  if (userMessage) {\n                    processMessageForMemories(userId, userMessage);\n                  }\n                } catch (contextError) {\n                  console.error('Error processing for user context:', contextError);\n                }\n              }\n            }\n          })\n        ).catch(e => console.error('Stream processing error:', e));\n        \n        // Return the stream directly\n        return new StreamingTextResponse(stream);\n      } else {\n        // For non-streaming, we need to wait for the full response\n        const anthropicClient = anthropic(model);\n        const response = await anthropicClient.chat({\n          messages: nonSystemMessages,\n          system: systemMessage || \"You are a helpful AI assistant.\",\n          max_tokens: 1024,\n        });\n        \n        const responseText = response.content || '';\n        \n        // Process for user context\n        if (userId && includeUserContext) {\n          try {\n            await processResponseForUserContext(userId, responseText);\n            \n            // Process for Theory of Mind\n            const userMessage = messages\n              .filter(msg => msg.role === 'user')\n              .pop()?.content || '';\n              \n            if (userMessage) {\n              await processMessageForMemories(userId, userMessage);\n            }\n          } catch (contextError) {\n            console.error('Error processing for user context:', contextError);\n          }\n        }\n        \n        return res.status(200).json({\n          content: responseText,\n          model: model\n        });\n      }\n    } catch (apiError) {\n      console.error('API error:', apiError);\n      \n      // Return a fallback response\n      if (stream) {\n        const fallbackResponse = \"Sorry, there was an error contacting the AI service. This is a fallback response.\";\n        \n        res.write(`data: ${JSON.stringify({ \n          type: 'chunk',\n          data: { content: fallbackResponse } \n        })}\\n\\n`);\n        \n        res.write(`data: ${JSON.stringify({ type: 'done' })}\\n\\n`);\n        res.end();\n      } else {\n        return res.status(200).json({\n          content: \"Sorry, there was an error contacting the AI service. This is a fallback response.\",\n          model: model,\n          error: apiError instanceof Error ? apiError.message : 'Unknown API error'\n        });\n      }\n    }\n  } catch (error) {\n    console.error('Unexpected error in handler:', error);\n    \n    // Return fallback response\n    return res.status(200).json({\n      content: \"An unexpected error occurred. This is a fallback response.\",\n      model: \"fallback\",\n      error: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { supabase } from '@/lib/supabaseClient';\nimport { generateUUID } from '@/utils/uuidUtils';\n\nexport default async function handler(req: NextApiRequest, NextApiResponse) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Get the authenticated user\n    const { data: { session }, error: authError } = await supabase.auth.getSession();\n    \n    if (authError || !session) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n    \n    const userId = session.user.id;\n    \n    // Get question from request body\n    const { question, title } = req.body;\n    \n    if (!question) {\n      return res.status(400).json({ error: 'Question is required' });\n    }\n    \n    // Create a new notebook\n    const notebookTitle = title || 'Notebook: ' + question.substring(0, 30) + (question.length > 30 ? '...' : '');\n    \n    const { data: notebook, error: notebookError } = await supabase\n      .from('notebooks')\n      .insert({\n        title: notebookTitle,\n        user_id: userId,\n        is_public: false,\n        is_collaborative: false,\n        system_prompt: '',\n        question: question\n      })\n      .select()\n      .single();\n      \n    if (notebookError) {\n      console.error('Error creating notebook:', notebookError);\n      return res.status(500).json({ error: 'Failed to create notebook' });\n    }\n    \n    // Create thread for the question\n    const notebookId = notebook.id;\n    const threadId = generateUUID();\n    \n    const { error: threadError } = await supabase\n      .from('threads')\n      .insert({\n        id: threadId,\n        notebook_id: notebookId,\n        title: question.substring(0, 50),\n        position: { x: 100, y: 100 },\n        parent_id: null,\n        referenced_threads: [],\n        card_type: 'question',\n        type: 'main',\n        handwriting_style: 'neat',\n        is_minimized: false,\n        z_index: 0,\n        user_id: userId,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n      \n    if (threadError) {\n      console.error('Error creating thread:', threadError);\n      return res.status(500).json({ error: 'Failed to create thread' });\n    }\n    \n    // Add the user's question as a message\n    const messageId = generateUUID();\n    \n    const { error: messageError } = await supabase\n      .from('thread_messages')\n      .insert({\n        id: messageId,\n        thread_id: threadId,\n        content: question,\n        role: 'user',\n        created_at: new Date().toISOString()\n      });\n      \n    if (messageError) {\n      console.error('Error creating message:', messageError);\n      return res.status(500).json({ error: 'Failed to create message' });\n    }\n    \n    // Create a card for the thread\n    const cardId = generateUUID();\n    \n    const { error: cardError } = await supabase\n      .from('cards')\n      .insert({\n        id: cardId,\n        notebook_id: notebookId,\n        thread_id: threadId,\n        type: 'text',\n        title: question.substring(0, 50),\n        content: question,\n        position: { x: 100, y: 100 },\n        size: { width: 300, height: 200 },\n        is_collapsed: false,\n        z_index: 0,\n        user_id: userId,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      });\n      \n    if (cardError) {\n      console.error('Error creating card:', cardError);\n      return res.status(500).json({ error: 'Failed to create card' });\n    }\n    \n    // Return the notebook ID\n    return res.status(200).json({ \n      success: true, \n      notebookId: notebookId,\n      threadId: threadId,\n      cardId: cardId\n    });\n  } catch (error) {\n    console.error('Error handling request:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createServerSupabaseClient } from '@supabase/auth-helpers-nextjs';\nimport { Notification } from '@/types/supabase';\nimport { format } from 'date-fns';\n\n/**\n * API handler for sending digest emails with batched notifications\n * This endpoint would be called by a scheduled job (e.g., cron job or serverless function)\n * \n * Security note: In production, this endpoint should be protected by a secret key\n * or called only from a secure server-side context.\n */\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  // Create Supabase server client (with admin rights)\n  const supabase = createServerSupabaseClient({ req, res });\n\n  try {\n    // Get digest frequency from request, default to 'daily'\n    const { digestFrequency = 'daily' } = req.body;\n\n    // Validate digest frequency\n    const validFrequencies = ['hourly', 'daily', 'weekly'];\n    if (!validFrequencies.includes(digestFrequency)) {\n      return res.status(400).json({ error: 'Invalid digest frequency' });\n    }\n\n    // Get users who have this digest frequency set\n    const { data: userPreferences, error: preferencesError } = await supabase\n      .from('notification_preferences')\n      .select('user_id')\n      .eq('email_digest_frequency', digestFrequency);\n\n    if (preferencesError) {\n      console.error('Error fetching user preferences:', preferencesError);\n      return res.status(500).json({ error: 'Error fetching user preferences' });\n    }\n\n    if (!userPreferences || userPreferences.length === 0) {\n      return res.status(200).json({ success: true, message: 'No users have this digest frequency' });\n    }\n\n    // Get user IDs\n    const userIds = userPreferences.map(pref => pref.user_id);\n\n    // Get user emails\n    const { data: userProfiles, error: profilesError } = await supabase\n      .from('profiles')\n      .select('id, email, username')\n      .in('id', userIds);\n\n    if (profilesError || !userProfiles) {\n      console.error('Error fetching user profiles:', profilesError);\n      return res.status(500).json({ error: 'Error fetching user profiles' });\n    }\n\n    // Process each user\n    const results = await Promise.all(\n      userProfiles.map(async (profile) => {\n        if (!profile.email) return null;\n\n        // Get unread notifications that haven't been emailed\n        const { data: notifications, error: notificationsError } = await supabase\n          .from('notifications')\n          .select('*')\n          .eq('recipient_id', profile.id)\n          .eq('is_email_sent', false)\n          .order('created_at', { ascending: false });\n\n        if (notificationsError) {\n          console.error(`Error fetching notifications for user ${profile.id}:`, notificationsError);\n          return null;\n        }\n\n        if (!notifications || notifications.length === 0) {\n          return { userId: profile.id, email: profile.email, sent: false, reason: 'No notifications' };\n        }\n\n        // Create digest email\n        const emailContent = createDigestEmail(notifications, profile.username || 'User', digestFrequency);\n        const emailSubject = `Your ${digestFrequency} digest from CursiveGPT`;\n\n        // Normally, we would send the email using a service like SendGrid, Mailgun, etc.\n        // For this example, we'll just log it\n        console.log(`Would send digest email to: ${profile.email}`);\n        console.log(`Subject: ${emailSubject}`);\n        console.log(`Content: ${emailContent}`);\n\n        // Mark all notifications as emailed\n        const notificationIds = notifications.map(n => n.id);\n        const { error: updateError } = await supabase\n          .from('notifications')\n          .update({ is_email_sent: true })\n          .in('id', notificationIds);\n\n        if (updateError) {\n          console.error(`Error updating notifications for user ${profile.id}:`, updateError);\n          return { userId: profile.id, email: profile.email, sent: false, reason: 'Error updating notifications' };\n        }\n\n        return { userId: profile.id, email: profile.email, sent: true, count: notifications.length };\n      })\n    );\n\n    // Filter out null results\n    const validResults = results.filter(Boolean);\n\n    return res.status(200).json({ \n      success: true, \n      message: `Processed digest emails for ${validResults.length} users`,\n      results: validResults \n    });\n  } catch (error) {\n    console.error('Error sending digest emails:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n\n/**\n * Create digest email content from notifications\n */\nfunction createDigestEmail(\n  notifications: Notification[],\n  username: string,\n  frequency: string\n): string {\n  const today = new Date();\n  const dateStr = format(today, 'EEEE, MMMM do, yyyy');\n  \n  let emailContent = `Hello ${username},\\n\\n`;\n  emailContent += `Here's your ${frequency} digest of activity from CursiveGPT for ${dateStr}.\\n\\n`;\n  \n  const mentionNotifications = notifications.filter(n => n.type === 'mention');\n  const editNotifications = notifications.filter(n => n.type === 'edit');\n  const commentNotifications = notifications.filter(n => n.type === 'comment');\n  const inviteNotifications = notifications.filter(n => n.type === 'collaboration_invite');\n  const systemNotifications = notifications.filter(n => n.type === 'system');\n  \n  // Mentions section\n  if (mentionNotifications.length > 0) {\n    emailContent += `===== MENTIONS (${mentionNotifications.length}) =====\\n\\n`;\n    mentionNotifications.forEach(notification => {\n      emailContent += `• ${notification.title}\\n`;\n      emailContent += `  ${notification.content}\\n\\n`;\n    });\n  }\n  \n  // Edits section\n  if (editNotifications.length > 0) {\n    emailContent += `===== NOTEBOOK EDITS (${editNotifications.length}) =====\\n\\n`;\n    editNotifications.forEach(notification => {\n      emailContent += `• ${notification.title}\\n`;\n      emailContent += `  ${notification.content}\\n\\n`;\n    });\n  }\n  \n  // Comments section\n  if (commentNotifications.length > 0) {\n    emailContent += `===== COMMENTS (${commentNotifications.length}) =====\\n\\n`;\n    commentNotifications.forEach(notification => {\n      emailContent += `• ${notification.title}\\n`;\n      emailContent += `  ${notification.content}\\n\\n`;\n    });\n  }\n  \n  // Invites section\n  if (inviteNotifications.length > 0) {\n    emailContent += `===== COLLABORATION INVITES (${inviteNotifications.length}) =====\\n\\n`;\n    inviteNotifications.forEach(notification => {\n      emailContent += `• ${notification.title}\\n`;\n      emailContent += `  ${notification.content}\\n\\n`;\n    });\n  }\n  \n  // System notifications section\n  if (systemNotifications.length > 0) {\n    emailContent += `===== SYSTEM NOTIFICATIONS (${systemNotifications.length}) =====\\n\\n`;\n    systemNotifications.forEach(notification => {\n      emailContent += `• ${notification.title}\\n`;\n      emailContent += `  ${notification.content}\\n\\n`;\n    });\n  }\n  \n  // Add CTA to view all notifications\n  emailContent += `View all notifications: https://cursivegpt.com/notifications\\n\\n`;\n  \n  // Add footer\n  emailContent += `---\\n`;\n  emailContent += `To manage your notification preferences, visit your account settings: https://cursivegpt.com/settings/notifications\\n`;\n  emailContent += `CursiveGPT - where learning happens together.`;\n  \n  return emailContent;\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createServerSupabaseClient } from '@supabase/auth-helpers-nextjs';\nimport { Notification, NotificationType } from '@/types/supabase';\nimport { formatDistanceToNow } from 'date-fns';\n\n// This API endpoint would typically use an email service like SendGrid, Mailgun, etc.\n// For demonstration, we'll just log what would be sent\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  // Create Supabase server client (with admin rights)\n  const supabase = createServerSupabaseClient({ req, res });\n\n  // Check if user is authenticated\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session || !session.user) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  try {\n    // Get notification ID from request body\n    const { notificationId } = req.body;\n\n    if (!notificationId) {\n      return res.status(400).json({ error: 'Missing notification ID' });\n    }\n\n    // Get notification details\n    const { data: notification, error: notificationError } = await supabase\n      .from('notifications')\n      .select('*, profiles!notifications_recipient_id_fkey(email, username), profiles!notifications_sender_id_fkey(username)')\n      .eq('id', notificationId)\n      .single();\n\n    if (notificationError || !notification) {\n      return res.status(404).json({ error: 'Notification not found' });\n    }\n\n    // Check if this notification has already been emailed\n    if (notification.is_email_sent) {\n      return res.status(400).json({ error: 'Email already sent for this notification' });\n    }\n\n    // Get recipient email\n    const recipientEmail = notification.profiles?.email;\n    const recipientUsername = notification.profiles?.username || 'User';\n    const senderUsername = notification.profiles?.username || 'Another user';\n\n    if (!recipientEmail) {\n      return res.status(400).json({ error: 'Recipient has no email address' });\n    }\n\n    // Construct email content based on notification type\n    const emailSubject = getEmailSubject(notification);\n    const emailContent = getEmailContent(notification, recipientUsername, senderUsername);\n\n    // Normally, we would send the email using a service like SendGrid, Mailgun, etc.\n    // For this example, we'll just log it\n    console.log(`Would send email to: ${recipientEmail}`);\n    console.log(`Subject: ${emailSubject}`);\n    console.log(`Content: ${emailContent}`);\n\n    // Update notification to mark email as sent\n    const { error: updateError } = await supabase\n      .from('notifications')\n      .update({ is_email_sent: true })\n      .eq('id', notificationId);\n\n    if (updateError) {\n      console.error('Error updating notification:', updateError);\n      return res.status(500).json({ error: 'Failed to update notification status' });\n    }\n\n    return res.status(200).json({ success: true, message: 'Email notification sent' });\n  } catch (error) {\n    console.error('Error sending email notification:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n\n// Helper functions for email formatting\n\nfunction getEmailSubject(notification: Notification): string {\n  switch (notification.type as NotificationType) {\n    case 'mention':\n      return `You were mentioned in a notebook`;\n    case 'edit':\n      return `Changes made to a notebook you collaborate on`;\n    case 'comment':\n      return `New comment on your notebook`;\n    case 'collaboration_invite':\n      return `Invitation to collaborate on a notebook`;\n    case 'system':\n      return `CursiveGPT notification`;\n    default:\n      return `New notification from CursiveGPT`;\n  }\n}\n\nfunction getEmailContent(\n  notification: Notification,\n  recipientUsername: string,\n  senderUsername: string\n): string {\n  const timeAgo = formatDistanceToNow(new Date(notification.created_at), { addSuffix: true });\n  const metadata = notification.metadata as Record<string, unknown> || {};\n  \n  let emailContent = `Hello ${recipientUsername},\\n\\n`;\n  \n  switch (notification.type as NotificationType) {\n    case 'mention':\n      emailContent += `${senderUsername} mentioned you in a ${notification.entity_type} ${timeAgo}.\\n\\n`;\n      if (metadata.notebookTitle) {\n        emailContent += `Notebook: ${metadata.notebookTitle}\\n\\n`;\n      }\n      if (metadata.originalText) {\n        emailContent += `Original Message:\\n\"${metadata.originalText}\"\\n\\n`;\n      }\n      break;\n    \n    case 'edit':\n      emailContent += `${notification.content}\\n\\n`;\n      if (metadata.notebookTitle) {\n        emailContent += `Notebook: ${metadata.notebookTitle}\\n\\n`;\n      }\n      emailContent += `This change was made ${timeAgo}.\\n\\n`;\n      break;\n    \n    case 'comment':\n      emailContent += `${notification.content}\\n\\n`;\n      if (metadata.commentText) {\n        emailContent += `Comment:\\n\"${metadata.commentText}\"\\n\\n`;\n      }\n      emailContent += `This comment was added ${timeAgo}.\\n\\n`;\n      break;\n    \n    case 'collaboration_invite':\n      emailContent += `${senderUsername} has invited you to collaborate on \"${metadata.notebookTitle || 'a notebook'}\".\\n\\n`;\n      emailContent += `You can now view and edit this notebook together.\\n\\n`;\n      break;\n    \n    default:\n      emailContent += `${notification.content}\\n\\n`;\n  }\n  \n  // Add a CTA to view the notebook/conversation\n  emailContent += `View it now: https://cursivegpt.com/notebooks/${notification.entity_id}\\n\\n`;\n  \n  // Add footer\n  emailContent += `---\\n`;\n  emailContent += `To manage your notification preferences, visit your account settings: https://cursivegpt.com/settings/notifications\\n`;\n  emailContent += `CursiveGPT - where learning happens together.`;\n  \n  return emailContent;\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { voteOnQuestion } from '@/lib/questionEvaluator';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Check authentication\n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  try {\n    const { questionId, voteType } = req.body;\n    \n    if (!questionId) {\n      return res.status(400).json({ error: 'Question ID is required' });\n    }\n    \n    if (voteType !== 1 && voteType !== -1) {\n      return res.status(400).json({ error: 'Vote type must be 1 (upvote) or -1 (downvote)' });\n    }\n    \n    // Register the vote\n    await voteOnQuestion(questionId, session.user.id, voteType);\n    \n    // Get updated vote counts\n    const { data: question, error } = await supabase\n      .from('public_questions')\n      .select('vote_score, total_score')\n      .eq('id', questionId)\n      .single();\n      \n    if (error) throw error;\n    \n    return res.status(200).json({\n      success: true,\n      questionId,\n      voteScore: question.vote_score,\n      totalScore: question.total_score\n    });\n  } catch (error) {\n    console.error('Error processing vote:', error);\n    return res.status(500).json({ \n      error: 'Failed to process vote',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n  \n  // Get question ID from the URL\n  const { id } = req.query;\n  \n  if (!id || typeof id !== 'string') {\n    return res.status(400).json({ error: 'Valid question ID is required' });\n  }\n\n  switch (req.method) {\n    case 'GET':\n      return getQuestion(req, res, supabase, id);\n    case 'PUT':\n      return updateQuestion(req, res, supabase, id);\n    case 'DELETE':\n      return deleteQuestion(req, res, supabase, id);\n    default:\n      return res.status(405).json({ error: 'Method not allowed' });\n  }\n}\n\n// Get a single question with all its details\nasync function getQuestion(req, res, supabase, id) {\n  try {\n    // Get the question with related data\n    const { data: question, error } = await supabase\n      .from('public_questions')\n      .select(`\n        *,\n        question_quality_scores (\n          criteria (\n            id,\n            name,\n            description,\n            weight\n          ),\n          score,\n          reasoning\n        ),\n        question_revisions (\n          id,\n          original_content,\n          revised_content,\n          revision_type,\n          revision_notes,\n          created_at\n        )\n      `)\n      .eq('id', id)\n      .single();\n    \n    if (error) {\n      if (error.code === 'PGRST116') {\n        return res.status(404).json({ error: 'Question not found' });\n      }\n      throw error;\n    }\n    \n    // Get vote counts\n    const { count: upvotes } = await supabase\n      .from('question_votes')\n      .select('*', { count: 'exact', head: true })\n      .eq('question_id', id)\n      .eq('vote_type', 1);\n      \n    const { count: downvotes } = await supabase\n      .from('question_votes')\n      .select('*', { count: 'exact', head: true })\n      .eq('question_id', id)\n      .eq('vote_type', -1);\n    \n    // Check if current user has voted\n    const { data: { session } } = await supabase.auth.getSession();\n    let userVote = null;\n    \n    if (session) {\n      const { data: voteData } = await supabase\n        .from('question_votes')\n        .select('vote_type')\n        .eq('question_id', id)\n        .eq('user_id', session.user.id)\n        .single();\n        \n      if (voteData) {\n        userVote = voteData.vote_type;\n      }\n    }\n    \n    // Format and return the question with vote data\n    return res.status(200).json({\n      ...question,\n      votes: {\n        upvotes: upvotes || 0,\n        downvotes: downvotes || 0,\n        userVote\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching question:', error);\n    return res.status(500).json({ \n      error: 'Failed to fetch question',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}\n\n// Update a question (only by owner)\nasync function updateQuestion(req, res, supabase, id) {\n  // Get the current session\n  const { data: { session } } = await supabase.auth.getSession();\n  \n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  try {\n    // First check if the user owns the question\n    const { data: question, error: fetchError } = await supabase\n      .from('public_questions')\n      .select('user_id, status')\n      .eq('id', id)\n      .single();\n      \n    if (fetchError) {\n      if (fetchError.code === 'PGRST116') {\n        return res.status(404).json({ error: 'Question not found' });\n      }\n      throw fetchError;\n    }\n    \n    // Verify ownership\n    if (question.user_id !== session.user.id) {\n      return res.status(403).json({ error: 'You do not have permission to update this question' });\n    }\n    \n    // Verify status is still pending (can't update approved questions)\n    if (question.status !== 'pending') {\n      return res.status(400).json({ error: 'Only pending questions can be updated' });\n    }\n    \n    // Get update fields from request\n    const { content, description, tags } = req.body;\n    \n    if (!content && !description && !tags) {\n      return res.status(400).json({ error: 'No update fields provided' });\n    }\n    \n    // Prepare update object\n    const updateData = {};\n    \n    if (content) updateData.content = content;\n    if (description) updateData.description = description;\n    if (tags) updateData.tags = tags;\n    \n    // Update the question\n    const { data: updatedQuestion, error: updateError } = await supabase\n      .from('public_questions')\n      .update({\n        ...updateData,\n        updated_at: new Date().toISOString()\n      })\n      .eq('id', id)\n      .single();\n      \n    if (updateError) throw updateError;\n    \n    // Save revision history if content changed\n    if (content) {\n      await supabase\n        .from('question_revisions')\n        .insert({\n          question_id: id,\n          original_content: question.content,\n          revised_content: content,\n          revision_type: 'user_edit',\n          revision_notes: 'User-initiated edit'\n        });\n    }\n    \n    return res.status(200).json({\n      success: true,\n      question: updatedQuestion\n    });\n  } catch (error) {\n    console.error('Error updating question:', error);\n    return res.status(500).json({ \n      error: 'Failed to update question',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}\n\n// Delete a question (only by owner)\nasync function deleteQuestion(req, res, supabase, id) {\n  // Get the current session\n  const { data: { session } } = await supabase.auth.getSession();\n  \n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  \n  try {\n    // First check if the user owns the question\n    const { data: question, error: fetchError } = await supabase\n      .from('public_questions')\n      .select('user_id')\n      .eq('id', id)\n      .single();\n      \n    if (fetchError) {\n      if (fetchError.code === 'PGRST116') {\n        return res.status(404).json({ error: 'Question not found' });\n      }\n      throw fetchError;\n    }\n    \n    // Verify ownership\n    if (question.user_id !== session.user.id) {\n      return res.status(403).json({ error: 'You do not have permission to delete this question' });\n    }\n    \n    // Delete the question\n    const { error: deleteError } = await supabase\n      .from('public_questions')\n      .delete()\n      .eq('id', id);\n      \n    if (deleteError) throw deleteError;\n    \n    return res.status(200).json({\n      success: true,\n      message: 'Question deleted successfully'\n    });\n  } catch (error) {\n    console.error('Error deleting question:', error);\n    return res.status(500).json({ \n      error: 'Failed to delete question',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n  \n  try {\n    // Parse query parameters\n    const {\n      page = '1',\n      limit = '20',\n      sort = 'total_score',\n      direction = 'desc',\n      status = 'approved',\n      tag,\n      search,\n      userId\n    } = req.query;\n    \n    // Convert parameters to expected types\n    const pageNum = parseInt(page as string, 10);\n    const limitNum = Math.min(parseInt(limit as string, 10), 100); // Cap at 100\n    const offset = (pageNum - 1) * limitNum;\n    \n    // Validate sort field\n    const validSortFields = ['total_score', 'quality_score', 'vote_score', 'created_at'];\n    const sortField = validSortFields.includes(sort as string) \n      ? sort \n      : 'total_score';\n      \n    // Validate sort direction\n    const sortDirection = (direction as string)?.toLowerCase() === 'asc' ? 'asc' : 'desc';\n    \n    // Start building query\n    let query = supabase\n      .from('public_questions')\n      .select(`\n        *,\n        question_quality_scores (\n          criteria_id,\n          score,\n          reasoning\n        ),\n        question_votes (\n          count\n        )\n      `, { count: 'exact' });\n    \n    // Apply filters\n    if (status) {\n      query = query.eq('status', status);\n    }\n    \n    if (tag) {\n      query = query.contains('tags', [tag]);\n    }\n    \n    if (search) {\n      query = query.ilike('content', `%${search}%`);\n    }\n    \n    if (userId) {\n      query = query.eq('user_id', userId);\n    }\n    \n    // Apply sorting and pagination\n    const { data, error, count } = await query\n      .order(sortField as any, { ascending: sortDirection === 'asc' })\n      .range(offset, offset + limitNum - 1);\n    \n    if (error) throw error;\n    \n    // Get user votes for the current user if authenticated\n    const { data: { session } } = await supabase.auth.getSession();\n    let userVotes = {};\n    \n    if (session) {\n      const questionIds = data.map(q => q.id);\n      const { data: votesData, error: votesError } = await supabase\n        .from('question_votes')\n        .select('question_id, vote_type')\n        .eq('user_id', session.user.id)\n        .in('question_id', questionIds);\n        \n      if (!votesError && votesData) {\n        userVotes = votesData.reduce((acc, vote) => {\n          acc[vote.question_id] = vote.vote_type;\n          return acc;\n        }, {} as Record<string, number>);\n      }\n    }\n    \n    // Return results\n    return res.status(200).json({\n      questions: data,\n      total: count,\n      page: pageNum,\n      limit: limitNum,\n      totalPages: Math.ceil((count || 0) / limitNum),\n      userVotes\n    });\n  } catch (error) {\n    console.error('Error fetching questions:', error);\n    return res.status(500).json({ \n      error: 'Failed to fetch questions',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createPagesServerClient } from '@supabase/auth-helpers-nextjs';\nimport { processQuestionSubmission } from '@/lib/questionEvaluator';\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  // Create authenticated Supabase client\n  const supabase = createPagesServerClient({ req, res });\n  const { data: { session } } = await supabase.auth.getSession();\n\n  // Check authentication\n  if (!session) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  try {\n    const { question, description, tags } = req.body;\n    \n    if (!question || typeof question !== 'string' || question.trim().length === 0) {\n      return res.status(400).json({ error: 'Question content is required' });\n    }\n    \n    // Validate tags if provided\n    let parsedTags: string[] = [];\n    if (tags) {\n      if (Array.isArray(tags)) {\n        parsedTags = tags;\n      } else if (typeof tags === 'string') {\n        parsedTags = tags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);\n      } else {\n        return res.status(400).json({ error: 'Tags must be a string or array' });\n      }\n    }\n    \n    // Process the question submission\n    const result = await processQuestionSubmission(\n      question.trim(),\n      session.user.id,\n      description,\n      parsedTags\n    );\n    \n    // Return the processed result\n    return res.status(200).json(result);\n  } catch (error) {\n    console.error('Error processing question submission:', error);\n    return res.status(500).json({ \n      error: 'Failed to process question',\n      details: error instanceof Error ? error.message : 'Unknown error'\n    });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createClient } from '@supabase/supabase-js';\nimport { Database, InvitationStatus } from '@/types/supabase';\n\n// Initialize admin Supabase client for server-side operations\nconst adminSupabase = createClient<Database>(\n  process.env.NEXT_PUBLIC_SUPABASE_URL || '',\n  process.env.SUPABASE_SERVICE_KEY || ''\n);\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Get the token and action from the request body\n    const { token, action, userId } = req.body;\n\n    if (!token || !action || !userId) {\n      return res.status(400).json({ \n        error: 'Missing required parameters',\n        missingParams: {\n          token: !token,\n          action: !action,\n          userId: !userId\n        }\n      });\n    }\n\n    if (action !== 'accept' && action !== 'decline') {\n      return res.status(400).json({ error: 'Invalid action' });\n    }\n\n    // Get the invitation by token\n    const { data: invitation, error: invitationError } = await adminSupabase\n      .from('invitations')\n      .select('*')\n      .eq('invitation_token', token)\n      .single();\n\n    if (invitationError || !invitation) {\n      console.error('Error fetching invitation:', invitationError);\n      return res.status(404).json({ error: 'Invitation not found' });\n    }\n\n    // Check if invitation is still valid\n    if (invitation.status !== 'pending') {\n      return res.status(400).json({ \n        error: 'Invitation is not pending', \n        status: invitation.status \n      });\n    }\n\n    // Check if invitation has expired\n    if (new Date(invitation.expires_at) < new Date()) {\n      await adminSupabase\n        .from('invitations')\n        .update({ status: 'expired' })\n        .eq('id', invitation.id);\n      \n      return res.status(400).json({ error: 'Invitation has expired' });\n    }\n\n    // Get the user's email\n    const { data: user, error: userError } = await adminSupabase\n      .from('profiles')\n      .select('username') // Username corresponds to email\n      .eq('id', userId)\n      .single();\n\n    if (userError || !user) {\n      console.error('Error fetching user:', userError);\n      return res.status(404).json({ error: 'User not found' });\n    }\n\n    // Update the invitation status\n    const newStatus: InvitationStatus = action === 'accept' ? 'accepted' : 'declined';\n\n    const { error: updateError } = await adminSupabase\n      .from('invitations')\n      .update({\n        status: newStatus,\n        invitee_id: userId\n      })\n      .eq('id', invitation.id);\n\n    if (updateError) {\n      console.error('Error updating invitation:', updateError);\n      return res.status(500).json({ error: 'Failed to update invitation' });\n    }\n\n    // Update any corresponding notification to read status\n    try {\n      const { error: notificationError } = await adminSupabase\n        .from('notifications')\n        .update({ status: 'read' })\n        .eq('type', 'collaboration_invite')\n        .eq('recipient_id', userId)\n        .eq('metadata->invitationId', invitation.id);\n\n      if (notificationError) {\n        console.error('Error updating notification:', notificationError);\n        // Non-critical error, continue anyway\n      }\n    } catch (err) {\n      console.error('Exception updating notification:', err);\n      // Non-critical error, continue anyway\n    }\n\n    // If accepting and this is a collaborative notebook with edit permissions, update the notebook\n    if (action === 'accept' && invitation.entity_type === 'notebook' && \n        (invitation.role === 'editor' || invitation.role === 'owner')) {\n      const { error: notebookError } = await adminSupabase\n        .from('notebooks')\n        .update({ is_collaborative: true })\n        .eq('id', invitation.entity_id);\n\n      if (notebookError) {\n        console.error('Error updating notebook:', notebookError);\n        // Non-critical error, continue anyway\n      }\n    }\n\n    // Return success with the entity details for redirection\n    return res.status(200).json({ \n      success: true,\n      entityId: invitation.entity_id,\n      entityType: invitation.entity_type,\n      action\n    });\n  } catch (error) {\n    console.error('Error processing invitation:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}import { NextApiRequest, NextApiResponse } from 'next';\nimport { createClient } from '@supabase/supabase-js';\nimport { Database } from '@/types/supabase';\n\n// Initialize admin Supabase client for server-side operations\nconst adminSupabase = createClient<Database>(\n  process.env.NEXT_PUBLIC_SUPABASE_URL || '',\n  process.env.SUPABASE_SERVICE_KEY || ''\n);\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse\n) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' });\n  }\n\n  try {\n    // Get the invitation ID from the request body\n    const { invitationId } = req.body;\n\n    if (!invitationId) {\n      return res.status(400).json({ error: 'Missing invitationId' });\n    }\n\n    // Get the invitation\n    const { data: invitation, error: invitationError } = await adminSupabase\n      .from('invitations')\n      .select('*, profiles:inviter_id(username, avatar_url)')\n      .eq('id', invitationId)\n      .single();\n\n    if (invitationError || !invitation) {\n      console.error('Error fetching invitation:', invitationError);\n      return res.status(404).json({ error: 'Invitation not found' });\n    }\n\n    // Get entity details (notebook or folder)\n    let entityName = 'a document';\n    if (invitation.entity_type === 'notebook') {\n      const { data: notebook } = await adminSupabase\n        .from('notebooks')\n        .select('title')\n        .eq('id', invitation.entity_id)\n        .single();\n\n      if (notebook) {\n        entityName = notebook.title || 'a notebook';\n      } else {\n        entityName = 'a notebook';\n      }\n    } else if (invitation.entity_type === 'folder') {\n      const { data: folder } = await adminSupabase\n        .from('folders')\n        .select('name')\n        .eq('id', invitation.entity_id)\n        .single();\n\n      if (folder) {\n        entityName = folder.name || 'a folder';\n      } else {\n        entityName = 'a folder';\n      }\n    }\n\n    // Get inviter details for better email content\n    const inviterProfile = invitation.profiles as { username: string; avatar_url: string | null };\n    const inviterName = inviterProfile?.username || 'Someone';\n\n    // Generate the invitation link\n    const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'https://cursivegpt.com';\n    const invitationUrl = `${baseUrl}/invitations/${invitation.invitation_token}`;\n\n    // Send the email using your preferred email service (below is a placeholder)\n    // You could use SendGrid, Mailgun, AWS SES, etc.\n    const emailSent = await sendEmail({\n      to: invitation.invitee_email,\n      subject: `${inviterName} has invited you to collaborate on ${entityName}`,\n      html: generateEmailHtml({\n        inviterName,\n        entityName,\n        entityType: invitation.entity_type,\n        role: invitation.role,\n        invitationUrl,\n      }),\n    });\n\n    if (!emailSent) {\n      return res.status(500).json({ error: 'Failed to send email' });\n    }\n\n    // Update the invitation to mark that email was sent\n    await adminSupabase\n      .from('invitations')\n      .update({ email_sent: true })\n      .eq('id', invitationId);\n\n    return res.status(200).json({ success: true });\n  } catch (error) {\n    console.error('Error sending invitation email:', error);\n    return res.status(500).json({ error: 'Internal server error' });\n  }\n}\n\n// Placeholder function to send email - replace with your email provider\nasync function sendEmail({ \n  to, \n  subject, \n  html \n}: { \n  to: string; \n  subject: string; \n  html: string;\n}): Promise<boolean> {\n  // Implementation will depend on your email provider\n  // For example, with SendGrid:\n  /*\n  const sgMail = require('@sendgrid/mail');\n  sgMail.setApiKey(process.env.SENDGRID_API_KEY);\n  \n  try {\n    await sgMail.send({\n      to,\n      from: 'noreply@cursivegpt.com',\n      subject,\n      html,\n    });\n    return true;\n  } catch (error) {\n    console.error('SendGrid error:', error);\n    return false;\n  }\n  */\n  \n  // For now, just log the email content and return success\n  console.log('Would send email to:', to);\n  console.log('Subject:', subject);\n  console.log('Content:', html);\n  return true;\n}\n\n// Generate HTML content for the invitation email\nfunction generateEmailHtml({ \n  inviterName, \n  entityName, \n  entityType, \n  role, \n  invitationUrl \n}: { \n  inviterName: string; \n  entityName: string; \n  entityType: string;\n  role: string;\n  invitationUrl: string;\n}): string {\n  const roleText = role === 'viewer' \n    ? 'view' \n    : role === 'editor' \n      ? 'edit' \n      : 'manage';\n\n  return `\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <meta charset=\"utf-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <title>Invitation to Collaborate</title>\n      <style>\n        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }\n        .header { text-align: center; margin-bottom: 30px; }\n        .content { background: #f9f9f9; padding: 20px; border-radius: 5px; }\n        .button { display: inline-block; background: #6366F1; color: white; text-decoration: none; padding: 10px 20px; border-radius: 5px; margin: 20px 0; }\n        .footer { margin-top: 30px; font-size: 12px; color: #666; text-align: center; }\n      </style>\n    </head>\n    <body>\n      <div class=\"header\">\n        <h1>You're Invited to Collaborate</h1>\n      </div>\n      <div class=\"content\">\n        <p>Hi there,</p>\n        <p><strong>${inviterName}</strong> has invited you to ${roleText} ${entityType} <strong>${entityName}</strong> on CursiveGPT.</p>\n        <p>CursiveGPT is a collaborative, AI-powered notebook that helps you capture and develop your ideas with handwritten notes.</p>\n        <div style=\"text-align: center;\">\n          <a href=\"${invitationUrl}\" class=\"button\">Accept Invitation</a>\n        </div>\n        <p>This invitation will expire in 7 days.</p>\n        <p>If you don't have a CursiveGPT account yet, you'll be able to create one after clicking the link above.</p>\n      </div>\n      <div class=\"footer\">\n        <p>If you didn't expect this invitation, you can simply ignore this email.</p>\n        <p>© CursiveGPT</p>\n      </div>\n    </body>\n    </html>\n  `;\n}// src/pages/notebooks/[id]/chat.tsx\nimport React from 'react';\nimport { useRouter } from 'next/router';\nimport { useNotebook } from '@/hooks/useNotebook';\nimport LlamaChat from '@/components/ui/LlamaChat';\nimport Layout from '@/components/layout/Layout';\nimport LoadingSpinner from '@/components/ui/LoadingSpinner';\n\nconst NotebookChatPage = () => {\n  const router = useRouter();\n  const { id } = router.query;\n  \n  // Handle the case when router.query isn't loaded yet\n  if (!router.isReady) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n  \n  const notebookId = typeof id === 'string' ? id : '';\n  \n  const { notebook, loading, error } = useNotebook(notebookId);\n\n  // Handle loading state\n  if (loading) {\n    return (\n      <Layout>\n        <div className=\"flex items-center justify-center h-screen\">\n          <LoadingSpinner />\n        </div>\n      </Layout>\n    );\n  }\n\n  // Handle error state\n  if (error || !notebook) {\n    return (\n      <Layout>\n        <div className=\"flex flex-col items-center justify-center h-screen\">\n          <h2 className=\"text-xl font-semibold text-red-600 mb-4\">Error Loading Notebook</h2>\n          <p className=\"text-gray-700 mb-6\">{error || 'Notebook not found'}</p>\n          <button\n            onClick={() => router.push('/notebooks')}\n            className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n          >\n            Return to Notebooks\n          </button>\n        </div>\n      </Layout>\n    );\n  }\n\n  return (\n    <Layout>\n      <div className=\"flex flex-col h-screen\">\n        {/* Header */}\n        <div className=\"bg-white border-b border-gray-200 px-4 py-4 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <button\n              onClick={() => router.push(`/notebooks/${notebookId}`)}\n              className=\"mr-4 text-gray-600 hover:text-gray-900\"\n            >\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-5 w-5\"\n                viewBox=\"0 0 20 20\"\n                fill=\"currentColor\"\n              >\n                <path\n                  fillRule=\"evenodd\"\n                  d=\"M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z\"\n                  clipRule=\"evenodd\"\n                />\n              </svg>\n            </button>\n            <h1 className=\"text-xl font-semibold text-gray-900\">\n              {notebook.title || 'Untitled Notebook'} - Chat\n            </h1>\n          </div>\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={() => router.push(`/notebooks/${notebookId}/unified`)}\n              className=\"text-blue-600 hover:text-blue-800 px-3 py-1 border border-blue-600 rounded-md hover:bg-blue-50\"\n            >\n              Switch to Canvas\n            </button>\n          </div>\n        </div>\n\n        {/* Main content - Chat UI */}\n        <div className=\"flex-1 overflow-hidden bg-gray-50\">\n          <LlamaChat\n            notebookId={notebookId}\n            systemPrompt={notebook.system_prompt}\n            fullScreen={true}\n            className=\"max-w-4xl mx-auto bg-white shadow-sm h-full\"\n          />\n        </div>\n      </div>\n    </Layout>\n  );\n};\n\nexport default NotebookChatPage;import React, { useState } from 'react';\nimport { GetServerSideProps } from 'next';\nimport Head from 'next/head';\nimport { createServerSupabaseClient } from '@supabase/auth-helpers-nextjs';\nimport QuestionsList from '@/components/ui/questions/QuestionsList';\nimport QuestionSubmitForm from '@/components/ui/questions/QuestionSubmitForm';\nimport { PublicQuestion } from '@/types/publicQuestions';\n\ninterface QuestionsPageProps {\n  initialQuestions?: PublicQuestion[];\n  isLoggedIn: boolean;\n}\n\nexport default function QuestionsPage({ initialQuestions, isLoggedIn }: QuestionsPageProps) {\n  const [showSubmitForm, setShowSubmitForm] = useState(false);\n  \n  return (\n    <>\n      <Head>\n        <title>Community Questions | Cursive</title>\n        <meta name=\"description\" content=\"Explore and contribute to thought-provoking questions from the Cursive community.\" />\n      </Head>\n      \n      <div className=\"max-w-6xl mx-auto px-4 py-8\">\n        <div className=\"flex justify-between items-center mb-8\">\n          <div>\n            <h1 className=\"text-3xl font-bold text-gray-900\">Community Questions</h1>\n            <p className=\"text-gray-600 mt-2\">\n              Explore thought-provoking questions from the community or submit your own.\n            </p>\n          </div>\n          \n          {isLoggedIn && (\n            <button\n              onClick={() => setShowSubmitForm(!showSubmitForm)}\n              className=\"px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700\"\n            >\n              {showSubmitForm ? 'Close Form' : 'Ask a Question'}\n            </button>\n          )}\n        </div>\n        \n        {showSubmitForm && (\n          <div className=\"mb-8\">\n            <QuestionSubmitForm \n              onSuccess={() => setShowSubmitForm(false)}\n            />\n          </div>\n        )}\n        \n        <QuestionsList initialQuestions={initialQuestions} />\n      </div>\n    </>\n  );\n}\n\nexport const getServerSideProps: GetServerSideProps = async (ctx) => {\n  // Create authenticated Supabase client\n  const supabase = createServerSupabaseClient(ctx);\n  \n  // Check if user is authenticated\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n  \n  // Try to fetch initial set of questions\n  try {\n    const { data: questions } = await supabase\n      .from('public_questions')\n      .select(`\n        *,\n        question_quality_scores (id, criteria_id, score, reasoning)\n      `)\n      .eq('status', 'approved')\n      .order('total_score', { ascending: false })\n      .limit(20);\n    \n    return {\n      props: {\n        initialQuestions: questions || [],\n        isLoggedIn: !!session\n      }\n    };\n  } catch (error) {\n    console.error('Error fetching initial questions:', error);\n    \n    return {\n      props: {\n        initialQuestions: [],\n        isLoggedIn: !!session\n      }\n    };\n  }\n}import React from 'react';\nimport { GetServerSideProps } from 'next';\nimport Head from 'next/head';\nimport Link from 'next/link';\nimport { createServerSupabaseClient } from '@supabase/auth-helpers-nextjs';\nimport QuestionsList from '@/components/ui/questions/QuestionsList';\nimport { PublicQuestion } from '@/types/publicQuestions';\n\ninterface MyQuestionsPageProps {\n  initialQuestions?: PublicQuestion[];\n  userId: string;\n}\n\nexport default function MyQuestionsPage({ initialQuestions, userId }: MyQuestionsPageProps) {\n  return (\n    <>\n      <Head>\n        <title>My Questions | Cursive</title>\n        <meta name=\"description\" content=\"Manage your submitted questions.\" />\n      </Head>\n      \n      <div className=\"max-w-6xl mx-auto px-4 py-8\">\n        <div className=\"flex justify-between items-center mb-8\">\n          <div>\n            <h1 className=\"text-3xl font-bold text-gray-900\">My Questions</h1>\n            <p className=\"text-gray-600 mt-2\">\n              Track and manage the questions you've submitted to the community.\n            </p>\n          </div>\n          \n          <div className=\"flex space-x-4\">\n            <Link \n              href=\"/questions\" \n              className=\"px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50\"\n            >\n              Browse All Questions\n            </Link>\n            <Link \n              href=\"/questions?showSubmitForm=true\" \n              className=\"px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700\"\n            >\n              Ask a New Question\n            </Link>\n          </div>\n        </div>\n        \n        <div className=\"bg-white rounded-lg shadow p-6 mb-8\">\n          <div className=\"grid grid-cols-3 gap-4 text-center\">\n            <div className=\"p-4 bg-purple-50 rounded-lg\">\n              <h3 className=\"text-xl font-semibold text-purple-800 mb-1\">Pending</h3>\n              <p className=\"text-sm text-gray-600\">\n                Questions awaiting moderation or approval\n              </p>\n            </div>\n            <div className=\"p-4 bg-green-50 rounded-lg\">\n              <h3 className=\"text-xl font-semibold text-green-800 mb-1\">Approved</h3>\n              <p className=\"text-sm text-gray-600\">\n                Questions published to the community\n              </p>\n            </div>\n            <div className=\"p-4 bg-red-50 rounded-lg\">\n              <h3 className=\"text-xl font-semibold text-red-800 mb-1\">Rejected</h3>\n              <p className=\"text-sm text-gray-600\">\n                Questions that weren't approved\n              </p>\n            </div>\n          </div>\n        </div>\n        \n        <QuestionsList \n          initialQuestions={initialQuestions}\n          showFilters={true}\n          showPagination={true}\n          showVoting={false}\n          emptyMessage=\"You haven't submitted any questions yet.\"\n        />\n      </div>\n    </>\n  );\n}\n\nexport const getServerSideProps: GetServerSideProps = async (ctx) => {\n  // Create authenticated Supabase client\n  const supabase = createServerSupabaseClient(ctx);\n  \n  // Check if user is authenticated\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n  \n  // Redirect to login if not authenticated\n  if (!session) {\n    return {\n      redirect: {\n        destination: '/login?redirect=/questions/my-questions',\n        permanent: false,\n      },\n    };\n  }\n  \n  // Try to fetch the user's questions\n  try {\n    const { data: questions } = await supabase\n      .from('public_questions')\n      .select(`\n        *,\n        question_quality_scores (id, criteria_id, score, reasoning)\n      `)\n      .eq('user_id', session.user.id)\n      .order('created_at', { ascending: false })\n      .limit(20);\n    \n    return {\n      props: {\n        initialQuestions: questions || [],\n        userId: session.user.id\n      }\n    };\n  } catch (error) {\n    console.error('Error fetching user questions:', error);\n    \n    return {\n      props: {\n        initialQuestions: [],\n        userId: session.user.id\n      }\n    };\n  }\n}import React from 'react';\nimport { GetServerSideProps } from 'next';\nimport Head from 'next/head';\nimport Link from 'next/link';\nimport { createServerSupabaseClient } from '@supabase/auth-helpers-nextjs';\nimport QuestionDetail from '@/components/ui/questions/QuestionDetail';\nimport { PublicQuestion } from '@/types/publicQuestions';\n\ninterface QuestionPageProps {\n  questionId: string;\n  initialQuestion?: PublicQuestion;\n}\n\nexport default function QuestionPage({ questionId, initialQuestion }: QuestionPageProps) {\n  // Use the title from the initial question if available\n  const title = initialQuestion?.content || 'Question Detail';\n  \n  return (\n    <>\n      <Head>\n        <title>{title} | Cursive</title>\n        <meta name=\"description\" content={initialQuestion?.description || 'Question detail page'} />\n      </Head>\n      \n      <div className=\"max-w-5xl mx-auto px-4 py-8\">\n        <div className=\"mb-8\">\n          <Link href=\"/questions\" className=\"text-purple-600 hover:text-purple-800 flex items-center\">\n            <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-5 w-5 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\">\n              <path fillRule=\"evenodd\" d=\"M9.707 14.707a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 1.414L7.414 9H15a1 1 0 110 2H7.414l2.293 2.293a1 1 0 010 1.414z\" clipRule=\"evenodd\" />\n            </svg>\n            Back to Questions\n          </Link>\n        </div>\n        \n        <QuestionDetail questionId={questionId} />\n      </div>\n    </>\n  );\n}\n\nexport const getServerSideProps: GetServerSideProps = async (ctx) => {\n  const { id } = ctx.params || {};\n  \n  if (!id || typeof id !== 'string') {\n    return {\n      notFound: true\n    };\n  }\n  \n  // Create authenticated Supabase client\n  const supabase = createServerSupabaseClient(ctx);\n  \n  // Try to fetch the question for initial rendering\n  try {\n    const { data: question, error } = await supabase\n      .from('public_questions')\n      .select(`\n        *,\n        question_quality_scores (\n          criteria_id,\n          score,\n          reasoning\n        ),\n        question_revisions (\n          id,\n          original_content,\n          revised_content,\n          revision_type,\n          revision_notes,\n          created_at\n        )\n      `)\n      .eq('id', id)\n      .single();\n    \n    if (error || !question) {\n      return {\n        notFound: true\n      };\n    }\n    \n    // Get vote counts\n    const { count: upvotes } = await supabase\n      .from('question_votes')\n      .select('*', { count: 'exact', head: true })\n      .eq('question_id', id)\n      .eq('vote_type', 1);\n      \n    const { count: downvotes } = await supabase\n      .from('question_votes')\n      .select('*', { count: 'exact', head: true })\n      .eq('question_id', id)\n      .eq('vote_type', -1);\n    \n    // Check if current user has voted\n    const { data: { session } } = await supabase.auth.getSession();\n    let userVote = null;\n    \n    if (session) {\n      const { data: voteData } = await supabase\n        .from('question_votes')\n        .select('vote_type')\n        .eq('question_id', id)\n        .eq('user_id', session.user.id)\n        .single();\n        \n      if (voteData) {\n        userVote = voteData.vote_type;\n      }\n    }\n    \n    // Add votes data to the question\n    const questionWithVotes = {\n      ...question,\n      votes: {\n        upvotes: upvotes || 0,\n        downvotes: downvotes || 0,\n        userVote\n      }\n    };\n    \n    return {\n      props: {\n        questionId: id,\n        initialQuestion: questionWithVotes\n      }\n    };\n  } catch (error) {\n    console.error('Error fetching question:', error);\n    \n    return {\n      props: {\n        questionId: id,\n        initialQuestion: null\n      }\n    };\n  }\n}// Service for working with nodes and relationships\n// src/services/nodeService.ts\n\nimport { supabase } from '@/lib/supabaseClient';\nimport { \n  Node, \n  Relationship, \n  CardType, \n  RelationshipType, \n  Vector,\n  ThreadView \n} from '@/types/thread';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Create a new node\n * @param notebookId The ID of the notebook to create the node in\n * @param content The content of the node\n * @param type The type of node (question, response, note, drawing)\n * @param position The position of the node on the canvas\n * @param metadata Optional metadata for the node (e.g., selection info, thumbnail)\n * @param attention Optional attention markers for the node\n * @returns The created node or null if there was an error\n */\nexport async function createNode(\n  notebookId: string, \n  content: string,\n  type: CardType,\n  position: { x: number, y: number },\n  metadata?: Record<string, any>,\n  attention?: string[]\n): Promise<Node | null> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .insert({\n        id: uuidv4(),\n        content,\n        type,\n        notebook_id: notebookId,\n        position,\n        attention: attention || [],\n        metadata: metadata || {},\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n      \n    if (error) {\n      console.error('Error creating node:', error);\n      return null;\n    }\n    \n    return data;\n  } catch (err) {\n    console.error('Exception creating node:', err);\n    return null;\n  }\n}\n\n/**\n * Update an existing node\n * @param nodeId The ID of the node to update\n * @param updates The properties to update\n * @returns The updated node or null if there was an error\n */\nexport async function updateNode(\n  nodeId: string,\n  updates: Partial<Omit<Node, 'id' | 'created_at' | 'created_by'>>\n): Promise<Node | null> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .update(updates)\n      .eq('id', nodeId)\n      .select()\n      .single();\n      \n    if (error) {\n      console.error('Error updating node:', error);\n      return null;\n    }\n    \n    return data;\n  } catch (err) {\n    console.error('Exception updating node:', err);\n    return null;\n  }\n}\n\n/**\n * Create a relationship between two nodes\n * @param fromNodeId The ID of the source node\n * @param toNodeId The ID of the target node\n * @param type The type of relationship\n * @param notebookId The ID of the notebook that contains both nodes\n * @param context Optional context explaining the relationship\n * @param vector Optional vector properties for the relationship\n * @returns The created relationship or null if there was an error\n */\nexport async function createRelationship(\n  fromNodeId: string,\n  toNodeId: string,\n  type: RelationshipType,\n  notebookId: string,\n  context?: string,\n  vector?: Vector\n): Promise<Relationship | null> {\n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .insert({\n        id: uuidv4(),\n        from_node_id: fromNodeId,\n        to_node_id: toNodeId,\n        type,\n        notebook_id: notebookId,\n        context,\n        vector,\n        created_at: new Date().toISOString()\n      })\n      .select()\n      .single();\n      \n    if (error) {\n      console.error('Error creating relationship:', error);\n      return null;\n    }\n    \n    return data;\n  } catch (err) {\n    console.error('Exception creating relationship:', err);\n    return null;\n  }\n}\n\n/**\n * Get all nodes for a notebook\n * @param notebookId The ID of the notebook to get nodes for\n * @returns Array of nodes or empty array if there was an error\n */\nexport async function getNodesByNotebook(notebookId: string): Promise<Node[]> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting nodes:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting nodes:', err);\n    return [];\n  }\n}\n\n/**\n * Get nodes by type for a notebook\n * @param notebookId The ID of the notebook to get nodes for\n * @param type The type of nodes to get\n * @returns Array of nodes matching the type or empty array if there was an error\n */\nexport async function getNodesByType(notebookId: string, type: CardType): Promise<Node[]> {\n  try {\n    const { data, error } = await supabase\n      .from('nodes')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .eq('type', type)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting nodes by type:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting nodes by type:', err);\n    return [];\n  }\n}\n\n/**\n * Get all relationships for a notebook\n * @param notebookId The ID of the notebook to get relationships for\n * @returns Array of relationships or empty array if there was an error\n */\nexport async function getRelationshipsByNotebook(notebookId: string): Promise<Relationship[]> {\n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting relationships:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting relationships:', err);\n    return [];\n  }\n}\n\n/**\n * Get all relationships of a specific type for a notebook\n * @param notebookId The ID of the notebook to get relationships for\n * @param type The type of relationships to get\n * @returns Array of relationships matching the type or empty array if there was an error\n */\nexport async function getRelationshipsByType(\n  notebookId: string, \n  type: RelationshipType\n): Promise<Relationship[]> {\n  try {\n    const { data, error } = await supabase\n      .from('relationships')\n      .select('*')\n      .eq('notebook_id', notebookId)\n      .eq('type', type)\n      .order('created_at', { ascending: true });\n      \n    if (error) {\n      console.error('Error getting relationships by type:', error);\n      return [];\n    }\n    \n    return data || [];\n  } catch (err) {\n    console.error('Exception getting relationships by type:', err);\n    return [];\n  }\n}\n\n/**\n * Get a threaded view of nodes for a notebook\n * Constructs a hierarchical view based on relationships\n * @param notebookId The ID of the notebook to get thread view for\n * @returns Array of ThreadView objects with parent-child relationships\n */\nexport async function getThreadView(notebookId: string): Promise<ThreadView[]> {\n  try {\n    // First get all nodes and relationships\n    const [nodes, relationships] = await Promise.all([\n      getNodesByNotebook(notebookId),\n      getRelationshipsByNotebook(notebookId)\n    ]);\n    \n    // Create a map of nodes by ID for quick lookup\n    const nodeMap = nodes.reduce((acc, node) => {\n      acc[node.id] = node;\n      return acc;\n    }, {} as Record<string, Node>);\n    \n    // Build parent-child relationships (prioritize 'extends' relationship type)\n    const childrenMap: Record<string, string[]> = {};\n    const parentMap: Record<string, string> = {};\n    \n    // First pass: process 'extends' relationships\n    relationships\n      .filter(rel => rel.type === 'extends')\n      .forEach(rel => {\n        if (!childrenMap[rel.from_node_id]) {\n          childrenMap[rel.from_node_id] = [];\n        }\n        childrenMap[rel.from_node_id].push(rel.to_node_id);\n        parentMap[rel.to_node_id] = rel.from_node_id;\n      });\n    \n    // Second pass: process other relationships (if no 'extends' is found)\n    relationships\n      .filter(rel => rel.type !== 'extends')\n      .forEach(rel => {\n        if (!parentMap[rel.to_node_id]) {\n          if (!childrenMap[rel.from_node_id]) {\n            childrenMap[rel.from_node_id] = [];\n          }\n          if (!childrenMap[rel.from_node_id].includes(rel.to_node_id)) {\n            childrenMap[rel.from_node_id].push(rel.to_node_id);\n            parentMap[rel.to_node_id] = rel.from_node_id;\n          }\n        }\n      });\n    \n    // Find root nodes (nodes without parents)\n    const rootNodeIds = nodes\n      .filter(node => !parentMap[node.id])\n      .map(node => node.id);\n    \n    // Build thread view recursively\n    const buildThreadView = (nodeId: string, depth: number = 0): ThreadView | null => {\n      const node = nodeMap[nodeId];\n      if (!node) return null;\n      \n      const childNodes = (childrenMap[nodeId] || [])\n        .map(childId => buildThreadView(childId, depth + 1))\n        .filter(Boolean) as ThreadView[];\n      \n      return {\n        id: node.id,\n        content: node.content,\n        type: node.type,\n        parent_id: parentMap[node.id],\n        depth,\n        position: node.position || { x: 0, y: 0 },\n        created_at: node.created_at,\n        created_by: node.created_by,\n        children: childNodes\n      };\n    };\n    \n    // Build thread views for all root nodes\n    return rootNodeIds\n      .map(nodeId => buildThreadView(nodeId))\n      .filter(Boolean) as ThreadView[];\n  } catch (err) {\n    console.error('Exception getting thread view:', err);\n    return [];\n  }\n}\n\n/**\n * Delete a node (and all its relationships)\n * @param nodeId The ID of the node to delete\n * @returns Boolean indicating success\n */\nexport async function deleteNode(nodeId: string): Promise<boolean> {\n  try {\n    // Deleting the node will cascade to delete its relationships\n    const { error } = await supabase\n      .from('nodes')\n      .delete()\n      .eq('id', nodeId);\n      \n    if (error) {\n      console.error('Error deleting node:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Exception deleting node:', err);\n    return false;\n  }\n}\n\n/**\n * Delete a relationship\n * @param relationshipId The ID of the relationship to delete\n * @returns Boolean indicating success\n */\nexport async function deleteRelationship(relationshipId: string): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('relationships')\n      .delete()\n      .eq('id', relationshipId);\n      \n    if (error) {\n      console.error('Error deleting relationship:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Exception deleting relationship:', err);\n    return false;\n  }\n}\n\n/**\n * Update node position in the database\n * @param nodeId The ID of the node to update\n * @param position The new position\n * @returns Boolean indicating success\n */\nexport async function updateNodePosition(\n  nodeId: string, \n  position: { x: number, y: number }\n): Promise<boolean> {\n  try {\n    const { error } = await supabase\n      .from('nodes')\n      .update({ position })\n      .eq('id', nodeId);\n      \n    if (error) {\n      console.error('Error updating node position:', error);\n      return false;\n    }\n    \n    return true;\n  } catch (err) {\n    console.error('Exception updating node position:', err);\n    return false;\n  }\n}\n\n/**\n * Get related nodes for a specific node\n * @param nodeId The ID of the node to get related nodes for\n * @returns Array of related nodes\n */\nexport async function getRelatedNodes(nodeId: string): Promise<Node[]> {\n  try {\n    // Get relationships involving this node\n    const { data: relationships, error: relError } = await supabase\n      .from('relationships')\n      .select('*')\n      .or(`from_node_id.eq.${nodeId},to_node_id.eq.${nodeId}`);\n      \n    if (relError) {\n      console.error('Error getting relationships:', relError);\n      return [];\n    }\n    \n    // Extract the related node IDs\n    const relatedNodeIds = new Set<string>();\n    relationships?.forEach(rel => {\n      if (rel.from_node_id === nodeId) {\n        relatedNodeIds.add(rel.to_node_id);\n      } else {\n        relatedNodeIds.add(rel.from_node_id);\n      }\n    });\n    \n    // If no related nodes, return empty array\n    if (relatedNodeIds.size === 0) {\n      return [];\n    }\n    \n    // Get the related nodes\n    const { data: nodes, error: nodeError } = await supabase\n      .from('nodes')\n      .select('*')\n      .in('id', Array.from(relatedNodeIds));\n      \n    if (nodeError) {\n      console.error('Error getting related nodes:', nodeError);\n      return [];\n    }\n    \n    return nodes || [];\n  } catch (err) {\n    console.error('Exception getting related nodes:', err);\n    return [];\n  }\n}\n\n/**\n * Convert legacy conversational data to the relationship-centric model\n * @param notebookId The ID of the notebook to migrate\n * @returns Boolean indicating success\n */\nexport async function migrateConversationsToNodes(notebookId: string): Promise<boolean> {\n  try {\n    // Call the RPC function in the database\n    const { data, error } = await supabase\n      .rpc('migrate_conversations_to_nodes', { p_notebook_id: notebookId });\n      \n    if (error) {\n      console.error('Error migrating conversations to nodes:', error);\n      return false;\n    }\n    \n    return data || false;\n  } catch (err) {\n    console.error('Exception migrating conversations to nodes:', err);\n    return false;\n  }\n}import { supabase } from '@/lib/supabaseClient';\nimport { Notebook, Stroke, Conversation } from '@/types/supabase';\n\nexport const notebookService = {\n  /**\n   * Get a notebook by ID\n   */\n  async getNotebook(id: string): Promise<Notebook | null> {\n    try {\n      const { data, error } = await supabase\n        .from('notebooks')\n        .select('*')\n        .eq('id', id)\n        .single();\n        \n      if (error) throw error;\n      return data;\n    } catch (err) {\n      console.error('Error fetching notebook:', err);\n      return null;\n    }\n  },\n  \n  /**\n   * Update notebook properties\n   */\n  async updateNotebook(id: string, updates: Partial<Omit<Notebook, 'id' | 'user_id' | 'created_at' | 'updated_at'>>): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('notebooks')\n        .update(updates)\n        .eq('id', id);\n        \n      if (error) throw error;\n      return true;\n    } catch (err) {\n      console.error('Error updating notebook:', err);\n      return false;\n    }\n  },\n  \n  /**\n   * Get all strokes for a notebook\n   */\n  async getStrokes(notebookId: string): Promise<Stroke[]> {\n    try {\n      const { data, error } = await supabase\n        .from('strokes')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n        \n      if (error) throw error;\n      return data || [];\n    } catch (err) {\n      console.error('Error fetching strokes:', err);\n      return [];\n    }\n  },\n  \n  /**\n   * Create a new stroke\n   */\n  async createStroke(stroke: Omit<Stroke, 'id' | 'created_at' | 'updated_at'>): Promise<Stroke | null> {\n    try {\n      const { data, error } = await supabase\n        .from('strokes')\n        .insert(stroke)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      return data;\n    } catch (err) {\n      console.error('Error creating stroke:', err);\n      return null;\n    }\n  },\n  \n  /**\n   * Delete a stroke\n   */\n  async deleteStroke(id: string): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('strokes')\n        .delete()\n        .eq('id', id);\n        \n      if (error) throw error;\n      return true;\n    } catch (err) {\n      console.error('Error deleting stroke:', err);\n      return false;\n    }\n  },\n  \n  /**\n   * Get all conversations for a notebook\n   */\n  async getConversations(notebookId: string): Promise<Conversation[]> {\n    try {\n      const { data, error } = await supabase\n        .from('conversations')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n        \n      if (error) throw error;\n      return data || [];\n    } catch (err) {\n      console.error('Error fetching conversations:', err);\n      return [];\n    }\n  },\n  \n  /**\n   * Create a new conversation\n   */\n  async createConversation(conversation: Omit<Conversation, 'id' | 'created_at' | 'updated_at'>): Promise<Conversation | null> {\n    try {\n      const { data, error } = await supabase\n        .from('conversations')\n        .insert(conversation)\n        .select()\n        .single();\n        \n      if (error) throw error;\n      return data;\n    } catch (err) {\n      console.error('Error creating conversation:', err);\n      return null;\n    }\n  },\n  \n  /**\n   * Update a conversation\n   */\n  async updateConversation(id: string, updates: Partial<Omit<Conversation, 'id' | 'created_at' | 'updated_at'>>): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('conversations')\n        .update(updates)\n        .eq('id', id);\n        \n      if (error) throw error;\n      return true;\n    } catch (err) {\n      console.error('Error updating conversation:', err);\n      return false;\n    }\n  },\n  \n  /**\n   * Update conversation position\n   */\n  async updateConversationPosition(id: string, x: number, y: number): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('conversations')\n        .update({\n          position: { x, y }\n        })\n        .eq('id', id);\n        \n      if (error) throw error;\n      return true;\n    } catch (err) {\n      console.error('Error updating conversation position:', err);\n      return false;\n    }\n  }\n};// src/services/threadService.ts\nimport { supabase } from '@/lib/supabaseClient';\nimport { Thread, Message, ThreadConnection, Card, CardConnection } from '@/types/thread';\nimport { nanoid } from 'nanoid';\n\n/**\n * Database update data type for thread\n */\ninterface ThreadUpdateData {\n  position?: { x: number; y: number };\n  title?: string;\n  parent_id?: string | null;\n  referenced_threads?: string[];\n  card_type?: string;\n  handwriting_style?: string;\n  is_minimized?: boolean;\n  z_index?: number;\n}\n\n// Service for thread operations\nexport const threadService = {\n  // Check if migration is needed\n  async isMigrationNeeded(_notebookId: string): Promise<boolean> {\n    try {\n      // This is a simple implementation that always returns false\n      // In a real implementation, you'd check if there are conversations to migrate\n      return false;\n    } catch (error) {\n      console.error('Error checking migration status:', error);\n      return false;\n    }\n  },\n\n  // Migrate conversations to threads\n  async migrateNotebookConversations(_notebookId: string): Promise<void> {\n    // This is a simple implementation that does nothing\n    // In a real implementation, you'd convert old conversation records to new thread format\n    console.log(`Migration would happen for notebook ${_notebookId}`);\n  },\n  // Fetch all threads for a notebook\n  async getThreadsByNotebook(notebookId: string): Promise<Thread[]> {\n    try {\n      const { data: threadsData, error: threadsError } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n        \n      if (threadsError) {\n        throw threadsError;\n      }\n      \n      if (!threadsData?.length) {\n        return [];\n      }\n      \n      // Fetch all messages for these threads in a single query\n      const threadIds = threadsData.map(thread => thread.id);\n      const { data: messagesData, error: messagesError } = await supabase\n        .from('thread_messages')\n        .select('*')\n        .in('thread_id', threadIds)\n        .order('created_at', { ascending: true });\n        \n      if (messagesError) {\n        throw messagesError;\n      }\n      \n      // Group messages by thread ID\n      const messagesByThread: Record<string, Message[]> = {};\n      \n      (messagesData || []).forEach(message => {\n        if (!messagesByThread[message.thread_id]) {\n          messagesByThread[message.thread_id] = [];\n        }\n        \n        messagesByThread[message.thread_id].push({\n          id: message.id,\n          threadId: message.thread_id,\n          content: message.content,\n          role: message.role,\n          createdAt: message.created_at\n        });\n      });\n      \n      // Combine thread data with messages\n      return threadsData.map(thread => ({\n        id: thread.id,\n        notebookId: thread.notebook_id,\n        title: thread.title,\n        position: thread.position,\n        messages: messagesByThread[thread.id] || [],\n        parentId: thread.parent_id,\n        referencedThreads: thread.referenced_threads,\n        createdAt: thread.created_at,\n        updatedAt: thread.updated_at,\n        cardType: thread.card_type,\n        handwritingStyle: thread.handwriting_style,\n        isMinimized: thread.is_minimized,\n        zIndex: thread.z_index\n      }));\n    } catch (error) {\n      console.error('Error fetching threads:', error);\n      throw error;\n    }\n  },\n  \n  // Create a new thread\n  async createThread(thread: Omit<Thread, 'id' | 'createdAt' | 'updatedAt' | 'messages'> & { messages?: Omit<Message, 'id' | 'threadId' | 'createdAt'>[] }): Promise<Thread> {\n    try {\n      // Let the database generate the UUID - don't specify an ID in the insert\n      const newThread = {\n        notebook_id: thread.notebookId,\n        title: thread.title,\n        position: thread.position,\n        parent_id: thread.parentId,\n        referenced_threads: thread.referencedThreads,\n        card_type: thread.cardType,\n        handwriting_style: thread.handwritingStyle,\n        is_minimized: thread.isMinimized || false,\n        z_index: thread.zIndex || 0\n      };\n      \n      // Insert thread into database and get the generated ID\n      const { data, error: threadError } = await supabase\n        .from('threads')\n        .insert(newThread)\n        .select('id')\n        .single();\n\n      if (threadError || !data) {\n        throw threadError || new Error('Failed to create thread - no ID returned');\n      }\n\n      // Get the database-generated UUID\n      const threadId = data.id;\n\n      // Create initial messages if any\n      if (thread.messages && thread.messages.length > 0) {\n        const messagesToInsert = thread.messages.map(message => ({\n          thread_id: threadId,\n          content: message.content,\n          role: message.role\n        }));\n\n        const { error: messagesError } = await supabase\n          .from('thread_messages')\n          .insert(messagesToInsert);\n\n        if (messagesError) {\n          throw messagesError;\n        }\n      }\n\n      // Convert message data to proper Message objects\n      const messageData = thread.messages || [];\n      const messages: Message[] = messageData.map(msg => ({\n        id: nanoid(), // It's ok to use nanoid here as it's just for the client\n        threadId,\n        content: msg.content,\n        role: msg.role,\n        createdAt: new Date().toISOString()\n      }));\n\n      // Return the complete thread\n      return {\n        id: threadId,\n        notebookId: thread.notebookId,\n        title: thread.title,\n        position: thread.position,\n        messages,\n        parentId: thread.parentId,\n        referencedThreads: thread.referencedThreads,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        cardType: thread.cardType,\n        handwritingStyle: thread.handwritingStyle,\n        isMinimized: thread.isMinimized || false,\n        zIndex: thread.zIndex || 0\n      };\n    } catch (error) {\n      console.error('Error creating thread:', error);\n      throw error;\n    }\n  },\n  \n  // Update thread properties (position, zIndex, title, etc.)\n  async updateThread(threadId: string, updates: Partial<Thread>): Promise<void> {\n    try {\n      // Convert to snake_case format for database\n      const updateData: ThreadUpdateData = {};\n      \n      if (updates.position) updateData.position = updates.position;\n      if (updates.title !== undefined) updateData.title = updates.title;\n      if (updates.parentId !== undefined) updateData.parent_id = updates.parentId;\n      if (updates.referencedThreads !== undefined) updateData.referenced_threads = updates.referencedThreads;\n      if (updates.cardType !== undefined) updateData.card_type = updates.cardType;\n      if (updates.handwritingStyle !== undefined) updateData.handwriting_style = updates.handwritingStyle;\n      if (updates.isMinimized !== undefined) updateData.is_minimized = updates.isMinimized;\n      if (updates.zIndex !== undefined) updateData.z_index = updates.zIndex;\n      \n      // Only update if we have changes\n      if (Object.keys(updateData).length === 0) return;\n      \n      const { error } = await supabase\n        .from('threads')\n        .update(updateData)\n        .eq('id', threadId);\n        \n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Delete a thread and all its messages\n  async deleteThread(threadId: string): Promise<void> {\n    try {\n      // Messages will be deleted automatically via ON DELETE CASCADE\n      const { error } = await supabase\n        .from('threads')\n        .delete()\n        .eq('id', threadId);\n        \n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error deleting thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Add a message to a thread\n  async addMessage(threadId: string, content: string, role: 'user' | 'assistant' | 'system'): Promise<Message> {\n    try {\n      const messageId = nanoid();\n      \n      const { error } = await supabase\n        .from('thread_messages')\n        .insert({\n          id: messageId,\n          thread_id: threadId,\n          content,\n          role\n        });\n        \n      if (error) {\n        throw error;\n      }\n      \n      // Return the new message\n      return {\n        id: messageId,\n        threadId,\n        content,\n        role,\n        createdAt: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error(`Error adding message to thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Stream a message from AI while saving it to the database\n  async streamMessage(threadId: string, userMessage: string, systemPrompt?: string): Promise<Response> {\n    try {\n      // First save the user message\n      await this.addMessage(threadId, userMessage, 'user');\n\n      // Call the AI endpoint and return the response\n      const response = await fetch('/api/claude/stream', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          threadId,\n          message: userMessage,\n          systemPrompt\n        })\n      });\n\n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`AI streaming error: ${errorText}`);\n      }\n\n      // Return the full response object\n      return response;\n    } catch (error) {\n      console.error(`Error streaming message to thread ${threadId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Update a message's content\n  async updateMessage(messageId: string, content: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('thread_messages')\n        .update({ content })\n        .eq('id', messageId);\n        \n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating message ${messageId}:`, error);\n      throw error;\n    }\n  },\n  \n  // Get thread connections\n  async getThreadConnections(notebookId: string): Promise<ThreadConnection[]> {\n    try {\n      // Fetch all threads for the notebook\n      const { data, error } = await supabase\n        .from('threads')\n        .select('id, parent_id, referenced_threads')\n        .eq('notebook_id', notebookId);\n\n      if (error) {\n        throw error;\n      }\n\n      const connections: ThreadConnection[] = [];\n\n      // Process parent-child relationships\n      data?.forEach(thread => {\n        if (thread.parent_id) {\n          connections.push({\n            fromId: thread.parent_id,\n            toId: thread.id,\n            type: 'parent-child'\n          });\n        }\n\n        // Process referenced threads\n        if (thread.referenced_threads && thread.referenced_threads.length > 0) {\n          thread.referenced_threads.forEach((referencedId: string) => {\n            connections.push({\n              fromId: thread.id,\n              toId: referencedId,\n              type: 'reference'\n            });\n          });\n        }\n      });\n\n      return connections;\n    } catch (error) {\n      console.error('Error fetching thread connections:', error);\n      throw error;\n    }\n  },\n\n  // Create a card linked to a thread\n  async createCard(notebookId: string, threadId: string, card: Omit<Card, 'id' | 'notebookId' | 'threadId' | 'createdAt' | 'updatedAt'>): Promise<Card> {\n    try {\n      const { data, error } = await supabase\n        .from('cards')\n        .insert({\n          notebook_id: notebookId,\n          thread_id: threadId,\n          type: card.type,\n          title: card.title,\n          content: card.content,\n          position: card.position,\n          size: card.size,\n          is_collapsed: card.isCollapsed,\n          z_index: card.zIndex,\n          style: card.style,\n          config: card.config\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      return {\n        id: data.id,\n        notebookId: data.notebook_id,\n        threadId: data.thread_id,\n        type: data.type,\n        title: data.title,\n        content: data.content,\n        position: data.position,\n        size: data.size,\n        isCollapsed: data.is_collapsed,\n        isDragging: false,\n        zIndex: data.z_index,\n        style: data.style,\n        config: data.config,\n        createdAt: data.created_at,\n        updatedAt: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error creating card:', error);\n      throw error;\n    }\n  },\n\n  // Get a card by thread ID\n  async getCardByThreadId(threadId: string): Promise<Card | null> {\n    try {\n      const { data, error } = await supabase\n        .from('cards')\n        .select('*')\n        .eq('thread_id', threadId)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          // No row found\n          return null;\n        }\n        throw error;\n      }\n\n      if (!data) return null;\n\n      return {\n        id: data.id,\n        notebookId: data.notebook_id,\n        threadId: data.thread_id,\n        type: data.type,\n        title: data.title,\n        content: data.content,\n        position: data.position,\n        size: data.size,\n        isCollapsed: data.is_collapsed,\n        isDragging: false,\n        zIndex: data.z_index,\n        style: data.style,\n        config: data.config,\n        createdAt: data.created_at,\n        updatedAt: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error fetching card by thread ID:', error);\n      throw error;\n    }\n  },\n\n  // Get a thread by card ID\n  async getThreadByCardId(cardId: string): Promise<Thread | null> {\n    try {\n      // First get the card to find the thread ID\n      const { data: cardData, error: cardError } = await supabase\n        .from('cards')\n        .select('thread_id')\n        .eq('id', cardId)\n        .single();\n\n      if (cardError) {\n        if (cardError.code === 'PGRST116') {\n          // No row found\n          return null;\n        }\n        throw cardError;\n      }\n\n      if (!cardData || !cardData.thread_id) return null;\n\n      // Get the thread\n      const { data: threadData, error: threadError } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('id', cardData.thread_id)\n        .single();\n\n      if (threadError) {\n        throw threadError;\n      }\n\n      if (!threadData) return null;\n\n      // Get thread messages\n      const { data: messagesData, error: messagesError } = await supabase\n        .from('thread_messages')\n        .select('*')\n        .eq('thread_id', threadData.id)\n        .order('created_at', { ascending: true });\n\n      if (messagesError) {\n        throw messagesError;\n      }\n\n      // Convert messages to the correct format\n      const messages: Message[] = (messagesData || []).map(message => ({\n        id: message.id,\n        threadId: message.thread_id,\n        content: message.content,\n        role: message.role,\n        createdAt: message.created_at\n      }));\n\n      // Return the thread with messages\n      return {\n        id: threadData.id,\n        notebookId: threadData.notebook_id,\n        title: threadData.title,\n        position: threadData.position,\n        messages: messages,\n        parentId: threadData.parent_id,\n        referencedThreads: threadData.referenced_threads,\n        createdAt: threadData.created_at,\n        updatedAt: threadData.updated_at,\n        cardType: threadData.card_type,\n        handwritingStyle: threadData.handwriting_style,\n        isMinimized: threadData.is_minimized,\n        zIndex: threadData.z_index\n      };\n    } catch (error) {\n      console.error('Error fetching thread by card ID:', error);\n      throw error;\n    }\n  },\n\n  // Get all cards in a notebook\n  async getCardsByNotebook(notebookId: string): Promise<Card[]> {\n    try {\n      const { data, error } = await supabase\n        .from('cards')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n\n      if (error) {\n        throw error;\n      }\n\n      return (data || []).map(card => ({\n        id: card.id,\n        notebookId: card.notebook_id,\n        threadId: card.thread_id,\n        type: card.type,\n        title: card.title,\n        content: card.content,\n        position: card.position,\n        size: card.size,\n        isCollapsed: card.is_collapsed,\n        isDragging: false,\n        zIndex: card.z_index,\n        style: card.style,\n        config: card.config,\n        createdAt: card.created_at,\n        updatedAt: card.updated_at\n      }));\n    } catch (error) {\n      console.error('Error fetching cards by notebook:', error);\n      throw error;\n    }\n  },\n\n  // Update a card\n  async updateCard(cardId: string, updates: Partial<Card>): Promise<void> {\n    try {\n      const updateData: Record<string, any> = {};\n\n      if (updates.title !== undefined) updateData.title = updates.title;\n      if (updates.content !== undefined) updateData.content = updates.content;\n      if (updates.position !== undefined) updateData.position = updates.position;\n      if (updates.size !== undefined) updateData.size = updates.size;\n      if (updates.isCollapsed !== undefined) updateData.is_collapsed = updates.isCollapsed;\n      if (updates.zIndex !== undefined) updateData.z_index = updates.zIndex;\n      if (updates.style !== undefined) updateData.style = updates.style;\n      if (updates.config !== undefined) updateData.config = updates.config;\n\n      // Only update if we have changes\n      if (Object.keys(updateData).length === 0) return;\n\n      const { error } = await supabase\n        .from('cards')\n        .update(updateData)\n        .eq('id', cardId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  // Delete a card\n  async deleteCard(cardId: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('cards')\n        .delete()\n        .eq('id', cardId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error deleting card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  // Card connection methods\n\n  // Create a connection between two cards\n  async createCardConnection(connection: Omit<CardConnection, 'id' | 'createdAt' | 'updatedAt'>): Promise<CardConnection> {\n    try {\n      const { data, error } = await supabase\n        .from('card_connections')\n        .insert({\n          notebook_id: connection.notebookId,\n          from_card_id: connection.fromCardId,\n          to_card_id: connection.toCardId,\n          type: connection.type,\n          label: connection.label,\n          style: connection.style\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      return {\n        id: data.id,\n        notebookId: data.notebook_id,\n        fromCardId: data.from_card_id,\n        toCardId: data.to_card_id,\n        type: data.type,\n        label: data.label,\n        style: data.style,\n        createdAt: data.created_at,\n        updatedAt: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error creating card connection:', error);\n      throw error;\n    }\n  },\n\n  // Get all connections for a notebook\n  async getCardConnections(notebookId: string): Promise<CardConnection[]> {\n    try {\n      const { data, error } = await supabase\n        .from('card_connections')\n        .select('*')\n        .eq('notebook_id', notebookId);\n\n      if (error) {\n        throw error;\n      }\n\n      return (data || []).map(conn => ({\n        id: conn.id,\n        notebookId: conn.notebook_id,\n        fromCardId: conn.from_card_id,\n        toCardId: conn.to_card_id,\n        type: conn.type,\n        label: conn.label,\n        style: conn.style,\n        createdAt: conn.created_at,\n        updatedAt: conn.updated_at\n      }));\n    } catch (error) {\n      console.error('Error fetching card connections:', error);\n      throw error;\n    }\n  },\n\n  // Get connections for a specific card\n  async getCardConnectionsForCard(cardId: string): Promise<CardConnection[]> {\n    try {\n      const { data, error } = await supabase\n        .from('card_connections')\n        .select('*')\n        .or(`from_card_id.eq.${cardId},to_card_id.eq.${cardId}`);\n\n      if (error) {\n        throw error;\n      }\n\n      return (data || []).map(conn => ({\n        id: conn.id,\n        notebookId: conn.notebook_id,\n        fromCardId: conn.from_card_id,\n        toCardId: conn.to_card_id,\n        type: conn.type,\n        label: conn.label,\n        style: conn.style,\n        createdAt: conn.created_at,\n        updatedAt: conn.updated_at\n      }));\n    } catch (error) {\n      console.error(`Error fetching connections for card ${cardId}:`, error);\n      throw error;\n    }\n  },\n\n  // Update a card connection\n  async updateCardConnection(connectionId: string, updates: Partial<CardConnection>): Promise<void> {\n    try {\n      const updateData: Record<string, any> = {};\n\n      if (updates.type !== undefined) updateData.type = updates.type;\n      if (updates.label !== undefined) updateData.label = updates.label;\n      if (updates.style !== undefined) updateData.style = updates.style;\n\n      // Only update if we have changes\n      if (Object.keys(updateData).length === 0) return;\n\n      const { error } = await supabase\n        .from('card_connections')\n        .update(updateData)\n        .eq('id', connectionId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error updating card connection ${connectionId}:`, error);\n      throw error;\n    }\n  },\n\n  // Delete a card connection\n  async deleteCardConnection(connectionId: string): Promise<void> {\n    try {\n      const { error } = await supabase\n        .from('card_connections')\n        .delete()\n        .eq('id', connectionId);\n\n      if (error) {\n        throw error;\n      }\n    } catch (error) {\n      console.error(`Error deleting card connection ${connectionId}:`, error);\n      throw error;\n    }\n  },\n\n  // Connect two threads with their cards\n  async connectThreads(fromThreadId: string, toThreadId: string, connectionType: 'parent-child' | 'reference' | 'custom', label?: string): Promise<void> {\n    try {\n      // First get the cards for both threads\n      const fromCard = await this.getCardByThreadId(fromThreadId);\n      const toCard = await this.getCardByThreadId(toThreadId);\n\n      if (!fromCard || !toCard) {\n        throw new Error('One or both threads do not have associated cards');\n      }\n\n      // Create the card connection\n      await this.createCardConnection({\n        notebookId: fromCard.notebookId,\n        fromCardId: fromCard.id,\n        toCardId: toCard.id,\n        type: connectionType,\n        label,\n        style: {}\n      });\n\n      // If this is a parent-child relationship, also update the thread's parent_id\n      if (connectionType === 'parent-child') {\n        await this.updateThread(toThreadId, {\n          parentId: fromThreadId\n        });\n      }\n\n      // If this is a reference, update the thread's referenced_threads array\n      if (connectionType === 'reference') {\n        const { data } = await supabase\n          .from('threads')\n          .select('referenced_threads')\n          .eq('id', fromThreadId)\n          .single();\n\n        const referencedThreads = data?.referenced_threads || [];\n\n        if (!referencedThreads.includes(toThreadId)) {\n          await this.updateThread(fromThreadId, {\n            referencedThreads: [...referencedThreads, toThreadId]\n          });\n        }\n      }\n    } catch (error) {\n      console.error(`Error connecting threads ${fromThreadId} and ${toThreadId}:`, error);\n      throw error;\n    }\n  },\n\n  // Drawing-related methods\n\n  /**\n   * Create a new stroke with support for multi-device inputs and pressure sensitivity\n   * @param notebookId The notebook ID\n   * @param points Array of stroke points with pressure data\n   * @param tool The drawing tool used (pen/eraser)\n   * @param color The stroke color\n   * @param width The stroke width\n   * @param inputType The input type (mouse/touch/pen)\n   */\n  async createStroke(\n    notebookId: string,\n    points: StrokePoint[],\n    tool: string,\n    color: string,\n    width: number,\n    inputType?: 'mouse' | 'touch' | 'pen'\n  ): Promise<Stroke> {\n    try {\n      // Add input type metadata to help with rendering optimization\n      const metadata = {\n        inputType: inputType || 'mouse'\n      };\n\n      // Insert the stroke record\n      const { data, error } = await supabase\n        .from('strokes')\n        .insert({\n          notebook_id: notebookId,\n          points: points,\n          tool: tool,\n          color: color,\n          width: width,\n          metadata: metadata\n        })\n        .select()\n        .single();\n\n      if (error) {\n        throw error;\n      }\n\n      // Convert the database record to our application type\n      return {\n        id: data.id,\n        notebook_id: data.notebook_id,\n        points: data.points as StrokePoint[],\n        tool: data.tool,\n        color: data.color,\n        width: data.width,\n        order_index: data.order_index,\n        created_at: data.created_at,\n        updated_at: data.updated_at\n      };\n    } catch (error) {\n      console.error('Error creating stroke:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Get all strokes for a notebook with optimized batch loading\n   * @param notebookId The notebook ID\n   */\n  async getStrokesByNotebook(notebookId: string): Promise<Stroke[]> {\n    try {\n      // Get all strokes in one query\n      const { data, error } = await supabase\n        .from('strokes')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: true });\n\n      if (error) {\n        throw error;\n      }\n\n      // Convert the database records to our application type\n      return (data || []).map(stroke => ({\n        id: stroke.id,\n        notebook_id: stroke.notebook_id,\n        points: stroke.points as StrokePoint[],\n        tool: stroke.tool,\n        color: stroke.color,\n        width: stroke.width,\n        order_index: stroke.order_index,\n        created_at: stroke.created_at,\n        updated_at: stroke.updated_at\n      }));\n    } catch (error) {\n      console.error('Error fetching strokes:', error);\n      throw error;\n    }\n  },\n\n  /**\n   * Send a stroke update in real-time to other users\n   * @param notebookId The notebook ID\n   * @param strokeId The stroke ID\n   * @param userId The user ID\n   * @param newPoints New stroke points to add\n   * @param inputType The input device type\n   */\n  async broadcastStrokeUpdate(\n    notebookId: string,\n    strokeId: string,\n    userId: string,\n    newPoints: StrokePoint[],\n    inputType?: 'mouse' | 'touch' | 'pen'\n  ): Promise<void> {\n    try {\n      // Generate a unique client ID if needed\n      const clientId = window.clientId || `client-${Math.random().toString(36).substring(2, 9)}`;\n\n      // Send the real-time update\n      await supabase.channel('drawing-updates')\n        .send({\n          type: 'broadcast',\n          event: 'stroke-update',\n          payload: {\n            notebookId,\n            strokeId,\n            userId,\n            clientId,\n            newPoints,\n            timestamp: new Date().toISOString(),\n            inputType: inputType || 'mouse'\n          }\n        });\n    } catch (error) {\n      console.error('Error broadcasting stroke update:', error);\n      // Don't throw the error - this is non-critical\n    }\n  }\n};// src/services/CardLocator.ts\n\nimport { Conversation } from '@/types/supabase';\n\nexport interface CardLocation {\n  x: number;\n  y: number;\n  zoom: number;\n  conversationId: string;\n}\n\n// Service for handling card positioning and navigation\nexport class CardLocator {\n  // Get a URL for a specific card\n  static getCardUrl(notebookId: string, conversationId: string): string {\n    return `/notebooks/${notebookId}/cards/${conversationId}`;\n  }\n  \n  // Get a URL with position parameters\n  static getPositionUrl(notebookId: string, x: number, y: number, zoom: number = 1): string {\n    return `/notebooks/${notebookId}?x=${x}&y=${y}&zoom=${zoom}`;\n  }\n  \n  // Find a card's ideal position\n  static findCardPosition(\n    conversation: Conversation,\n    allConversations: Conversation[],\n    positions: Record<string, { x: number; y: number }>\n  ): { x: number; y: number } {\n    // If card already has a position, use it\n    if (conversation.position && typeof conversation.position === 'object') {\n      const pos = conversation.position as { x: number; y: number };\n      if (typeof pos.x === 'number' && typeof pos.y === 'number') {\n        return { x: pos.x, y: pos.y };\n      }\n    }\n    \n    // If card has a parent, position it relative to parent\n    if (conversation.parent_id) {\n      const parentPos = positions[conversation.parent_id];\n      if (parentPos) {\n        // How many siblings does this card have?\n        const siblings = allConversations.filter(c => \n          c.parent_id === conversation.parent_id\n        );\n        \n        const index = siblings.findIndex(s => s.id === conversation.id);\n        \n        // Position below parent with offset based on index\n        return {\n          x: parentPos.x + (index * 50),\n          y: parentPos.y + 300\n        };\n      }\n    }\n    \n    // If card has a thread_id, position it relative to other thread members\n    if (conversation.thread_id) {\n      const threadMembers = allConversations.filter(c => \n        c.thread_id === conversation.thread_id\n      );\n      \n      if (threadMembers.length > 0) {\n        const memberPositions = threadMembers\n          .filter(m => m.id !== conversation.id)\n          .map(m => positions[m.id])\n          .filter(Boolean);\n        \n        if (memberPositions.length > 0) {\n          // Calculate average position of thread members\n          const avgX = memberPositions.reduce((sum, pos) => sum + pos.x, 0) / memberPositions.length;\n          const avgY = memberPositions.reduce((sum, pos) => sum + pos.y, 0) / memberPositions.length;\n          \n          // Add some randomness to avoid direct overlap\n          return {\n            x: avgX + (Math.random() * 200 - 100),\n            y: avgY + (Math.random() * 200 - 100)\n          };\n        }\n      }\n    }\n    \n    // If no other positioning logic applies, use a default position\n    // with some randomness to avoid all cards stacking at the same point\n    return {\n      x: 100 + (Math.random() * 300),\n      y: 100 + (Math.random() * 300)\n    };\n  }\n  \n  // Update the browser URL to reflect the current view\n  static updateUrlWithPosition(notebookId: string, x: number, y: number, zoom: number): void {\n    if (typeof window === 'undefined') return;\n    \n    const url = new URL(window.location.href);\n    url.searchParams.set('x', x.toString());\n    url.searchParams.set('y', y.toString());\n    url.searchParams.set('zoom', zoom.toString());\n    \n    window.history.replaceState({}, '', url.toString());\n  }\n  \n  // Extract position from URL\n  static getPositionFromUrl(): { x: number | null; y: number | null; zoom: number | null } {\n    if (typeof window === 'undefined') return { x: null, y: null, zoom: null };\n    \n    const url = new URL(window.location.href);\n    const x = url.searchParams.get('x');\n    const y = url.searchParams.get('y');\n    const zoom = url.searchParams.get('zoom');\n    \n    return {\n      x: x ? parseFloat(x) : null,\n      y: y ? parseFloat(y) : null,\n      zoom: zoom ? parseFloat(zoom) : null\n    };\n  }\n  \n  // Get the nearest cards to a given position\n  static getNearbyCards(\n    x: number,\n    y: number,\n    positions: Record<string, { x: number; y: number }>,\n    maxDistance: number = 500\n  ): string[] {\n    return Object.entries(positions)\n      .map(([id, pos]) => {\n        const distance = Math.sqrt(\n          Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2)\n        );\n        return { id, distance };\n      })\n      .filter(item => item.distance <= maxDistance)\n      .sort((a, b) => a.distance - b.distance)\n      .map(item => item.id);\n  }\n}// src/services/api/langchainService.ts\n\n/**\n * Client for LangChain API endpoints\n */\nexport const extractMemories = async (\n  userMessage: string,\n  currentMemories: any[] = [],\n  extractionThreshold = 0.5\n) => {\n  try {\n    const response = await fetch('/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        userMessage,\n        currentMemories,\n        extractionThreshold,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to extract memories');\n    }\n\n    const result = await response.json();\n    return result.data;\n  } catch (error) {\n    console.error('Error extracting memories:', error);\n    throw error;\n  }\n};\n\nexport const evaluateQuestion = async (question: string) => {\n  try {\n    const response = await fetch('/api/langchain/questions/evaluate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        question,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to evaluate question');\n    }\n\n    const result = await response.json();\n    return result.data;\n  } catch (error) {\n    console.error('Error evaluating question:', error);\n    throw error;\n  }\n};\n\n// Add more functions as needed for other LangChain features/**\n * Unified Conversation Service\n * \n * This service provides a centralized API for all conversation operations including:\n * - CRUD operations for conversations\n * - Message management\n * - AI interactions\n * - Parliament functionality\n */\n\nimport { supabase } from '@/lib/supabaseClient';\nimport { \n  Conversation, \n  Message, \n  ConversationConnection,\n  ConversationInput,\n  MessageInput,\n  ConversationUpdate\n} from '@/types/conversation';\nimport { threadToConversation, conversationToThread } from '@/adapters/threadAdapter';\nimport { parliamentToConversation } from '@/adapters/parliamentAdapter';\n\n/**\n * Get current authenticated user ID\n */\nasync function getUserId(): Promise<string | null> {\n  const { data } = await supabase.auth.getUser();\n  return data?.user?.id || null;\n}\n\n/**\n * Core conversation service with unified API for all conversation types\n */\nexport const conversationService = {\n  // ----- Conversation CRUD -----\n  \n  /**\n   * Fetch conversations for a specific notebook\n   */\n  async getByNotebook(notebookId: string): Promise<Conversation[]> {\n    try {\n      // First try to get threads from the threads table\n      const { data: threads, error: threadsError } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: false });\n      \n      if (threadsError) {\n        console.error('Error fetching threads:', threadsError);\n        throw threadsError;\n      }\n      \n      // Get messages for each thread\n      const threadIds = threads.map(thread => thread.id);\n      const { data: messages, error: messagesError } = await supabase\n        .from('thread_messages')\n        .select('*')\n        .in('thread_id', threadIds)\n        .order('created_at', { ascending: true });\n      \n      if (messagesError) {\n        console.error('Error fetching messages:', messagesError);\n        throw messagesError;\n      }\n      \n      // Group messages by thread\n      const messagesByThread: Record<string, any[]> = {};\n      messages?.forEach(message => {\n        if (!messagesByThread[message.thread_id]) {\n          messagesByThread[message.thread_id] = [];\n        }\n        messagesByThread[message.thread_id].push(message);\n      });\n      \n      // Convert threads to conversations\n      const conversations: Conversation[] = threads.map(thread => {\n        const threadWithMessages = {\n          ...thread,\n          messages: messagesByThread[thread.id] || []\n        };\n        \n        const conversation = threadToConversation(threadWithMessages);\n        \n        // Add user ID\n        conversation.userId = thread.user_id || '';\n        \n        return conversation;\n      });\n      \n      // Also fetch classic conversations\n      const { data: classicConversations, error: conversationsError } = await supabase\n        .from('conversations')\n        .select('*')\n        .eq('notebook_id', notebookId)\n        .order('created_at', { ascending: false });\n        \n      if (conversationsError) {\n        console.warn('Error fetching classic conversations:', conversationsError);\n        // Continue with threads only\n      } else if (classicConversations?.length) {\n        // Convert classic conversations to unified model\n        const legacyConversations: Conversation[] = classicConversations.map(conv => ({\n          id: conv.id,\n          notebookId: conv.notebook_id,\n          userId: conv.user_id || '',\n          title: conv.user_content?.substring(0, 40) || 'Untitled',\n          createdAt: conv.created_at,\n          updatedAt: conv.updated_at,\n          messages: [\n            {\n              id: `${conv.id}-user`,\n              role: 'user',\n              content: conv.user_content || '',\n              createdAt: conv.created_at\n            },\n            ...(conv.ai_response ? [{\n              id: `${conv.id}-ai`,\n              role: 'assistant',\n              content: conv.ai_response,\n              createdAt: conv.updated_at\n            }] : [])\n          ],\n          position: conv.position,\n          cardType: 'chat',\n          handwritingStyle: conv.handwriting_style as any,\n        }));\n        \n        conversations.push(...legacyConversations);\n      }\n      \n      // TODO: Fetch parliaments when implemented\n      \n      return conversations;\n      \n    } catch (error) {\n      console.error('Error in getByNotebook:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Get a single conversation by ID\n   */\n  async getById(id: string): Promise<Conversation | null> {\n    try {\n      // First check threads table\n      const { data: thread, error: threadError } = await supabase\n        .from('threads')\n        .select('*')\n        .eq('id', id)\n        .single();\n      \n      if (thread) {\n        // Get messages for this thread\n        const { data: messages, error: messagesError } = await supabase\n          .from('thread_messages')\n          .select('*')\n          .eq('thread_id', id)\n          .order('created_at', { ascending: true });\n        \n        if (messagesError) {\n          console.error('Error fetching messages:', messagesError);\n          throw messagesError;\n        }\n        \n        const threadWithMessages = {\n          ...thread,\n          messages: messages || []\n        };\n        \n        const conversation = threadToConversation(threadWithMessages);\n        conversation.userId = thread.user_id || '';\n        \n        return conversation;\n      }\n      \n      // Check classic conversations\n      const { data: conversation, error: conversationError } = await supabase\n        .from('conversations')\n        .select('*')\n        .eq('id', id)\n        .single();\n        \n      if (conversation) {\n        return {\n          id: conversation.id,\n          notebookId: conversation.notebook_id,\n          userId: conversation.user_id || '',\n          title: conversation.user_content?.substring(0, 40) || 'Untitled',\n          createdAt: conversation.created_at,\n          updatedAt: conversation.updated_at,\n          messages: [\n            {\n              id: `${conversation.id}-user`,\n              role: 'user',\n              content: conversation.user_content || '',\n              createdAt: conversation.created_at\n            },\n            ...(conversation.ai_response ? [{\n              id: `${conversation.id}-ai`,\n              role: 'assistant',\n              content: conversation.ai_response,\n              createdAt: conversation.updated_at\n            }] : [])\n          ],\n          position: conversation.position,\n          cardType: 'chat',\n          handwritingStyle: conversation.handwriting_style as any,\n        };\n      }\n      \n      // TODO: Check parliaments when implemented\n      \n      return null;\n    } catch (error) {\n      console.error('Error in getById:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Create a new conversation\n   */\n  async create(input: ConversationInput): Promise<Conversation> {\n    try {\n      const userId = await getUserId();\n      if (!userId) {\n        throw new Error('Authentication required');\n      }\n      \n      // Generate ID\n      const id = crypto.randomUUID();\n      const now = new Date().toISOString();\n      \n      // Create a conversation object\n      const conversation: Conversation = {\n        ...input,\n        id,\n        userId,\n        createdAt: now,\n        updatedAt: now,\n      };\n      \n      // Convert to thread format (using the thread table for new conversations)\n      const thread = conversationToThread(conversation);\n      \n      // Insert thread\n      const { error: threadError } = await supabase\n        .from('threads')\n        .insert({\n          id: thread.id,\n          notebook_id: thread.notebookId,\n          title: thread.title,\n          position: thread.position,\n          parent_id: thread.parentId,\n          referenced_threads: thread.referencedThreads,\n          card_type: thread.cardType,\n          handwriting_style: thread.handwritingStyle,\n          is_minimized: thread.isMinimized,\n          z_index: thread.zIndex,\n          user_id: userId,\n        });\n        \n      if (threadError) {\n        console.error('Error creating thread:', threadError);\n        throw threadError;\n      }\n      \n      // Insert messages\n      if (conversation.messages.length > 0) {\n        const messagesToInsert = conversation.messages.map(message => ({\n          id: message.id,\n          thread_id: thread.id,\n          content: message.content,\n          role: message.role,\n        }));\n        \n        const { error: messagesError } = await supabase\n          .from('thread_messages')\n          .insert(messagesToInsert);\n          \n        if (messagesError) {\n          console.error('Error inserting messages:', messagesError);\n          throw messagesError;\n        }\n      }\n      \n      return conversation;\n    } catch (error) {\n      console.error('Error in create:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Update an existing conversation\n   */\n  async update(id: string, updates: ConversationUpdate): Promise<void> {\n    try {\n      // First determine if this is a thread or classic conversation\n      const { data: thread, error: threadError } = await supabase\n        .from('threads')\n        .select('id')\n        .eq('id', id)\n        .maybeSingle();\n      \n      if (thread) {\n        // Update thread\n        const threadUpdates: Record<string, any> = {};\n        \n        if (updates.title !== undefined) threadUpdates.title = updates.title;\n        if (updates.position) threadUpdates.position = updates.position;\n        if (updates.parentId !== undefined) threadUpdates.parent_id = updates.parentId;\n        if (updates.references) threadUpdates.referenced_threads = updates.references;\n        if (updates.cardType) threadUpdates.card_type = updates.cardType;\n        if (updates.handwritingStyle) threadUpdates.handwriting_style = updates.handwritingStyle;\n        if (updates.isMinimized !== undefined) threadUpdates.is_minimized = updates.isMinimized;\n        if (updates.zIndex !== undefined) threadUpdates.z_index = updates.zIndex;\n        \n        if (Object.keys(threadUpdates).length > 0) {\n          const { error: updateError } = await supabase\n            .from('threads')\n            .update(threadUpdates)\n            .eq('id', id);\n            \n          if (updateError) {\n            console.error('Error updating thread:', updateError);\n            throw updateError;\n          }\n        }\n        \n        return;\n      }\n      \n      // Check if it's a classic conversation\n      const { data: conversation, error: conversationError } = await supabase\n        .from('conversations')\n        .select('id')\n        .eq('id', id)\n        .maybeSingle();\n        \n      if (conversation) {\n        // Update conversation\n        const conversationUpdates: Record<string, any> = {};\n        \n        if (updates.position) conversationUpdates.position = updates.position;\n        if (updates.handwritingStyle) conversationUpdates.handwriting_style = updates.handwritingStyle;\n        \n        // Special handling for messages in classic conversations\n        if (updates.messages) {\n          const userMessage = updates.messages.find(m => m.role === 'user');\n          const aiMessage = updates.messages.find(m => m.role === 'assistant');\n          \n          if (userMessage) conversationUpdates.user_content = userMessage.content;\n          if (aiMessage) conversationUpdates.ai_response = aiMessage.content;\n        }\n        \n        if (Object.keys(conversationUpdates).length > 0) {\n          const { error: updateError } = await supabase\n            .from('conversations')\n            .update(conversationUpdates)\n            .eq('id', id);\n            \n          if (updateError) {\n            console.error('Error updating conversation:', updateError);\n            throw updateError;\n          }\n        }\n      }\n      \n      // TODO: Handle parliament updates when implemented\n      \n    } catch (error) {\n      console.error('Error in update:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Delete a conversation\n   */\n  async delete(id: string): Promise<void> {\n    try {\n      // Try deleting from threads\n      const { error: threadError } = await supabase\n        .from('threads')\n        .delete()\n        .eq('id', id);\n        \n      if (!threadError) {\n        return; // Successfully deleted from threads\n      }\n      \n      // Try deleting from conversations\n      const { error: conversationError } = await supabase\n        .from('conversations')\n        .delete()\n        .eq('id', id);\n        \n      if (conversationError) {\n        console.error('Error deleting conversation:', conversationError);\n        throw conversationError;\n      }\n      \n      // TODO: Handle parliament deletion when implemented\n      \n    } catch (error) {\n      console.error('Error in delete:', error);\n      throw error;\n    }\n  },\n  \n  // ----- Message operations -----\n  \n  /**\n   * Add a message to a conversation\n   */\n  async addMessage(conversationId: string, message: MessageInput): Promise<Message> {\n    try {\n      // Generate message ID and timestamp\n      const messageId = crypto.randomUUID();\n      const createdAt = new Date().toISOString();\n      \n      // First check if this is a thread\n      const { data: thread, error: threadError } = await supabase\n        .from('threads')\n        .select('id')\n        .eq('id', conversationId)\n        .maybeSingle();\n        \n      if (thread) {\n        // Add message to thread_messages\n        const { error: insertError } = await supabase\n          .from('thread_messages')\n          .insert({\n            id: messageId,\n            thread_id: conversationId,\n            content: message.content,\n            role: message.role,\n          });\n          \n        if (insertError) {\n          console.error('Error adding message to thread:', insertError);\n          throw insertError;\n        }\n        \n        // Update thread's updated_at timestamp\n        await supabase\n          .from('threads')\n          .update({ updated_at: createdAt })\n          .eq('id', conversationId);\n          \n        return {\n          id: messageId,\n          ...message,\n          createdAt,\n        };\n      }\n      \n      // Check if it's a classic conversation\n      const { data: conversation, error: conversationError } = await supabase\n        .from('conversations')\n        .select('*')\n        .eq('id', conversationId)\n        .maybeSingle();\n        \n      if (conversation) {\n        // Update the appropriate field based on message role\n        const updates: Record<string, any> = {\n          updated_at: createdAt,\n        };\n        \n        if (message.role === 'user') {\n          updates.user_content = message.content;\n        } else if (message.role === 'assistant') {\n          updates.ai_response = message.content;\n        }\n        \n        const { error: updateError } = await supabase\n          .from('conversations')\n          .update(updates)\n          .eq('id', conversationId);\n          \n        if (updateError) {\n          console.error('Error updating conversation with message:', updateError);\n          throw updateError;\n        }\n        \n        return {\n          id: messageId,\n          ...message,\n          createdAt,\n        };\n      }\n      \n      // TODO: Handle parliament messages when implemented\n      \n      throw new Error('Conversation not found');\n    } catch (error) {\n      console.error('Error in addMessage:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Delete a message from a conversation\n   */\n  async deleteMessage(conversationId: string, messageId: string): Promise<void> {\n    try {\n      // Check if this is a thread message\n      const { error: deleteError } = await supabase\n        .from('thread_messages')\n        .delete()\n        .eq('id', messageId)\n        .eq('thread_id', conversationId);\n        \n      if (!deleteError) {\n        // Update thread's updated_at timestamp\n        await supabase\n          .from('threads')\n          .update({ updated_at: new Date().toISOString() })\n          .eq('id', conversationId);\n          \n        return;\n      }\n      \n      // For classic conversations, we need to null out the appropriate field\n      const { data: message, error: messageError } = await supabase\n        .from('thread_messages')\n        .select('role')\n        .eq('id', messageId)\n        .maybeSingle();\n        \n      if (message) {\n        const updates: Record<string, any> = {\n          updated_at: new Date().toISOString(),\n        };\n        \n        if (message.role === 'user') {\n          updates.user_content = null;\n        } else if (message.role === 'assistant') {\n          updates.ai_response = null;\n        }\n        \n        const { error: updateError } = await supabase\n          .from('conversations')\n          .update(updates)\n          .eq('id', conversationId);\n          \n        if (updateError) {\n          console.error('Error nulling conversation message:', updateError);\n          throw updateError;\n        }\n      }\n      \n      // TODO: Handle parliament message deletion when implemented\n      \n    } catch (error) {\n      console.error('Error in deleteMessage:', error);\n      throw error;\n    }\n  },\n  \n  // ----- AI Interactions -----\n  \n  /**\n   * Send a message to Claude AI and get a response\n   */\n  async sendToAI(conversationId: string, userMessage: string): Promise<Message> {\n    try {\n      // First add the user message to the conversation\n      const userMsg = await this.addMessage(conversationId, {\n        role: 'user',\n        content: userMessage,\n      });\n      \n      // Get the conversation with all messages\n      const conversation = await this.getById(conversationId);\n      if (!conversation) {\n        throw new Error('Conversation not found');\n      }\n      \n      // Prepare messages for Claude API (only include role and content)\n      const messages = conversation.messages.map(msg => ({\n        role: msg.role,\n        content: msg.content,\n      }));\n      \n      // Call Claude API\n      const response = await fetch('/api/claude/chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages,\n          stream: false,\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`AI request failed: ${response.status} ${response.statusText}`);\n      }\n      \n      const result = await response.json();\n      \n      // Extract response text from Claude API format\n      let responseText = '';\n      if (result.content && Array.isArray(result.content)) {\n        responseText = result.content\n          .filter((block: any) => block.type === 'text')\n          .map((block: any) => 'text' in block ? block.text : '')\n          .join('\\n');\n      } else if (result.response) {\n        responseText = result.response;\n      } else {\n        responseText = 'Received an empty or invalid response from AI.';\n      }\n      \n      // Add the AI response to the conversation\n      const aiMessage = await this.addMessage(conversationId, {\n        role: 'assistant',\n        content: responseText,\n      });\n      \n      return aiMessage;\n    } catch (error) {\n      console.error('Error in sendToAI:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Stream a response from Claude AI\n   */\n  async streamFromAI(conversationId: string, userMessage: string): Promise<ReadableStream<Uint8Array> | null> {\n    try {\n      // First add the user message to the conversation\n      await this.addMessage(conversationId, {\n        role: 'user',\n        content: userMessage,\n      });\n      \n      // Get the conversation with all messages\n      const conversation = await this.getById(conversationId);\n      if (!conversation) {\n        throw new Error('Conversation not found');\n      }\n      \n      // Prepare messages for Claude API (only include role and content)\n      const messages = conversation.messages.map(msg => ({\n        role: msg.role,\n        content: msg.content,\n      }));\n      \n      // Call Claude API with streaming\n      const response = await fetch('/api/claude/chat', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages,\n          stream: true,\n        }),\n      });\n      \n      if (!response.ok) {\n        throw new Error(`AI stream request failed: ${response.status} ${response.statusText}`);\n      }\n      \n      return response.body;\n    } catch (error) {\n      console.error('Error in streamFromAI:', error);\n      throw error;\n    }\n  },\n  \n  // ----- Connections -----\n  \n  /**\n   * Get connections for a notebook\n   */\n  async getConnections(notebookId: string): Promise<ConversationConnection[]> {\n    try {\n      // Check for thread connections\n      const { data: threads, error: threadsError } = await supabase\n        .from('threads')\n        .select('id, parent_id, referenced_threads')\n        .eq('notebook_id', notebookId);\n        \n      if (threadsError) {\n        console.error('Error fetching thread connections:', threadsError);\n        throw threadsError;\n      }\n      \n      const connections: ConversationConnection[] = [];\n      \n      // Process thread connections\n      threads.forEach(thread => {\n        // Add parent-child connections\n        if (thread.parent_id) {\n          connections.push({\n            id: `${thread.parent_id}-${thread.id}-parent`,\n            fromId: thread.parent_id,\n            toId: thread.id,\n            notebookId,\n            type: 'parent-child',\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n          });\n        }\n        \n        // Add reference connections\n        if (thread.referenced_threads && Array.isArray(thread.referenced_threads)) {\n          thread.referenced_threads.forEach(refId => {\n            connections.push({\n              id: `${thread.id}-${refId}-reference`,\n              fromId: thread.id,\n              toId: refId,\n              notebookId,\n              type: 'reference',\n              createdAt: new Date().toISOString(),\n              updatedAt: new Date().toISOString(),\n            });\n          });\n        }\n      });\n      \n      // TODO: Check for card connections when implemented\n      \n      return connections;\n    } catch (error) {\n      console.error('Error in getConnections:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Create a connection between conversations\n   */\n  async createConnection(connection: Omit<ConversationConnection, 'id' | 'createdAt' | 'updatedAt'>): Promise<ConversationConnection> {\n    try {\n      const id = crypto.randomUUID();\n      const now = new Date().toISOString();\n      \n      const newConnection: ConversationConnection = {\n        ...connection,\n        id,\n        createdAt: now,\n        updatedAt: now,\n      };\n      \n      // For now, we handle connections as thread relationships\n      if (connection.type === 'parent-child') {\n        // Update the \"to\" thread with parent_id\n        const { error: updateError } = await supabase\n          .from('threads')\n          .update({ parent_id: connection.fromId })\n          .eq('id', connection.toId);\n          \n        if (updateError) {\n          console.error('Error setting parent thread:', updateError);\n          throw updateError;\n        }\n      } else if (connection.type === 'reference') {\n        // Get current referenced_threads\n        const { data: thread, error: threadError } = await supabase\n          .from('threads')\n          .select('referenced_threads')\n          .eq('id', connection.fromId)\n          .single();\n          \n        if (threadError) {\n          console.error('Error getting thread:', threadError);\n          throw threadError;\n        }\n        \n        // Add toId to referenced_threads\n        const referencedThreads = thread.referenced_threads || [];\n        if (!referencedThreads.includes(connection.toId)) {\n          referencedThreads.push(connection.toId);\n          \n          const { error: updateError } = await supabase\n            .from('threads')\n            .update({ referenced_threads: referencedThreads })\n            .eq('id', connection.fromId);\n            \n          if (updateError) {\n            console.error('Error updating referenced threads:', updateError);\n            throw updateError;\n          }\n        }\n      }\n      \n      // TODO: Support actual connection table when implemented\n      \n      return newConnection;\n    } catch (error) {\n      console.error('Error in createConnection:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Delete a connection\n   */\n  async deleteConnection(connectionId: string): Promise<void> {\n    try {\n      // Parse the connection ID to determine type and IDs\n      const parts = connectionId.split('-');\n      if (parts.length < 3) {\n        throw new Error('Invalid connection ID format');\n      }\n      \n      const fromId = parts[0];\n      const toId = parts[1];\n      const type = parts[2];\n      \n      if (type === 'parent') {\n        // Remove parent-child relationship\n        const { error: updateError } = await supabase\n          .from('threads')\n          .update({ parent_id: null })\n          .eq('id', toId);\n          \n        if (updateError) {\n          console.error('Error removing parent thread:', updateError);\n          throw updateError;\n        }\n      } else if (type === 'reference') {\n        // Remove reference\n        const { data: thread, error: threadError } = await supabase\n          .from('threads')\n          .select('referenced_threads')\n          .eq('id', fromId)\n          .single();\n          \n        if (threadError) {\n          console.error('Error getting thread:', threadError);\n          throw threadError;\n        }\n        \n        const referencedThreads = (thread.referenced_threads || []).filter(id => id !== toId);\n        \n        const { error: updateError } = await supabase\n          .from('threads')\n          .update({ referenced_threads: referencedThreads })\n          .eq('id', fromId);\n          \n        if (updateError) {\n          console.error('Error updating referenced threads:', updateError);\n          throw updateError;\n        }\n      }\n      \n      // TODO: Support actual connection table when implemented\n      \n    } catch (error) {\n      console.error('Error in deleteConnection:', error);\n      throw error;\n    }\n  },\n  \n  // ----- Parliament operations -----\n  \n  // TODO: Implement parliament-specific operations when needed\n};"
          },
          {
            "file_name": "paste-3.txt",
            "file_size": 6556,
            "file_type": "txt",
            "extracted_content": "const fetch = require('node-fetch');\n\nasync function testMemoryExtraction() {\n  try {\n    const response = await fetch('http://localhost:3000/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        userMessage: \"I'm really excited about my upcoming trip to Japan next month. I've been learning Japanese for two years now.\",\n        currentMemories: [],\n        extractionThreshold: 0.5\n      })\n    });\n    \n    const result = await response.json();\n    console.log('API Response:', JSON.stringify(result, null, 2));\n    console.log('Test passed:', response.status === 200 && result.success);\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n}\n\ntestMemoryExtraction();\n\n# API Architecture\n\nThis document outlines the architecture of our API system, which has been migrated to a server-side approach for handling LangChain and other server-only operations.\n\n## Core Architecture\n\nOur API architecture follows these principles:\n\n1. **Server-Side Processing**: All LangChain operations run exclusively on the server\n2. **Type Safety**: Comprehensive request/response validation with Zod schemas\n3. **Error Handling**: Centralized error handling for consistent responses\n4. **Rate Limiting**: Protection against abuse and cost management\n5. **Caching**: Performance optimization with appropriate cache headers\n6. **Documentation**: Self-documenting with OpenAPI/Swagger\n\n## API Endpoints\n\nThe main API endpoints are:\n\n### LangChain APIs\n\n- **Memory Extraction**: `/api/langchain/memory/extract`\n  - Extracts user memories from conversation\n  - POST request with user message and optional context\n  - Returns extracted memories with confidence scores\n\n- **Question Evaluation**: `/api/langchain/questions/evaluate`\n  - Evaluates question quality across multiple dimensions\n  - POST request with question content\n  - Returns scores and improvement suggestions\n\n### Chat APIs\n\n- **Unified Chat**: `/api/claude/unified-chat`\n  - Simplified, reliable chat endpoint\n  - POST request with message history and options\n  - Returns AI response with appropriate formatting\n\n## Implementation Details\n\n### Validation\n\nRequest validation is handled through Zod schemas defined in `src/lib/validation/apiSchemas.ts`. These schemas ensure:\n\n- Required fields are present\n- Values are within expected ranges\n- Types are correct\n\n### Error Handling\n\nA centralized error handler in `src/lib/errorHandler.ts` provides:\n\n- Consistent error response structure\n- Appropriate HTTP status codes\n- Error logging\n- Development vs. production error detail control\n\n### Rate Limiting\n\nRate limits are enforced through Upstash Redis:\n\n- Memory extraction: 10 requests per minute\n- Question evaluation: 20 requests per minute\n- Chat: 30 requests per minute\n- Default: 50 requests per minute\n\nThese limits are configured in `src/lib/rateLimit.ts` and can be adjusted as needed.\n\n### Documentation\n\nAPI documentation is available at `/api-docs` and is generated using:\n\n- Swagger UI for interactive documentation\n- JSDoc comments for API descriptions\n- OpenAPI specification generation at build time\n\n## Client-Side Integration\n\nThe client interacts with these APIs through service modules:\n\n- `src/services/api/langchainService.ts`: Client for LangChain endpoints\n- Provides type-safe wrappers around fetch operations\n- Handles client-side error management\n\n## Testing\n\nAPI endpoints are tested using:\n\n- Jest for unit tests\n- Mock Service Worker for API simulation\n- Integration tests against real endpoints\n\n## Next Steps\n\nFuture improvements to consider:\n\n1. **Monitoring**: Implement OpenTelemetry for observability\n2. **Edge Functions**: Move computation to Supabase Edge Functions\n3. **Enhanced Caching**: Add Redis-based response caching\n4. **Authentication Middleware**: Centralized auth across all endpoints\n5. **GraphQL API**: Consider adding a GraphQL layer for complex data requirements\n# API Migration Summary\n\nThis document summarizes the changes made to migrate LangChain and other server-only functionality to an API-based architecture.\n\n## Completed Implementations\n\n### 1. Validation with Zod\n- **Files Created:**\n  - `src/lib/validation/apiSchemas.ts` - Centralized validation schemas\n- **Benefits:**\n  - Type-safe API requests and responses\n  - Clear error messages for invalid inputs\n  - Runtime validation of data structures\n\n### 2. Error Handling\n- **Files Created:**\n  - `src/lib/errorHandler.ts` - Centralized error handling\n- **Benefits:**\n  - Consistent error response format\n  - Proper HTTP status codes\n  - Better developer experience with clear error messages\n\n### 3. Rate Limiting\n- **Files Created:**\n  - `src/lib/rateLimit.ts` - Rate limiting middleware\n- **Benefits:**\n  - Protection against API abuse\n  - Cost control for LLM API calls\n  - Different limits for different endpoints\n\n### 4. API Documentation\n- **Files Created:**\n  - `src/pages/api-docs.tsx` - Swagger UI integration\n  - JSDoc annotations for API endpoints\n- **Benefits:**\n  - Interactive API documentation\n  - Self-documenting code\n  - Better developer onboarding\n\n### 5. API Testing\n- **Files Created:**\n  - `src/tests/api/memory-extraction.test.ts` - Example API test\n- **Benefits:**\n  - Confidence in API behavior\n  - Regression testing\n  - Test-driven development\n\n### 6. Updated API Endpoints\n- **Files Updated:**\n  - `src/pages/api/langchain/memory/extract.ts` - Memory extraction endpoint\n  - `src/pages/api/claude/unified-chat.ts` - Chat endpoint\n- **Benefits:**\n  - Server-side execution of LangChain code\n  - Clean separation of concerns\n  - Improved error handling\n\n## Architecture Documentation\n- **Files Created:**\n  - `API_ARCHITECTURE.md` - Overview of API design\n  - `LANGCHAIN_MIGRATION.md` - Details on migration process\n- **Benefits:**\n  - Clear documentation for the team\n  - Onboarding resource for new developers\n  - Reference for future extensions\n\n## Next Steps\n\n1. **Apply to All Endpoints**\n   - Update all existing API endpoints with the new patterns\n   - Migrate any remaining client-side LangChain usage\n\n2. **Monitoring**\n   - Add OpenTelemetry integration\n   - Track API performance and errors\n\n3. **Edge Deployment**\n   - Consider moving to Supabase Edge Functions for better performance\n   - Explore serverless deployment options\n\n4. **Enhanced Caching**\n   - Implement Redis-based response caching\n   - Add cache invalidation mechanisms\n\n5. **Authentication Enhancements**\n   - Add role-based access control\n   - Implement more granular permissions"
          }
        ],
        "files": [
          {
            "file_name": "paste.txt"
          },
          {
            "file_name": "paste-2.txt"
          },
          {
            "file_name": "paste-3.txt"
          }
        ]
      }
    },
    {
      "id": "412ca7e6-3227-4dd6-96d4-6beb041e3f07",
      "role": "assistant",
      "content": "Based on the terminal output you shared, it looks like the test script for the memory extraction API endpoint was executed successfully. The API responded with a 200 status code and returned a structured response with extracted memories from the test message, which is a positive sign.\n\nLet's analyze what happened here:\n\n1. There were a couple of \"command not found\" errors because you tried to directly run the shell comments (`#`) as commands.\n2. There's a Node.js deprecation warning about the 'punycode' module, which isn't critical but something to note.\n3. The API endpoint `/api/langchain/memory/extract` was compiled successfully.\n4. The API call succeeded with a 200 status code in about 13.7 seconds.\n5. The response contains three extracted memories with proper structure, each with a confidence score, rationale, category, etc.\n6. The test passed as expected.\n\nSince you're asking for files to replace in full, I should provide you with implementation files that address what you were trying to test. It seems you were testing the memory extraction API endpoint, and it appears to be working correctly.\n\nFrom what I can see, you'd need:\n\n1. The `test_memory_api.js` script that was used for this test\n2. The `/api/langchain/memory/extract.ts` API endpoint code\n3. Possibly the memory extraction implementation in `src/lib/memoryExtractor.ts`\n4. Any related utility files\n\nLet me provide these files with improvements based on the output:Great! It looks like your test of the memory extraction API endpoint worked successfully. The API responded correctly with a 200 status code and provided properly structured memories extracted from the test message, along with confidence scores and categorization.\n\nLet me provide you with the full implementations for the key files you'd need to complete this migration:\n\n## 1. First, let's create a proper test script (`test_memory_api.js`):\n\n```javascript\nconst fetch = require('node-fetch');\n\nasync function testMemoryExtraction() {\n  try {\n    console.log('Testing memory extraction API...');\n    const response = await fetch('http://localhost:3000/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        userMessage: \"I'm really excited about my upcoming trip to Japan next month. I've been learning Japanese for two years now.\",\n        currentMemories: [],\n        extractionThreshold: 0.5\n      })\n    });\n    \n    const result = await response.json();\n    console.log('API Response:', JSON.stringify(result, null, 2));\n    console.log('Test passed:', response.status === 200 && result.success);\n    \n    if (result.success) {\n      console.log(`Extracted ${result.data.newMemories.length} memories:`);\n      result.data.newMemories.forEach((memory, i) => {\n        console.log(`${i+1}. ${memory.content} (${memory.category}, confidence: ${memory.confidence})`);\n      });\n    }\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n}\n\ntestMemoryExtraction();\n```\n\n## 2. Now, let's improve the API endpoint (`/pages/api/langchain/memory/extract.ts`):\n\n```typescript\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { ChatAnthropic } from \"@langchain/anthropic\";\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport { StructuredOutputParser } from '@langchain/core/output_parsers';\nimport { z } from \"zod\";\nimport { nanoid } from \"nanoid\";\nimport { getPromptTemplate } from \"@/lib/configLoader\";\nimport { handleApiError } from \"@/lib/errorHandler\";\nimport { rateLimit } from \"@/lib/rateLimit\";\n\n// Define response type\ntype ApiResponse = {\n  success: boolean;\n  data?: any;\n  error?: string;\n};\n\n// Memory extraction output parser schema\nconst memoryExtractorSchema = z.object({\n  newMemories: z.array(\n    z.object({\n      content: z.string(),\n      rationale: z.string(),\n      confidence: z.number().min(0).max(1),\n      category: z.enum([\n        \"interest\",\n        \"preference\",\n        \"belief\",\n        \"knowledge\",\n        \"experience\",\n        \"demographic\",\n        \"personality\",\n        \"goal\",\n        \"relationship\",\n        \"communication_style\",\n        \"meta\",\n      ]),\n    })\n  ),\n  reasoning: z.string(),\n});\n\n// Request validation schema\nconst requestSchema = z.object({\n  userMessage: z.string().min(1),\n  currentMemories: z.array(\n    z.object({\n      content: z.string(),\n      category: z.string(),\n      confidence: z.number().min(0).max(1),\n      id: z.string().optional(),\n      timestamp: z.string().optional(),\n      source: z.string().optional(),\n    })\n  ).optional().default([]),\n  extractionThreshold: z.number().min(0).max(1).optional().default(0.5)\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ success: false, error: 'Method not allowed' });\n  }\n\n  try {\n    // Apply rate limiting (if configured)\n    try {\n      await rateLimit(req, 'memory_extraction', 10, '1m');\n      console.log('Rate limit check passed');\n    } catch (error) {\n      console.log('Rate limiting is not configured, allowing request');\n    }\n    \n    // Validate request body\n    const validatedData = requestSchema.parse(req.body);\n    const { userMessage, currentMemories, extractionThreshold } = validatedData;\n\n    // Model setup\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      return res.status(500).json({ \n        success: false, \n        error: 'ANTHROPIC_API_KEY is not set' \n      });\n    }\n\n    const model = new ChatAnthropic({\n      modelName: \"claude-3-5-sonnet-20240620\",\n      temperature: 0.2,\n      anthropicApiKey: apiKey,\n    });\n\n    // Format current memories\n    const currentMemoriesFormatted = currentMemories.length === 0 \n      ? \"No current memories.\" \n      : currentMemories.map(m =>\n          `- ${m.content} (${m.category}, confidence: ${m.confidence})`\n        ).join(\"\\n\");\n\n    // Get the prompt template\n    const memoryExtractorOutputParser = StructuredOutputParser.fromZodSchema(memoryExtractorSchema);\n    const PROMPT_TEMPLATE = getPromptTemplate(\"theory_of_mind\", \"memory_extraction\") ||\n      `You are a specialized AI system that extracts important information about users to build a Theory of Mind.\n\n      Your task is to analyze the following message to identify any potential information that would help understand the user better.\n      Only extract meaningful information that reveals something significant about the user. Don't include trivial details.\n\n      ## User message:\n      {userMessage}\n\n      ## Current memories about the user (if any):\n      {currentMemoriesFormatted}\n\n      For each piece of significant information, provide:\n      1. The content (the specific memory/fact about the user)\n      2. A rationale for why this is relevant and useful for understanding the user\n      3. A confidence score (0.0-1.0) of how certain you are about this information\n      4. The best category for this memory\n\n      Only include information that meets a confidence threshold of {extractionThreshold}.\n\n      Respond in this exact JSON format:\n      {formatInstructions}`;\n\n    // Format the prompt with the user message and instructions\n    const extractionPrompt = await PromptTemplate.fromTemplate(PROMPT_TEMPLATE).format({\n      userMessage,\n      currentMemoriesFormatted,\n      extractionThreshold,\n      formatInstructions: memoryExtractorOutputParser.getFormatInstructions(),\n    });\n\n    // Get extraction from Claude\n    const startTime = Date.now();\n    const rawExtraction = await model.invoke(extractionPrompt);\n    console.log(`Claude API call completed in ${Date.now() - startTime}ms`);\n    \n    // Parse the extraction results\n    const extraction = await memoryExtractorOutputParser.parse(rawExtraction.content);\n\n    // Add IDs and timestamps to the new memories\n    const newMemories = extraction.newMemories.map(m => ({\n      ...m,\n      id: nanoid(),\n      timestamp: new Date().toISOString(),\n      source: \"conversation\",\n    }));\n\n    // Add cache headers (1 minute, stale-while-revalidate for 5 minutes)\n    res.setHeader('Cache-Control', 'max-age=60, stale-while-revalidate=300');\n    \n    // Return the successful response\n    return res.status(200).json({\n      success: true,\n      data: {\n        newMemories,\n        reasoning: extraction.reasoning,\n      }\n    });\n  } catch (error: any) {\n    return handleApiError(error, res);\n  }\n}\n```\n\n## 3. Here's the error handler utility (`src/lib/errorHandler.ts`):\n\n```typescript\nimport { NextApiResponse } from 'next';\nimport { ZodError } from 'zod';\n\nexport class ApiError extends Error {\n  statusCode: number;\n  \n  constructor(message: string, statusCode: number = 500) {\n    super(message);\n    this.statusCode = statusCode;\n    this.name = 'ApiError';\n  }\n}\n\nexport const handleApiError = (error: unknown, res: NextApiResponse) => {\n  console.error('API Error:', error);\n  \n  // Handle Zod validation errors\n  if (error instanceof ZodError) {\n    return res.status(400).json({\n      success: false,\n      error: 'Validation error',\n      details: error.errors\n    });\n  }\n  \n  // Handle our custom API errors\n  if (error instanceof ApiError) {\n    return res.status(error.statusCode).json({\n      success: false,\n      error: error.message\n    });\n  }\n  \n  // Handle general errors\n  if (error instanceof Error) {\n    return res.status(500).json({\n      success: false,\n      error: process.env.NODE_ENV === 'production' \n        ? 'Internal server error' \n        : error.message\n    });\n  }\n  \n  // Handle unknown errors\n  return res.status(500).json({\n    success: false,\n    error: 'Unknown error occurred'\n  });\n};\n```\n\n## 4. Let's add a basic rate limiting utility (`src/lib/rateLimit.ts`):\n\n```typescript\nimport { NextApiRequest } from 'next';\nimport { ApiError } from './errorHandler';\n\n// Simple in-memory rate limiting\n// In production, use Redis or a similar solution\nconst rateLimits: Record<string, Map<string, { count: number; resetAt: number }>> = {};\n\nexport const rateLimit = async (\n  req: NextApiRequest,\n  limiterKey: string,\n  limit: number,\n  window: string\n): Promise<void> => {\n  // Check if rate limiting is enabled\n  if (process.env.ENABLE_RATE_LIMITING !== 'true') {\n    throw new Error('Rate limiting not enabled');\n  }\n  \n  // Parse window string (e.g., '1m', '10s', '1h')\n  const value = parseInt(window.slice(0, -1));\n  const unit = window.slice(-1);\n  \n  // Convert to milliseconds\n  let windowMs = value;\n  if (unit === 's') windowMs *= 1000;\n  if (unit === 'm') windowMs *= 60 * 1000;\n  if (unit === 'h') windowMs *= 60 * 60 * 1000;\n  \n  // Get user identifier (IP address, or better, a user ID if authenticated)\n  const identifier = req.headers['x-forwarded-for'] || \n                     req.socket.remoteAddress || \n                     'unknown';\n                     \n  // Get or create limiter for this key\n  if (!rateLimits[limiterKey]) {\n    rateLimits[limiterKey] = new Map();\n  }\n  \n  const limiter = rateLimits[limiterKey];\n  const now = Date.now();\n  \n  // Get or create user's rate limit data\n  let userData = limiter.get(identifier as string);\n  if (!userData || userData.resetAt <= now) {\n    userData = { count: 0, resetAt: now + windowMs };\n  }\n  \n  // Check if limit exceeded\n  if (userData.count >= limit) {\n    throw new ApiError('Rate limit exceeded', 429);\n  }\n  \n  // Increment count and update\n  userData.count += 1;\n  limiter.set(identifier as string, userData);\n  \n  // Set headers\n  req.res?.setHeader('X-RateLimit-Limit', limit.toString());\n  req.res?.setHeader('X-RateLimit-Remaining', (limit - userData.count).toString());\n  req.res?.setHeader('X-RateLimit-Reset', Math.ceil(userData.resetAt / 1000).toString());\n};\n```\n\n## 5. And finally, the client-side API service (`src/services/api/langchainService.ts`):\n\n```typescript\n// src/services/api/langchainService.ts\n\n/**\n * Client for LangChain API endpoints\n */\n\nexport interface MemoryEntry {\n  id?: string;\n  content: string;\n  category: string;\n  confidence: number;\n  timestamp?: string;\n  source?: string;\n  rationale?: string;\n}\n\nexport interface MemoryExtractionResponse {\n  newMemories: MemoryEntry[];\n  reasoning: string;\n}\n\nexport interface EvaluationScore {\n  score: number;\n  justification: string;\n  improvementSuggestion?: string;\n}\n\nexport interface QuestionEvaluation {\n  clarity: EvaluationScore;\n  depth: EvaluationScore;\n  relevance: EvaluationScore;\n  originality: EvaluationScore;\n  engagement: EvaluationScore;\n  strengths: string[];\n  areasForImprovement: string[];\n  suggestedRevision?: string;\n}\n\n/**\n * Extract memories from user message\n */\nexport const extractMemories = async (\n  userMessage: string,\n  currentMemories: MemoryEntry[] = [],\n  extractionThreshold = 0.5\n): Promise<MemoryExtractionResponse> => {\n  try {\n    const response = await fetch('/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        userMessage,\n        currentMemories,\n        extractionThreshold,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to extract memories');\n    }\n\n    const result = await response.json();\n    return result.data;\n  } catch (error) {\n    console.error('Error extracting memories:', error);\n    throw error;\n  }\n};\n\n/**\n * Evaluate question quality\n */\nexport const evaluateQuestion = async (question: string): Promise<QuestionEvaluation> => {\n  try {\n    const response = await fetch('/api/langchain/questions/evaluate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        question,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to evaluate question');\n    }\n\n    const result = await response.json();\n    return result.data;\n  } catch (error) {\n    console.error('Error evaluating question:', error);\n    throw error;\n  }\n};\n\n/**\n * Process a conversation with AI\n */\nexport const processConversation = async (messages: any[], streaming = false) => {\n  try {\n    const response = await fetch('/api/claude/unified-chat', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messages,\n        stream: streaming\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to process conversation');\n    }\n\n    if (streaming) {\n      return response.body;\n    }\n\n    return await response.json();\n  } catch (error) {\n    console.error('Error processing conversation:', error);\n    throw error;\n  }\n};\n\nexport default {\n  extractMemories,\n  evaluateQuestion,\n  processConversation\n};\n```\n\nBased on your successful test results, these implementations should provide a solid foundation for your API migration. The memory extraction endpoint is working correctly, and these files include improvements like proper error handling, rate limiting, and validation that will make your API more robust.\n\nWould you like me to explain any specific part of these implementations in more detail?",
      "created_at": "2025-05-14T05:58:19.505278Z",
      "sequence_order": 1,
      "metadata": {
        "content": [
          {
            "start_timestamp": "2025-05-14T05:57:32.476579Z",
            "stop_timestamp": "2025-05-14T05:57:37.312320Z",
            "flags": null,
            "type": "thinking",
            "thinking": "Based on the terminal output you shared, it looks like the test script for the memory extraction API endpoint was executed successfully. The API responded with a 200 status code and returned a structured response with extracted memories from the test message, which is a positive sign.\n\nLet's analyze what happened here:\n\n1. There were a couple of \"command not found\" errors because you tried to directly run the shell comments (`#`) as commands.\n2. There's a Node.js deprecation warning about the 'punycode' module, which isn't critical but something to note.\n3. The API endpoint `/api/langchain/memory/extract` was compiled successfully.\n4. The API call succeeded with a 200 status code in about 13.7 seconds.\n5. The response contains three extracted memories with proper structure, each with a confidence score, rationale, category, etc.\n6. The test passed as expected.\n\nSince you're asking for files to replace in full, I should provide you with implementation files that address what you were trying to test. It seems you were testing the memory extraction API endpoint, and it appears to be working correctly.\n\nFrom what I can see, you'd need:\n\n1. The `test_memory_api.js` script that was used for this test\n2. The `/api/langchain/memory/extract.ts` API endpoint code\n3. Possibly the memory extraction implementation in `src/lib/memoryExtractor.ts`\n4. Any related utility files\n\nLet me provide these files with improvements based on the output:",
            "summaries": [
              {
                "summary": "Thinking about resolving terminal errors and analyzing API memory extraction results"
              },
              {
                "summary": "Extracting and analyzing user's memories from conversation"
              },
              {
                "summary": "Decoded memory extraction test, confirmed successful API response."
              }
            ],
            "cut_off": false
          },
          {
            "start_timestamp": "2025-05-14T05:57:37.415933Z",
            "stop_timestamp": "2025-05-14T05:58:19.431247Z",
            "flags": null,
            "type": "text",
            "text": "Great! It looks like your test of the memory extraction API endpoint worked successfully. The API responded correctly with a 200 status code and provided properly structured memories extracted from the test message, along with confidence scores and categorization.\n\nLet me provide you with the full implementations for the key files you'd need to complete this migration:\n\n## 1. First, let's create a proper test script (`test_memory_api.js`):\n\n```javascript\nconst fetch = require('node-fetch');\n\nasync function testMemoryExtraction() {\n  try {\n    console.log('Testing memory extraction API...');\n    const response = await fetch('http://localhost:3000/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        userMessage: \"I'm really excited about my upcoming trip to Japan next month. I've been learning Japanese for two years now.\",\n        currentMemories: [],\n        extractionThreshold: 0.5\n      })\n    });\n    \n    const result = await response.json();\n    console.log('API Response:', JSON.stringify(result, null, 2));\n    console.log('Test passed:', response.status === 200 && result.success);\n    \n    if (result.success) {\n      console.log(`Extracted ${result.data.newMemories.length} memories:`);\n      result.data.newMemories.forEach((memory, i) => {\n        console.log(`${i+1}. ${memory.content} (${memory.category}, confidence: ${memory.confidence})`);\n      });\n    }\n  } catch (error) {\n    console.error('Test failed:', error);\n  }\n}\n\ntestMemoryExtraction();\n```\n\n## 2. Now, let's improve the API endpoint (`/pages/api/langchain/memory/extract.ts`):\n\n```typescript\nimport type { NextApiRequest, NextApiResponse } from 'next';\nimport { ChatAnthropic } from \"@langchain/anthropic\";\nimport { PromptTemplate } from '@langchain/core/prompts';\nimport { StructuredOutputParser } from '@langchain/core/output_parsers';\nimport { z } from \"zod\";\nimport { nanoid } from \"nanoid\";\nimport { getPromptTemplate } from \"@/lib/configLoader\";\nimport { handleApiError } from \"@/lib/errorHandler\";\nimport { rateLimit } from \"@/lib/rateLimit\";\n\n// Define response type\ntype ApiResponse = {\n  success: boolean;\n  data?: any;\n  error?: string;\n};\n\n// Memory extraction output parser schema\nconst memoryExtractorSchema = z.object({\n  newMemories: z.array(\n    z.object({\n      content: z.string(),\n      rationale: z.string(),\n      confidence: z.number().min(0).max(1),\n      category: z.enum([\n        \"interest\",\n        \"preference\",\n        \"belief\",\n        \"knowledge\",\n        \"experience\",\n        \"demographic\",\n        \"personality\",\n        \"goal\",\n        \"relationship\",\n        \"communication_style\",\n        \"meta\",\n      ]),\n    })\n  ),\n  reasoning: z.string(),\n});\n\n// Request validation schema\nconst requestSchema = z.object({\n  userMessage: z.string().min(1),\n  currentMemories: z.array(\n    z.object({\n      content: z.string(),\n      category: z.string(),\n      confidence: z.number().min(0).max(1),\n      id: z.string().optional(),\n      timestamp: z.string().optional(),\n      source: z.string().optional(),\n    })\n  ).optional().default([]),\n  extractionThreshold: z.number().min(0).max(1).optional().default(0.5)\n});\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<ApiResponse>\n) {\n  // Only allow POST requests\n  if (req.method !== 'POST') {\n    return res.status(405).json({ success: false, error: 'Method not allowed' });\n  }\n\n  try {\n    // Apply rate limiting (if configured)\n    try {\n      await rateLimit(req, 'memory_extraction', 10, '1m');\n      console.log('Rate limit check passed');\n    } catch (error) {\n      console.log('Rate limiting is not configured, allowing request');\n    }\n    \n    // Validate request body\n    const validatedData = requestSchema.parse(req.body);\n    const { userMessage, currentMemories, extractionThreshold } = validatedData;\n\n    // Model setup\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    if (!apiKey) {\n      return res.status(500).json({ \n        success: false, \n        error: 'ANTHROPIC_API_KEY is not set' \n      });\n    }\n\n    const model = new ChatAnthropic({\n      modelName: \"claude-3-5-sonnet-20240620\",\n      temperature: 0.2,\n      anthropicApiKey: apiKey,\n    });\n\n    // Format current memories\n    const currentMemoriesFormatted = currentMemories.length === 0 \n      ? \"No current memories.\" \n      : currentMemories.map(m =>\n          `- ${m.content} (${m.category}, confidence: ${m.confidence})`\n        ).join(\"\\n\");\n\n    // Get the prompt template\n    const memoryExtractorOutputParser = StructuredOutputParser.fromZodSchema(memoryExtractorSchema);\n    const PROMPT_TEMPLATE = getPromptTemplate(\"theory_of_mind\", \"memory_extraction\") ||\n      `You are a specialized AI system that extracts important information about users to build a Theory of Mind.\n\n      Your task is to analyze the following message to identify any potential information that would help understand the user better.\n      Only extract meaningful information that reveals something significant about the user. Don't include trivial details.\n\n      ## User message:\n      {userMessage}\n\n      ## Current memories about the user (if any):\n      {currentMemoriesFormatted}\n\n      For each piece of significant information, provide:\n      1. The content (the specific memory/fact about the user)\n      2. A rationale for why this is relevant and useful for understanding the user\n      3. A confidence score (0.0-1.0) of how certain you are about this information\n      4. The best category for this memory\n\n      Only include information that meets a confidence threshold of {extractionThreshold}.\n\n      Respond in this exact JSON format:\n      {formatInstructions}`;\n\n    // Format the prompt with the user message and instructions\n    const extractionPrompt = await PromptTemplate.fromTemplate(PROMPT_TEMPLATE).format({\n      userMessage,\n      currentMemoriesFormatted,\n      extractionThreshold,\n      formatInstructions: memoryExtractorOutputParser.getFormatInstructions(),\n    });\n\n    // Get extraction from Claude\n    const startTime = Date.now();\n    const rawExtraction = await model.invoke(extractionPrompt);\n    console.log(`Claude API call completed in ${Date.now() - startTime}ms`);\n    \n    // Parse the extraction results\n    const extraction = await memoryExtractorOutputParser.parse(rawExtraction.content);\n\n    // Add IDs and timestamps to the new memories\n    const newMemories = extraction.newMemories.map(m => ({\n      ...m,\n      id: nanoid(),\n      timestamp: new Date().toISOString(),\n      source: \"conversation\",\n    }));\n\n    // Add cache headers (1 minute, stale-while-revalidate for 5 minutes)\n    res.setHeader('Cache-Control', 'max-age=60, stale-while-revalidate=300');\n    \n    // Return the successful response\n    return res.status(200).json({\n      success: true,\n      data: {\n        newMemories,\n        reasoning: extraction.reasoning,\n      }\n    });\n  } catch (error: any) {\n    return handleApiError(error, res);\n  }\n}\n```\n\n## 3. Here's the error handler utility (`src/lib/errorHandler.ts`):\n\n```typescript\nimport { NextApiResponse } from 'next';\nimport { ZodError } from 'zod';\n\nexport class ApiError extends Error {\n  statusCode: number;\n  \n  constructor(message: string, statusCode: number = 500) {\n    super(message);\n    this.statusCode = statusCode;\n    this.name = 'ApiError';\n  }\n}\n\nexport const handleApiError = (error: unknown, res: NextApiResponse) => {\n  console.error('API Error:', error);\n  \n  // Handle Zod validation errors\n  if (error instanceof ZodError) {\n    return res.status(400).json({\n      success: false,\n      error: 'Validation error',\n      details: error.errors\n    });\n  }\n  \n  // Handle our custom API errors\n  if (error instanceof ApiError) {\n    return res.status(error.statusCode).json({\n      success: false,\n      error: error.message\n    });\n  }\n  \n  // Handle general errors\n  if (error instanceof Error) {\n    return res.status(500).json({\n      success: false,\n      error: process.env.NODE_ENV === 'production' \n        ? 'Internal server error' \n        : error.message\n    });\n  }\n  \n  // Handle unknown errors\n  return res.status(500).json({\n    success: false,\n    error: 'Unknown error occurred'\n  });\n};\n```\n\n## 4. Let's add a basic rate limiting utility (`src/lib/rateLimit.ts`):\n\n```typescript\nimport { NextApiRequest } from 'next';\nimport { ApiError } from './errorHandler';\n\n// Simple in-memory rate limiting\n// In production, use Redis or a similar solution\nconst rateLimits: Record<string, Map<string, { count: number; resetAt: number }>> = {};\n\nexport const rateLimit = async (\n  req: NextApiRequest,\n  limiterKey: string,\n  limit: number,\n  window: string\n): Promise<void> => {\n  // Check if rate limiting is enabled\n  if (process.env.ENABLE_RATE_LIMITING !== 'true') {\n    throw new Error('Rate limiting not enabled');\n  }\n  \n  // Parse window string (e.g., '1m', '10s', '1h')\n  const value = parseInt(window.slice(0, -1));\n  const unit = window.slice(-1);\n  \n  // Convert to milliseconds\n  let windowMs = value;\n  if (unit === 's') windowMs *= 1000;\n  if (unit === 'm') windowMs *= 60 * 1000;\n  if (unit === 'h') windowMs *= 60 * 60 * 1000;\n  \n  // Get user identifier (IP address, or better, a user ID if authenticated)\n  const identifier = req.headers['x-forwarded-for'] || \n                     req.socket.remoteAddress || \n                     'unknown';\n                     \n  // Get or create limiter for this key\n  if (!rateLimits[limiterKey]) {\n    rateLimits[limiterKey] = new Map();\n  }\n  \n  const limiter = rateLimits[limiterKey];\n  const now = Date.now();\n  \n  // Get or create user's rate limit data\n  let userData = limiter.get(identifier as string);\n  if (!userData || userData.resetAt <= now) {\n    userData = { count: 0, resetAt: now + windowMs };\n  }\n  \n  // Check if limit exceeded\n  if (userData.count >= limit) {\n    throw new ApiError('Rate limit exceeded', 429);\n  }\n  \n  // Increment count and update\n  userData.count += 1;\n  limiter.set(identifier as string, userData);\n  \n  // Set headers\n  req.res?.setHeader('X-RateLimit-Limit', limit.toString());\n  req.res?.setHeader('X-RateLimit-Remaining', (limit - userData.count).toString());\n  req.res?.setHeader('X-RateLimit-Reset', Math.ceil(userData.resetAt / 1000).toString());\n};\n```\n\n## 5. And finally, the client-side API service (`src/services/api/langchainService.ts`):\n\n```typescript\n// src/services/api/langchainService.ts\n\n/**\n * Client for LangChain API endpoints\n */\n\nexport interface MemoryEntry {\n  id?: string;\n  content: string;\n  category: string;\n  confidence: number;\n  timestamp?: string;\n  source?: string;\n  rationale?: string;\n}\n\nexport interface MemoryExtractionResponse {\n  newMemories: MemoryEntry[];\n  reasoning: string;\n}\n\nexport interface EvaluationScore {\n  score: number;\n  justification: string;\n  improvementSuggestion?: string;\n}\n\nexport interface QuestionEvaluation {\n  clarity: EvaluationScore;\n  depth: EvaluationScore;\n  relevance: EvaluationScore;\n  originality: EvaluationScore;\n  engagement: EvaluationScore;\n  strengths: string[];\n  areasForImprovement: string[];\n  suggestedRevision?: string;\n}\n\n/**\n * Extract memories from user message\n */\nexport const extractMemories = async (\n  userMessage: string,\n  currentMemories: MemoryEntry[] = [],\n  extractionThreshold = 0.5\n): Promise<MemoryExtractionResponse> => {\n  try {\n    const response = await fetch('/api/langchain/memory/extract', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        userMessage,\n        currentMemories,\n        extractionThreshold,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to extract memories');\n    }\n\n    const result = await response.json();\n    return result.data;\n  } catch (error) {\n    console.error('Error extracting memories:', error);\n    throw error;\n  }\n};\n\n/**\n * Evaluate question quality\n */\nexport const evaluateQuestion = async (question: string): Promise<QuestionEvaluation> => {\n  try {\n    const response = await fetch('/api/langchain/questions/evaluate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        question,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to evaluate question');\n    }\n\n    const result = await response.json();\n    return result.data;\n  } catch (error) {\n    console.error('Error evaluating question:', error);\n    throw error;\n  }\n};\n\n/**\n * Process a conversation with AI\n */\nexport const processConversation = async (messages: any[], streaming = false) => {\n  try {\n    const response = await fetch('/api/claude/unified-chat', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        messages,\n        stream: streaming\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error || 'Failed to process conversation');\n    }\n\n    if (streaming) {\n      return response.body;\n    }\n\n    return await response.json();\n  } catch (error) {\n    console.error('Error processing conversation:', error);\n    throw error;\n  }\n};\n\nexport default {\n  extractMemories,\n  evaluateQuestion,\n  processConversation\n};\n```\n\nBased on your successful test results, these implementations should provide a solid foundation for your API migration. The memory extraction endpoint is working correctly, and these files include improvements like proper error handling, rate limiting, and validation that will make your API more robust.\n\nWould you like me to explain any specific part of these implementations in more detail?",
            "citations": []
          }
        ],
        "updated_at": "2025-05-14T05:58:19.505278Z",
        "attachments": [],
        "files": []
      }
    }
  ]
}