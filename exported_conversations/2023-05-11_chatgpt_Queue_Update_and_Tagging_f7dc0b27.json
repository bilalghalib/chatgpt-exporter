{
  "id": "f7dc0b27-c170-4f16-aa96-365625739b51",
  "source": "chatgpt",
  "title": "Queue Update and Tagging",
  "created_at": "2023-05-11T20:42:04.254441",
  "updated_at": "2023-05-11T22:06:54",
  "summary": null,
  "message_count": 8,
  "messages": [
    {
      "id": "aaa2b89c-9f70-4190-a9ff-750c6c4cfa0d",
      "role": "user",
      "content": "check this server code:\n# Constants\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.parliament = None\n        self.start_server = serve(self.chat, self.host, self.port)\n\n    def configure_openai(self):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n\n    async def chat(self, websocket, path):\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == SET_PARLIAMENT:\n                await self.handle_set_parliament(websocket, data)\n            elif action == SEND_MESSAGE:\n                await self.handle_send_message(websocket, data)\n            elif action == ADD_AGENTS:\n                await self.handle_add_agents(websocket, data)\n            elif action in [TYPING, STOPPED_TYPING]:  \n                await self.handle_typing(websocket, data)\n\n    async def handle_typing(self, websocket, data):\n        sender = data.get('sender')\n        action = data.get('action')\n        is_typing = action == TYPING\n\n        self.parliament.set_typing_status(sender, is_typing)\n\n        # Send the typing status update to other clients:\n        await websocket.send(json.dumps({\n            \"action\": action,\n            \"sender\": sender,\n            \"is_typing\": is_typing\n        }))\n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        if parliament_name:\n            self.parliament = Parliament(parliament_name)\n            await self.update_queue(websocket)\n\n    async def handle_send_message(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        sender = data.get(\"sender\")\n        user_message = data.get(\"message\")\n        timestamp = datetime.now()\n        await websocket.send(json.dumps({\n            \"action\": RECEIVE_MESSAGE,\n            \"message\": user_message,\n            \"sender\": sender,\n            \"timestamp\": timestamp.isoformat()}))\n        asyncio.create_task(self.parliament.broadcast_message(user_message, sender, timestamp))\n\n        # Sending agent info after broadcasting message\n        agent_info = self.parliament.get_agents_info()  # Assuming that this method returns agents' information\n        await websocket.send(json.dumps({\"action\": UPDATE_AGENTS, \"agents\": agent_info}))\n        await self.update_queue(websocket)\n\n    async def handle_add_agents(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        agents_data = data.get(\"agents\")\n        if not agents_data:\n            await self.send_error(websocket, \"No agent data provided.\")\n            return\n        for agent_data in agents_data:\n            agent_name = agent_data.get(\"name\")\n            speaking_pressure_increment = int(agent_data.get(\"speaking_pressure_increment\"))\n            other_agents = \", \".join([agent['name'] for agent in agents_data if agent['name'] != agent_name])\n            context = (\n                f\"Hello  out of 100\"\n            )\n            agent_type = agent_data.get(\"type\")\n            agent_class = self.parliament.agent_types.get(agent_type)\n            if not agent_class:\n                await self.send_error(websocket, f\"Unknown agent type: {agent_type}\")\n                # Here, 'continue' is used within a loop, so it's okay\n                continue\n            agent_instance = agent_class(context)  # Create a new instance of the agent class\n            self.parliament.add_agent(agent_name, speaking_pressure_increment, context, agent_type, agent_instance, websocket)\n        await self.update_queue(websocket)\n\n\n    async def update_queue(self, websocket):\n        if self.parliament:\n            speaking_queue = self.parliament.get_speaking_queue()\n            print(f\"Queue updated: {speaking_queue.to_json()}\")\n            await websocket.send(json.dumps({\"action\": UPDATE_QUEUE, \"queue\": speaking_queue.to_json()}))\n\n    async def send_error(self, websocket, message):\n        await websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\n    def run(self):\n        self.configure_openai()\n        asyncio.get_event_loop().run_until_complete(self.start_server)\n        print(\"Starting WebSocket server...\")\n        print(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n        asyncio.get_event_loop().run_forever()\n\n\nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()\nand this parliaments.py\n\n\nclass Agent:\n    def __init__(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, parliament, agent_instance=None, websocket=None):\n        self.name = name\n        self.speaking_pressure_increment = speaking_pressure_increment\n        self.context = context\n        self.speaking_pressure = 0\n        self.tagged = False\n        self.agent_type = agent_type\n        self.agent_instance = agent_instance\n        self.websocket = websocket\n        self.parliament = parliament\n        self.is_speaking = False\n    def should_speak(self):\n        return self.parliament.speaker_manager.should_speak(self)\n\n    async def try_to_speak(self):\n        if self.should_speak() and not self.is_speaking:\n            await self.speak()\n\n    async def increment_pressure(self):\n        while True:\n            await asyncio.sleep(PRESSURE_INCREMENT_INTERVAL)\n            self.speaking_pressure += self.speaking_pressure_increment\n            await self.try_to_speak()\n\n    def get_agent_message(self, chat_history):\n        \"\"\"\n        Generate a message from this agent based on the current chat history.\n        \"\"\"\n        message = \"\"\n        if isinstance(self.agent_instance, self.parliament.agent_types[self.agent_type]):\n            response = self.agent_instance.get_response(chat_history)\n            message = f\"{response}\"\n        return message\n    \n    def in_queue(self):\n        return self.name in self.parliament.speaking_queue.queue\n    \n    def calculate_relevancy(self, chat_context: str) -> int:\n        # Replace this with your actual relevancy calculation logic\n        return random.randint(0, 100)\n\n    async def speak(self):\n        self.is_speaking = True  # Agent starts speaking\n        print(f\"{self.name} is speaking...\")  # Add log\n        await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n        agent_message = self.get_agent_message(self.parliament.chat_history)\n        await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n        self.speaking_pressure = 0  # Reset the speaking pressure\n        print(f\"{self.name}'s speaking pressure reset to {self.speaking_pressure}.\")  # Add log\n        self.is_speaking = False  # Agent finishes speaking\n        print(f\"{self.name} has finished speaking.\")  # Add log\n        if self.in_queue():\n            self.parliament.speaking_queue.remove(self.name)\n\n    def reset_pressure(self):\n        self.speaking_pressure = 0\n\nclass SpeakingQueue:\n    def __init__(self):\n        self.queue = deque()\n\n    def add(self, agent_name):\n        self.queue.append(agent_name)\n\n    def pop(self):\n        if len(self.queue) > 0:\n            return self.queue.pop()\n        else:\n            return None\n        \n    def enqueue(self, name):\n        self.queue.append(name)\n\n    def dequeue(self):\n        return self.queue.popleft() if self.queue else None\n\n    def front(self):\n        return self.queue[0] if self.queue else None\n\n    def remove(self, name):\n        self.queue.remove(name)\n\n    def contains(self, name):\n        return name in self.queue\n\n    def to_json(self):\n        return list(self.queue)\n    \nclass SpeakerManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    def should_speak(self, agent):\n        return self.parliament.speaking_queue.front() == agent.name and agent.speaking_pressure >= SPEAKING_PRESSURE_LIMIT\n\n\nclass Parliament:\n    def __init__(self, name: str):\n        self.name = name\n        self.agents = {}\n        self.chat_history = ChatHistory()\n        self.speaking_queue = SpeakingQueue()\n        self.speaker_manager = SpeakerManager(self)\n        self.agent_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n        self.typing_status = {} \n\n    def set_typing_status(self, agent_name: str, status: bool):\n        self.typing_status[agent_name] = status\n\n    def get_typing_status(self, agent_name: str):\n        return self.typing_status.get(agent_name, False)\n\n    async def broadcast_message(self, message, sender, timestamp):\n        self.chat_history.add(message, sender, timestamp)\n        mentioned_agents = self.identify_and_tag_mentioned_agents(message)\n        self.increment_speaking_pressure(mentioned_agents)\n        self.update_speaking_queue()\n\n        # Check if any agent should speak after updating the speaking pressures and the queue\n        for agent in self.agents.values():\n            if not self.get_typing_status(agent.name):  # Don't let agent speak if user is typing\n                await agent.try_to_speak()\n\n        await asyncio.sleep(BROADCAST_DELAY)\n\n        # If no user input after the delay, let the first agent in queue speak\n        first_agent_in_queue = self.speaking_queue.dequeue()\n        if first_agent_in_queue and not self.get_typing_status(first_agent_in_queue):\n            await self.agents[first_agent_in_queue].speak()\n\n    def add_to_speaking_queue(self, agent):\n        if not self.speaking_queue.contains(agent.name):\n            self.speaking_queue.enqueue(agent.name)\n\n    def update_speaking_queue(self):\n        # First, add all agents with high speaking pressure to the queue\n        for agent in self.agents.values():\n            if agent.speaking_pressure >= RELEVANCY_THRESHOLD:\n                self.add_to_speaking_queue(agent)\n\n        # Then, add all tagged agents to the queue\n        for agent in self.agents.values():\n            if agent.tagged:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n        # Finally, add the most relevant agent to the queue\n        most_relevant_agent = max(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history.last_message()), default=None)\n        if most_relevant_agent:\n            self.add_to_speaking_queue(most_relevant_agent)\n            most_relevant_agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = SPEAKING_PRESSURE_LIMIT\n                self.agents[agent_name].tagged = True\n        return mentioned_agents\n    \n    def get_speaking_queue(self):\n        return self.speaking_queue\n            \n    def add_agent(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, agent_instance=None, websocket=None):\n        agent = Agent(name, speaking_pressure_increment, context, agent_type, self, agent_instance, websocket)\n        self.agents[name] = agent\n        self.typing_status[name] = False  # Initialize typing status when adding an agent\n        asyncio.create_task(agent.increment_pressure())\n\n    def remove_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        del self.agents[agent_name]\n\n    def get_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        return self.agents[agent_name]\n\n\n\n    def add_to_chat_history(self, message, sender, timestamp):\n        self.chat_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = 100\n                self.agents[agent_name].tagged = True\n                print(f\"Tagged agent: {agent_name}\")  # Debug print\n        return mentioned_agents\n\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def add_tagged_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.tagged and agent.name not in self.speaking_queue.queue:    \n                self.speaking_queue.add(agent.name)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def add_high_pressure_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.speaking_pressure > 100 and agent.name not in self.speaking_queue.queue:\n                self.speaking_queue.add(agent.name)\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def trigger_next_speaker(self):\n        if self.speaking_queue:\n            next_speaker = self.get_agent(self.speaking_queue.pop())  # Remove the agent from the queue\n\n    def update_speaking_queue(self):\n        sorted_agents = self.get_sorted_agents_based_on_relevancy()\n        most_relevant_agent = sorted_agents[0]\n        most_relevant_agent.speaking_pressure = 100\n        self.speaking_queue.add(most_relevant_agent.name)\n        self.add_tagged_agents_to_queue()\n        self.add_high_pressure_agents_to_queue()\n\n        self.trigger_next_speaker()\n\n    def get_sorted_agents_based_on_relevancy(self):\n        return sorted(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history), reverse=True)\n\n\n    def get_agents_info(self) -> List[dict]:\n        agents_info = []\n        for agent_name, agent in self.agents.items():\n            agents_info.append({\n                \"name\": agent_name,\n                \"speaking_pressure\": agent.speaking_pressure,\n                \"speaking_pressure_increment\": agent.speaking_pressure_increment,\n                \"context\": agent.context,\n                \"agent_type\": agent.agent_type\n                # Add more fields as needed\n            })\n        return agents_info\n\nAnd let me know why the queue isn't being added to and why when I tag someone sometimes someone else will respond",
      "created_at": "2023-05-11T20:42:04.257410",
      "sequence_order": 0,
      "parent_id": "ba6293dd-50f8-4a63-9d77-2226f164af23",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "3538fad5-d3b9-4b19-ac4c-b619c37c796d",
      "role": "assistant",
      "content": "Looking at your code, there are several things that might be causing the issue you're experiencing:\n\n1. **Concurrency**: In Python, asyncio allows you to write single-threaded concurrent code. In your `Agent` class, the `try_to_speak` method is called within the `increment_pressure` method, which is running in a separate task (via `asyncio.create_task`). This means multiple agents could potentially be trying to speak at the same time. You could use a semaphore or a similar construct to ensure that only one agent can speak at a time.\n\n2. **Agent Selection**: The logic in the `update_speaking_queue` method in your `Parliament` class might not be giving you the behavior you're expecting. This method first adds all agents with high speaking pressure to the queue, then it adds all tagged agents, and finally the most relevant agent. However, it's important to note that `add_to_speaking_queue` doesn't check if the agent is already in the queue. So, if an agent has high speaking pressure and is also tagged, it will be added to the queue twice. Furthermore, if the most relevant agent is also one of the high speaking pressure or tagged agents, it will be added to the queue again.\n\n3. **Speaking Pressure Management**: The speaking pressure is reset to 0 every time an agent is added to the queue, which might not be the behavior you're intending. If an agent is added to the queue because it has high speaking pressure, it would make sense to leave its speaking pressure high until it speaks.\n\n4. **Broadcasting Message**: In the `broadcast_message` method, you call `should_speak` method of `speaker_manager` for each agent. However, `should_speak` method checks whether the agent is at the front of the queue, which might not",
      "created_at": "2023-05-11T20:43:05.113872",
      "sequence_order": 1,
      "parent_id": "aaa2b89c-9f70-4190-a9ff-750c6c4cfa0d",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "aaa2f06a-4d60-4be2-8440-f91e1f1d07c8",
      "role": "user",
      "content": "check this server code:\n# Constants\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.parliament = None\n        self.start_server = serve(self.chat, self.host, self.port)\n\n    def configure_openai(self):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n\n    async def chat(self, websocket, path):\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == SET_PARLIAMENT:\n                await self.handle_set_parliament(websocket, data)\n            elif action == SEND_MESSAGE:\n                await self.handle_send_message(websocket, data)\n            elif action == ADD_AGENTS:\n                await self.handle_add_agents(websocket, data)\n            elif action in [TYPING, STOPPED_TYPING]:  \n                await self.handle_typing(websocket, data)\n\n    async def handle_typing(self, websocket, data):\n        sender = data.get('sender')\n        action = data.get('action')\n        is_typing = action == TYPING\n\n        self.parliament.set_typing_status(sender, is_typing)\n\n        # Send the typing status update to other clients:\n        await websocket.send(json.dumps({\n            \"action\": action,\n            \"sender\": sender,\n            \"is_typing\": is_typing\n        }))\n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        if parliament_name:\n            self.parliament = Parliament(parliament_name)\n            await self.update_queue(websocket)\n\n    async def handle_send_message(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        sender = data.get(\"sender\")\n        user_message = data.get(\"message\")\n        timestamp = datetime.now()\n        await websocket.send(json.dumps({\n            \"action\": RECEIVE_MESSAGE,\n            \"message\": user_message,\n            \"sender\": sender,\n            \"timestamp\": timestamp.isoformat()}))\n        asyncio.create_task(self.parliament.broadcast_message(user_message, sender, timestamp))\n\n        # Sending agent info after broadcasting message\n        agent_info = self.parliament.get_agents_info()  # Assuming that this method returns agents' information\n        await websocket.send(json.dumps({\"action\": UPDATE_AGENTS, \"agents\": agent_info}))\n        await self.update_queue(websocket)\n\n    async def handle_add_agents(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        agents_data = data.get(\"agents\")\n        if not agents_data:\n            await self.send_error(websocket, \"No agent data provided.\")\n            return\n        for agent_data in agents_data:\n            agent_name = agent_data.get(\"name\")\n            speaking_pressure_increment = int(agent_data.get(\"speaking_pressure_increment\"))\n            other_agents = \", \".join([agent['name'] for agent in agents_data if agent['name'] != agent_name])\n            context = (\n                f\"Hello  out of 100\"\n            )\n            agent_type = agent_data.get(\"type\")\n            agent_class = self.parliament.agent_types.get(agent_type)\n            if not agent_class:\n                await self.send_error(websocket, f\"Unknown agent type: {agent_type}\")\n                # Here, 'continue' is used within a loop, so it's okay\n                continue\n            agent_instance = agent_class(context)  # Create a new instance of the agent class\n            self.parliament.add_agent(agent_name, speaking_pressure_increment, context, agent_type, agent_instance, websocket)\n        await self.update_queue(websocket)\n\n\n    async def update_queue(self, websocket):\n        if self.parliament:\n            speaking_queue = self.parliament.get_speaking_queue()\n            print(f\"Queue updated: {speaking_queue.to_json()}\")\n            await websocket.send(json.dumps({\"action\": UPDATE_QUEUE, \"queue\": speaking_queue.to_json()}))\n\n    async def send_error(self, websocket, message):\n        await websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\n    def run(self):\n        self.configure_openai()\n        asyncio.get_event_loop().run_until_complete(self.start_server)\n        print(\"Starting WebSocket server...\")\n        print(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n        asyncio.get_event_loop().run_forever()\n\n\nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()\nand this parliaments.py\n\n\nclass Agent:\n    def __init__(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, parliament, agent_instance=None, websocket=None):\n        self.name = name\n        self.speaking_pressure_increment = speaking_pressure_increment\n        self.context = context\n        self.speaking_pressure = 0\n        self.tagged = False\n        self.agent_type = agent_type\n        self.agent_instance = agent_instance\n        self.websocket = websocket\n        self.parliament = parliament\n        self.is_speaking = False\n    def should_speak(self):\n        return self.parliament.speaker_manager.should_speak(self)\n\n    async def try_to_speak(self):\n        if self.should_speak() and not self.is_speaking:\n            await self.speak()\n\n    async def increment_pressure(self):\n        while True:\n            await asyncio.sleep(PRESSURE_INCREMENT_INTERVAL)\n            self.speaking_pressure += self.speaking_pressure_increment\n            await self.try_to_speak()\n\n    def get_agent_message(self, chat_history):\n        \"\"\"\n        Generate a message from this agent based on the current chat history.\n        \"\"\"\n        message = \"\"\n        if isinstance(self.agent_instance, self.parliament.agent_types[self.agent_type]):\n            response = self.agent_instance.get_response(chat_history)\n            message = f\"{response}\"\n        return message\n    \n    def in_queue(self):\n        return self.name in self.parliament.speaking_queue.queue\n    \n    def calculate_relevancy(self, chat_context: str) -> int:\n        # Replace this with your actual relevancy calculation logic\n        return random.randint(0, 100)\n\n    async def speak(self):\n        self.is_speaking = True  # Agent starts speaking\n        print(f\"{self.name} is speaking...\")  # Add log\n        await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n        agent_message = self.get_agent_message(self.parliament.chat_history)\n        await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n        self.speaking_pressure = 0  # Reset the speaking pressure\n        print(f\"{self.name}'s speaking pressure reset to {self.speaking_pressure}.\")  # Add log\n        self.is_speaking = False  # Agent finishes speaking\n        print(f\"{self.name} has finished speaking.\")  # Add log\n        if self.in_queue():\n            self.parliament.speaking_queue.remove(self.name)\n\n    def reset_pressure(self):\n        self.speaking_pressure = 0\n\nclass SpeakingQueue:\n    def __init__(self):\n        self.queue = deque()\n\n    def add(self, agent_name):\n        self.queue.append(agent_name)\n\n    def pop(self):\n        if len(self.queue) > 0:\n            return self.queue.pop()\n        else:\n            return None\n        \n    def enqueue(self, name):\n        self.queue.append(name)\n\n    def dequeue(self):\n        return self.queue.popleft() if self.queue else None\n\n    def front(self):\n        return self.queue[0] if self.queue else None\n\n    def remove(self, name):\n        self.queue.remove(name)\n\n    def contains(self, name):\n        return name in self.queue\n\n    def to_json(self):\n        return list(self.queue)\n    \nclass SpeakerManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    def should_speak(self, agent):\n        return self.parliament.speaking_queue.front() == agent.name and agent.speaking_pressure >= SPEAKING_PRESSURE_LIMIT\n\n\nclass Parliament:\n    def __init__(self, name: str):\n        self.name = name\n        self.agents = {}\n        self.chat_history = ChatHistory()\n        self.speaking_queue = SpeakingQueue()\n        self.speaker_manager = SpeakerManager(self)\n        self.agent_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n        self.typing_status = {} \n\n    def set_typing_status(self, agent_name: str, status: bool):\n        self.typing_status[agent_name] = status\n\n    def get_typing_status(self, agent_name: str):\n        return self.typing_status.get(agent_name, False)\n\n    async def broadcast_message(self, message, sender, timestamp):\n        self.chat_history.add(message, sender, timestamp)\n        mentioned_agents = self.identify_and_tag_mentioned_agents(message)\n        self.increment_speaking_pressure(mentioned_agents)\n        self.update_speaking_queue()\n\n        # Check if any agent should speak after updating the speaking pressures and the queue\n        for agent in self.agents.values():\n            if not self.get_typing_status(agent.name):  # Don't let agent speak if user is typing\n                await agent.try_to_speak()\n\n        await asyncio.sleep(BROADCAST_DELAY)\n\n        # If no user input after the delay, let the first agent in queue speak\n        first_agent_in_queue = self.speaking_queue.dequeue()\n        if first_agent_in_queue and not self.get_typing_status(first_agent_in_queue):\n            await self.agents[first_agent_in_queue].speak()\n\n    def add_to_speaking_queue(self, agent):\n        if not self.speaking_queue.contains(agent.name):\n            self.speaking_queue.enqueue(agent.name)\n\n    def update_speaking_queue(self):\n        # First, add all agents with high speaking pressure to the queue\n        for agent in self.agents.values():\n            if agent.speaking_pressure >= RELEVANCY_THRESHOLD:\n                self.add_to_speaking_queue(agent)\n\n        # Then, add all tagged agents to the queue\n        for agent in self.agents.values():\n            if agent.tagged:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n        # Finally, add the most relevant agent to the queue\n        most_relevant_agent = max(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history.last_message()), default=None)\n        if most_relevant_agent:\n            self.add_to_speaking_queue(most_relevant_agent)\n            most_relevant_agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = SPEAKING_PRESSURE_LIMIT\n                self.agents[agent_name].tagged = True\n        return mentioned_agents\n    \n    def get_speaking_queue(self):\n        return self.speaking_queue\n            \n    def add_agent(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, agent_instance=None, websocket=None):\n        agent = Agent(name, speaking_pressure_increment, context, agent_type, self, agent_instance, websocket)\n        self.agents[name] = agent\n        self.typing_status[name] = False  # Initialize typing status when adding an agent\n        asyncio.create_task(agent.increment_pressure())\n\n    def remove_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        del self.agents[agent_name]\n\n    def get_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        return self.agents[agent_name]\n\n\n\n    def add_to_chat_history(self, message, sender, timestamp):\n        self.chat_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = 100\n                self.agents[agent_name].tagged = True\n                print(f\"Tagged agent: {agent_name}\")  # Debug print\n        return mentioned_agents\n\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def add_tagged_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.tagged and agent.name not in self.speaking_queue.queue:    \n                self.speaking_queue.add(agent.name)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def add_high_pressure_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.speaking_pressure > 100 and agent.name not in self.speaking_queue.queue:\n                self.speaking_queue.add(agent.name)\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def trigger_next_speaker(self):\n        if self.speaking_queue:\n            next_speaker = self.get_agent(self.speaking_queue.pop())  # Remove the agent from the queue\n\n    def update_speaking_queue(self):\n        sorted_agents = self.get_sorted_agents_based_on_relevancy()\n        most_relevant_agent = sorted_agents[0]\n        most_relevant_agent.speaking_pressure = 100\n        self.speaking_queue.add(most_relevant_agent.name)\n        self.add_tagged_agents_to_queue()\n        self.add_high_pressure_agents_to_queue()\n\n        self.trigger_next_speaker()\n\n    def get_sorted_agents_based_on_relevancy(self):\n        return sorted(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history), reverse=True)\n\n\n    def get_agents_info(self) -> List[dict]:\n        agents_info = []\n        for agent_name, agent in self.agents.items():\n            agents_info.append({\n                \"name\": agent_name,\n                \"speaking_pressure\": agent.speaking_pressure,\n                \"speaking_pressure_increment\": agent.speaking_pressure_increment,\n                \"context\": agent.context,\n                \"agent_type\": agent.agent_type\n                # Add more fields as needed\n            })\n        return agents_info\n\nAnd let me know why the queue isn't being added to and why when I tag someone sometimes someone else will respond. When you found issues, fix them in a single block of code I can copy/paste",
      "created_at": "2023-05-11T20:52:36.147277",
      "sequence_order": 2,
      "parent_id": "aaa147c5-0033-4f95-937f-f3aa716a4f86",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "bb5157ed-7c23-4710-8300-d081bd4f9097",
      "role": "assistant",
      "content": "Firstly, in `ParliamentServer` class, in the method `handle_send_message`, you are creating a task to broadcast the message but not waiting for it to complete. This could potentially cause issues as broadcasting involves manipulating the speaking queue and other agent states. You should probably wait for the task to complete.\n\nSecondly, you are not properly initialising the agent's `speaking_pressure` in the `Agent` class. It's always being initialised to zero. Instead, it should be initialised to `speaking_pressure_increment` value which is passed during its creation.\n\nLastly, in your `Parliament` class, you are not updating the speaking queue in the `add_agent` method. This could be the reason why the queue isn't being updated.\n\nHere's a code snippet with the suggested changes:\n\n```python\nclass ParliamentServer:\n    # ...\n    async def handle_send_message(self, websocket, data):\n        # ...\n        await self.parliament.broadcast_message(user_message, sender, timestamp)\n\nclass Agent:\n    def __init__(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, parliament, agent_instance=None, websocket=None):\n        # ...\n        self.speaking_pressure = speaking_pressure_increment\n        # ...\n\nclass Parliament:\n    # ...\n    def add_agent(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, agent_instance=None, websocket=None):\n        # ...\n        self.update_speaking_queue()\n        # ...\n```\n\nAs for the issue where sometimes when you tag an agent, another agent responds instead, this could be due to the fact that you're not checking if the tagged agent is already speaking or not before adding them to the speaking queue. You should add a check in `update_speaking_queue` method to ensure that the tagged agent is not already speaking.\n\nHere's how you can do it:\n\n```python\nclass Parliament:\n    # ...\n    def update_speaking_queue(self):\n        # ...\n        for agent in self.agents.values():\n            if agent.tagged and not agent.is_speaking:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n        # ...\n```\n\nPlease review these changes and see if they resolve your issues.",
      "created_at": "2023-05-11T20:54:11.477736",
      "sequence_order": 3,
      "parent_id": "aaa2f06a-4d60-4be2-8440-f91e1f1d07c8",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa25744-7cff-4d67-b694-24357ce6e18b",
      "role": "user",
      "content": "Like this? import asyncio\nimport random\nimport json\nimport openai\nfrom openai.error import RateLimitError\nimport time\nfrom typing import List\nfrom collections import deque\n\nPRESSURE_INCREMENT_INTERVAL = 15\nSPEAKING_PRESSURE_LIMIT = 100\nBROADCAST_DELAY = 10\nRELEVANCY_THRESHOLD = 100\n\nclass Agent:\n    def __init__(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, parliament, agent_instance=None, websocket=None):\n        self.name = name\n        self.speaking_pressure_increment = speaking_pressure_increment\n        self.context = context\n        self.speaking_pressure = speaking_pressure_increment\n        self.tagged = False\n        self.agent_type = agent_type\n        self.agent_instance = agent_instance\n        self.websocket = websocket\n        self.parliament = parliament\n        self.is_speaking = False\n\n    def should_speak(self):\n        return self.parliament.speaker_manager.should_speak(self)\n\n    async def try_to_speak(self):\n        if self.should_speak() and not self.is_speaking:\n            await self.speak()\n\n    async def increment_pressure(self):\n        while True:\n            await asyncio.sleep(PRESSURE_INCREMENT_INTERVAL)\n            self.speaking_pressure += self.speaking_pressure_increment\n            await self.try_to_speak()\n\n    def get_agent_message(self, chat_history):\n        \"\"\"\n        Generate a message from this agent based on the current chat history.\n        \"\"\"\n        message = \"\"\n        if isinstance(self.agent_instance, self.parliament.agent_types[self.agent_type]):\n            response = self.agent_instance.get_response(chat_history)\n            message = f\"{response}\"\n        return message\n    \n    def in_queue(self):\n        return self.name in self.parliament.speaking_queue.queue\n    \n    def calculate_relevancy(self, chat_context: str) -> int:\n        # Replace this with your actual relevancy calculation logic\n        return random.randint(0, 100)\n\n    async def speak(self):\n        self.is_speaking = True  # Agent starts speaking\n        print(f\"{self.name} is speaking...\")  # Add log\n        await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n        agent_message = self.get_agent_message(self.parliament.chat_history)\n        await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n        self.speaking_pressure = 0  # Reset the speaking pressure\n        print(f\"{self.name}'s speaking pressure reset to {self.speaking_pressure}.\")  # Add log\n        self.is_speaking = False  # Agent finishes speaking\n        print(f\"{self.name} has finished speaking.\")  # Add log\n        if self.in_queue():\n            self.parliament.speaking_queue.remove(self.name)\n\n    def reset_pressure(self):\n        self.speaking_pressure = 0\n\nclass ChatHistory:\n    def __init__(self):\n        self.chat_history = []\n\n    def add(self, message, sender, timestamp):\n        self.chat_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\n    def last_message(self):\n        return self.chat_history[-1] if self.chat_history else None\n\nclass SpeakingQueue:\n    def __init__(self):\n        self.queue = deque()\n\n    def add(self, agent_name):\n        self.queue.append(agent_name)\n\n    def pop(self):\n        if len(self.queue) > 0:\n            return self.queue.pop()\n        else:\n            return None\n        \n    def enqueue(self, name):\n        self.queue.append(name)\n\n    def dequeue(self):\n        return self.queue.popleft() if self.queue else None\n\n    def front(self):\n        return self.queue[0] if self.queue else None\n\n    def remove(self, name):\n        self.queue.remove(name)\n\n    def contains(self, name):\n        return name in self.queue\n\n    def to_json(self):\n        return list(self.queue)\n    \nclass SpeakerManager:\n    def __init__(self, parliament):\n        self.parliament = parliament\n\n    def should_speak(self, agent):\n        return self.parliament.speaking_queue.front() == agent.name and agent.speaking_pressure >= SPEAKING_PRESSURE_LIMIT\n\nclass OpenAIAgent:\n    def __init__(self, initial_context: str):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n        self.model = \"gpt-3.5-turbo\"\n        self.initial_context = initial_context\n\n    def get_response(self, chat_history):\n        system_msg = self.initial_context\n\n        messages = [{\"role\": \"system\", \"content\": system_msg}]\n        for message in chat_history.chat_history:\n            role = message[\"sender\"]\n            msg = message[\"message\"]\n            messages.append({\"role\": \"assistant\" if role != \"assistant\" else role, \"content\": msg})\n\n        max_retries = 3\n        retry_delay = 5\n\n        for i in range(max_retries):\n            try:\n                # Call the OpenAI API with the messages array\n                response = openai.ChatCompletion.create(\n                    model=self.model,\n                    messages=messages,\n                    max_tokens=150,\n                    temperature=0.5,\n                    top_p=1,\n                    frequency_penalty=0,\n                    presence_penalty=0,\n                )\n                # Extract and return the assistant's response from the API response\n                return response.choices[0].message[\"content\"].strip()\n\n            except RateLimitError as e:\n                print(f\"Rate limit error: {e}. Retrying in {retry_delay} seconds...\")\n                if i < max_retries - 1:  # Don't sleep on the last iteration\n                    time.sleep(retry_delay)\n                else:\n                    raise\n        return \"Sorry, I am unable to respond at the moment.\"\n\n\nclass GPT4AllAgent:\n    def __init__(self):\n        # Download and set up the GPT4All model\n        self._initialize_gpt4all_model()\n        self._initialize_llm_chain()\n\n    def _initialize_gpt4all_model(self):\n        local_path = \"/Users/bilalghalib/Projects/scripts/models/ggml-gpt4all-j.bin\"\n        Path(local_path).parent.mkdir(parents=True, exist_ok=True)\n\n        url = 'http://gpt4all.io/models/ggml-gpt4all-l13b-snoozy.bin'\n        response = requests.get(url, stream=True)\n\n        with open(local_path, 'wb') as f:\n            for chunk in tqdm(response.iter_content(chunk_size=8192)):\n                if chunk:\n                    f.write(chunk)\n\n        self.model_path = local_path\n\n    def _initialize_llm_chain(self):\n        template = \"\"\"{chat_history}\n\n        Question: {question}\n\n        Answer: Let's think step by step.\"\"\"\n        prompt = PromptTemplate(template=template, input_variables=[\"chat_history\", \"question\"])\n\n        callbacks = [StreamingStdOutCallbackHandler()]\n        llm = GPT4All(model=self.model_path, callbacks=callbacks, verbose=True)\n        self.llm_chain = LLMChain(prompt=prompt, llm=llm)\n\n    def get_response(self, chat_history, question):\n        return self.llm_chain.run(chat_history=chat_history, question=question)\n\n\n\nclass Parliament:\n    def __init__(self, name: str):\n        self.name = name\n        self.agents = {}\n        self.chat_history = ChatHistory()\n        self.speaking_queue = SpeakingQueue()\n        self.speaker_manager = SpeakerManager(self)\n        self.agent_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n        self.typing_status = {} \n\n    def set_typing_status(self, agent_name: str, status: bool):\n        self.typing_status[agent_name] = status\n\n    def get_typing_status(self, agent_name: str):\n        return self.typing_status.get(agent_name, False)\n\n    async def broadcast_message(self, message, sender, timestamp):\n        self.chat_history.add(message, sender, timestamp)\n        mentioned_agents = self.identify_and_tag_mentioned_agents(message)\n        self.increment_speaking_pressure(mentioned_agents)\n        self.update_speaking_queue()\n\n        # Check if any agent should speak after updating the speaking pressures and the queue\n        for agent in self.agents.values():\n            if not self.get_typing_status(agent.name):  # Don't let agent speak if user is typing\n                await agent.try_to_speak()\n\n        await asyncio.sleep(BROADCAST_DELAY)\n\n        # If no user input after the delay, let the first agent in queue speak\n        first_agent_in_queue = self.speaking_queue.dequeue()\n        if first_agent_in_queue and not self.get_typing_status(first_agent_in_queue):\n            await self.agents[first_agent_in_queue].speak()\n\n    def add_to_speaking_queue(self, agent):\n        if not self.speaking_queue.contains(agent.name):\n            self.speaking_queue.enqueue(agent.name)\n\n    def update_speaking_queue(self):\n        # First, add all agents with high speaking pressure to the queue\n        for agent in self.agents.values():\n            if agent.speaking_pressure >= RELEVANCY_THRESHOLD:\n                self.add_to_speaking_queue(agent)\n\n        # Then, add all tagged agents to the queue\n        for agent in self.agents.values():\n            if agent.tagged:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n\n        # Finally, add the most relevant agent to the queue\n        most_relevant_agent = max(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history.last_message()), default=None)\n        if most_relevant_agent:\n            self.add_to_speaking_queue(most_relevant_agent)\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = SPEAKING_PRESSURE_LIMIT\n                self.agents[agent_name].tagged = True\n        return mentioned_agents\n    \n    def get_speaking_queue(self):\n        return self.speaking_queue\n            \n    def add_agent(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, agent_instance=None, websocket=None):\n        agent = Agent(name, speaking_pressure_increment, context, agent_type, self, agent_instance, websocket)\n        self.agents[name] = agent\n        self.typing_status[name] = False  # Initialize typing status when adding an agent\n        asyncio.create_task(agent.increment_pressure())\n        self.update_speaking_queue()\n\n    def remove_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        del self.agents[agent_name]\n\n    def get_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        return self.agents[agent_name]\n\n\n\n    def add_to_chat_history(self, message, sender, timestamp):\n        self.chat_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = 100\n                self.agents[agent_name].tagged = True\n                print(f\"Tagged agent: {agent_name}\")  # Debug print\n        return mentioned_agents\n\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def add_tagged_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.tagged and agent.name not in self.speaking_queue.queue:    \n                self.speaking_queue.add(agent.name)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def add_high_pressure_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.speaking_pressure > 100 and agent.name not in self.speaking_queue.queue:\n                self.speaking_queue.add(agent.name)\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def trigger_next_speaker(self):\n        if self.speaking_queue:\n            next_speaker = self.get_agent(self.speaking_queue.pop())  # Remove the agent from the queue\n\n    def update_speaking_queue(self):\n        sorted_agents = self.get_sorted_agents_based_on_relevancy()\n        most_relevant_agent = sorted_agents[0]\n        most_relevant_agent.speaking_pressure = 100\n        self.speaking_queue.add(most_relevant_agent.name)\n        self.add_tagged_agents_to_queue()\n        self.add_high_pressure_agents_to_queue()\n        for agent in self.agents.values():\n            if agent.tagged and not agent.is_speaking:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n        self.trigger_next_speaker()\n\n    def get_sorted_agents_based_on_relevancy(self):\n        return sorted(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history), reverse=True)\n\n\n    def get_agents_info(self) -> List[dict]:\n        agents_info = []\n        for agent_name, agent in self.agents.items():\n            agents_info.append({\n                \"name\": agent_name,\n                \"speaking_pressure\": agent.speaking_pressure,\n                \"speaking_pressure_increment\": agent.speaking_pressure_increment,\n                \"context\": agent.context,\n                \"agent_type\": agent.agent_type\n                # Add more fields as needed\n            })\n        return agents_info",
      "created_at": "2023-05-11T21:00:02.766264",
      "sequence_order": 4,
      "parent_id": "bb5157ed-7c23-4710-8300-d081bd4f9097",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "38471b7d-55ea-49d7-8f1f-3ff26bf7be2b",
      "role": "assistant",
      "content": "Based on the provided information, it seems like the following issues might be causing the problem:\n\n1. The `update_speaking_queue` method in the `Parliament` class is not handling the speaking queue correctly. The method should add all agents with speaking pressure above the relevancy threshold and all tagged agents to the queue. Then, it should also add the most relevant agent to the queue.\n\n2. The `broadcast_message` method in the `Parliament` class should check if any agent should speak after updating the speaking pressures and the queue. If no user is typing, it should allow the first agent in the queue to speak.\n\n3. The `should_speak` method in the `SpeakerManager` class should check if the agent is the first in the queue and if its speaking pressure is above the limit.\n\n4. The `speak` method in the `Agent` class should reset the agent's speaking pressure and remove it from the queue after it finishes speaking.\n\n5. The `try_to_speak` method in the `Agent` class should check if the agent should speak and if it is not currently speaking before allowing it to speak.\n\nHere's the revised code:\n\n```python\nclass Agent:\n    #...\n\n    async def try_to_speak(self):\n        if self.should_speak() and not self.is_speaking:\n            await self.speak()\n\n    #...\n\n    async def speak(self):\n        self.is_speaking = True\n        await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n        agent_message = self.get_agent_message(self.parliament.chat_history)\n        await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n        self.speaking_pressure = 0\n        self.is_speaking = False\n        if self.in_queue():\n            self.parliament.speaking_queue.remove(self.name)\n\nclass SpeakerManager:\n    #...\n\n    def should_speak(self, agent):\n        return self.parliament.speaking_queue.front() == agent.name and agent.speaking_pressure >= SPEAKING_PRESSURE_LIMIT\n\nclass Parliament:\n    #...\n\n    async def broadcast_message(self, message, sender, timestamp):\n        self.chat_history.add(message, sender, timestamp)\n        mentioned_agents = self.identify_and_tag_mentioned_agents(message)\n        self.increment_speaking_pressure(mentioned_agents)\n        self.update_speaking_queue()\n\n        for agent in self.agents.values():\n            if not self.get_typing_status(agent.name):\n                await agent.try_to_speak()\n\n        await asyncio.sleep(BROADCAST_DELAY)\n\n        first_agent_in_queue = self.speaking_queue.dequeue()\n        if first_agent_in_queue and not self.get_typing_status(first_agent_in_queue):\n            await self.agents[first_agent_in_queue].speak()\n\n    #...\n\n    def update_speaking_queue(self):\n        for agent in self.agents.values():\n            if agent.speaking_pressure >= RELEVANCY_THRESHOLD:\n                self.add_to_speaking_queue(agent)\n\n        for agent in self.agents.values():\n            if agent.tagged:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0\n\n        most_relevant_agent = max(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history.last_message()), default=None)\n        if most_relevant_agent:\n            self.add_to_speaking_queue(most_relevant_agent)\n            most_relevant_agent.speaking_pressure = 0\n```\n\nPlease replace the corresponding methods in your classes with these revised methods and try again. I hope this helps! If you have any questions or face any issues, feel free to",
      "created_at": "2023-05-11T21:01:59.033609",
      "sequence_order": 5,
      "parent_id": "aaa25744-7cff-4d67-b694-24357ce6e18b",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "aaa23a52-56b4-4776-91cb-d2b606f580ed",
      "role": "user",
      "content": "get this error: ^CTraceback (most recent call last):\n  File \"/Users/bilalghalib/Projects/scripts/Parliment/parliament-chat-nextjs/pages/parliament_backend/server.py\", line 132, in <module>\n    server.run()\n  File \"/Users/bilalghalib/Projects/scripts/Parliment/parliament-chat-nextjs/pages/parliament_backend/server.py\", line 127, in run\n    asyncio.get_event_loop().run_forever()\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/asyncio/base_events.py\", line 603, in run_forever\n    self._run_once()\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/asyncio/base_events.py\", line 1871, in _run_once\n    event_list = self._selector.select(timeout)\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/selectors.py\", line 562, in select\n    kev_list = self._selector.control(None, max_ev, timeout)\nKeyboardInterrupt\n",
      "created_at": "2023-05-11T22:01:15.633165",
      "sequence_order": 6,
      "parent_id": "38471b7d-55ea-49d7-8f1f-3ff26bf7be2b",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "aaa238e9-c3bd-4920-a6ed-0c72b83990f7",
      "role": "user",
      "content": "get this error: ^CTraceback (most recent call last):\n  File \"/Users/bilalghalib/Projects/scripts/Parliment/parliament-chat-nextjs/pages/parliament_backend/server.py\", line 132, in <module>\n    server.run()\n  File \"/Users/bilalghalib/Projects/scripts/Parliment/parliament-chat-nextjs/pages/parliament_backend/server.py\", line 127, in run\n    asyncio.get_event_loop().run_forever()\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/asyncio/base_events.py\", line 603, in run_forever\n    self._run_once()\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/asyncio/base_events.py\", line 1871, in _run_once\n    event_list = self._selector.select(timeout)\n  File \"/Users/bilalghalib/mambaforge/lib/python3.10/selectors.py\", line 562, in select\n    kev_list = self._selector.control(None, max_ev, timeout)\nKeyboardInterrupt\nAgent class:\n\nclass Agent:\n    def __init__(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, parliament, agent_instance=None, websocket=None):\n        self.name = name\n        self.speaking_pressure_increment = speaking_pressure_increment\n        self.context = context\n        self.speaking_pressure = speaking_pressure_increment\n        self.tagged = False\n        self.agent_type = agent_type\n        self.agent_instance = agent_instance\n        self.websocket = websocket\n        self.parliament = parliament\n        self.is_speaking = False\n\n    def should_speak(self):\n        return self.parliament.speaker_manager.should_speak(self)\n\n    async def try_to_speak(self):\n        if self.should_speak() and not self.is_speaking:\n            await self.speak()\n\n    async def increment_pressure(self):\n        while True:\n            await asyncio.sleep(PRESSURE_INCREMENT_INTERVAL)\n            self.speaking_pressure += self.speaking_pressure_increment\n            await self.try_to_speak()\n\n    def get_agent_message(self, chat_history):\n        \"\"\"\n        Generate a message from this agent based on the current chat history.\n        \"\"\"\n        message = \"\"\n        if isinstance(self.agent_instance, self.parliament.agent_types[self.agent_type]):\n            response = self.agent_instance.get_response(chat_history)\n            message = f\"{response}\"\n        return message\n    \n    def in_queue(self):\n        return self.name in self.parliament.speaking_queue.queue\n    \n    def calculate_relevancy(self, chat_context: str) -> int:\n        # Replace this with your actual relevancy calculation logic\n        return random.randint(0, 100)\n\n    async def speak(self):\n        self.is_speaking = True\n        await self.websocket.send(json.dumps({\"action\": \"typing\", \"sender\": self.name}))\n        agent_message = self.get_agent_message(self.parliament.chat_history)\n        await self.websocket.send(json.dumps({\"action\": \"receive_message\", \"message\": agent_message, \"sender\": self.name}))\n        self.speaking_pressure = 0\n        self.is_speaking = False\n        if self.in_queue():\n            self.parliament.speaking_queue.remove(self.name)\n\n    def reset_pressure(self):\n        self.speaking_pressure = 0\nParliament class:\n\nclass Parliament:\n    def __init__(self, name: str):\n        self.name = name\n        self.agents = {}\n        self.chat_history = ChatHistory()\n        self.speaking_queue = SpeakingQueue()\n        self.speaker_manager = SpeakerManager(self)\n        self.agent_types = {\"openai\": OpenAIAgent, \"gpt4all\": GPT4AllAgent}\n        self.typing_status = {} \n\n    def set_typing_status(self, agent_name: str, status: bool):\n        self.typing_status[agent_name] = status\n\n    def get_typing_status(self, agent_name: str):\n        return self.typing_status.get(agent_name, False)\n\n    async def broadcast_message(self, message, sender, timestamp):\n        self.chat_history.add(message, sender, timestamp)\n        mentioned_agents = self.identify_and_tag_mentioned_agents(message)\n        self.increment_speaking_pressure(mentioned_agents)\n        self.update_speaking_queue()\n\n        for agent in self.agents.values():\n            if not self.get_typing_status(agent.name):\n                await agent.try_to_speak()\n\n        await asyncio.sleep(BROADCAST_DELAY)\n\n        first_agent_in_queue = self.speaking_queue.dequeue()\n        if first_agent_in_queue and not self.get_typing_status(first_agent_in_queue):\n            await self.agents[first_agent_in_queue].speak()\n\n    def add_to_speaking_queue(self, agent):\n        if not self.speaking_queue.contains(agent.name):\n            self.speaking_queue.enqueue(agent.name)\n\n    def update_speaking_queue(self):\n        for agent in self.agents.values():\n            if agent.speaking_pressure >= RELEVANCY_THRESHOLD:\n                self.add_to_speaking_queue(agent)\n\n        for agent in self.agents.values():\n            if agent.tagged:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0\n\n        most_relevant_agent = max(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history.last_message()), default=None)\n        if most_relevant_agent:\n            self.add_to_speaking_queue(most_relevant_agent)\n            most_relevant_agent.speaking_pressure = 0\n\n        # Finally, add the most relevant agent to the queue\n        most_relevant_agent = max(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history.last_message()), default=None)\n        if most_relevant_agent:\n            self.add_to_speaking_queue(most_relevant_agent)\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = SPEAKING_PRESSURE_LIMIT\n                self.agents[agent_name].tagged = True\n        return mentioned_agents\n    \n    def get_speaking_queue(self):\n        return self.speaking_queue\n            \n    def add_agent(self, name: str, speaking_pressure_increment: int, context: str, agent_type: str, agent_instance=None, websocket=None):\n        agent = Agent(name, speaking_pressure_increment, context, agent_type, self, agent_instance, websocket)\n        self.agents[name] = agent\n        self.typing_status[name] = False  # Initialize typing status when adding an agent\n        asyncio.create_task(agent.increment_pressure())\n        self.update_speaking_queue()\n\n    def remove_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        del self.agents[agent_name]\n\n    def get_agent(self, agent_name: str):\n        if agent_name not in self.agents:\n            raise ValueError(f\"Agent '{agent_name}' not found.\")\n        return self.agents[agent_name]\n\n\n\n    def add_to_chat_history(self, message, sender, timestamp):\n        self.chat_history.append({\"sender\": sender, \"message\": message, \"timestamp\": timestamp})\n\n    def identify_and_tag_mentioned_agents(self, message):\n        mentioned_agents = []\n        for agent_name in self.agents:\n            if '@'+agent_name in message:\n                mentioned_agents.append(agent_name)\n                self.agents[agent_name].speaking_pressure = 100\n                self.agents[agent_name].tagged = True\n                print(f\"Tagged agent: {agent_name}\")  # Debug print\n        return mentioned_agents\n\n\n    def increment_speaking_pressure(self, mentioned_agents):\n        for agent in self.agents.values():\n            if agent.name not in mentioned_agents:\n                agent.speaking_pressure += agent.speaking_pressure_increment\n\n    def add_tagged_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.tagged and agent.name not in self.speaking_queue.queue:    \n                self.speaking_queue.add(agent.name)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def add_high_pressure_agents_to_queue(self):\n        for agent in self.agents.values():\n            if agent.speaking_pressure > 100 and agent.name not in self.speaking_queue.queue:\n                self.speaking_queue.add(agent.name)\n                agent.speaking_pressure = 0  # Reset speaking pressure\n\n    def trigger_next_speaker(self):\n        if self.speaking_queue:\n            next_speaker = self.get_agent(self.speaking_queue.pop())  # Remove the agent from the queue\n\n    def update_speaking_queue(self):\n        sorted_agents = self.get_sorted_agents_based_on_relevancy()\n        most_relevant_agent = sorted_agents[0]\n        most_relevant_agent.speaking_pressure = 100\n        self.speaking_queue.add(most_relevant_agent.name)\n        self.add_tagged_agents_to_queue()\n        self.add_high_pressure_agents_to_queue()\n        for agent in self.agents.values():\n            if agent.tagged and not agent.is_speaking:\n                self.add_to_speaking_queue(agent)\n                agent.tagged = False\n                agent.speaking_pressure = 0  # Reset speaking pressure\n        self.trigger_next_speaker()\n\n    def get_sorted_agents_based_on_relevancy(self):\n        return sorted(self.agents.values(), key=lambda agent: agent.calculate_relevancy(self.chat_history), reverse=True)\n\n\n    def get_agents_info(self) -> List[dict]:\n        agents_info = []\n        for agent_name, agent in self.agents.items():\n            agents_info.append({\n                \"name\": agent_name,\n                \"speaking_pressure\": agent.speaking_pressure,\n                \"speaking_pressure_increment\": agent.speaking_pressure_increment,\n                \"context\": agent.context,\n                \"agent_type\": agent.agent_type\n                # Add more fields as needed\n            })\n        return agents_info\nServer:\nfrom datetime import datetime\nimport asyncio\nimport json\nfrom websockets import serve\nfrom parliament import Parliament, GPT4AllAgent, OpenAIAgent, Agent\nimport openai\n\n# Constants\nSET_PARLIAMENT = \"set_parliament\"\nSEND_MESSAGE = \"send_message\"\nADD_AGENTS = \"add_agents\"\nUPDATE_QUEUE = \"update_queue\"\nUPDATE_AGENTS = \"update_agents\"\nRECEIVE_MESSAGE = \"receive_message\"\nERROR = \"error\"\nTYPING = \"typing\"\nSTOPPED_TYPING = \"stopped_typing\"\n\nclass ParliamentServer:\n    def __init__(self, host=\"localhost\", port=8080):\n        self.host = host\n        self.port = port\n        self.parliament = None\n        self.start_server = serve(self.chat, self.host, self.port)\n\n    def configure_openai(self):\n        openai.organization = \"org-ADENd47ZFNjAt0kqYo7foBYK\"\n        openai.api_key = \"REDACTED_API_KEY\"\n\n    async def chat(self, websocket, path):\n        async for message in websocket:\n            data = json.loads(message)\n            action = data.get(\"action\")\n            if action == SET_PARLIAMENT:\n                await self.handle_set_parliament(websocket, data)\n            elif action == SEND_MESSAGE:\n                await self.handle_send_message(websocket, data)\n            elif action == ADD_AGENTS:\n                await self.handle_add_agents(websocket, data)\n            elif action in [TYPING, STOPPED_TYPING]:  \n                await self.handle_typing(websocket, data)\n\n    async def handle_typing(self, websocket, data):\n        sender = data.get('sender')\n        action = data.get('action')\n        is_typing = action == TYPING\n\n        self.parliament.set_typing_status(sender, is_typing)\n\n        # Send the typing status update to other clients:\n        await websocket.send(json.dumps({\n            \"action\": action,\n            \"sender\": sender,\n            \"is_typing\": is_typing\n        }))\n\n    async def handle_set_parliament(self, websocket, data):\n        parliament_name = data.get(\"name\")\n        if parliament_name:\n            self.parliament = Parliament(parliament_name)\n            await self.update_queue(websocket)\n\n    async def handle_send_message(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        sender = data.get(\"sender\")\n        user_message = data.get(\"message\")\n        timestamp = datetime.now()\n        await websocket.send(json.dumps({\n            \"action\": RECEIVE_MESSAGE,\n            \"message\": user_message,\n            \"sender\": sender,\n            \"timestamp\": timestamp.isoformat()}))\n        await self.parliament.broadcast_message(user_message, sender, timestamp)\n        #asyncio.create_task(self.parliament.broadcast_message(user_message, sender, timestamp))\n\n        # Sending agent info after broadcasting message\n        agent_info = self.parliament.get_agents_info()  # Assuming that this method returns agents' information\n        await websocket.send(json.dumps({\"action\": UPDATE_AGENTS, \"agents\": agent_info}))\n        await self.update_queue(websocket)\n\n    async def handle_add_agents(self, websocket, data):\n        if not self.parliament:\n            await self.send_error(websocket, \"Parliament not set.\")\n            return\n        agents_data = data.get(\"agents\")\n        if not agents_data:\n            await self.send_error(websocket, \"No agent data provided.\")\n            return\n        for agent_data in agents_data:\n            agent_name = agent_data.get(\"name\")\n            speaking_pressure_increment = int(agent_data.get(\"speaking_pressure_increment\"))\n            other_agents = \", \".join([agent['name'] for agent in agents_data if agent['name'] != agent_name])\n            context = (\n                f\"Hello 100\"\n            )\n            agent_type = agent_data.get(\"type\")\n            agent_class = self.parliament.agent_types.get(agent_type)\n            if not agent_class:\n                await self.send_error(websocket, f\"Unknown agent type: {agent_type}\")\n                # Here, 'continue' is used within a loop, so it's okay\n                continue\n            agent_instance = agent_class(context)  # Create a new instance of the agent class\n            self.parliament.add_agent(agent_name, speaking_pressure_increment, context, agent_type, agent_instance, websocket)\n        await self.update_queue(websocket)\n\n\n    async def update_queue(self, websocket):\n        if self.parliament:\n            speaking_queue = self.parliament.get_speaking_queue()\n            print(f\"Queue updated: {speaking_queue.to_json()}\")\n            await websocket.send(json.dumps({\"action\": UPDATE_QUEUE, \"queue\": speaking_queue.to_json()}))\n\n    async def send_error(self, websocket, message):\n        await websocket.send(json.dumps({\"action\": ERROR, \"message\": message}))\n\n    def run(self):\n        self.configure_openai()\n        asyncio.get_event_loop().run_until_complete(self.start_server)\n        print(\"Starting WebSocket server...\")\n        print(f\"WebSocket server is running on ws://{self.host}:{self.port}\")\n        asyncio.get_event_loop().run_forever()\n\n\nif __name__ == \"__main__\":\n    server = ParliamentServer()\n    server.run()\n",
      "created_at": "2023-05-11T22:02:43.674292",
      "sequence_order": 7,
      "parent_id": "38471b7d-55ea-49d7-8f1f-3ff26bf7be2b",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    }
  ]
}