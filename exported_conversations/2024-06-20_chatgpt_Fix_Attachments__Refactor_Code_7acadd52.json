{
  "id": "7acadd52-a77e-4b73-8381-fd379d837372",
  "source": "chatgpt",
  "title": "Fix Attachments, Refactor Code",
  "created_at": "2024-06-20T06:19:45.549756",
  "updated_at": "2024-06-20T07:04:36.274020",
  "summary": null,
  "message_count": 8,
  "messages": [
    {
      "id": "aaa2d39e-29e7-4e4f-a54b-688eeb6b11e1",
      "role": "user",
      "content": "I'm working on an application that will take an email webhook and process it, the incoming json looks like this:\nINFO:app:Webhook received: {'items': [{'Uuid': ['6a65bfc8-ea97-439c-9d60-a479d0a503d8'], 'Recipients': ['graph@txtray.com'], 'MessageId': '<CACPpfXLOjKnYW1xP4ZuUxeKXKS_jvMOBPPy8Yn=ZYj7eeJESiA@mail.gmail.com>', 'InReplyTo': None, 'From': {'Name': 'Bilal Ghalib', 'Address': 'bg@bilalghalib.com'}, 'To': [{'Name': None, 'Address': 'graph@txtray.com'}], 'Cc': [], 'Bcc': [], 'ReplyTo': None, 'SentAtDate': 'Thu, 20 Jun 2024 06:10:12 +0200', 'Subject': 'make me a kake', 'Attachments': [], 'Headers': {'Received': 'by mail-lj1-f173.google.com with SMTP id 38308e7fff4ca-2ec0f3b9cdbso3449051fa.0 for <graph@txtray.com>; Wed, 19 Jun 2024 21:10:30 -0700 (PDT)', 'DKIM-Signature': 'v=1; a=rsa-sha256; c=relaxed/relaxed; d=bilalghalib-com.20230601.gappssmtp.com; s=20230601; t=1718856629; x=1719461429; darn=txtray.com; h=to:subject:message-id:date:from:mime-version:from:to:cc:subject :date:message-id:reply-to; bh=K1LyVoP0PrXdclQvVpjs6Sw3cHZTUO0D0fs+4hd+7YE=; b=Ks2ps9dcqn3DtZPGg1tVBtPIK25W7AOQX+bLqYIAG64hqHxjtajpm7YOppIMOJkeCy p0L+HZC5Yrhh6nm/cpKZej4b9QTcNzFlGmyf4zKYNFljGMXeljSyssRx5qIf6IdzaTPB oOpOF6NkySsvHqUZG59MxEeO9QteY9pJ4OyCxqVSIjHTDQKwEQ1ZvAWxBUgu0Jfo7Pdk xfLVxyfbgwGJnG2VgSZms4ZVg9wmynBsuYlvhS40uyC9KDCAoG8dHSM4i8eg3wql+66/ O293S9rDE3NTUcyNE4zMFgdNWAgnaJNaMXCzwa0puUBAUGNNmRQivFYWvBxW2H39Un4D Cvow==', 'X-Google-DKIM-Signature': 'v=1; a=rsa-sha256; c=relaxed/relaxed; d=1e100.net; s=20230601; t=1718856629; x=1719461429; h=to:subject:message-id:date:from:mime-version:x-gm-message-state :from:to:cc:subject:date:message-id:reply-to; bh=K1LyVoP0PrXdclQvVpjs6Sw3cHZTUO0D0fs+4hd+7YE=; b=oMAKdu2/gF9QjwJaQ3GZlWiyzMtmCgPEdjz+7r3lBpx2AXZ2R50g15Spk+mZ25Hxd7 JymlOLAmdHMLTuFHKDmF4lBQL/+qaIamay1LRpIOHqsIquwGhqHdQfXMyKuW3F3uY48x XWOExows9c8HaVpV/G2T+tkITUddsTUkjXAl4gUdRepdsZQE4OJy/ndUVuVkQYuGD4Fu kPvJ3lOdfEd176HBeLlLjP++X+83HHQtBwYiLx9ANZp7l82LeO5DNyb/hqMsdK5AqeIT k1jROWDrwFBZ6Z/yhkhp13yYx4uZvS1gpTumosgHOmAtCOpz8J9eLt+9bdOp7UA/PYk/ uNbw==', 'X-Gm-Message-State': 'AOJu0Yzpq+f+OwJhwznn3++9nIZOMlNEhLbrXBQEVDvDR2oFxJPFWbP1 JJ1z3O0DVfSSnFEXIZgvI8sPzv0kSmXY0Ay8KHQJ9Iq8dFYks1gGcm5h1tOY9JQOF9p6AnMC086 LEWA3gO2kG1xWhf8BXLKLpKJ3Q1Zj4qqnpk7QDCmgcDuNdChXGxw=', 'X-Google-Smtp-Source': 'AGHT+IGV/qw1hgsRSx3Vifqn/DKpA+mkGAMQ/afOhQqnJS6mzGd4LXeUaKTvPo8sEYobkBEqpXQLHh9RrXRw2QIKSK4=', 'X-Received': 'by 2002:a2e:9c04:0:b0:2ec:4399:9c0f with SMTP id 38308e7fff4ca-2ec4399a2b0mr10575661fa.0.1718856628654; Wed, 19 Jun 2024 21:10:28 -0700 (PDT)', 'MIME-Version': '1.0', 'From': 'Bilal Ghalib <bg@bilalghalib.com>', 'Date': 'Thu, 20 Jun 2024 06:10:12 +0200', 'Message-ID': '<CACPpfXLOjKnYW1xP4ZuUxeKXKS_jvMOBPPy8Yn=ZYj7eeJESiA@mail.gmail.com>', 'Subject': 'make me a kake', 'To': 'graph@txtray.com', 'Content-Type': 'multipart/alternative'}, 'SpamScore': 2.4, 'ExtractedMarkdownMessage': \"make me a cake as fast as you can  \\nif you can't make a cake  \\ngo learn  \\nthis is a plain command from the emailer, haha\", 'ExtractedMarkdownSignature': None, 'RawHtmlBody': '<div dir=\"ltr\">make me a cake as fast as you can<div>if you can&#39;t make a cake</div><div>go learn</div><div>this is a plain command from the emailer, haha</div></div>\\r\\n', 'RawTextBody': \"make me a cake as fast as you can\\r\\nif you can't make a cake\\r\\ngo learn\\r\\nthis is a plain command from the emailer, haha\\r\\n\", 'EMLDownloadToken': 'eyJmb2xkZXIiOiIyMDI0MDYyMDA0MTAzMC4xMy4xMDk5NzgwNjQxIiwiZmlsZW5hbWUiOiJzbXRwLmVtbCJ9'}]}\nERROR:app:Error processing webhook: No attachments found in the webhook data\n\nThe issue is that the code seems to be looking for attachments all the time even with the if, what's wrong why can't my app.py which follows run the code without an attachment:\napp.py\n#app.py\nfrom flask import Flask, render_template, request, jsonify, redirect, url_for, Response\nfrom celery import Celery, states\nimport os\nimport uuid\nfrom tasks import process_graph_task, transcribe_audio_task, download_and_process_attachment_task, save_metadata\nfrom flask_cors import CORS\nimport requests\nfrom dotenv import load_dotenv\nfrom datetime import datetime\n\n# Load environment variables from .env file\nload_dotenv()\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS\napp.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'\napp.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'\ncelery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])\ncelery.conf.update(app.config)\n\ndef save_file_content(file_content, filename, task_id):\n    output_dir = os.path.join('uploads', f\"download_{task_id}\")\n    os.makedirs(output_dir, exist_ok=True)\n    file_path = os.path.join(output_dir, filename)\n    with open(file_path, 'wb') as file:\n        file.write(file_content)\n    return file_path, output_dir\n\n@app.route('/', methods=['GET'])\ndef home():\n    return \"Go to www.txt-ray.com to make graphs\"\n\n@app.route('/graphme', methods=['GET', 'POST'])\ndef graphme():\n    if request.method == 'POST':\n        if request.is_json:\n            data = request.get_json()\n            if 'fileUrl' in data:\n                file_path, error = download_file_from_url(data['fileUrl'], 'file_from_url.txt')\n                if error:\n                    return jsonify({'error': error}), 400\n            elif 'fileContent' in data:\n                task_id = str(uuid.uuid4())\n                file_path, output_dir = save_file_content(data['fileContent'], 'file_from_content.txt', task_id)\n            else:\n                return jsonify({'error': 'No file URL or file content provided'}), 400\n        elif 'file' in request.files:\n            file = request.files['file']\n            if file.filename == '':\n                return jsonify({'error': 'No selected file'}), 400\n            task_id = str(uuid.uuid4())\n            file_path, output_dir = save_file_content(file.read(), file.filename, task_id)\n        else:\n            return jsonify({'error': 'Invalid request format'}), 400\n        \n        process_task = process_graph_task.delay(file_path, output_dir)\n        \n        return jsonify({'task_id': process_task.id, 'task_url': url_for('task_status', task_id=process_task.id, _external=True)})\n    \n    return render_template('index.html')\n\n@app.route('/progress/<task_id>')\ndef progress(task_id):\n    return render_template('progress.html', task_id=task_id)\n\n@app.route('/status/<task_id>')\ndef task_status(task_id):\n    task = process_graph_task.AsyncResult(task_id)\n    \n    if task.state == states.PENDING:\n        response = {\n            'state': task.state,\n            'status': 'Processing...'\n        }\n    elif task.state == states.SUCCESS:\n        response = {\n            'state': task.state,\n            'status': 'Processing complete.',\n            'result': task.get()\n        }\n    elif task.state == states.FAILURE:\n        response = {\n            'state': task.state,\n            'status': f'Error: {str(task.info)}'\n        }\n    else:\n        response = {\n            'state': task.state,\n            'status': str(task.info)\n        }\n    \n    return jsonify(response)\n\n@app.route('/webhook', methods=['POST'])\ndef respond():\n    app.logger.info('Webhook received: %s', request.json)\n    \n    try:\n        data = request.json['items'][0]\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment = data['Attachments'][0]\n            file_url = f\"https://api.brevo.com/v3/inbound/attachments/{attachment['DownloadToken']}\"\n        else:\n            raise Exception(\"No attachments found in the webhook data\")\n        \n        email_sender = data['From']['Address']\n        email_recipient = data['To'][0]['Address']\n        email_subject = data['Subject']\n        api_key = os.getenv(\"BREVO_API\")\n        \n        task = download_and_process_attachment_task.delay(file_url, email_sender, email_recipient, api_key, email_subject, data)\n        return jsonify({'task_id': task.id, 'task_url': url_for('task_status', task_id=task.id, _external=True)}), 200\n    \n    except Exception as e:\n        app.logger.error(f\"Error processing webhook: {e}\")\n        return jsonify({'error': 'Webhook processing failed'}), 500\n        \n@app.route('/whisper', methods=['POST'])\ndef whisper():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n\n    download_task_id = str(uuid.uuid4())\n    file_path, output_dir = save_file_content(file.read(), file.filename, download_task_id)\n    if file_path is None:\n        return jsonify({'error': 'File saving failed'}), 500\n\n    try:\n        metadata = {\n            'file_name': file.filename,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path\n        }\n        save_metadata(metadata, output_dir)\n\n        transcribe_task = transcribe_audio_task.delay(file_path, metadata)\n        return jsonify({'task_id': transcribe_task.id})\n    except Exception as e:\n        app.logger.error(f\"Error starting transcription task: {e}\")\n        return jsonify({'error': 'Transcription task failed'}), 500\n\nif __name__ == '__main__':\n    if not os.path.exists('uploads'):\n        os.makedirs('uploads')\n    if not os.path.exists('static/generated'):\n        os.makedirs('static/generated')\n    \n    app.run(debug=True, host='0.0.0.0')\n\nTasks.py\n#tasks.py\nfrom celery import Celery, states, chain\nfrom celery.utils.log import get_task_logger\nfrom contextlib import contextmanager\nfrom redis import Redis\nfrom graph_generator import generate_graph, save_graph_to_html\nimport os\nimport uuid\nimport whisper_api\nimport requests\nimport logging\nfrom datetime import datetime\nimport json\nimport asyncio\nfrom email_utils import send_email\nfrom download_utils import download_file_from_brevo, save_file_content\n\nlogger = get_task_logger(__name__)\n\ncelery = Celery('tasks', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')\n\n@contextmanager\ndef redis_lock(lock_name, timeout=60):\n    redis_client = Redis(host='localhost', port=6379, db=0)\n    lock = redis_client.lock(lock_name, timeout=timeout)\n    try:\n        yield lock.acquire(blocking=True)\n    finally:\n        if lock.owned():\n            lock.release()\n\ndef save_metadata(metadata, output_dir):\n    metadata_path = os.path.join(output_dir, 'data.json')\n    with open(metadata_path, 'w') as f:\n        json.dump(metadata, f, indent=4)\n    return metadata_path\n\n@celery.task(bind=True)\ndef process_graph_task(self, file_path, output_dir):\n    try:\n        graph_task_id = str(uuid.uuid4())\n        graph_output_dir = os.path.join('static', 'generated', f\"graph_{graph_task_id}\")\n        os.makedirs(graph_output_dir, exist_ok=True)\n        \n        G = generate_graph(file_path, graph_output_dir)\n        save_graph_to_html(G, graph_output_dir)\n\n        logger.info(f\"Graph generated successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error generating graph for task {self.request.id}: {str(e)}\")\n        raise\n    return {\n        'task_id': graph_task_id,\n        'd3_url': f'/static/generated/graph_{graph_task_id}/index.html',\n        'pyvis_url': f'/static/generated/graph_{graph_task_id}/pyvis.html'\n    }\n\n@celery.task(bind=True)\ndef transcribe_audio_task(self, file_path, download_task_metadata, email_sender, email_subject):\n    download_task_id = download_task_metadata['download_task_id']\n    output_dir = os.path.join('uploads', f\"tr_{download_task_id}\")\n    transcription_path = os.path.join(output_dir, 'transcription.txt')\n\n    # Check if the transcription has already been completed\n    if os.path.exists(transcription_path):\n        logger.info(f\"Transcription already exists for download task {download_task_id}\")\n    else:\n        # Use a lock to ensure only one instance of the task is running at a time\n        lock_name = f\"transcribe_lock_{download_task_id}\"\n        with redis_lock(lock_name) as acquired:\n            if acquired:\n                try:\n                    logger.info(f\"Starting transcription for download task {download_task_id}\")\n                    transcription = asyncio.run(whisper_api.transcribe_audio(file_path))\n                    os.makedirs(output_dir, exist_ok=True)\n                    with open(transcription_path, 'w') as f:\n                        f.write(transcription)\n\n                    metadata = download_task_metadata\n                    metadata.update({\n                        'transcription_data': transcription,\n                        'transcription_task_id': self.request.id,\n                        'transcription_file_link': transcription_path,\n                        'transcription_created_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                    })\n                    save_metadata(metadata, output_dir)\n                except Exception as e:\n                    exc_type = type(e).__name__\n                    exc_message = str(e)\n                    self.update_state(\n                        state=states.FAILURE,\n                        meta={\n                            'exc_type': exc_type,\n                            'exc_message': exc_message\n                        }\n                    )\n                    raise self.retry(exc=e, countdown=5, max_retries=3)\n            else:\n                logger.info(f\"Another instance of the task is already running for download task {download_task_id}\")\n\n    # Create a Celery chain to execute tasks sequentially\n    graph_chain = chain(\n        process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n        send_email_task.s(email_sender, email_subject)\n    )\n    graph_chain.apply_async()\n\n    logger.info(f\"Transcription completed for download task {download_task_id}\")\n    return transcription_path\n\n@celery.task(bind=True)\ndef send_email_task(self, email_sender, email_subject, graph_result):\n    try:\n        progress_url = f'https://www.txtray.com/progress/{graph_result[\"task_id\"]}'\n        send_email(\n            email=email_sender,\n            subject=f\"Re: {email_subject}\",\n            content=f\"Your transcription and graph are ready. You can view the progress at: {progress_url}\"\n        )\n        logger.info(f\"Email sent successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error sending email for task {self.request.id}: {str(e)}\")\n        raise\n\n@celery.task(bind=True)\ndef download_and_process_attachment_task(self, file_url, email_sender, email_recipient, api_key, email_subject, data):\n    try:\n        download_task_id = str(uuid.uuid4())\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            download_token = file_url.split('/')[-1]\n            file_content = download_file_from_brevo(download_token, api_key)\n            \n            # Extract the file name and extension from the webhook data\n            attachment_data = next(attachment for attachment in data['Attachments'] if attachment['DownloadToken'] == download_token)\n            file_name = attachment_data['Name']\n            file_extension = os.path.splitext(file_name)[1].lower()\n            \n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", file_name)\n            save_file_content(file_content, file_path)\n        else:\n            # No attachments, use the content inside ExtractedMarkdownMessage\n            file_name = 'message.txt'\n            file_extension = '.txt'\n            file_content = data.get('ExtractedMarkdownMessage', '')\n            \n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", file_name)\n            save_file_content(file_content.encode('utf-8'), file_path)\n        \n        metadata = {\n            'file_name': file_name,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path,\n        }\n\n        process_task = process_graph_task.delay(file_path, os.path.dirname(file_path))\n        graph_result = process_task.get()\n        progress_url = f'https://www.txtray.com/progress/{graph_result[\"task_id\"]}'\n\n        recipients = [email_sender]\n        cc_recipients = []\n\n        if 'To' in data:\n            recipients.extend([to['Address'] for to in data['To']])\n        if 'Cc' in data:\n            cc_recipients = [cc['Address'] for cc in data['Cc']]\n\n        if not recipients:\n            recipients = ['bilal@bloom.pm']\n\n        for recipient in recipients:\n            send_email(\n                email=recipient,\n                subject=f\"Re: {email_subject}\",\n                content=f\"Your file has been processed. You can view the progress at: {progress_url}\",\n                cc=cc_recipients\n            )\n\n        return {'task_id': graph_result[\"task_id\"]}\n    except Exception as e:\n        self.update_state(\n            state=states.FAILURE,\n            meta={\n                'exc_type': type(e).__name__,\n                'exc_message': str(e)\n            }\n        )\n        raise\n        email_utils.py\nfrom __future__ import print_function\nimport time\nimport sib_api_v3_sdk\nfrom sib_api_v3_sdk.rest import ApiException\nfrom pprint import pprint\n\ndef send_email(email, subject, content, cc=None, attachment_path=None, attachment_filename=None):\n    configuration = sib_api_v3_sdk.Configuration()\n    configuration.api_key['api-key'] = 'xkeysib-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX_REDACTED-xTXc3nVVM1ncUcXE'\n    api_instance = sib_api_v3_sdk.TransactionalEmailsApi(sib_api_v3_sdk.ApiClient(configuration))\n\n    sender = {\"name\": \"TxtRay\", \"email\": \"graph@txtray.com\"}\n    to = [{\"email\": email}]\n\n    send_smtp_email = sib_api_v3_sdk.SendSmtpEmail(\n        to=to,\n        html_content=content,\n        sender=sender,\n        subject=subject,\n        cc=[{\"email\": cc_email} for cc_email in cc] if cc else None\n    )\n\n    if attachment_path and attachment_filename:\n        attachment = sib_api_v3_sdk.Attachment()\n        attachment.name = attachment_filename\n        with open(attachment_path, 'rb') as file:\n            attachment.content = file.read()\n        send_smtp_email.attachment = [attachment]\n\n    try:\n        api_response = api_instance.send_transac_email(send_smtp_email)\n        pprint(api_response)\n    except ApiException as e:\n        print(\"Exception when calling SMTPApi->send_transac_email: %s\\n\" % e)\ndownload_util.py\nimport os\nimport requests\n\ndef download_file_from_brevo(download_token, api_key):\n    url = f\"https://api.brevo.com/v3/inbound/attachments/{download_token}\"\n    headers = {\n        \"accept\": \"application/octet-stream\",\n        \"api-key\": api_key\n    }\n    response = requests.get(url, headers=headers)\n    \n    if response.status_code == 200:\n        return response.content\n    else:\n        raise Exception(f\"Failed to download file from Brevo. Status code: {response.status_code}\")\n\ndef save_file_content(file_content, file_path):\n    os.makedirs(os.path.dirname(file_path), exist_ok=True)\n    with open(file_path, 'wb') as file:\n        file.write(file_content)\n    return file_path\nwhisper_api.py\nimport aiohttp\nimport asyncio\nimport os\n\nasync def transcribe_audio(file_path):\n    openai_api_key = \"REDACTED_API_KEY\"  # Ensure this is set in your environment\n    url = \"https://api.openai.com/v1/audio/transcriptions\"\n    \n    async with aiohttp.ClientSession() as session:\n        with open(file_path, \"rb\") as audio_file:\n            form_data = aiohttp.FormData()\n            form_data.add_field('file', audio_file, filename=os.path.basename(file_path))\n            form_data.add_field('model', 'whisper-1')\n        \n            headers = {\n                \"Authorization\": f\"Bearer {openai_api_key}\"\n            }\n            async with session.post(url, headers=headers, data=form_data) as response:\n                if response.status != 200:\n                    response_text = await response.text()\n                    raise Exception(f\"Failed to transcribe audio: {response.status} {response_text}\")\n                \n                result = await response.json()\n                return result['text']\n\n\nwhat can I do to make this work? review the code, analyse it for ways to better organize, structure and improve it to be more pythonic and return your results ",
      "created_at": "2024-06-20T06:19:45.556157",
      "sequence_order": 0,
      "parent_id": "ef790ec6-c4c6-40fd-ace2-0602b910d865",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "22d6ee7b-2d86-4edc-b50a-ae60cd8aca8d",
      "role": "assistant",
      "content": "Alright team, let's tackle this issue and improve the code. First, let's identify and solve the problem with attachments. Then we'll focus on refactoring and improving the overall structure.\n\n### Problem with Attachments\n\n**Claude (Green Hat)**:\nThe primary issue is that the code raises an exception if no attachments are found, which is unnecessary if attachments are optional. We can handle this more gracefully by adding a check and processing the email accordingly if no attachments are found.\n\n### Code Review and Improvement\n\n**Prunella (Black Hat)**:\nWe'll start by fixing the attachment processing logic and then look into other potential areas of improvement such as code readability, structure, error handling, and optimization.\n\n**Josephine (White Hat)**:\nLet's address the issues and refactor the code step by step.\n\n1. **Fixing the Attachment Check**:\n   Update the `/webhook` endpoint to handle cases without attachments.\n\n```python\n@app.route('/webhook', methods=['POST'])\ndef respond():\n    app.logger.info('Webhook received: %s', request.json)\n    \n    try:\n        data = request.json['items'][0]\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment = data['Attachments'][0]\n            file_url = f\"https://api.brevo.com/v3/inbound/attachments/{attachment['DownloadToken']}\"\n            task = download_and_process_attachment_task.delay(file_url, data)\n        else:\n            # Process without attachment\n            email_sender = data['From']['Address']\n            email_subject = data['Subject']\n            message_content = data.get('ExtractedMarkdownMessage', 'No content available')\n            task = process_without_attachment_task.delay(email_sender, email_subject, message_content)\n        \n        return jsonify({'task_id': task.id, 'task_url': url_for('task_status', task_id=task.id, _external=True)}), 200\n    \n    except Exception as e:\n        app.logger.error(f\"Error processing webhook: {e}\")\n        return jsonify({'error': 'Webhook processing failed'}), 500\n```\n\n2. **New Task to Process Without Attachment**:\n   Create a new task to handle emails without attachments.\n\n```python\n@celery.task(bind=True)\ndef process_without_attachment_task(self, email_sender, email_subject, message_content):\n    try:\n        # Create a file with the message content\n        task_id = str(uuid.uuid4())\n        output_dir = os.path.join('uploads', f\"message_{task_id}\")\n        os.makedirs(output_dir, exist_ok=True)\n        file_path = os.path.join(output_dir, 'message.txt')\n        \n        with open(file_path, 'w') as file:\n            file.write(message_content)\n        \n        # Process the file as needed, e.g., generate a graph\n        process_task = process_graph_task.delay(file_path, output_dir)\n        graph_result = process_task.get()\n        \n        return {\n            'task_id': process_task.id,\n            'graph_result': graph_result\n        }\n    except Exception as e:\n        self.update_state(\n            state=states.FAILURE,\n            meta={\n                'exc_type': type(e).__name__,\n                'exc_message': str(e)\n            }\n        )\n        raise\n```\n\n3. **Refactor the `download_and_process_attachment_task` Function**:\n   Simplify the function to improve readability and error handling.\n\n```python\n@celery.task(bind=True)\ndef download_and_process_attachment_task(self, file_url, data):\n    try:\n        download_task_id = str(uuid.uuid4())\n        file_content = download_file_from_brevo(file_url)\n        \n        attachment_data = data['Attachments'][0]\n        file_name = attachment_data['Name']\n        file_path = save_file_content(file_content, f'uploads/download_{download_task_id}/{file_name}')\n        \n        process_task = process_graph_task.delay(file_path, os.path.dirname(file_path))\n        graph_result = process_task.get()\n        \n        progress_url = f'https://www.txtray.com/progress/{graph_result[\"task_id\"]}'\n        send_email_notification(data['From']['Address'], data['Subject'], progress_url, data)\n        \n        return {'task_id': graph_result[\"task_id\"]}\n    except Exception as e:\n        self.update_state(\n            state=states.FAILURE,\n            meta={\n                'exc_type': type(e).__name__,\n                'exc_message': str(e)\n            }\n        )\n        raise\n```\n\n4. **Utility Function for Sending Email**:\n   Create a utility function to send email notifications.\n\n```python\ndef send_email_notification(email_sender, email_subject, progress_url, data):\n    recipients = [email_sender]\n    cc_recipients = []\n\n    if 'To' in data:\n        recipients.extend([to['Address'] for to in data['To']])\n    if 'Cc' in data:\n        cc_recipients = [cc['Address'] for cc in data['Cc']]\n\n    send_email(\n        email=email_sender,\n        subject=f\"Re: {email_subject}\",\n        content=f\"Your file has been processed. You can view the progress at: {progress_url}\",\n        cc=cc_recipients\n    )\n```\n\n5. **Error Handling and Logging**:\n   Improve error handling and logging for better debugging.\n\n```python\n@app.route('/webhook', methods=['POST'])\ndef respond():\n    app.logger.info('Webhook received: %s', request.json)\n    \n    try:\n        data = request.json['items'][0]\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment = data['Attachments'][0]\n            file_url = f\"https://api.brevo.com/v3/inbound/attachments/{attachment['DownloadToken']}\"\n            task = download_and_process_attachment_task.delay(file_url, data)\n        else:\n            email_sender = data['From']['Address']\n            email_subject = data['Subject']\n            message_content = data.get('ExtractedMarkdownMessage', 'No content available')\n            task = process_without_attachment_task.delay(email_sender, email_subject, message_content)\n        \n        return jsonify({'task_id': task.id, 'task_url': url_for('task_status', task_id=task.id, _external=True)}), 200\n    \n    except Exception as e:\n        app.logger.error(f\"Error processing webhook: {e}\", exc_info=True)\n        return jsonify({'error': 'Webhook processing failed'}), 500\n```\n\n**Percy (Yellow Hat)**:\nThese changes will ensure that your application can handle emails with and without attachments gracefully. The overall structure is improved, making the code more readable and maintainable.\n\n**Cyril (Red Hat)**:\nIntuitively, these adjustments will make the system more robust and user-friendly, reducing the likelihood of errors and making it easier to debug issues when they do occur.\n\n**Quackers (Blue Hat)**:\nNow, we have a comprehensive plan that addresses the immediate issue with attachments and improves the overall code structure. Let's proceed with implementing these changes. If you need further adjustments or additional features, feel free to ask!",
      "created_at": "2024-06-20T06:20:24.264212",
      "sequence_order": 1,
      "parent_id": "aaa2d39e-29e7-4e4f-a54b-688eeb6b11e1",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2a0ba-083e-4ca0-8243-c2a8acd9a5f0",
      "role": "user",
      "content": "we should send the URLs because that's the body of the email, let's review what we are sending it should be responded to the person who sent it, the subject should a reply to their subject and the body should be a link to their progress page\n#tasks.py\nimport re\nfrom celery import Celery, states, chain\nfrom celery.utils.log import get_task_logger\nfrom contextlib import contextmanager\nfrom redis import Redis\nfrom graph_generator import generate_graph, save_graph_to_html\nimport os\nimport uuid\nimport whisper_api\nimport requests\nimport logging\nfrom datetime import datetime\nimport json\nimport asyncio\nfrom email_utils import send_email\nfrom download_utils import download_file_from_brevo, save_file_content\n\nlogger = get_task_logger(__name__)\n\ncelery = Celery('tasks', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')\n\n@contextmanager\ndef redis_lock(lock_name, timeout=60):\n    redis_client = Redis(host='localhost', port=6379, db=0)\n    lock = redis_client.lock(lock_name, timeout=timeout)\n    try:\n        yield lock.acquire(blocking=True)\n    finally:\n        if lock.owned():\n            lock.release()\n\ndef save_metadata(metadata, output_dir):\n    metadata_path = os.path.join(output_dir, 'data.json')\n    with open(metadata_path, 'w') as f:\n        json.dump(metadata, f, indent=4)\n    return metadata_path\n\n@celery.task(bind=True)\ndef process_graph_task(self, file_path, output_dir):\n    try:\n        graph_task_id = str(uuid.uuid4())\n        graph_output_dir = os.path.join('static', 'generated', f\"graph_{graph_task_id}\")\n        os.makedirs(graph_output_dir, exist_ok=True)\n        \n        G = generate_graph(file_path, graph_output_dir)\n        save_graph_to_html(G, graph_output_dir)\n\n        logger.info(f\"Graph generated successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error generating graph for task {self.request.id}: {str(e)}\")\n        raise\n    return {\n        'task_id': graph_task_id,\n        'd3_url': f'/static/generated/graph_{graph_task_id}/index.html',\n        'pyvis_url': f'/static/generated/graph_{graph_task_id}/pyvis.html'\n    }\n\n@celery.task(bind=True)\ndef transcribe_audio_task(self, file_path, download_task_metadata, email_sender, email_subject):\n    download_task_id = download_task_metadata['download_task_id']\n    output_dir = os.path.join('uploads', f\"tr_{download_task_id}\")\n    transcription_path = os.path.join(output_dir, 'transcription.txt')\n\n    # Check if the transcription has already been completed\n    if os.path.exists(transcription_path):\n        logger.info(f\"Transcription already exists for download task {download_task_id}\")\n    else:\n        # Use a lock to ensure only one instance of the task is running at a time\n        lock_name = f\"transcribe_lock_{download_task_id}\"\n        with redis_lock(lock_name) as acquired:\n            if acquired:\n                try:\n                    logger.info(f\"Starting transcription for download task {download_task_id}\")\n                    transcription = asyncio.run(whisper_api.transcribe_audio(file_path))\n                    os.makedirs(output_dir, exist_ok=True)\n                    with open(transcription_path, 'w') as f:\n                        f.write(transcription)\n\n                    metadata = download_task_metadata\n                    metadata.update({\n                        'transcription_data': transcription,\n                        'transcription_task_id': self.request.id,\n                        'transcription_file_link': transcription_path,\n                        'transcription_created_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                    })\n                    save_metadata(metadata, output_dir)\n                except Exception as e:\n                    exc_type = type(e).__name__\n                    exc_message = str(e)\n                    self.update_state(\n                        state=states.FAILURE,\n                        meta={\n                            'exc_type': exc_type,\n                            'exc_message': exc_message\n                        }\n                    )\n                    raise self.retry(exc=e, countdown=5, max_retries=3)\n            else:\n                logger.info(f\"Another instance of the task is already running for download task {download_task_id}\")\n\n    # Create a Celery chain to execute tasks sequentially\n    graph_chain = chain(\n        process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n        send_email_task.s(email_sender, email_subject)\n    )\n    graph_chain.apply_async()\n\n    logger.info(f\"Transcription completed for download task {download_task_id}\")\n    return transcription_path\n\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\n@celery.task(bind=True)\ndef send_email_task(self, email_sender, email_subject, task_id):\n    try:\n        # Convert email_sender to a string\n        email_sender = str(email_sender)\n        \n        if not is_valid_email(email_sender):\n            raise ValueError(f\"Invalid email address: {email_sender}\")\n        \n        progress_url = f'https://www.txtray.com/progress/{task_id}'\n        send_email(\n            email=email_sender,\n            subject=f\"Re: {email_subject}\",\n            content=f\"Your transcription and graph are ready. You can view the progress at: {progress_url}\"\n        )\n        logger.info(f\"Email sent successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error sending email for task {self.request.id}: {str(e)}\")\n        raise        \n@celery.task(bind=True)\ndef download_and_process_attachment_task(self, file_url, email_sender, email_recipient, api_key, email_subject, data):\n    try:\n        download_task_id = str(uuid.uuid4())\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment_data = data['Attachments'][0]\n            attachment_name = attachment_data['Name']\n            attachment_type = attachment_data['ContentType']\n            download_token = data['EMLDownloadToken']\n            \n            file_content = download_file_from_brevo(download_token, api_key)\n            file_extension = os.path.splitext(attachment_name)[1].lower()\n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", f\"attachment{file_extension}\")\n            save_file_content(file_content, file_path)\n        else:\n            # No attachments, use the content inside ExtractedMarkdownMessage\n            attachment_name = 'message.txt'\n            attachment_type = 'text/plain'\n            file_content = data.get('ExtractedMarkdownMessage', '')\n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", attachment_name)\n            save_file_content(file_content.encode('utf-8'), file_path)\n        \n        metadata = {\n            'file_name': attachment_name,\n            'file_type': attachment_type,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path,\n        }\n        if attachment_type.startswith('audio/'):\n            transcribe_task = transcribe_audio_task.delay(file_path, metadata, email_sender, email_subject)\n            transcription_result = transcribe_task.get()\n            transcription_path = transcription_result['transcription_path']\n            graph_chain = chain(\n                process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n                send_email_task.s(email_sender, email_subject)\n\t\t\t)\n            graph_result = graph_chain.apply_async()\n            return {'task_id': graph_result.parent.get()[\"task_id\"]}\n        elif attachment_type == 'text/plain' or file_extension == '.txt':\n            graph_chain = chain(\n                process_graph_task.s(file_path, os.path.dirname(file_path)),\n                send_email_task.s(email_sender, email_subject)\n            )\n            graph_result = graph_chain.apply_async()\n            return {'task_id': graph_result.parent.get()[\"task_id\"]}\n        else:\n            process_task = process_graph_task.delay(file_path, os.path.dirname(file_path))\n            graph_result = process_task.get()\n            progress_url = f'https://www.txtray.com/progress/{graph_result[\"task_id\"]}'\n            \n            recipients = [email_sender]\n            cc_recipients = []\n            \n            if 'To' in data:\n                recipients.extend([to['Address'] for to in data['To']])\n            if 'Cc' in data:\n                cc_recipients = [cc['Address'] for cc in data['Cc']]\n            \n            if not recipients:\n                recipients = ['bilal@bloom.pm']\n            \n            for recipient in recipients:\n                send_email(\n                    email=recipient,\n                    subject=f\"Re: {email_subject}\",\n                    content=f\"Your file has been processed. You can view the progress at: {progress_url}\",\n                    cc=cc_recipients\n                )\n            \n            return {'task_id': graph_result[\"task_id\"]}\n    except Exception as e:\n        self.update_state(\n            state=states.FAILURE,\n            meta={\n                'exc_type': type(e).__name__,\n                'exc_message': str(e)\n            }\n        )\n        raise        #app.py\nfrom flask import Flask, render_template, request, jsonify, redirect, url_for, Response\nfrom celery import Celery, states\nimport os\nimport uuid\nfrom tasks import process_graph_task, transcribe_audio_task, download_and_process_attachment_task, save_metadata\nfrom flask_cors import CORS\nimport requests\nfrom dotenv import load_dotenv\nfrom datetime import datetime\n\n# Load environment variables from .env file\nload_dotenv()\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS\napp.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'\napp.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'\ncelery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])\ncelery.conf.update(app.config)\n\ndef save_file_content(file_content, filename, task_id):\n    output_dir = os.path.join('uploads', f\"download_{task_id}\")\n    os.makedirs(output_dir, exist_ok=True)\n    file_path = os.path.join(output_dir, filename)\n    with open(file_path, 'wb') as file:\n        file.write(file_content)\n    return file_path, output_dir\n\n@app.route('/', methods=['GET'])\ndef home():\n    return \"Go to www.txt-ray.com to make graphs\"\n\n@app.route('/graphme', methods=['GET', 'POST'])\ndef graphme():\n    if request.method == 'POST':\n        if request.is_json:\n            data = request.get_json()\n            if 'fileUrl' in data:\n                file_path, error = download_file_from_url(data['fileUrl'], 'file_from_url.txt')\n                if error:\n                    return jsonify({'error': error}), 400\n            elif 'fileContent' in data:\n                task_id = str(uuid.uuid4())\n                file_path, output_dir = save_file_content(data['fileContent'], 'file_from_content.txt', task_id)\n            else:\n                return jsonify({'error': 'No file URL or file content provided'}), 400\n        elif 'file' in request.files:\n            file = request.files['file']\n            if file.filename == '':\n                return jsonify({'error': 'No selected file'}), 400\n            task_id = str(uuid.uuid4())\n            file_path, output_dir = save_file_content(file.read(), file.filename, task_id)\n        else:\n            return jsonify({'error': 'Invalid request format'}), 400\n        \n        process_task = process_graph_task.delay(file_path, output_dir)\n        \n        return jsonify({'task_id': process_task.id, 'task_url': url_for('task_status', task_id=process_task.id, _external=True)})\n    \n    return render_template('index.html')\n\n@app.route('/progress/<task_id>')\ndef progress(task_id):\n    return render_template('progress.html', task_id=task_id)\n\n@app.route('/status/<task_id>')\ndef task_status(task_id):\n    task = process_graph_task.AsyncResult(task_id)\n    \n    if task.state == states.PENDING:\n        response = {\n            'state': task.state,\n            'status': 'Processing...'\n        }\n    elif task.state == states.SUCCESS:\n        response = {\n            'state': task.state,\n            'status': 'Processing complete.',\n            'result': task.get()\n        }\n    elif task.state == states.FAILURE:\n        response = {\n            'state': task.state,\n            'status': f'Error: {str(task.info)}'\n        }\n    else:\n        response = {\n            'state': task.state,\n            'status': str(task.info)\n        }\n    \n    return jsonify(response)\n\n@app.route('/webhook', methods=['POST'])\ndef respond():\n    app.logger.info('Webhook received: %s', request.json)\n    \n    try:\n        data = request.json['items'][0]\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment = data['Attachments'][0]\n            file_url = f\"https://api.brevo.com/v3/inbound/attachments/{attachment['DownloadToken']}\"\n        else:\n            file_url = None  # Set file_url to None when there are no attachments\n        \n        email_sender = data['From']['Address']\n        email_recipient = data['To'][0]['Address']\n        email_subject = data['Subject']\n        api_key = os.getenv(\"BREVO_API\")\n        \n        task = download_and_process_attachment_task.delay(file_url, email_sender, email_recipient, api_key, email_subject, data)\n        return jsonify({'task_id': task.id, 'task_url': url_for('task_status', task_id=task.id, _external=True)}), 200\n    \n    except Exception as e:\n        app.logger.error(f\"Error processing webhook: {e}\")\n        return jsonify({'error': 'Webhook processing failed'}), 500        \n@app.route('/whisper', methods=['POST'])\ndef whisper():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n\n    download_task_id = str(uuid.uuid4())\n    file_path, output_dir = save_file_content(file.read(), file.filename, download_task_id)\n    if file_path is None:\n        return jsonify({'error': 'File saving failed'}), 500\n\n    try:\n        metadata = {\n            'file_name': file.filename,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path\n        }\n        save_metadata(metadata, output_dir)\n\n        transcribe_task = transcribe_audio_task.delay(file_path, metadata)\n        return jsonify({'task_id': transcribe_task.id})\n    except Exception as e:\n        app.logger.error(f\"Error starting transcription task: {e}\")\n        return jsonify({'error': 'Transcription task failed'}), 500\n\nif __name__ == '__main__':\n    if not os.path.exists('uploads'):\n        os.makedirs('uploads')\n    if not os.path.exists('static/generated'):\n        os.makedirs('static/generated')\n    \n    app.run(debug=True, host='0.0.0.0')",
      "created_at": "2024-06-20T06:54:43.169879",
      "sequence_order": 2,
      "parent_id": "22d6ee7b-2d86-4edc-b50a-ae60cd8aca8d",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "9d61f0db-e72f-427f-8013-31f48b99fa08",
      "role": "assistant",
      "content": "### Improving the Code\n\n#### Problem Addressed:\n1. Send emails with a link to the progress page.\n2. Handle both cases where there are attachments and where there are none.\n3. Respond to the person who sent the email.\n4. Ensure the subject of the response email is a reply to their subject.\n\n**Quackers (Blue Hat)**:\nTo achieve these goals, let's refactor the necessary sections in both `tasks.py` and `app.py`.\n\n### Updated `tasks.py`\n\n1. **Refactor `download_and_process_attachment_task`**:\n   Update the task to handle cases with and without attachments appropriately, and send emails with the progress URL.\n\n2. **Update `send_email_task`**:\n   Ensure the email includes a link to the progress page.\n\n```python\nimport re\nfrom celery import Celery, states, chain\nfrom celery.utils.log import get_task_logger\nfrom contextlib import contextmanager\nfrom redis import Redis\nfrom graph_generator import generate_graph, save_graph_to_html\nimport os\nimport uuid\nimport whisper_api\nimport requests\nimport logging\nfrom datetime import datetime\nimport json\nimport asyncio\nfrom email_utils import send_email\nfrom download_utils import download_file_from_brevo, save_file_content\n\nlogger = get_task_logger(__name__)\n\ncelery = Celery('tasks', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')\n\n@contextmanager\ndef redis_lock(lock_name, timeout=60):\n    redis_client = Redis(host='localhost', port=6379, db=0)\n    lock = redis_client.lock(lock_name, timeout=timeout)\n    try:\n        yield lock.acquire(blocking=True)\n    finally:\n        if lock.owned():\n            lock.release()\n\ndef save_metadata(metadata, output_dir):\n    metadata_path = os.path.join(output_dir, 'data.json')\n    with open(metadata_path, 'w') as f:\n        json.dump(metadata, f, indent=4)\n    return metadata_path\n\n@celery.task(bind=True)\ndef process_graph_task(self, file_path, output_dir):\n    try:\n        graph_task_id = str(uuid.uuid4())\n        graph_output_dir = os.path.join('static', 'generated', f\"graph_{graph_task_id}\")\n        os.makedirs(graph_output_dir, exist_ok=True)\n        \n        G = generate_graph(file_path, graph_output_dir)\n        save_graph_to_html(G, graph_output_dir)\n\n        logger.info(f\"Graph generated successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error generating graph for task {self.request.id}: {str(e)}\")\n        raise\n    return {\n        'task_id': graph_task_id,\n        'd3_url': f'/static/generated/graph_{graph_task_id}/index.html',\n        'pyvis_url': f'/static/generated/graph_{graph_task_id}/pyvis.html'\n    }\n\n@celery.task(bind=True)\ndef transcribe_audio_task(self, file_path, download_task_metadata, email_sender, email_subject):\n    download_task_id = download_task_metadata['download_task_id']\n    output_dir = os.path.join('uploads', f\"tr_{download_task_id}\")\n    transcription_path = os.path.join(output_dir, 'transcription.txt')\n\n    # Check if the transcription has already been completed\n    if os.path.exists(transcription_path):\n        logger.info(f\"Transcription already exists for download task {download_task_id}\")\n    else:\n        # Use a lock to ensure only one instance of the task is running at a time\n        lock_name = f\"transcribe_lock_{download_task_id}\"\n        with redis_lock(lock_name) as acquired:\n            if acquired:\n                try:\n                    logger.info(f\"Starting transcription for download task {download_task_id}\")\n                    transcription = asyncio.run(whisper_api.transcribe_audio(file_path))\n                    os.makedirs(output_dir, exist_ok=True)\n                    with open(transcription_path, 'w') as f:\n                        f.write(transcription)\n\n                    metadata = download_task_metadata\n                    metadata.update({\n                        'transcription_data': transcription,\n                        'transcription_task_id': self.request.id,\n                        'transcription_file_link': transcription_path,\n                        'transcription_created_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                    })\n                    save_metadata(metadata, output_dir)\n                except Exception as e:\n                    exc_type = type(e).__name__\n                    exc_message = str(e)\n                    self.update_state(\n                        state=states.FAILURE,\n                        meta={\n                            'exc_type': exc_type,\n                            'exc_message': exc_message\n                        }\n                    )\n                    raise self.retry(exc=e, countdown=5, max_retries=3)\n            else:\n                logger.info(f\"Another instance of the task is already running for download task {download_task_id}\")\n\n    # Create a Celery chain to execute tasks sequentially\n    graph_chain = chain(\n        process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n        send_email_task.s(email_sender, email_subject)\n    )\n    graph_chain.apply_async()\n\n    logger.info(f\"Transcription completed for download task {download_task_id}\")\n    return transcription_path\n\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\n@celery.task(bind=True)\ndef send_email_task(self, email_sender, email_subject, task_id):\n    try:\n        # Convert email_sender to a string\n        email_sender = str(email_sender)\n        \n        if not is_valid_email(email_sender):\n            raise ValueError(f\"Invalid email address: {email_sender}\")\n        \n        progress_url = f'https://www.txtray.com/progress/{task_id}'\n        send_email(\n            email=email_sender,\n            subject=f\"Re: {email_subject}\",\n            content=f\"Your file has been processed. You can view the progress at: {progress_url}\"\n        )\n        logger.info(f\"Email sent successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error sending email for task {self.request.id}: {str(e)}\")\n        raise        \n@celery.task(bind=True)\ndef download_and_process_attachment_task(self, file_url, email_sender, email_recipient, api_key, email_subject, data):\n    try:\n        download_task_id = str(uuid.uuid4())\n        \n        if file_url:\n            file_content = download_file_from_brevo(file_url, api_key)\n            attachment_data = data['Attachments'][0]\n            attachment_name = attachment_data['Name']\n            file_extension = os.path.splitext(attachment_name)[1].lower()\n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", f\"attachment{file_extension}\")\n            save_file_content(file_content, file_path)\n        else:\n            # No attachments, use the content inside ExtractedMarkdownMessage\n            attachment_name = 'message.txt'\n            file_content = data.get('ExtractedMarkdownMessage', 'No content available')\n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", attachment_name)\n            save_file_content(file_content.encode('utf-8'), file_path)\n        \n        metadata = {\n            'file_name': attachment_name,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path,\n        }\n\n        if attachment_name.endswith('.mp3') or attachment_name.endswith('.wav'):\n            transcribe_task = transcribe_audio_task.delay(file_path, metadata, email_sender, email_subject)\n            transcription_result = transcribe_task.get()\n            transcription_path = transcription_result['transcription_path']\n            graph_chain = chain(\n                process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n                send_email_task.s(email_sender, email_subject)\n            )\n            graph_result = graph_chain.apply_async()\n            return {'task_id': graph_result.parent.get()[\"task_id\"]}\n        else:\n            graph_chain = chain(\n                process_graph_task.s(file_path, os.path.dirname(file_path)),\n                send_email_task.s(email_sender, email_subject)\n            )\n            graph_result = graph_chain.apply_async()\n            return {'task_id': graph_result.parent.get()[\"task_id\"]}\n    except Exception as e:\n        self.update_state(\n            state=states.FAILURE,\n            meta={\n                'exc_type': type(e).__name__,\n                'exc_message': str(e)\n            }\n        )\n        raise\n```\n\n### Updated `app.py`\n\n1. **Update the `/webhook` endpoint**:\n   Adjust to call the task correctly based on whether an attachment is present or not.\n\n```python\nfrom flask import Flask, render_template, request, jsonify, redirect, url_for, Response\nfrom celery import Celery, states\nimport os\nimport uuid\nfrom tasks import process_graph_task, transcribe_audio_task, download_and_process_attachment_task, save_metadata\nfrom flask_cors import CORS\nimport requests\nfrom dotenv import load_dotenv\nfrom datetime import datetime\n\n# Load environment variables from .env file\nload_dotenv()\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS\napp.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'\napp.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'\ncelery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])\ncelery.conf.update(app.config)\n\ndef save_file_content(file_content, filename, task_id):\n    output_dir = os.path.join('uploads', f\"download_{task_id}\")\n    os.makedirs(output_dir, exist_ok=True)\n    file_path = os.path.join",
      "created_at": "2024-06-20T06:55:39.966685",
      "sequence_order": 3,
      "parent_id": "aaa2a0ba-083e-4ca0-8243-c2a8acd9a5f0",
      "metadata": {
        "status": "finished_partial_completion",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "09f47764-8779-49da-b1cf-72164f9ffa5d",
      "role": "assistant",
      "content": "(output_dir, filename)\n    with open(file_path, 'wb') as file:\n        file.write(file_content)\n    return file_path, output_dir\n\n@app.route('/', methods=['GET'])\ndef home():\n    return \"Go to www.txt-ray.com to make graphs\"\n\n@app.route('/graphme', methods=['GET', 'POST'])\ndef graphme():\n    if request.method == 'POST':\n        if request.is_json:\n            data = request.get_json()\n            if 'fileUrl' in data:\n                file_path, error = download_file_from_url(data['fileUrl'], 'file_from_url.txt')\n                if error:\n                    return jsonify({'error': error}), 400\n            elif 'fileContent' in data:\n                task_id = str(uuid.uuid4())\n                file_path, output_dir = save_file_content(data['fileContent'], 'file_from_content.txt', task_id)\n            else:\n                return jsonify({'error': 'No file URL or file content provided'}), 400\n        elif 'file' in request.files:\n            file = request.files['file']\n            if file.filename == '':\n                return jsonify({'error': 'No selected file'}), 400\n            task_id = str(uuid.uuid4())\n            file_path, output_dir = save_file_content(file.read(), file.filename, task_id)\n        else:\n            return jsonify({'error': 'Invalid request format'}), 400\n        \n        process_task = process_graph_task.delay(file_path, output_dir)\n        \n        return jsonify({'task_id': process_task.id, 'task_url': url_for('task_status', task_id=process_task.id, _external=True)})\n    \n    return render_template('index.html')\n\n@app.route('/progress/<task_id>')\ndef progress(task_id):\n    return render_template('progress.html', task_id=task_id)\n\n@app.route('/status/<task_id>')\ndef task_status(task_id):\n    task = process_graph_task.AsyncResult(task_id)\n    \n    if task.state == states.PENDING:\n        response = {\n            'state': task.state,\n            'status': 'Processing...'\n        }\n    elif task.state == states.SUCCESS:\n        response = {\n            'state': task.state,\n            'status': 'Processing complete.',\n            'result': task.get()\n        }\n    elif task.state == states.FAILURE:\n        response = {\n            'state': task.state,\n            'status': f'Error: {str(task.info)}'\n        }\n    else:\n        response = {\n            'state': task.state,\n            'status': str(task.info)\n        }\n    \n    return jsonify(response)\n\n@app.route('/webhook', methods=['POST'])\ndef respond():\n    app.logger.info('Webhook received: %s', request.json)\n    \n    try:\n        data = request.json['items'][0]\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment = data['Attachments'][0]\n            file_url = f\"https://api.brevo.com/v3/inbound/attachments/{attachment['DownloadToken']}\"\n        else:\n            file_url = None  # Set file_url to None when there are no attachments\n        \n        email_sender = data['From']['Address']\n        email_subject = data['Subject']\n        api_key = os.getenv(\"BREVO_API\")\n        \n        task = download_and_process_attachment_task.delay(file_url, email_sender, email_recipient, api_key, email_subject, data)\n        return jsonify({'task_id': task.id, 'task_url': url_for('task_status', task_id=task.id, _external=True)}), 200\n    \n    except Exception as e:\n        app.logger.error(f\"Error processing webhook: {e}\")\n        return jsonify({'error': 'Webhook processing failed'}), 500        \n@app.route('/whisper', methods=['POST'])\ndef whisper():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n\n    download_task_id = str(uuid.uuid4())\n    file_path, output_dir = save_file_content(file.read(), file.filename, download_task_id)\n    if file_path is None:\n        return jsonify({'error': 'File saving failed'}), 500\n\n    try:\n        metadata = {\n            'file_name': file.filename,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path\n        }\n        save_metadata(metadata, output_dir)\n\n        transcribe_task = transcribe_audio_task.delay(file_path, metadata)\n        return jsonify({'task_id': transcribe_task.id})\n    except Exception as e:\n        app.logger.error(f\"Error starting transcription task: {e}\")\n        return jsonify({'error': 'Transcription task failed'}), 500\n\nif __name__ == '__main__':\n    if not os.path.exists('uploads'):\n        os.makedirs('uploads')\n    if not os.path.exists('static/generated'):\n        os.makedirs('static/generated')\n    \n    app.run(debug=True, host='0.0.0.0')\n```\n\n### Summary of Changes\n\n1. **download_and_process_attachment_task**:\n   - Handles both attachment and non-attachment scenarios.\n   - Constructs file paths and saves file content appropriately.\n   - Sends emails with the progress URL.\n\n2. **send_email_task**:\n   - Sends emails to the sender with a link to the progress page.\n   - Ensures the email's subject is a reply to the original subject.\n\n3. **respond function in app.py**:\n   - Correctly initializes tasks based on the presence of attachments.\n\nThese changes improve the handling of email processing, ensure appropriate responses, and streamline the code for better readability and maintainability.",
      "created_at": "2024-06-20T06:57:42.081912",
      "sequence_order": 4,
      "parent_id": "9d61f0db-e72f-427f-8013-31f48b99fa08",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    },
    {
      "id": "aaa2cde3-a63f-4ede-ba64-7ee7d4166775",
      "role": "user",
      "content": "INFO:app:Webhook received: {'items': [{'Uuid': ['130b9c47-841f-4ee9-b685-4545dfc7b59d'], 'Recipients': ['graph@txtray.com'], 'MessageId': '<CACPpfXJqfk-DW8xYony=y9GMY22Az-YtP_KFPEci68bt9txxAQ@mail.gmail.com>', 'InReplyTo': '<CACPpfX+XFagWHHsoG8fOb3LLGC8JEXkWVcDWCO8rgtenxkv1bQ@mail.gmail.com>', 'From': {'Name': 'Bilal Ghalib', 'Address': 'bg@bilalghalib.com'}, 'To': [{'Name': None, 'Address': 'graph@txtray.com'}], 'Cc': [], 'Bcc': [], 'ReplyTo': None, 'SentAtDate': 'Thu, 20 Jun 2024 07:01:48 +0200', 'Subject': 'Re: make me a cake', 'Attachments': [], 'Headers': {'Received': 'by mail-ed1-f54.google.com with SMTP id 4fb4d7f45d1cf-57d0eca877cso417284a12.2 for <graph@txtray.com>; Wed, 19 Jun 2024 22:02:06 -0700 (PDT)', 'DKIM-Signature': 'v=1; a=rsa-sha256; c=relaxed/relaxed; d=bilalghalib-com.20230601.gappssmtp.com; s=20230601; t=1718859725; x=1719464525; darn=txtray.com; h=to:subject:message-id:date:from:in-reply-to:references:mime-version :from:to:cc:subject:date:message-id:reply-to; bh=sv92b50tM6VEnF6j3ryNjbSDRmA9Q/PVIv1uBdBQua0=; b=OQWipM3KiRQFIjSqJcPKFf1Cq4ZhUELUdCcZ8D5P2hYip7GRl/7Ae0YJw0FFb2HEYj zbMzs4jvq8lChly5n73OnXMI4okhpETrX2Dwnz6Pqv3nqHSQW6hRD20BzgLjxMTVo9vM VvwU68ZSVPRFxsQgZLOtFkZHtQ9RlgjReOe0YLh2CvPewZNfB4SOqaDhqt3ojjHyzX1n 82zWjvuWGlQZZIwEnjZ7ooHphaP2hC72ynIuYgD54cUfMk7eajEjDGWwxoJyprbSDC8L UV7oJIGy5a+ZPgpBVRO6KNYKkW6mO/vz8jEfwMN4VcPGO7hO3OdgyY8C5QabJtJj18kz zYlg==', 'X-Google-DKIM-Signature': 'v=1; a=rsa-sha256; c=relaxed/relaxed; d=1e100.net; s=20230601; t=1718859725; x=1719464525; h=to:subject:message-id:date:from:in-reply-to:references:mime-version :x-gm-message-state:from:to:cc:subject:date:message-id:reply-to; bh=sv92b50tM6VEnF6j3ryNjbSDRmA9Q/PVIv1uBdBQua0=; b=QNtIWRVRTrLS4X9bGNqdeF+Ea5NvVtvNcmOZczhcByaybqbLRXVEAsqoAzvXPerYAs 6esFkx8uW5Ie2YkMiPsTaUxJb6lRd/20200W3usqIc7kNgR96Vgx1yx9Cm/zDrAuv/j7 XJHmvebn1AQ4APKWrMBScQ0zdsAMSYFf9ams9qA8VuOSe2JI7vtbthyn7GgSc0x0MDTo MNJmn0UpkC26wAvsbC3daip7DVCzFcsFb66TDn1D39Rnhb2Q0atBPxMQibH8Yatf0Q6N qIad4N3RdAnUXa8lkXBy6bbu6LsK+8cfdxPN0+cgTtMrc5Gb9oBprYG4B39mBpb/zXx4 7JmA==', 'X-Gm-Message-State': 'AOJu0YwNr8pjLQ7M26dwC3qp8HvsFWYsYnPDw/F2fWlYwLA5ezTw1gMz HRcoW108qHNEvznXWPH0X+EJzRil2s4x+KfI20HZCagNhGGiTAeDtY4IUcyIsl4eHEmpvN5pTTf tgSM0uvCuCy/y7JvkVOMzTpx/nFWTiZBGehsK8YBlqWtmdmXjMes=', 'X-Google-Smtp-Source': 'AGHT+IExta1o22oDew+1HL1sYuA1PKFyUcqkRNsQONNLrcao45L8/Kar+3qop2eSwN4LbkSd+8ww8zKGN6kpW8lywYA=', 'X-Received': 'by 2002:a50:8704:0:b0:57d:3ea:3862 with SMTP id 4fb4d7f45d1cf-57d07ed410dmr3288768a12.27.1718859724778; Wed, 19 Jun 2024 22:02:04 -0700 (PDT)', 'MIME-Version': '1.0', 'References': '<CACPpfXK6H7zvanuBotU8b-x216MT03atKHRgO32+MqkKVURYbg@mail.gmail.com> <CACPpfXL7jB+YDuJ+fn4tN_DAuQw1HqQGRhMXLku01Vfqq9dDJQ@mail.gmail.com> <CACPpfXKf3AQs9Oz7pT1mF=JmcoRUiUP=SKa66fDLdwgpmmi9ZQ@mail.gmail.com> <CACPpfX+kyXojybPDOQ5Pf-OZ2PSXHrm=c=nRC0v1k-yq6ya5BA@mail.gmail.com> <CACPpfXLn-kU_PVDxHA1+zUYKDW=2GHoYwJaRvPng62oGrp+Jbw@mail.gmail.com> <CACPpfX+XFagWHHsoG8fOb3LLGC8JEXkWVcDWCO8rgtenxkv1bQ@mail.gmail.com>', 'In-Reply-To': '<CACPpfX+XFagWHHsoG8fOb3LLGC8JEXkWVcDWCO8rgtenxkv1bQ@mail.gmail.com>', 'From': 'Bilal Ghalib <bg@bilalghalib.com>', 'Date': 'Thu, 20 Jun 2024 07:01:48 +0200', 'Message-ID': '<CACPpfXJqfk-DW8xYony=y9GMY22Az-YtP_KFPEci68bt9txxAQ@mail.gmail.com>', 'Subject': 'Re: make me a cake', 'To': 'graph@txtray.com', 'Content-Type': 'multipart/alternative'}, 'SpamScore': 2.4, 'ExtractedMarkdownMessage': 'what about all the previous replies, why are they not cake?', 'ExtractedMarkdownSignature': None, 'RawHtmlBody': '<div dir=\"ltr\">what about all the previous replies, why are they not cake?</div><br><div class=\"gmail_quote\"><div dir=\"ltr\" class=\"gmail_attr\">On Thu, Jun 20, 2024 at 6:56\\u202fAM Bilal Ghalib &lt;<a href=\"mailto:bg@bilalghalib.com\">bg@bilalghalib.com</a>&gt; wrote:<br></div><blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-style:solid;border-left-color:rgb(204,204,204);padding-left:1ex\"><div dir=\"ltr\">and if it&#39;s a real cake it will be the most beautiful cake in the world because it is a time house</div><br><div class=\"gmail_quote\"><div dir=\"ltr\" class=\"gmail_attr\">On Thu, Jun 20, 2024 at 6:50\\u202fAM Bilal Ghalib &lt;<a href=\"mailto:bg@bilalghalib.com\" target=\"_blank\">bg@bilalghalib.com</a>&gt; wrote:<br></div><blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-style:solid;border-left-color:rgb(204,204,204);padding-left:1ex\"><div dir=\"ltr\">but this cake can also be a lie</div><br><div class=\"gmail_quote\"><div dir=\"ltr\" class=\"gmail_attr\">On Thu, Jun 20, 2024 at 6:47\\u202fAM Bilal Ghalib &lt;<a href=\"mailto:bg@bilalghalib.com\" target=\"_blank\">bg@bilalghalib.com</a>&gt; wrote:<br></div><blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-style:solid;border-left-color:rgb(204,204,204);padding-left:1ex\"><div dir=\"ltr\">cake is great and looks like a beautiful flower</div><br><div class=\"gmail_quote\"><div dir=\"ltr\" class=\"gmail_attr\">On Thu, Jun 20, 2024 at 6:46\\u202fAM Bilal Ghalib &lt;<a href=\"mailto:bg@bilalghalib.com\" target=\"_blank\">bg@bilalghalib.com</a>&gt; wrote:<br></div><blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-style:solid;border-left-color:rgb(204,204,204);padding-left:1ex\"><div dir=\"ltr\">cake is good</div><br><div class=\"gmail_quote\"><div dir=\"ltr\" class=\"gmail_attr\">On Thu, Jun 20, 2024 at 6:39\\u202fAM Bilal Ghalib &lt;<a href=\"mailto:bg@bilalghalib.com\" target=\"_blank\">bg@bilalghalib.com</a>&gt; wrote:<br></div><blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-style:solid;border-left-color:rgb(204,204,204);padding-left:1ex\"><div dir=\"ltr\"><div style=\"margin:0px;min-width:0px;padding:0px 0px 20px;width:initial;font-family:&quot;Google Sans&quot;,Roboto,RobotoDraft,Helvetica,Arial,sans-serif\"><div><div id=\"m_-4735118681294003976m_4440833384287798486m_-3463269231559932453m_7213537615729734662m_-4658028290751123114gmail-:3w8\" style=\"direction:ltr;margin:8px 0px 0px;padding:0px;font-size:0.875rem;overflow-x:hidden\"><div id=\"m_-4735118681294003976m_4440833384287798486m_-3463269231559932453m_7213537615729734662m_-4658028290751123114gmail-:3w7\" style=\"direction:initial;font-stretch:normal;font-size:small;line-height:1.5;font-family:Arial,Helvetica,sans-serif;font-size-adjust:none;font-kerning:auto;font-variant-alternates:normal;font-variant-ligatures:normal;font-variant-numeric:normal;font-variant-east-asian:normal;font-feature-settings:normal;overflow:auto hidden\"><div dir=\"ltr\">do the cake making as fast as you can\\xa0<div>i want a cake and i need it fast</div><div>the king awaits!\\xa0</div></div><div></div><div></div></div></div></div></div><br></div><br><div class=\"gmail_quote\"><div dir=\"ltr\" class=\"gmail_attr\">On Thu, Jun 20, 2024 at 6:34\\u202fAM Bilal Ghalib &lt;<a href=\"mailto:bg@bilalghalib.com\" target=\"_blank\">bg@bilalghalib.com</a>&gt; wrote:<br></div><blockquote class=\"gmail_quote\" style=\"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-style:solid;border-left-color:rgb(204,204,204);padding-left:1ex\"><div dir=\"ltr\">do the cake making as fast as you can\\xa0<div>i want a cake and i need it fast</div><div>the king awaits!\\xa0</div></div>\\r\\n</blockquote></div>\\r\\n</blockquote></div>\\r\\n</blockquote></div>\\r\\n</blockquote></div>\\r\\n</blockquote></div>\\r\\n</blockquote></div>\\r\\n', 'RawTextBody': \"what about all the previous replies, why are they not cake?\\r\\n\\nOn Thu, Jun 20, 2024 at 6:56\\u202fAM Bilal Ghalib <bg@bilalghalib.com> wrote:\\r\\n\\n> and if it's a real cake it will be the most beautiful cake in the world\\r\\n> because it is a time house\\r\\n>\\r\\n> On Thu, Jun 20, 2024 at 6:50\\u202fAM Bilal Ghalib <bg@bilalghalib.com> wrote:\\r\\n>\\r\\n>> but this cake can also be a lie\\r\\n>>\\r\\n>> On Thu, Jun 20, 2024 at 6:47\\u202fAM Bilal Ghalib <bg@bilalghalib.com> wrote:\\r\\n>>\\r\\n>>> cake is great and looks like a beautiful flower\\r\\n>>>\\r\\n>>> On Thu, Jun 20, 2024 at 6:46\\u202fAM Bilal Ghalib <bg@bilalghalib.com> wrote:\\r\\n>>>\\r\\n>>>> cake is good\\r\\n>>>>\\r\\n>>>> On Thu, Jun 20, 2024 at 6:39\\u202fAM Bilal Ghalib <bg@bilalghalib.com>\\r\\n>>>> wrote:\\r\\n>>>>\\r\\n>>>>> do the cake making as fast as you can\\r\\n>>>>> i want a cake and i need it fast\\r\\n>>>>> the king awaits!\\r\\n>>>>>\\r\\n>>>>>\\r\\n>>>>> On Thu, Jun 20, 2024 at 6:34\\u202fAM Bilal Ghalib <bg@bilalghalib.com>\\r\\n>>>>> wrote:\\r\\n>>>>>\\r\\n>>>>>> do the cake making as fast as you can\\r\\n>>>>>> i want a cake and i need it fast\\r\\n>>>>>> the king awaits!\\r\\n>>>>>>\\r\\n>>>>>\\r\\n\", 'EMLDownloadToken': 'eyJmb2xkZXIiOiIyMDI0MDYyMDA1MDIwNi4wMy4yNzk0ODIwODc4IiwiZmlsZW5hbWUiOiJzbXRwLmVtbCJ9'}]}\nERROR:app:Error processing webhook: name 'email_recipient' is not defined\n",
      "created_at": "2024-06-20T07:03:03.733277",
      "sequence_order": 5,
      "parent_id": "09f47764-8779-49da-b1cf-72164f9ffa5d",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": null
      }
    },
    {
      "id": "641bbc77-844f-4c76-b213-dbaf735a3825",
      "role": "assistant",
      "content": "### Fixing the Error and Ensuring Proper Email Handling\n\nThe error in your `app.py` indicates that the variable `email_recipient` is not defined. Since the email recipient is not required for the current logic, we should remove it from the parameters being passed to the `download_and_process_attachment_task` function.\n\nLet's adjust the code accordingly.\n\n### Updated `app.py`\n\n1. **Remove `email_recipient` from the function call**:\n   Ensure the `download_and_process_attachment_task` function call does not pass an undefined variable.\n\n```python\nfrom flask import Flask, render_template, request, jsonify, redirect, url_for, Response\nfrom celery import Celery, states\nimport os\nimport uuid\nfrom tasks import process_graph_task, transcribe_audio_task, download_and_process_attachment_task, save_metadata\nfrom flask_cors import CORS\nimport requests\nfrom dotenv import load_dotenv\nfrom datetime import datetime\n\n# Load environment variables from .env file\nload_dotenv()\n\napp = Flask(__name__)\nCORS(app)  # Enable CORS\napp.config['CELERY_BROKER_URL'] = 'redis://localhost:6379/0'\napp.config['CELERY_RESULT_BACKEND'] = 'redis://localhost:6379/0'\ncelery = Celery(app.name, broker=app.config['CELERY_BROKER_URL'])\ncelery.conf.update(app.config)\n\ndef save_file_content(file_content, filename, task_id):\n    output_dir = os.path.join('uploads', f\"download_{task_id}\")\n    os.makedirs(output_dir, exist_ok=True)\n    file_path = os.path.join(output_dir, filename)\n    with open(file_path, 'wb') as file:\n        file.write(file_content)\n    return file_path, output_dir\n\n@app.route('/', methods=['GET'])\ndef home():\n    return \"Go to www.txt-ray.com to make graphs\"\n\n@app.route('/graphme', methods=['GET', 'POST'])\ndef graphme():\n    if request.method == 'POST':\n        if request.is_json:\n            data = request.get_json()\n            if 'fileUrl' in data:\n                file_path, error = download_file_from_url(data['fileUrl'], 'file_from_url.txt')\n                if error:\n                    return jsonify({'error': error}), 400\n            elif 'fileContent' in data:\n                task_id = str(uuid.uuid4())\n                file_path, output_dir = save_file_content(data['fileContent'], 'file_from_content.txt', task_id)\n            else:\n                return jsonify({'error': 'No file URL or file content provided'}), 400\n        elif 'file' in request.files:\n            file = request.files['file']\n            if file.filename == '':\n                return jsonify({'error': 'No selected file'}), 400\n            task_id = str(uuid.uuid4())\n            file_path, output_dir = save_file_content(file.read(), file.filename, task_id)\n        else:\n            return jsonify({'error': 'Invalid request format'}), 400\n        \n        process_task = process_graph_task.delay(file_path, output_dir)\n        \n        return jsonify({'task_id': process_task.id, 'task_url': url_for('task_status', task_id=process_task.id, _external=True)})\n    \n    return render_template('index.html')\n\n@app.route('/progress/<task_id>')\ndef progress(task_id):\n    return render_template('progress.html', task_id=task_id)\n\n@app.route('/status/<task_id>')\ndef task_status(task_id):\n    task = process_graph_task.AsyncResult(task_id)\n    \n    if task.state == states.PENDING:\n        response = {\n            'state': task.state,\n            'status': 'Processing...'\n        }\n    elif task.state == states.SUCCESS:\n        response = {\n            'state': task.state,\n            'status': 'Processing complete.',\n            'result': task.get()\n        }\n    elif task.state == states.FAILURE:\n        response = {\n            'state': task.state,\n            'status': f'Error: {str(task.info)}'\n        }\n    else:\n        response = {\n            'state': task.state,\n            'status': str(task.info)\n        }\n    \n    return jsonify(response)\n\n@app.route('/webhook', methods=['POST'])\ndef respond():\n    app.logger.info('Webhook received: %s', request.json)\n    \n    try:\n        data = request.json['items'][0]\n        \n        if 'Attachments' in data and len(data['Attachments']) > 0:\n            attachment = data['Attachments'][0]\n            file_url = f\"https://api.brevo.com/v3/inbound/attachments/{attachment['DownloadToken']}\"\n        else:\n            file_url = None  # Set file_url to None when there are no attachments\n        \n        email_sender = data['From']['Address']\n        email_subject = data['Subject']\n        api_key = os.getenv(\"BREVO_API\")\n        \n        task = download_and_process_attachment_task.delay(file_url, email_sender, api_key, email_subject, data)\n        return jsonify({'task_id': task.id, 'task_url': url_for('task_status', task_id=task.id, _external=True)}), 200\n    \n    except Exception as e:\n        app.logger.error(f\"Error processing webhook: {e}\")\n        return jsonify({'error': 'Webhook processing failed'}), 500        \n@app.route('/whisper', methods=['POST'])\ndef whisper():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n\n    download_task_id = str(uuid.uuid4())\n    file_path, output_dir = save_file_content(file.read(), file.filename, download_task_id)\n    if file_path is None:\n        return jsonify({'error': 'File saving failed'}), 500\n\n    try:\n        metadata = {\n            'file_name': file.filename,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path\n        }\n        save_metadata(metadata, output_dir)\n\n        transcribe_task = transcribe_audio_task.delay(file_path, metadata)\n        return jsonify({'task_id': transcribe_task.id})\n    except Exception as e:\n        app.logger.error(f\"Error starting transcription task: {e}\")\n        return jsonify({'error': 'Transcription task failed'}), 500\n\nif __name__ == '__main__':\n    if not os.path.exists('uploads'):\n        os.makedirs('uploads')\n    if not os.path.exists('static/generated'):\n        os.makedirs('static/generated')\n    \n    app.run(debug=True, host='0.0.0.0')\n```\n\n### Updated `tasks.py`\n\n1. **Remove `email_recipient` from the function parameters**:\n   Ensure the `download_and_process_attachment_task` does not expect an `email_recipient`.\n\n```python\nimport re\nfrom celery import Celery, states, chain\nfrom celery.utils.log import get_task_logger\nfrom contextlib import contextmanager\nfrom redis import Redis\nfrom graph_generator import generate_graph, save_graph_to_html\nimport os\nimport uuid\nimport whisper_api\nimport requests\nimport logging\nfrom datetime import datetime\nimport json\nimport asyncio\nfrom email_utils import send_email\nfrom download_utils import download_file_from_brevo, save_file_content\n\nlogger = get_task_logger(__name__)\n\ncelery = Celery('tasks', broker='redis://localhost:6379/0', backend='redis://localhost:6379/0')\n\n@contextmanager\ndef redis_lock(lock_name, timeout=60):\n    redis_client = Redis(host='localhost', port=6379, db=0)\n    lock = redis_client.lock(lock_name, timeout=timeout)\n    try:\n        yield lock.acquire(blocking=True)\n    finally:\n        if lock.owned():\n            lock.release()\n\ndef save_metadata(metadata, output_dir):\n    metadata_path = os.path.join(output_dir, 'data.json')\n    with open(metadata_path, 'w') as f:\n        json.dump(metadata, f, indent=4)\n    return metadata_path\n\n@celery.task(bind=True)\ndef process_graph_task(self, file_path, output_dir):\n    try:\n        graph_task_id = str(uuid.uuid4())\n        graph_output_dir = os.path.join('static', 'generated', f\"graph_{graph_task_id}\")\n        os.makedirs(graph_output_dir, exist_ok=True)\n        \n        G = generate_graph(file_path, graph_output_dir)\n        save_graph_to_html(G, graph_output_dir)\n\n        logger.info(f\"Graph generated successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error generating graph for task {self.request.id}: {str(e)}\")\n        raise\n    return {\n        'task_id': graph_task_id,\n        'd3_url': f'/static/generated/graph_{graph_task_id}/index.html',\n        'pyvis_url': f'/static/generated/graph_{graph_task_id}/pyvis.html'\n    }\n\n@celery.task(bind=True)\ndef transcribe_audio_task(self, file_path, download_task_metadata, email_sender, email_subject):\n    download_task_id = download_task_metadata['download_task_id']\n    output_dir = os.path.join('uploads', f\"tr_{download_task_id}\")\n    transcription_path = os.path.join(output_dir, 'transcription.txt')\n\n    # Check if the transcription has already been completed\n    if os.path.exists(transcription_path):\n        logger.info(f\"Transcription already exists for download task {download_task_id}\")\n    else:\n        # Use a lock to ensure only one instance of the task is running at a time\n        lock_name = f\"transcribe_lock_{download_task_id}\"\n        with redis_lock(lock_name) as acquired:\n            if acquired:\n               ",
      "created_at": "2024-06-20T07:03:57.229253",
      "sequence_order": 6,
      "parent_id": "aaa2cde3-a63f-4ede-ba64-7ee7d4166775",
      "metadata": {
        "status": "finished_partial_completion",
        "weight": 1,
        "end_turn": false
      }
    },
    {
      "id": "a1a8336d-f6ed-47ed-8c63-a15779efb560",
      "role": "assistant",
      "content": " try:\n                    logger.info(f\"Starting transcription for download task {download_task_id}\")\n                    transcription = asyncio.run(whisper_api.transcribe_audio(file_path))\n                    os.makedirs(output_dir, exist_ok=True)\n                    with open(transcription_path, 'w') as f:\n                        f.write(transcription)\n\n                    metadata = download_task_metadata\n                    metadata.update({\n                        'transcription_data': transcription,\n                        'transcription_task_id': self.request.id,\n                        'transcription_file_link': transcription_path,\n                        'transcription_created_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n                    })\n                    save_metadata(metadata, output_dir)\n                except Exception as e:\n                    exc_type = type(e).__name__\n                    exc_message = str(e)\n                    self.update_state(\n                        state=states.FAILURE,\n                        meta={\n                            'exc_type': exc_type,\n                            'exc_message': exc_message\n                        }\n                    )\n                    raise self.retry(exc=e, countdown=5, max_retries=3)\n            else:\n                logger.info(f\"Another instance of the task is already running for download task {download_task_id}\")\n\n    # Create a Celery chain to execute tasks sequentially\n    graph_chain = chain(\n        process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n        send_email_task.s(email_sender, email_subject)\n    )\n    graph_chain.apply_async()\n\n    logger.info(f\"Transcription completed for download task {download_task_id}\")\n    return transcription_path\n\n\ndef is_valid_email(email):\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n\n@celery.task(bind=True)\ndef send_email_task(self, email_sender, email_subject, task_id):\n    try:\n        # Convert email_sender to a string\n        email_sender = str(email_sender)\n        \n        if not is_valid_email(email_sender):\n            raise ValueError(f\"Invalid email address: {email_sender}\")\n        \n        progress_url = f'https://www.txtray.com/progress/{task_id}'\n        send_email(\n            email=email_sender,\n            subject=f\"Re: {email_subject}\",\n            content=f\"Your file has been processed. You can view the progress at: {progress_url}\"\n        )\n        logger.info(f\"Email sent successfully for task {self.request.id}\")\n    except Exception as e:\n        logger.error(f\"Error sending email for task {self.request.id}: {str(e)}\")\n        raise        \n\n@celery.task(bind=True)\ndef download_and_process_attachment_task(self, file_url, email_sender, api_key, email_subject, data):\n    try:\n        download_task_id = str(uuid.uuid4())\n        \n        if file_url:\n            file_content = download_file_from_brevo(file_url, api_key)\n            attachment_data = data['Attachments'][0]\n            attachment_name = attachment_data['Name']\n            file_extension = os.path.splitext(attachment_name)[1].lower()\n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", f\"attachment{file_extension}\")\n            save_file_content(file_content, file_path)\n        else:\n            # No attachments, use the content inside ExtractedMarkdownMessage\n            attachment_name = 'message.txt'\n            file_content = data.get('ExtractedMarkdownMessage', 'No content available')\n            file_path = os.path.join('uploads', f\"download_{download_task_id}\", attachment_name)\n            save_file_content(file_content.encode('utf-8'), file_path)\n        \n        metadata = {\n            'file_name': attachment_name,\n            'date_uploaded': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'download_task_id': download_task_id,\n            'downloaded_file_link': file_path,\n        }\n\n        if attachment_name.endswith('.mp3') or attachment_name.endswith('.wav'):\n            transcribe_task = transcribe_audio_task.delay(file_path, metadata, email_sender, email_subject)\n            transcription_result = transcribe_task.get()\n            transcription_path = transcription_result['transcription_path']\n            graph_chain = chain(\n                process_graph_task.s(transcription_path, os.path.dirname(transcription_path)),\n                send_email_task.s(email_sender, email_subject)\n            )\n            graph_result = graph_chain.apply_async()\n            return {'task_id': graph_result.parent.get()[\"task_id\"]}\n        else:\n            graph_chain = chain(\n                process_graph_task.s(file_path, os.path.dirname(file_path)),\n                send_email_task.s(email_sender, email_subject)\n            )\n            graph_result = graph_chain.apply_async()\n            return {'task_id': graph_result.parent.get()[\"task_id\"]}\n    except Exception as e:\n        self.update_state(\n            state=states.FAILURE,\n            meta={\n                'exc_type': type(e).__name__,\n                'exc_message': str(e)\n            }\n        )\n        raise\n```\n\n### Summary of Changes\n\n1. **Fixed the `respond` function in `app.py`**:\n   - Removed the `email_recipient` parameter.\n   - Adjusted the function call to `download_and_process_attachment_task`.\n\n2. **Updated `download_and_process_attachment_task` in `tasks.py`**:\n   - Removed `email_recipient` from the function parameters.\n   - Handled file processing and email sending appropriately.\n\nThese changes should ensure that your webhook processing and task handling work correctly, including sending an email with a link to the progress page.",
      "created_at": "2024-06-20T07:04:36.070082",
      "sequence_order": 7,
      "parent_id": "641bbc77-844f-4c76-b213-dbaf735a3825",
      "metadata": {
        "status": "finished_successfully",
        "weight": 1,
        "end_turn": true
      }
    }
  ]
}